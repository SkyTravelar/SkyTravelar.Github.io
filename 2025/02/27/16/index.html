<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"skytravelar.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="中南大学复试机试练手记录">
<meta property="og:type" content="article">
<meta property="og:title" content="中南大学复试机试练手 Based on Acwing">
<meta property="og:url" content="https://skytravelar.github.io/2025/02/27/16/index.html">
<meta property="og:site_name" content="賦幸の個人ブログ">
<meta property="og:description" content="中南大学复试机试练手记录">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-02-27T12:04:06.000Z">
<meta property="article:modified_time" content="2025-03-07T11:45:44.794Z">
<meta property="article:author" content="赋倖">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://skytravelar.github.io/2025/02/27/16/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>中南大学复试机试练手 Based on Acwing | 賦幸の個人ブログ</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">賦幸の個人ブログ</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://skytravelar.github.io/2025/02/27/16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="赋倖">
      <meta itemprop="description" content="长夜梦旅有尽时">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="賦幸の個人ブログ">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          中南大学复试机试练手 Based on Acwing
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-27 20:04:06" itemprop="dateCreated datePublished" datetime="2025-02-27T20:04:06+08:00">2025-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-07 19:45:44" itemprop="dateModified" datetime="2025-03-07T19:45:44+08:00">2025-03-07</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description">中南大学复试机试练手记录</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="算法基础课">算法基础课</h1>
<h2 id="第一讲-基础算法">第一讲 基础算法</h2>
<p><strong>2025.2.27</strong></p>
<h3 id="acwing-785.-快速排序">AcWing 785. 快速排序</h3>
<p>内置函数法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;int&gt; a(n);</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a.begin(),a.end());</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  // 引入输入输出流库</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010; // 定义最大数组长度</span><br><span class="line">int a[N];           // 全局数组用于存储原始数据</span><br><span class="line"></span><br><span class="line">// 函数功能：使用Hoare分区方案的快速排序算法对数组a[l..r]进行升序排序</span><br><span class="line">void quick_sort(int a[], int l, int r) &#123;</span><br><span class="line">    if (l &gt;= r) return; // 递归终止条件：区间长度为1时无需排序</span><br><span class="line">    </span><br><span class="line">    int x = a[l + r &gt;&gt; 1]; // 选取中间位置的元素作为基准值（位运算优化）</span><br><span class="line">    int i = l - 1, j = r + 1; // 初始化双指针（i左移一位，j右移一位）</span><br><span class="line">    </span><br><span class="line">    // Hoare分区核心逻辑：i向右找≥x的元素，j向左找≤x的元素，交换不符合条件的元素</span><br><span class="line">    while (i &lt; j) &#123;</span><br><span class="line">        // 找到第一个≥x的元素（跳过比x小的元素）</span><br><span class="line">        while (a[++i] &lt; x);</span><br><span class="line">        // 找到第一个≤x的元素（跳过比x大的元素）</span><br><span class="line">        while (a[--j] &gt; x);</span><br><span class="line">        if (i &lt; j)</span><br><span class="line">            swap(a[i], a[j]); // 交换不满足顺序的元素</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 递归排序左右子区间（注意：Hoare分区后的基准值位置在j）</span><br><span class="line">    quick_sort(a, l, j);</span><br><span class="line">    quick_sort(a, j + 1, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n; // 输入数组长度</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i]; // 输入数组元素</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    quick_sort(a, 0, n - 1); // 调用快速排序函数对整个数组排序</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; // 输出排序后的数组</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-786.-第k个数">AcWing 786. 第k个数</h3>
<p>内置函数法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    vector&lt;int&gt; a(n);</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a.begin(),a.end());</span><br><span class="line">    cout&lt;&lt;a[k-1]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  // 引入输入输出流库</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 函数功能：使用快速选择算法在数组a[l..r]范围内查找第k小的元素（k从1开始计数）</span><br><span class="line">// 参数：</span><br><span class="line">//   a[]：待查找的数组</span><br><span class="line">//   l：当前查找范围的左边界（包含）</span><br><span class="line">//   r：当前查找范围的右边界（包含）</span><br><span class="line">//   k：要查找的第k小的元素的序号（k &gt;= 1）</span><br><span class="line">int quicksortfind(int a[], int l, int r, int k) &#123;</span><br><span class="line">    if (l &gt;= r) return a[l]; // 当区间只有一个元素时，直接返回该元素</span><br><span class="line">    </span><br><span class="line">    int x = a[l + r &gt;&gt; 1]; // 选择中间位置的元素作为基准值（位运算优化）</span><br><span class="line">    int i = l - 1, j = r + 1; // i初始指向l左侧，j初始指向r右侧</span><br><span class="line">    </span><br><span class="line">    // Hoare分区核心逻辑：i向右找≥x的元素，j向左找≤x的元素，交换不符合条件的元素</span><br><span class="line">    while (i &lt; j) &#123;</span><br><span class="line">        // 找到第一个≥x的元素（跳过比x小的元素）</span><br><span class="line">        while (a[++i] &lt; x);</span><br><span class="line">        // 找到第一个≤x的元素（跳过比x大的元素）</span><br><span class="line">        while (a[--j] &gt; x);</span><br><span class="line">        if (i &lt; j)</span><br><span class="line">            swap(a[i], a[j]); // 交换不满足顺序的元素</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int sl = j - l + 1; // 当前基准值所在位置分割后的左半部分长度（包含基准值）</span><br><span class="line">    // 根据k的值决定递归方向</span><br><span class="line">    if (k &lt;= sl) </span><br><span class="line">        return quicksortfind(a, l, j, k); // 递归处理左半部分</span><br><span class="line">    else </span><br><span class="line">        return quicksortfind(a, j + 1, r, k - sl); // 递归处理右半部分</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k; // 输入数组长度和要查找的第k小的元素序号</span><br><span class="line">    int a[n]; // 定义数组（注意：C++标准不支持VLA，此处为GCC扩展语法）</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i]; // 输入数组元素</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; quicksortfind(a, 0, n - 1, k) &lt;&lt; endl; // 输出第k小的元素</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-787.-归并排序">AcWing 787. 归并排序</h3>
<p>内置函数法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;int&gt; a(n);</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a.begin(),a.end());</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  // 引入输入输出流库</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int temp[100010] = &#123;&#125;; // 全局临时数组，用于合并过程中的数据暂存</span><br><span class="line"></span><br><span class="line">// 归并排序函数声明：对数组a的[l, r]区间进行升序排序</span><br><span class="line">void merge_sort(int a[], int l, int r) &#123;</span><br><span class="line">    if (l &gt;= r) return; // 递归终止条件：单个元素已有序</span><br><span class="line">    int mid = (l + r) &gt;&gt; 1; // 计算中间索引（等价于(l+r)/2，位运算更高效）</span><br><span class="line">    </span><br><span class="line">    // 递归划分左右子数组</span><br><span class="line">    merge_sort(a, l, mid);   // 对左半部分排序 [l, mid]</span><br><span class="line">    merge_sort(a, mid+1, r); // 对右半部分排序 [mid+1, r]</span><br><span class="line">    </span><br><span class="line">    // 合并两个有序子数组为整体有序数组</span><br><span class="line">    int k = 0;            // temp数组的写入指针</span><br><span class="line">    int i = l, j = mid + 1; // 左右子数组的遍历指针</span><br><span class="line">    </span><br><span class="line">    // 比较左右子数组元素，按顺序存入temp数组</span><br><span class="line">    while (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        if (a[i] &lt; a[j]) &#123;</span><br><span class="line">            temp[k++] = a[i++];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            temp[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理左子数组剩余元素</span><br><span class="line">    while (i &lt;= mid) &#123;</span><br><span class="line">        temp[k++] = a[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理右子数组剩余元素</span><br><span class="line">    while (j &lt;= r) &#123;</span><br><span class="line">        temp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 将temp数组中的数据复制回原数组a的[l, r]区间</span><br><span class="line">    k = 0; // 重置temp数组的读取指针</span><br><span class="line">    for (int m = l; m &lt;= r; ++m) &#123;</span><br><span class="line">        a[m] = temp[k++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n; // 输入数组长度</span><br><span class="line">    </span><br><span class="line">    int a[n]; // 定义整型数组（注意：C++标准不支持VLA，此处为GCC扩展语法）</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i]; // 输入数组元素</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    merge_sort(a, 0, n-1); // 调用归并排序函数，对整个数组排序</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; // 输出排序后的数组，元素间以空格分隔</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-788.-逆序对的数量">AcWing 788. 逆序对的数量</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  // 引入输入输出流库</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010; // 定义最大数组长度</span><br><span class="line">int a[N];           // 全局数组用于存储原始数据</span><br><span class="line">int temp[N];        // 全局临时数组用于归并过程</span><br><span class="line"></span><br><span class="line">// 函数功能：使用归并排序计算数组a[l..r]范围内的逆序对总数</span><br><span class="line">// 参数：a为数组，l/r为当前处理区间的左右边界</span><br><span class="line">// 返回值：当前区间的逆序对数量</span><br><span class="line">long long find(int a[], int l, int r) &#123;</span><br><span class="line">    if (l &gt;= r) return 0; // 区间长度为1时无逆序对</span><br><span class="line">    </span><br><span class="line">    int mid = (l + r) &gt;&gt; 1; // 计算中间位置（位运算优化）</span><br><span class="line">    long long res = 0;</span><br><span class="line">    </span><br><span class="line">    // 递归计算左右子区间的逆序对数</span><br><span class="line">    res += find(a, l, mid);</span><br><span class="line">    res += find(a, mid + 1, r);</span><br><span class="line">    </span><br><span class="line">    // 合并两个有序子区间并统计跨越两区的逆序对</span><br><span class="line">    int i = l, j = mid + 1, k = 0;</span><br><span class="line">    while (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        if (a[i] &lt;= a[j]) &#123; // 左侧元素不大于右侧，无需统计逆序</span><br><span class="line">            temp[k++] = a[i++];</span><br><span class="line">        &#125; else &#123; // 右侧元素更小，左侧剩余元素全部构成逆序对</span><br><span class="line">            temp[k++] = a[j++];</span><br><span class="line">            res += mid - i + 1; // 统计逆序对数量</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理剩余元素</span><br><span class="line">    while (i &lt;= mid) temp[k++] = a[i++];</span><br><span class="line">    while (j &lt;= r) temp[k++] = a[j++];</span><br><span class="line">    </span><br><span class="line">    // 将合并结果复制回原数组a</span><br><span class="line">    for (int m = l, k = 0; m &lt;= r; ++m) &#123;</span><br><span class="line">        a[m] = temp[k++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return res; // 返回总逆序对数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n; // 输入数组长度</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i]; // 输入数组元素</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; find(a, 0, n - 1) &lt;&lt; endl; // 输出整个数组的逆序对总数</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-789.-数的范围">AcWing 789. 数的范围</h3>
<p>内置函数法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line">#include &quot;algorithm&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,q,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    int a[n];</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; q; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;k;</span><br><span class="line">        if(binary_search(a,a+n,k))&#123;</span><br><span class="line">            cout&lt;&lt;lower_bound(a,a+n,k) -a &lt;&lt;&quot; &quot;&lt;&lt;upper_bound(a,a+n,k) -a - 1&lt;&lt;endl;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            cout &lt;&lt; &quot;-1 -1&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-790.-数的三次方根">AcWing 790. 数的三次方根</h3>
<p>内置函数法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    double n;</span><br><span class="line">    scanf(&quot;%lf&quot;,&amp;n);</span><br><span class="line">    printf(&quot;%lf&quot;,cbrt(n));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line">#include &quot;iomanip&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    double n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    double l=-100000,r=100000;</span><br><span class="line">    while (r-l&gt;1e-8)&#123;</span><br><span class="line">        double mid = (l+r)/2;</span><br><span class="line">        if(mid*mid*mid&lt;n)</span><br><span class="line">            l=mid;</span><br><span class="line">        else</span><br><span class="line">            r=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;setprecision(6)&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-791.-高精度加法">AcWing 791. 高精度加法</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string a,b;</span><br><span class="line"></span><br><span class="line">string add(string s1,string s2)&#123;</span><br><span class="line">    string c;</span><br><span class="line">    int t=0;</span><br><span class="line">    for (int i = s1.size()-1,j=s2.size()-1; i &gt;=0||j&gt;=0||t&gt;0 ; --i,--j) &#123;</span><br><span class="line">        if (i&gt;=0) t+=(s1[i]-&#x27;0&#x27;);</span><br><span class="line">        if (j&gt;=0) t+=(s2[j]-&#x27;0&#x27;);</span><br><span class="line">        c+=((t%10)+&#x27;0&#x27;);</span><br><span class="line">        t/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(c.begin(),c.end());</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    cout&lt;&lt;add(a,b)&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-792.-高精度减法">AcWing 792. 高精度减法</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;   // 引入输入输出流库</span><br><span class="line">#include &lt;algorithm&gt;  // 引入算法库，用于std::sort等函数</span><br><span class="line"></span><br><span class="line">using namespace std;  // 使用标准命名空间</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief 比较两个字符串表示的数字的大小</span><br><span class="line"> * </span><br><span class="line"> * @param s1 第一个字符串数字</span><br><span class="line"> * @param s2 第二个字符串数字</span><br><span class="line"> * @return bool 如果s1大于或等于s2，返回true；否则返回false</span><br><span class="line"> */</span><br><span class="line">bool cmp(string s1, string s2)&#123;</span><br><span class="line">    if(s1.size() != s2.size()) </span><br><span class="line">        return s1.size() &gt; s2.size();  // 如果长度不同，长度较长的数字更大</span><br><span class="line">    for (int i = 0; i &lt; s1.size(); ++i) &#123;</span><br><span class="line">        if(s1[i] != s2[i]) </span><br><span class="line">            return s1[i] &gt; s2[i];  // 从高位到低位逐位比较，较大的数字更大</span><br><span class="line">    &#125;</span><br><span class="line">    return true;  // 如果所有位都相同，返回true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief 计算两个字符串表示的数字的差值，s1 - s2</span><br><span class="line"> * </span><br><span class="line"> * @param s1 被减数，字符串形式的数字</span><br><span class="line"> * @param s2 减数，字符串形式的数字</span><br><span class="line"> * @return string 返回差值的字符串表示，保证没有前导零（除非结果为0）</span><br><span class="line"> */</span><br><span class="line">string sub(string s1, string s2)&#123;</span><br><span class="line">    string c;  // 存储结果的字符串</span><br><span class="line">    int t = 0; // 借位标志，初始为0</span><br><span class="line"></span><br><span class="line">    // 从字符串的末尾（即数字的最低位）开始逐位相减</span><br><span class="line">    for (int i = s1.size() - 1, j = s2.size() - 1; </span><br><span class="line">         i &gt;= 0 || j &gt;= 0 || t &gt; 0; --i, --j) &#123;</span><br><span class="line">        // 如果被减数的当前位有效，减去借位</span><br><span class="line">        if(i &gt;= 0) </span><br><span class="line">            t = (s1[i] - &#x27;0&#x27;) - t;</span><br><span class="line">        </span><br><span class="line">        // 如果减数的当前位有效，继续减去该位的值</span><br><span class="line">        if(j &gt;= 0) </span><br><span class="line">            t -= (s2[j] - &#x27;0&#x27;);</span><br><span class="line">        </span><br><span class="line">        // 将当前位的结果加上10后取模，确保结果为非负数，并转换为字符</span><br><span class="line">        c += ((t + 10) % 10) + &#x27;0&#x27;;</span><br><span class="line">        </span><br><span class="line">        // 更新借位标志</span><br><span class="line">        if(t &lt; 0) &#123;</span><br><span class="line">            t = 1;  // 需要继续借位</span><br><span class="line">        &#125; </span><br><span class="line">        else &#123;</span><br><span class="line">            t = 0;  // 不需要借位</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 移除结果中末尾多余的零（如果有的话），但保留至少一个零</span><br><span class="line">    while (c.size() &gt; 1 &amp;&amp; c.back() == &#x27;0&#x27;)</span><br><span class="line">        c.pop_back();</span><br><span class="line">    </span><br><span class="line">    reverse(c.begin(), c.end());  // 反转字符串，得到正确的顺序</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string a, b;  // 定义两个字符串变量，用于存储输入的数字</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;  // 从标准输入读取两个数字字符串</span><br><span class="line"></span><br><span class="line">    // 比较a和b的大小</span><br><span class="line">    if (cmp(a, b)) </span><br><span class="line">        cout &lt;&lt; sub(a, b) &lt;&lt; endl;  // 如果a &gt;= b，输出a - b的结果</span><br><span class="line">    else </span><br><span class="line">        cout &lt;&lt; &quot;-&quot; &lt;&lt; sub(b, a) &lt;&lt; endl;  // 如果a &lt; b，输出-(b - a)的结果</span><br><span class="line"></span><br><span class="line">    return 0;  // 程序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-793.-高精度乘法">AcWing 793. 高精度乘法</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 函数mul：实现一个大整数（用vector&lt;int&gt;表示）与一个整数的乘法</span><br><span class="line">// 参数v：大整数，每个元素表示一位数字，且低位在前，高位在后</span><br><span class="line">// 参数i：要乘的整数</span><br><span class="line">// 返回值：返回乘积，同样用vector&lt;int&gt;表示，低位在前，高位在后</span><br><span class="line">vector&lt;int&gt; mul(vector&lt;int&gt; v, int i) &#123;</span><br><span class="line">    vector&lt;int&gt; ve;  // 用于存储乘积的结果</span><br><span class="line">    int t = 0;       // 进位初始化为0</span><br><span class="line"></span><br><span class="line">    // 遍历输入的大整数v的每一位</span><br><span class="line">    for (int j = 0; j &lt; v.size(); ++j) &#123;</span><br><span class="line">        t += v[j] * i;          // 当前位乘以i并加上进位</span><br><span class="line">        ve.push_back(t % 10);   // 将当前位的结果（个位数）存入ve</span><br><span class="line">        t /= 10;                // 更新进位</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理剩余的进位</span><br><span class="line">    while (t) &#123;</span><br><span class="line">        ve.push_back(t % 10);</span><br><span class="line">        t /= 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 去除结果中高位的无效零（保证至少有一位有效数字）</span><br><span class="line">    while (ve.size() &gt; 1 &amp;&amp; ve.back() == 0)</span><br><span class="line">        ve.pop_back();</span><br><span class="line"></span><br><span class="line">    return ve;  // 返回乘积结果</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s;  // 用于存储输入的大整数（以字符串形式）</span><br><span class="line">    int a;     // 用于存储要乘的整数</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; s &gt;&gt; a;  // 输入大整数和乘数</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; aa;  // 用于存储转换后的大整数（低位在前）</span><br><span class="line"></span><br><span class="line">    // 将字符串形式的大整数s转换为vector&lt;int&gt;形式，低位在前</span><br><span class="line">    for (int i = s.size() - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">        aa.push_back(s[i] - &#x27;0&#x27;);  // 将字符转换为数字并存入aa</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto au = mul(aa, a);  // 调用mul函数计算乘积</span><br><span class="line"></span><br><span class="line">    // 输出乘积结果，从高位到低位</span><br><span class="line">    for (int i = au.size() - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">        cout &lt;&lt; au[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;  // 程序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-794.-高精度除法">AcWing 794. 高精度除法</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;       // 引入向量容器库</span><br><span class="line">#include &lt;algorithm&gt;    // 引入算法库（用于反转容器）</span><br><span class="line">#include &quot;iostream&quot;      // 引入输入输出流库</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 函数功能：对逆序存储的数字数组进行除法运算，返回商的各位数字（高位在前）</span><br><span class="line">// 参数：v表示逆序存储的被除数数字数组，i表示除数，y通过引用返回余数</span><br><span class="line">vector&lt;int&gt; div(vector&lt;int&gt; v, int i, int &amp;y) &#123;</span><br><span class="line">    vector&lt;int&gt; result; // 存储商的各位数字</span><br><span class="line">    y = 0;             // 初始化余数为0</span><br><span class="line">    </span><br><span class="line">    // 从最高位到最低位处理每一位数字（v的索引0对应个位，索引末尾对应最高位）</span><br><span class="line">    for (int j = v.size() - 1; j &gt;= 0; --j) &#123;</span><br><span class="line">        y = y * 10 + v[j]; // 累加当前位到余数y（模拟手动除法的逐位操作）</span><br><span class="line">        result.push_back(y / i); // 计算当前位的商并存储</span><br><span class="line">        y %= i;               // 更新余数</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    reverse(result.begin(), result.end()); // 反转商的顺序（使高位在前）</span><br><span class="line">    // 去除商末尾的零（例如：结果为[0, 2, 3]时，去除前导零变为[2, 3]）</span><br><span class="line">    while (result.size() &gt; 1 &amp;&amp; result.back() == 0) &#123;</span><br><span class="line">        result.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s;           // 输入的整数字符串</span><br><span class="line">    int b, r;           // 除数b和余数r</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; s &gt;&gt; b;      // 读取输入的字符串和除数</span><br><span class="line">    vector&lt;int&gt; a;       // 存储逆序的数字位（例如：&quot;123&quot; -&gt; [3,2,1]）</span><br><span class="line">    </span><br><span class="line">    // 将字符串转换为逆序的数字数组</span><br><span class="line">    for (int i = s.size() - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">        a.push_back(s[i] - &#x27;0&#x27;); // 字符转数字并逆序存储</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    auto result = div(a, b, r); // 调用div函数进行除法运算</span><br><span class="line">    </span><br><span class="line">    // 输出商的结果（注意：result已经是高位到低位的顺序）</span><br><span class="line">    for (int i = result.size() - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">        cout &lt;&lt; result[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; endl&lt;&lt; r &lt;&lt; endl; // 输出余数</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-795.-前缀和">AcWing 795. 前缀和</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,l,r;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    int a[n],b[n];</span><br><span class="line">    for(int i = 1;i &lt;= n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    b[0]=0;</span><br><span class="line">    b[1]=a[1];</span><br><span class="line">    for (int i = 2; i &lt;= n; ++i)</span><br><span class="line">        b[i]=b[i-1]+a[i];</span><br><span class="line">    for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        cout&lt;&lt; b[r]-b[l-1]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-796.-子矩阵的和">AcWing 796. 子矩阵的和</h3>
<p>超时版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1010;</span><br><span class="line">int a[N][N],b[N][N];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,q,x1,x2,y1,y2,cnt;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt;= m; ++j) &#123;</span><br><span class="line">            if (j==0)&#123;</span><br><span class="line">                a[i][j]=0;</span><br><span class="line">                b[i][j]=0;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                cin&gt;&gt;a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; ++j) &#123;</span><br><span class="line">            b[i][j]=a[i][j]+b[i][j-1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= q ; ++i) &#123;</span><br><span class="line">        cnt=0;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">        for (int j = x1; j &lt;= x2 ; ++j) &#123;</span><br><span class="line">            cnt = cnt + b[j][y2]-b[j][y1-1];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>混元模型优化版</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1010;</span><br><span class="line">int a[N+1][N+1], b[N+1][N+1], s[N+1][N+1];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line"></span><br><span class="line">    int n, m, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    // 初始化数组并输入数据</span><br><span class="line">    memset(a, 0, sizeof a);</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 计算每行的前缀和</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; ++j) &#123;</span><br><span class="line">            b[i][j] = b[i][j-1] + a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 计算二维前缀和</span><br><span class="line">    memset(s, 0, sizeof s);</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; ++j) &#123;</span><br><span class="line">            s[i][j] = s[i-1][j] + b[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理查询</span><br><span class="line">    while (q--) &#123;</span><br><span class="line">        int x1, y1, x2, y2;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">        cout &lt;&lt; s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1] &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-797.-差分">AcWing 797. 差分</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,l,r,c;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    int a[n+1],b[n+1];</span><br><span class="line">    a[0]=0;</span><br><span class="line">    b[0]=0;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        b[i]=a[i]-a[i-1];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line">        b[l]+=c;</span><br><span class="line">        b[r+1]-=c;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        b[i]+=b[i-1];</span><br><span class="line">        cout&lt;&lt;b[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-798.-差分矩阵">AcWing 798. 差分矩阵</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;  // 引入输入输出流库</span><br><span class="line"></span><br><span class="line">using namespace std;  // 使用标准命名空间</span><br><span class="line"></span><br><span class="line">const int N = 1010;  // 定义一个常量N，表示数组的最大尺寸</span><br><span class="line">int a[N][N] = &#123;&#125;, s[N][N] = &#123;&#125;;  // 定义两个二维数组a和s，并初始化为0</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m, q, x1, y1, x2, y2, c;  // 定义变量用于存储输入的数据</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;  // 输入矩阵的行数n、列数m，以及操作的次数q</span><br><span class="line"></span><br><span class="line">    // 输入初始矩阵的值，并存储在s数组中</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; s[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 计算初始矩阵的前缀和，并存储在a数组中</span><br><span class="line">    // a[i][j]表示从(1,1)到(i,j)的子矩阵的和</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; ++j) &#123;</span><br><span class="line">            a[i][j] = s[i][j] + s[i - 1][j - 1] - s[i - 1][j] - s[i][j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理q次操作，每次操作给出一个子矩阵的左上角(x1,y1)和右下角(x2,y2)，以及要增加的值c</span><br><span class="line">    for (int i = 0; i &lt; q; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        // 使用差分数组的方法，对子矩阵进行加减操作</span><br><span class="line">        // 这样可以在O(1)的时间内完成子矩阵的加减操作</span><br><span class="line">        a[x1][y1] += c;</span><br><span class="line">        a[x1][y2 + 1] -= c;</span><br><span class="line">        a[x2 + 1][y1] -= c;</span><br><span class="line">        a[x2 + 1][y2 + 1] += c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据差分数组a，重新计算矩阵s的值</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; ++j) &#123;</span><br><span class="line">            // 通过前缀和的方式，计算出每个位置的值</span><br><span class="line">            s[i][j] = a[i][j] + s[i][j - 1] + s[i - 1][j] - s[i - 1][j - 1];</span><br><span class="line">            cout &lt;&lt; s[i][j] &lt;&lt; &quot; &quot;;  // 输出计算后的矩阵值</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;  // 换行，输出下一行的矩阵值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;  // 程序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-799.-最长连续不重复子序列">AcWing 799.
最长连续不重复子序列</h3>
<p>超时版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line">#include &quot;cstring&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,cnt=0,x=0;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    int a[n],b[100001]=&#123;0&#125;;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        if (b[a[i]]==0)&#123;</span><br><span class="line">            b[a[i]]=1;</span><br><span class="line">            cnt++;</span><br><span class="line">            x= max(cnt,x);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (b[a[i]]==1)&#123;</span><br><span class="line">            x= max(cnt,x);</span><br><span class="line">            i=i-cnt;</span><br><span class="line">            cnt=0;</span><br><span class="line">            memset(b, 0, sizeof(b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX_VALUE = 100001; // 根据题目数据范围设置最大值</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(nullptr);</span><br><span class="line"></span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; a(n);</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; last_pos(MAX_VALUE, -1); // 记录每个元素最后出现的索引</span><br><span class="line">    int max_len = 0, left = 0;</span><br><span class="line"></span><br><span class="line">    for (int right = 0; right &lt; n; ++right) &#123;</span><br><span class="line">        if (last_pos[a[right]] &gt;= left) &#123; // 如果该元素在当前窗口中出现过</span><br><span class="line">            left = last_pos[a[right]] + 1; // 移动左边界到重复元素的下一个位置</span><br><span class="line">        &#125;</span><br><span class="line">        last_pos[a[right]] = right; // 更新最后一次出现的位置</span><br><span class="line">        max_len = max(max_len, right - left + 1); // 更新最大长度</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; max_len &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-800.-数组元素的目标和">AcWing 800. 数组元素的目标和</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,x;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x;</span><br><span class="line">    int a[n],b[m];</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0,j=m-1; i &lt; n; ++i) &#123;</span><br><span class="line">        while (a[i]+b[j]&gt;x&amp;&amp;j&gt;0) j--;</span><br><span class="line">        if(a[i]+b[j]==x)</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-801.-二进制中1的个数">AcWing 801. 二进制中1的个数</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int lowbit(int x)&#123;</span><br><span class="line">    return x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,x;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        while (x)&#123;</span><br><span class="line">            x-= lowbit(x);</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-802.-区间和">AcWing 802. 区间和</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义一个类型别名 p，用于表示键值对 (int, int)</span><br><span class="line">typedef pair&lt;int, int&gt; p;</span><br><span class="line"></span><br><span class="line">// 存储添加操作的区间及其对应的值</span><br><span class="line">vector&lt;p&gt; add;</span><br><span class="line">// 存储查询操作的区间</span><br><span class="line">vector&lt;p&gt; query;</span><br><span class="line">// 存储所有出现过的坐标，用于离散化</span><br><span class="line">vector&lt;int&gt; alls;</span><br><span class="line"></span><br><span class="line">// 定义常量 N，设定数组的最大大小</span><br><span class="line">const int N = 300010;</span><br><span class="line">// 数组 a 用于存储每个离散化后的位置的累加值</span><br><span class="line">int a[N];</span><br><span class="line">// 数组 s 用于存储前缀和，便于快速查询区间和</span><br><span class="line">int s[N];</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief 使用二分查找找到 x 在 alls 中的位置，并返回其在离散化后的索引（从1开始）</span><br><span class="line"> * </span><br><span class="line"> * @param x 需要查找的坐标</span><br><span class="line"> * @return int 离散化后的索引</span><br><span class="line"> */</span><br><span class="line">int find(int x) &#123;</span><br><span class="line">    int l = 0, r = alls.size() - 1, mid;</span><br><span class="line">    // 标准的二分查找，找到第一个 &gt;= x 的位置</span><br><span class="line">    while (l &lt; r) &#123;</span><br><span class="line">        mid = (l + r) / 2;</span><br><span class="line">        if (alls[mid] &gt;= x)</span><br><span class="line">            r = mid;</span><br><span class="line">        else</span><br><span class="line">            l = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回离散化后的索引（假设 alls 已排序且唯一）</span><br><span class="line">    return r + 1; // 索引从1开始，方便后续前缀和计算</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m; // n 是添加操作的次数，m 是查询操作的次数</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    // 处理所有的添加操作</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        int x, c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.emplace_back(x, c); // 存储添加操作的坐标和值</span><br><span class="line">        alls.push_back(x);      // 将坐标记录下来，用于后续离散化</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理所有的查询操作</span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        int l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        query.emplace_back(l, r); // 存储查询操作的区间</span><br><span class="line">        alls.push_back(l);        // 记录查询区间的左右端点</span><br><span class="line">        alls.push_back(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对所有记录的坐标进行排序</span><br><span class="line">    sort(alls.begin(), alls.end());</span><br><span class="line"></span><br><span class="line">    // 去除重复的坐标，并调整 alls 的大小</span><br><span class="line">    alls.erase(unique(alls.begin(), alls.end()), alls.end());</span><br><span class="line"></span><br><span class="line">    // 遍历所有的添加操作，将对应的值累加到离散化后的位置</span><br><span class="line">    for (auto aa : add) &#123;</span><br><span class="line">        // 找到坐标 aa.first 在离散化后的索引，并累加值 aa.second</span><br><span class="line">        a[find(aa.first)] += aa.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 计算前缀和数组 s，s[i] 表示前 i 个位置的累加总和</span><br><span class="line">    for (int i = 1; i &lt;= alls.size(); i++) &#123;</span><br><span class="line">        s[i] = s[i - 1] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理每一个查询操作，输出对应区间的累加和</span><br><span class="line">    for (auto q : query) &#123;</span><br><span class="line">        // 计算区间 [q.first, q.second] 的累加和</span><br><span class="line">        // find(q.second) 得到右端点的离散索引</span><br><span class="line">        // find(q.first) - 1 得到左端点前一个位置的离散索引</span><br><span class="line">        cout &lt;&lt; s[find(q.second)] - s[find(q.first) - 1] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-803.-区间合并">AcWing 803. 区间合并</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int, int&gt; p;    // 定义区间类型，方便后续使用</span><br><span class="line"></span><br><span class="line">vector&lt;p&gt; nums, res;         // nums存储原始区间，res存储合并后的结果</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, l, r;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    // 读取n个区间并存入nums容器</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        nums.emplace_back(l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 按照区间的起始点进行升序排序</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    </span><br><span class="line">    int start = -1, end = -1;</span><br><span class="line">    // 遍历每个区间，进行合并处理</span><br><span class="line">    for (auto num : nums) &#123;</span><br><span class="line">        if (num.first &gt; end) &#123; // 当前区间与已合并区间无重叠</span><br><span class="line">            if (end != -1) &#123; // 如果已有合并区间，则存入结果集</span><br><span class="line">                res.emplace_back(start, end);</span><br><span class="line">            &#125;</span><br><span class="line">            // 更新当前合并区间的起始和结束位置</span><br><span class="line">            start = num.first;</span><br><span class="line">            end = num.second;</span><br><span class="line">        &#125; else if (num.second &gt; end) &#123; // 当前区间与已合并区间有重叠，合并它们</span><br><span class="line">            end = num.second; // 扩展合并区间的结束位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理最后一个区间</span><br><span class="line">    res.emplace_back(start, end);</span><br><span class="line">    </span><br><span class="line">    // 输出合并后的不重叠区间数量</span><br><span class="line">    cout &lt;&lt; res.size() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-2816.-判断子序列">AcWing 2816. 判断子序列</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt; // 引入输入输出流库</span><br><span class="line"></span><br><span class="line">using namespace std; // 使用标准命名空间</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n, m, x = 0; // 声明并初始化变量 n 和 m，x 用于跟踪数组 a 的匹配索引</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; // 从标准输入读取两个整数 n 和 m</span><br><span class="line">    // n 表示第一个数组的大小，m 表示第二个数组的大小</span><br><span class="line">    </span><br><span class="line">    int a[n], b[m]; // 声明两个整型数组 a 和 b，大小分别为 n 和 m</span><br><span class="line">    // 注意：在 C++ 中，使用变量长度数组（VLA）是非标准的，建议使用 vector 替代</span><br><span class="line">    </span><br><span class="line">    // 读取 n 个整数存入数组 a</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 读取 m 个整数存入数组 b</span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 遍历数组 b，检查数组 a 中的元素是否按顺序出现在数组 b 中</span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123; // 遍历数组 b 的每一个元素</span><br><span class="line">        if(a[x] == b[i] &amp;&amp; x &lt; n) &#123; // 如果 a 的当前元素等于 b 的当前元素，并且 x 没有超出 a 的范围</span><br><span class="line">            x++; // 匹配成功，移动到 a 的下一个元素</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 检查是否所有 a 的元素都按顺序在 b 中找到了匹配</span><br><span class="line">    if(x != n) </span><br><span class="line">        cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; // 如果有 a 的元素未匹配，输出 &quot;No&quot;</span><br><span class="line">    else </span><br><span class="line">        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; // 如果所有 a 的元素都匹配，输出 &quot;Yes&quot;</span><br><span class="line">    </span><br><span class="line">    return 0; // 程序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="第二讲-数据结构">第二讲 数据结构</h2>
<p><strong>2025.3.4</strong></p>
<h3 id="acwing-826.-单链表">AcWing 826. 单链表</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;  // 引入输入输出流库</span><br><span class="line"></span><br><span class="line">using namespace std;  // 使用标准命名空间</span><br><span class="line"></span><br><span class="line">const int N = 100010;  // 定义一个常量N，表示链表的最大长度</span><br><span class="line">int e[N], ne[N], idx = 1, hh = 0;  // 定义数组e存储链表节点的值，ne存储下一个节点的索引，idx为当前节点索引，hh为头节点索引</span><br><span class="line"></span><br><span class="line">// 在链表头部添加一个值为x的节点</span><br><span class="line">void add_to_head(int x) &#123;</span><br><span class="line">    e[idx] = x;          // 将x存入当前节点的值</span><br><span class="line">    ne[idx] = hh;        // 将当前节点的下一个节点指向原来的头节点</span><br><span class="line">    hh = idx++;          // 更新头节点为当前节点，并将索引值自增</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除链表中第k个节点的下一个节点</span><br><span class="line">void Delete(int k) &#123;</span><br><span class="line">    if (k == 0) &#123;        // 如果k为0，表示删除头节点</span><br><span class="line">        hh = ne[hh];     // 更新头节点为下一个节点</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ne[k] = ne[ne[k]];  // 将第k个节点的下一个节点指向其下下个节点，从而删除第k+1个节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在链表中第k个节点后面添加一个值为x的节点</span><br><span class="line">void add(int k, int x) &#123;</span><br><span class="line">    e[idx] = x;          // 将x存入当前节点的值</span><br><span class="line">    ne[idx] = ne[k];     // 将当前节点的下一个节点指向第k个节点的下一个节点</span><br><span class="line">    ne[k] = idx++;       // 将第k个节点的下一个节点指向当前节点，并将索引值自增</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int m;               // 定义一个变量m表示操作次数</span><br><span class="line">    cin &gt;&gt; m;            // 输入操作次数</span><br><span class="line">    while (m--) &#123;        // 循环m次，执行相应操作</span><br><span class="line">        char c;          // 定义一个字符变量c表示操作类型</span><br><span class="line">        int k, x;        // 定义变量k和x，k表示节点位置，x表示节点值</span><br><span class="line">        cin &gt;&gt; c;        // 输入操作类型</span><br><span class="line">        if (c == &#x27;H&#x27;) &#123;  // 如果操作类型为&#x27;H&#x27;，表示在头部添加节点</span><br><span class="line">            cin &gt;&gt; x;    // 输入节点值</span><br><span class="line">            add_to_head(x);  // 调用add_to_head函数添加节点</span><br><span class="line">        &#125; else if (c == &#x27;D&#x27;) &#123;  // 如果操作类型为&#x27;D&#x27;，表示删除节点</span><br><span class="line">            cin &gt;&gt; k;    // 输入要删除的节点位置</span><br><span class="line">            Delete(k);   // 调用Delete函数删除节点</span><br><span class="line">        &#125; else &#123;         // 如果操作类型为其他，表示在指定位置后添加节点</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;  // 输入节点位置和节点值</span><br><span class="line">            add(k, x);      // 调用add函数添加节点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 遍历链表并输出所有节点的值</span><br><span class="line">    for (int i = hh; i != 0; i = ne[i]) &#123;  // 从头节点开始，依次遍历每个节点</span><br><span class="line">        cout &lt;&lt; e[i] &lt;&lt; &quot; &quot;;  // 输出当前节点的值，并在后面加一个空格</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;  // 程序正常结束，返回0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-827.-双链表">AcWing 827. 双链表</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot; // 引入输入输出流库</span><br><span class="line"></span><br><span class="line">using namespace std; // 使用标准命名空间</span><br><span class="line"></span><br><span class="line">const int N = 100010; // 定义数组的最大容量，假设最多有100,000个节点</span><br><span class="line"></span><br><span class="line">int m, x, k; // 定义变量：</span><br><span class="line">// m: 操作次数</span><br><span class="line">// x: 插入或删除的值</span><br><span class="line">// k: 节点编号相关的参数</span><br><span class="line">string c; // 操作类型字符串</span><br><span class="line"></span><br><span class="line">// 定义数组用于模拟双向链表：</span><br><span class="line">// e[N]: 存储每个节点的值</span><br><span class="line">// l[N]: 存储每个节点左边节点的索引</span><br><span class="line">// r[N]: 存储每个节点右边节点的索引</span><br><span class="line">// idx: 当前可用的节点索引，初始化为2（因为0和1已被占用）</span><br><span class="line">int e[N], l[N], r[N], idx = 2;</span><br><span class="line"></span><br><span class="line">// 在指定位置pos的右边插入值为i的新节点</span><br><span class="line">void insert(int pos, int i)&#123;</span><br><span class="line">    e[idx] = i;          // 将新节点的值设为i</span><br><span class="line">    l[idx] = pos;        // 新节点的左邻居设为pos</span><br><span class="line">    r[idx] = r[pos];     // 新节点的右邻居设为pos原来的右邻居</span><br><span class="line">    l[r[pos]] = idx;     // pos原来的右邻居的左邻居设为新节点</span><br><span class="line">    r[pos] = idx++;      // pos的右邻居更新为新节点，并递增idx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除指定位置pos的节点</span><br><span class="line">void remove(int pos)&#123;</span><br><span class="line">    l[r[pos]] = l[pos]; // pos左邻居的右邻居指向pos的右邻居</span><br><span class="line">    r[l[pos]] = r[pos]; // pos右邻居的左邻居指向pos的左邻居</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; m; // 输入操作次数</span><br><span class="line"></span><br><span class="line">    // 初始化双向链表的左右端点：</span><br><span class="line">    // 0表示最左端，1表示最右端</span><br><span class="line">    r[0] = 1; // 最左端的右邻居是最右端</span><br><span class="line">    l[1] = 0; // 最右端的左邻居是最左端</span><br><span class="line"></span><br><span class="line">    while (m--)&#123; // 循环处理每一个操作</span><br><span class="line">        cin &gt;&gt; c; // 输入操作类型</span><br><span class="line"></span><br><span class="line">        if (c == &quot;L&quot;)&#123; // 在最左端插入值x</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            insert(0, x); // 在位置0（最左端）插入x</span><br><span class="line">        &#125; </span><br><span class="line">        else if(c == &quot;R&quot;)&#123; // 在最右端插入值x</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            insert(l[1], x); // 在最右端的左邻居（即位置1）插入x</span><br><span class="line">        &#125; </span><br><span class="line">        else if(c == &quot;D&quot;)&#123; // 删除编号为k的节点</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            remove(k + 1); // 节点编号从1开始，数组索引从2开始，因此k对应的节点是k+1</span><br><span class="line">        &#125; </span><br><span class="line">        else if(c == &quot;IL&quot;)&#123; // 在编号为k的节点左边插入值x</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            insert(l[k + 1], x); // 在编号为k的节点的左邻居处插入x</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123; // 其他情况默认为在编号为k的节点右边插入值x</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            insert(k + 1, x); // 在编号为k的节点的右邻居处插入x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历并输出链表中的所有元素，从最左端开始，直到最右端</span><br><span class="line">    for (int i = r[0]; i != 1; i = r[i]) &#123; // r[0]是最左端，1是最右端</span><br><span class="line">        cout &lt;&lt; e[i] &lt;&lt; &quot; &quot;; // 输出当前节点的值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0; // 程序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-828.-模拟栈">AcWing 828. 模拟栈</h3>
<p>内置函数法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int M;</span><br><span class="line">    cin &gt;&gt; M; // 输入操作次数</span><br><span class="line"></span><br><span class="line">    stack&lt;int&gt; s; // 创建一个空栈</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; M; i++) &#123;</span><br><span class="line">        string operation;</span><br><span class="line">        cin &gt;&gt; operation; // 输入操作命令</span><br><span class="line"></span><br><span class="line">        if (operation == &quot;push&quot;) &#123;</span><br><span class="line">            int x;</span><br><span class="line">            cin &gt;&gt; x; // 输入要插入的数</span><br><span class="line">            s.push(x); // 将数压入栈</span><br><span class="line">        &#125; else if (operation == &quot;pop&quot;) &#123;</span><br><span class="line">            if (!s.empty()) &#123;</span><br><span class="line">                s.pop(); // 弹出栈顶元素</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (operation == &quot;empty&quot;) &#123;</span><br><span class="line">            if (s.empty()) &#123;</span><br><span class="line">                cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; // 栈为空，输出YES</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; // 栈不为空，输出NO</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (operation == &quot;query&quot;) &#123;</span><br><span class="line">            if (!s.empty()) &#123;</span><br><span class="line">                cout &lt;&lt; s.top() &lt;&lt; endl; // 输出栈顶元素</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot; // 引入输入输出流库</span><br><span class="line"></span><br><span class="line">using namespace std; // 使用标准命名空间</span><br><span class="line"></span><br><span class="line">const int N = 100010; // 定义栈的最大容量为100,000</span><br><span class="line"></span><br><span class="line">int st[N]; // 定义一个数组来模拟栈</span><br><span class="line">int top = -1; // 初始化栈顶指针，-1表示栈为空</span><br><span class="line">int n, a; // 定义变量：</span><br><span class="line">// n: 操作次数</span><br><span class="line">// a: 用于存储push操作的值</span><br><span class="line">string s; // 存储每次操作的命令</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n; // 输入操作次数</span><br><span class="line"></span><br><span class="line">    while (n--)&#123; // 循环处理每一个操作</span><br><span class="line">        cin &gt;&gt; s; // 输入操作类型</span><br><span class="line"></span><br><span class="line">        if (s == &quot;push&quot;)&#123; // 如果操作类型是&quot;push&quot;</span><br><span class="line">            cin &gt;&gt; a; // 输入要压入栈的值</span><br><span class="line">            st[++top] = a; // 栈顶指针先递增，然后将值a存入新的栈顶位置</span><br><span class="line">        &#125; </span><br><span class="line">        else if(s == &quot;pop&quot;)&#123; // 如果操作类型是&quot;pop&quot;</span><br><span class="line">            top--; // 栈顶指针递减，表示弹出栈顶元素</span><br><span class="line">        &#125; </span><br><span class="line">        else if(s == &quot;query&quot;)&#123; // 如果操作类型是&quot;query&quot;</span><br><span class="line">            cout &lt;&lt; st[top] &lt;&lt; endl; // 输出当前栈顶元素</span><br><span class="line">        &#125; </span><br><span class="line">        else&#123; // 其他情况默认为操作类型是&quot;empty&quot;</span><br><span class="line">            // 判断栈是否为空，并输出相应的结果</span><br><span class="line">            cout &lt;&lt; (top == -1 ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; endl; </span><br><span class="line">            // 如果栈顶指针为-1，表示栈为空，输出&quot;YES&quot;；否则输出&quot;NO&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0; // 程序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-3302.-表达式求值">AcWing 3302. 表达式求值</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string s; // 存储输入的表达式字符串</span><br><span class="line">stack&lt;int&gt; num; // 用于存放操作数的栈</span><br><span class="line">stack&lt;char&gt; op; // 用于存放运算符的栈</span><br><span class="line">unordered_map&lt;char, int&gt; h&#123;&#123;&#x27;+&#x27;,1&#125;, &#123;&#x27;-&#x27;,1&#125;, &#123;&#x27;*&#x27;,2&#125;, &#123;&#x27;/&#x27;,2&#125;&#125;; // 运算符优先级表</span><br><span class="line"></span><br><span class="line">// 执行栈顶的运算操作，将结果存回num栈</span><br><span class="line">void eval()&#123;</span><br><span class="line">    int a = num.top(); num.pop(); // 弹出第二个操作数</span><br><span class="line">    int b = num.top(); num.pop(); // 弹出第一个操作数</span><br><span class="line">    char p = op.top(); op.pop(); // 弹出运算符</span><br><span class="line">    </span><br><span class="line">    int r = 0;</span><br><span class="line">    switch (p) &#123;</span><br><span class="line">        case &#x27;+&#x27;: r = b + a; break; // 加法运算</span><br><span class="line">        case &#x27;-&#x27;: r = b - a; break; // 减法运算（注意顺序）</span><br><span class="line">        case &#x27;*&#x27;: r = b * a; break; // 乘法运算</span><br><span class="line">        case &#x27;/&#x27;: r = b / a; break; // 整除运算</span><br><span class="line">        default: break;</span><br><span class="line">    &#125;</span><br><span class="line">    num.push(r); // 将结果压入操作数栈</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; s; // 读取输入的中缀表达式</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; s.size(); ++i) &#123;</span><br><span class="line">        if (isdigit(s[i])) &#123; // 处理多位数字字符</span><br><span class="line">            int x = 0, j = i;</span><br><span class="line">            while (j &lt; s.size() &amp;&amp; isdigit(s[j])) &#123; // 提取完整数字</span><br><span class="line">                x = x * 10 + (s[j] - &#x27;0&#x27;);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            num.push(x); // 将数字压入栈</span><br><span class="line">            i = j - 1; // 调整索引以跳过已处理的数字</span><br><span class="line">        &#125; else if (s[i] == &#x27;(&#x27;) &#123; // 左括号直接入栈</span><br><span class="line">            op.push(s[i]);</span><br><span class="line">        &#125; else if (s[i] == &#x27;)&#x27;) &#123; // 右括号触发计算直到左括号</span><br><span class="line">            while (op.top() != &#x27;(&#x27;)</span><br><span class="line">                eval();</span><br><span class="line">            op.pop(); // 弹出左括号（不处理）</span><br><span class="line">        &#125; else &#123; // 处理运算符：保证优先级高的先计算</span><br><span class="line">            while (!op.empty() &amp;&amp; h[op.top()] &gt;= h[s[i]]) &#123; </span><br><span class="line">                eval();</span><br><span class="line">            &#125;</span><br><span class="line">            op.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理剩余的运算符</span><br><span class="line">    while (!op.empty())</span><br><span class="line">        eval();</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; num.top() &lt;&lt; endl; // 输出最终结果</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-829.-模拟队列">AcWing 829. 模拟队列</h3>
<p>内置函数法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line">#include &quot;queue&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">string s;</span><br><span class="line">int n,x;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    while (n--)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        if (s==&quot;push&quot;)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            q.push(x);</span><br><span class="line">        &#125;else if(s==&quot;empty&quot;)&#123;</span><br><span class="line">            if (q.empty())</span><br><span class="line">                cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">            else</span><br><span class="line">                cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;else if(s==&quot;query&quot;)&#123;</span><br><span class="line">            cout&lt;&lt;q.front()&lt;&lt;endl;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=100010;</span><br><span class="line">int qh=-1,qt=-1,n,x;</span><br><span class="line">int a[N];</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    while (n--)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        if(s==&quot;push&quot;)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            a[++qt]=x;</span><br><span class="line">        &#125; else if(s==&quot;pop&quot;)&#123;</span><br><span class="line">            qh++;</span><br><span class="line">        &#125;else if (s==&quot;empty&quot;)&#123;</span><br><span class="line">            if (qt==qh)</span><br><span class="line">                cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">            else</span><br><span class="line">                cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cout&lt;&lt;a[qh+1]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-830.-单调栈">AcWing 830. 单调栈</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;   // 引入输入输出流库</span><br><span class="line">#include &quot;stack&quot;      // 引入栈容器库</span><br><span class="line"></span><br><span class="line">using namespace std;  // 使用标准命名空间</span><br><span class="line"></span><br><span class="line">int n, x;              // 定义两个整数变量，n用于存储测试用例的数量，x用于临时存储每个输入的值</span><br><span class="line">stack&lt;int&gt; s;          // 定义一个整数类型的栈，用于辅助查找下一个更小的元素</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n;          // 从标准输入读取测试用例的数量</span><br><span class="line">    while (n--)&#123;       // 循环处理每一个测试用例</span><br><span class="line">        cin &gt;&gt; x;      // 从标准输入读取当前需要处理的整数x</span><br><span class="line">        </span><br><span class="line">        // 当栈不为空且栈顶元素大于等于当前输入的x时，持续弹出栈顶元素</span><br><span class="line">        // 这一步的目的是找到当前x左边第一个比它小的元素</span><br><span class="line">        while (!s.empty() &amp;&amp; s.top() &gt;= x)</span><br><span class="line">            s.pop();</span><br><span class="line">        </span><br><span class="line">        // 如果栈不为空，说明找到了一个比x小的元素，输出该元素</span><br><span class="line">        // 如果栈为空，说明x左边没有比它小的元素，输出-1</span><br><span class="line">        if (!s.empty())</span><br><span class="line">            cout &lt;&lt; s.top() &lt;&lt; &quot; &quot;;  // 输出栈顶元素，即当前x左边第一个更小的元素</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; -1 &lt;&lt; &quot; &quot;;       // 输出-1，表示没有更小的元素</span><br><span class="line">        </span><br><span class="line">        s.push(x);       // 将当前输入的x压入栈中，供后续元素比较使用</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;            // 程序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-154.-滑动窗口">AcWing 154. 滑动窗口</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1000010;</span><br><span class="line">int a[N]; // 存储输入的数组元素</span><br><span class="line">int n, k; // n为数组长度，k为滑动窗口大小</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    deque&lt;int&gt; dq; // 定义一个双端队列，用于维护滑动窗口内的最大值或最小值</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k; // 输入数组长度和滑动窗口大小</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i]; // 输入数组元素</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 求解滑动窗口内的最大值</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        // 当队列非空且队尾元素大于当前元素时，弹出队尾元素，保证队列单调递减</span><br><span class="line">        while (!dq.empty() &amp;&amp; dq.back() &gt; a[i])</span><br><span class="line">            dq.pop_back();</span><br><span class="line">        dq.push_back(a[i]); // 将当前元素加入队列</span><br><span class="line">        // 当窗口大小达到k时，检查队首元素是否等于窗口最左边的元素，若相等则弹出队首元素</span><br><span class="line">        if (i - k &gt;= 1 &amp;&amp; dq.front() == a[i - k])</span><br><span class="line">            dq.pop_front();</span><br><span class="line">        // 当窗口大小达到k时，输出队首元素，即当前窗口的最大值</span><br><span class="line">        if (i &gt;= k)</span><br><span class="line">            cout &lt;&lt; dq.front() &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    dq.clear(); // 清空队列，准备求解滑动窗口内的最小值</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 求解滑动窗口内的最小值</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        // 当队列非空且队尾元素小于当前元素时，弹出队尾元素，保证队列单调递增</span><br><span class="line">        while (!dq.empty() &amp;&amp; dq.back() &lt; a[i])</span><br><span class="line">            dq.pop_back();</span><br><span class="line">        dq.push_back(a[i]); // 将当前元素加入队列</span><br><span class="line">        // 当窗口大小达到k时，检查队首元素是否等于窗口最左边的元素，若相等则弹出队首元素</span><br><span class="line">        if (i - k &gt;= 1 &amp;&amp; a[i - k] == dq.front())</span><br><span class="line">            dq.pop_front();</span><br><span class="line">        // 当窗口大小达到k时，输出队首元素，即当前窗口的最小值</span><br><span class="line">        if (i &gt;= k)</span><br><span class="line">            cout &lt;&lt; dq.front() &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-831.-kmp字符串">AcWing 831. KMP字符串</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot; // 引入输入输出流库</span><br><span class="line"></span><br><span class="line">using namespace std; // 使用标准命名空间</span><br><span class="line"></span><br><span class="line">// 定义常量N和M，设置模式串和主串的最大长度</span><br><span class="line">const int N = 100010, M = 1000010;</span><br><span class="line"></span><br><span class="line">// 全局变量声明</span><br><span class="line">int n, m, ne[N]; // n为模式串长度，m为主串长度，ne数组用于存储KMP算法的next值</span><br><span class="line">char p[N], s[M]; // p数组存储模式串，s数组存储主串</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 输入模式串的长度n，并将模式串p的输入从p[1]开始存储（为了方便后续处理，通常从1开始索引）</span><br><span class="line">    // 接着输入主串的长度m，并将主串s的输入从s[1]开始存储</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1;</span><br><span class="line"></span><br><span class="line">    // 构建模式串p的Next数组，用于KMP算法中的模式匹配</span><br><span class="line">    for (int i = 2, j = 0; i &lt;= n; ++i) &#123; // 从模式串的第二个字符开始遍历</span><br><span class="line">        // 当j不为0且当前字符p[i]与模式串中p[j+1]不匹配时，回退到上一个可能的匹配位置</span><br><span class="line">        while (j &amp;&amp; p[i] != p[j + 1])</span><br><span class="line">            j = ne[j];</span><br><span class="line">        </span><br><span class="line">        // 如果当前字符p[i]与模式串中p[j+1]匹配，增加匹配长度j</span><br><span class="line">        if (p[i] == p[j + 1])</span><br><span class="line">            j++;</span><br><span class="line">        </span><br><span class="line">        // 将当前的匹配长度j存储到Next数组中，供后续匹配使用</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 使用KMP算法在主串s中查找模式串p的所有出现位置</span><br><span class="line">    for (int i = 1, j = 0; i &lt;= m; ++i) &#123; // 从主串的第一个字符开始遍历</span><br><span class="line">        // 当j不为0且当前字符s[i]与模式串中p[j+1]不匹配时，回退到上一个可能的匹配位置</span><br><span class="line">        while (j &amp;&amp; s[i] != p[j + 1])</span><br><span class="line">            j = ne[j];</span><br><span class="line">        </span><br><span class="line">        // 如果当前字符s[i]与模式串中p[j+1]匹配，增加匹配长度j</span><br><span class="line">        if (s[i] == p[j + 1])</span><br><span class="line">            j++;</span><br><span class="line">        </span><br><span class="line">        // 如果j等于模式串的长度n，表示找到了一个完整的匹配</span><br><span class="line">        if (j == n) &#123;</span><br><span class="line">            // 输出匹配的起始位置（相对于主串的起始位置）</span><br><span class="line">            cout &lt;&lt; i - n &lt;&lt; &quot; &quot;;</span><br><span class="line">            </span><br><span class="line">            // 继续查找下一个可能的匹配，调整j的位置为ne[j]</span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0; // 程序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-835.-trie字符串统计">AcWing 835. Trie字符串统计</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;   // 引入输入输出流库</span><br><span class="line">#include &lt;map&gt;        // 引入map容器库，用于存储字符串及其对应的计数</span><br><span class="line">#include &lt;string&gt;     // 引入字符串处理库</span><br><span class="line"></span><br><span class="line">using namespace std;  // 使用标准命名空间，简化代码书写</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int N;                  // 定义一个整数变量N，用于存储操作的总次数</span><br><span class="line">    cin &gt;&gt; N;               // 从标准输入读取操作的总次数</span><br><span class="line"></span><br><span class="line">    map&lt;string, int&gt; countMap; // 定义一个map容器，键为string类型（字符串），值为int类型（计数）</span><br><span class="line">                             // 用于记录每个字符串出现的次数</span><br><span class="line"></span><br><span class="line">    string op, x;            // 定义两个字符串变量，op用于存储操作类型，x用于存储操作的字符串</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; N; ++i) &#123; // 循环N次，依次处理每一个操作</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x;          // 从标准输入读取操作类型和对应的字符串</span><br><span class="line"></span><br><span class="line">        if (op == &quot;I&quot;) &#123;         // 如果操作类型是&quot;I&quot;，表示插入操作</span><br><span class="line">            countMap[x]++;       // 将字符串x对应的计数加1</span><br><span class="line">                               // 如果x不存在于map中，会自动初始化为0，然后自增为1</span><br><span class="line">        &#125;</span><br><span class="line">        else if (op == &quot;Q&quot;) &#123;    // 如果操作类型是&quot;Q&quot;，表示查询操作</span><br><span class="line">            // 输出字符串x当前的计数，如果x不存在，map会返回默认值0</span><br><span class="line">            cout &lt;&lt; countMap[x] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果操作类型既不是&quot;I&quot;也不是&quot;Q&quot;，则忽略该操作</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0; // 程序结束，返回0表示成功</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-143.-最大异或对">AcWing 143. 最大异或对</h3>
<p>还是不咋会</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义常量N为100010，表示输入数组的最大长度</span><br><span class="line">// M为N*32，用于存储字典树节点，假设每个数最多32位</span><br><span class="line">const int N=100010,M=N*32;</span><br><span class="line">int n, ans=0, idx=0; // n为输入数组长度，ans存储最大异或值，idx为字典树节点索引</span><br><span class="line">int a[N], son[M][2]; // a为输入数组，son为字典树的左右子节点数组</span><br><span class="line"></span><br><span class="line">// 插入一个整数i到字典树中</span><br><span class="line">void insert(int i)&#123;</span><br><span class="line">    int p=0; // 从字典树的根节点开始</span><br><span class="line">    // 遍历整数i的每一位，从最高位到最低位</span><br><span class="line">    for (int j = 30; j &gt;=0 ; --j) &#123;</span><br><span class="line">        int u=i&gt;&gt;j&amp;1; // 提取整数i的第j位</span><br><span class="line">        if (!son[p][u]) // 如果当前位对应的子节点不存在</span><br><span class="line">            son[p][u]=++idx; // 创建新的子节点，并更新索引</span><br><span class="line">        p=son[p][u]; // 移动到下一个节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在字典树中查找与整数i异或结果最大的数</span><br><span class="line">int find(int i)&#123;</span><br><span class="line">    int p=0, res=0; // 从字典树的根节点开始，res存储当前最大异或值</span><br><span class="line">    // 遍历整数i的每一位，从最高位到最低位</span><br><span class="line">    for (int j = 30; j &gt;=0 ; --j) &#123;</span><br><span class="line">        int u=i&gt;&gt;j&amp;1; // 提取整数i的第j位</span><br><span class="line">        if (son[p][!u])&#123; // 如果存在与当前位相反的子节点</span><br><span class="line">            p=son[p][!u]; // 移动到该子节点</span><br><span class="line">            res=res*2+1; // 更新最大异或值</span><br><span class="line">        &#125; else &#123; // 如果不存在与当前位相反的子节点</span><br><span class="line">            p=son[p][u]; // 移动到当前位的子节点</span><br><span class="line">            res*=2; // 更新最大异或值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res; // 返回最大异或值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n; // 输入数组长度</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;a[i]; // 输入数组元素</span><br><span class="line">        insert(a[i]); // 将元素插入字典树</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        ans = max(ans, find(a[i])); // 查找与当前元素异或结果最大的数，并更新最大异或值</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl; // 输出最大异或值</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-836.-合并集合">AcWing 836. 合并集合</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义常量N为100010，表示元素的最大数量</span><br><span class="line">const int N = 100010;</span><br><span class="line"></span><br><span class="line">// 数组a用于存储每个元素的父节点，初始时每个元素的父节点指向自己</span><br><span class="line">int a[N];</span><br><span class="line">int n, m; // n表示元素的数量，m表示操作的数量</span><br><span class="line">int x, y; // 用于存储每次操作的参数</span><br><span class="line">char c;   // 存储操作类型，&#x27;M&#x27;表示合并，其他表示查找</span><br><span class="line"></span><br><span class="line">// 查找函数，使用路径压缩优化</span><br><span class="line">int Find(int i)&#123;</span><br><span class="line">    // 如果当前元素的父节点不是自己，递归查找父节点，并进行路径压缩</span><br><span class="line">    if (a[i] != i)</span><br><span class="line">        a[i] = Find(a[i]);</span><br><span class="line">    return a[i]; // 返回当前元素的根节点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; // 输入元素数量和操作数量</span><br><span class="line"></span><br><span class="line">    // 初始化并查集，每个元素的父节点指向自己</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理m个操作</span><br><span class="line">    while (m--)&#123;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; x &gt;&gt; y; // 输入操作类型和两个元素</span><br><span class="line"></span><br><span class="line">        if (c == &#x27;M&#x27;)&#123;</span><br><span class="line">            // 合并操作：将x所在的集合合并到y所在的集合</span><br><span class="line">            // 具体做法是将x的根节点的父节点指向y的根节点</span><br><span class="line">            a[Find(x)] = Find(y);</span><br><span class="line">            // 注意：这里原代码是a[Find(y)] = Find(x); 可能是笔误，通常合并是将一个集合的根指向另一个集合的根</span><br><span class="line">            // 如果要合并x到y，应该是a[Find(x)] = Find(y);</span><br><span class="line">            // 如果要合并y到x，应该是a[Find(y)] = Find(x);</span><br><span class="line">            // 根据具体需求调整</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            // 查找操作：判断x和y是否在同一个集合中</span><br><span class="line">            if (Find(x) == Find(y))</span><br><span class="line">                cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; // 如果根节点相同，说明在同一集合</span><br><span class="line">            else</span><br><span class="line">                cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;  // 否则不在同一集合</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-837.-连通块中点的数量">AcWing 837. 连通块中点的数量</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line">#include &quot;string&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义常量N为100010，用于数组大小</span><br><span class="line">const int N=100010;</span><br><span class="line"></span><br><span class="line">// a数组用于存储并查集的父节点信息</span><br><span class="line">int a[N];</span><br><span class="line">// S数组用于存储每个集合的大小</span><br><span class="line">int S[N];</span><br><span class="line"></span><br><span class="line">int n, m; // n表示元素的数量，m表示操作的次数</span><br><span class="line">string s; // 用于存储每次操作的类型</span><br><span class="line">int x, y; // 用于存储操作涉及的元素编号</span><br><span class="line"></span><br><span class="line">// 查找函数，使用路径压缩优化查找根节点</span><br><span class="line">int Find(int x)&#123;</span><br><span class="line">    if (a[x]==x) return x; // 如果x是根节点，直接返回x</span><br><span class="line">    else return a[x]= Find(a[x]); // 否则递归查找，并将x的父节点直接指向根节点，实现路径压缩</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 合并函数，将x和y所在的集合合并</span><br><span class="line">void merge(int x,int y)&#123;</span><br><span class="line">    x= Find(x); // 找到x所在集合的根节点</span><br><span class="line">    y= Find(y); // 找到y所在集合的根节点</span><br><span class="line">    a[x] = y; // 将x的根节点指向y的根节点，实现合并</span><br><span class="line">    S[y]+=S[x]; // 更新y所在集合的大小，加上x所在集合的大小</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断函数，判断x和y是否在同一个集合中</span><br><span class="line">bool same(int x,int y)&#123;</span><br><span class="line">    return Find(x) == Find(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m; // 输入元素的数量和操作的次数</span><br><span class="line">    for (int i = 1 ; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i]=i; // 初始化并查集，每个元素的父节点初始化为自身</span><br><span class="line">        S[i]=1; // 初始化每个集合的大小为1</span><br><span class="line">    &#125;</span><br><span class="line">    while (m--)&#123;</span><br><span class="line">        cin&gt;&gt;s; // 输入操作的类型</span><br><span class="line">        if (s==&quot;C&quot;)&#123; // 如果操作类型为&quot;C&quot;，表示合并操作</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y; // 输入要合并的两个元素</span><br><span class="line">            if (!same(x,y)) // 如果两个元素不在同一个集合中</span><br><span class="line">                merge(x,y); // 合并两个元素所在的集合</span><br><span class="line">        &#125;else if(s==&quot;Q1&quot;)&#123; // 如果操作类型为&quot;Q1&quot;，表示查询两个元素是否在同一个集合中</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y; // 输入要查询的两个元素</span><br><span class="line">            if(same(x,y)) // 如果两个元素在同一个集合中</span><br><span class="line">                cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; // 输出&quot;Yes&quot;</span><br><span class="line">            else</span><br><span class="line">                cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; // 输出&quot;No&quot;</span><br><span class="line">        &#125; else &#123; // 如果操作类型为其他，表示查询某个元素所在集合的大小</span><br><span class="line">            cin&gt;&gt;x; // 输入要查询的元素</span><br><span class="line">            cout &lt;&lt; S[Find(x)] &lt;&lt; endl; // 输出该元素所在集合的大小</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-240.-食物链">AcWing 240. 食物链</h3>
<p>这题也不是很懂</p>
<blockquote>
<p>这里的核心在于
<strong>根相同并不直接等同于同类</strong>，而是需要通过距离差来判断具体关系。</p>
<p>在食物链问题中：</p>
<ul>
<li><code>d[x] % 3 == 0</code> 表示 x 与根是同类</li>
<li><code>d[x] % 3 == 1</code> 表示 x 吃根</li>
<li><code>d[x] % 3 == 2</code> 表示 x 被根吃（或者说根吃 x）</li>
</ul>
<p>当 <code>rx == ry</code>（根相同）时，说明 x 和 y
<strong>已经被连接过</strong>，但它们的实际关系需要由 <code>d[x]</code>
和 <code>d[y]</code> 的差决定：</p>
<ul>
<li><code>(d[x] - d[y]) % 3 == 0</code> → 同类</li>
<li><code>(d[x] - d[y]) % 3 == 1</code> → x 吃 y</li>
<li><code>(d[x] - d[y]) % 3 == 2</code> → y 吃 x</li>
</ul>
<p><strong>为什么不能直接认为根相同就是同类？</strong>
因为并查集的树结构可能经过多次合并，虽然根相同，但路径上的权值差异可能代表不同的食物链关系。例如：</p>
<ul>
<li>可能存在 A→B→C 的链条，其中 A 吃 B，B 吃 C，此时 A 和 C 的根相同但 A
吃 C</li>
<li>通过权值差 <code>d[A] - d[C] = 2</code>，满足 <code>2 %3 == 2</code>
表示 C 吃 A 的反向关系</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 50010;</span><br><span class="line">int n, k, res;          // res记录假话数量</span><br><span class="line">int p[N];               // 并查集父节点数组</span><br><span class="line">int d[N];               // 到父节点的距离（用于表示关系，模3后 0同类，1吃父节点，2被父节点吃）</span><br><span class="line"></span><br><span class="line">// 带路径压缩的查找函数，同时维护节点到根节点的距离</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(p[x] != x)&#123;</span><br><span class="line">        int t = find(p[x]);   // 递归找到根节点</span><br><span class="line">        d[x] += d[p[x]];      // 路径压缩时累加路径上的权值（先累加父节点到根的权值）</span><br><span class="line">        p[x] = t;             // 路径压缩，直接指向根节点</span><br><span class="line">    &#125;</span><br><span class="line">    return p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    // 初始化并查集，每个节点父节点是自己，初始距离为0</span><br><span class="line">    for(int i = 1; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    while(k--)&#123;</span><br><span class="line">        int v, x, y;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        </span><br><span class="line">        // 规则1：编号超出范围直接判定为假</span><br><span class="line">        if(x &gt; n || y &gt; n) res++;</span><br><span class="line">        else&#123;</span><br><span class="line">            int rx = find(x), ry = find(y);  // 找到两个节点的根</span><br><span class="line">            </span><br><span class="line">            if(v == 1)&#123;  // 声称x和y是同类</span><br><span class="line">                // 如果根相同但距离差模3不为0，说明不是同类</span><br><span class="line">                if(rx == ry &amp;&amp; (d[y] - d[x]) % 3) res++;</span><br><span class="line">                // 根不同时需要合并集合</span><br><span class="line">                else if(rx != ry)&#123;</span><br><span class="line">                    p[rx] = ry;  // 将x的根挂到y的根</span><br><span class="line">                    // 设定rx到ry的距离：要满足(d[x]+d[rx]-d[y])%3 == 0</span><br><span class="line">                    d[rx] = d[y] - d[x];  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;  // 声称x吃y（v==2时）</span><br><span class="line">                // 规则2：自己吃自己是假话</span><br><span class="line">                if(x == y) res++;</span><br><span class="line">                // 根相同但距离差不符合捕食关系（d[x]应该比d[y]大1模3）</span><br><span class="line">                else if(rx == ry &amp;&amp; (d[x] - d[y] - 1) % 3) res++;</span><br><span class="line">                // 根不同时需要合并集合</span><br><span class="line">                else if(rx != ry)&#123;</span><br><span class="line">                    p[rx] = ry;  // 将x的根挂到y的根</span><br><span class="line">                    // 设定rx到ry的距离：要满足(d[x]+d[rx]-d[y])%3 == 1</span><br><span class="line">                    d[rx] = d[y] + 1 - d[x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-838.-堆排序">AcWing 838. 堆排序</h3>
<p>内置函数法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;int&gt; a(n);</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a.begin(),a.end());</span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010;  // 定义数组的最大大小</span><br><span class="line">int a[N];              // 用于存储数据的数组</span><br><span class="line">int n, m;              // n: 数组元素个数, m: 需要输出的最小值的个数</span><br><span class="line">int r;                 // 当前堆的大小</span><br><span class="line"></span><br><span class="line">// S函数用于维护堆的性质，u是当前节点的下标</span><br><span class="line">void S(int u)</span><br><span class="line">&#123;</span><br><span class="line">    int t = u;  // t用于记录最小值的下标</span><br><span class="line">    // 如果左子节点存在且比当前节点小，则更新t</span><br><span class="line">    if(2 * u &lt;= r &amp;&amp; a[2 * u] &lt; a[u]) t = 2 * u;</span><br><span class="line">    // 如果右子节点存在且比当前节点和左子节点都小，则更新t</span><br><span class="line">    if(2 * u + 1 &lt;= r &amp;&amp; a[2 * u + 1] &lt; a[t]) t = 2 * u + 1;</span><br><span class="line">    // 如果当前节点不是最小值，则交换并递归调整</span><br><span class="line">    if(u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(a[u], a[t]);</span><br><span class="line">        S(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;  // 输入数组元素个数n和需要输出的最小值的个数m</span><br><span class="line">    r = n;      // 初始化堆的大小为n</span><br><span class="line">    // 输入数组元素</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    // 从最后一个非叶子节点开始，自底向上构建最小堆</span><br><span class="line">    for (int i = n/2; i&gt;=1; --i) &#123;</span><br><span class="line">        S(i);</span><br><span class="line">    &#125;</span><br><span class="line">    // 输出前m个最小值</span><br><span class="line">    while (m--)&#123;</span><br><span class="line">        cout&lt;&lt;a[1]&lt;&lt;&quot; &quot;;  // 输出堆顶元素（当前最小值）</span><br><span class="line">        swap(a[1], a[r]); // 将堆顶元素与最后一个元素交换</span><br><span class="line">        r--;              // 缩小堆的大小</span><br><span class="line">        S(1);             // 调整堆，使其重新满足最小堆性质</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-839.-模拟堆">AcWing 839. 模拟堆</h3>
<p>内置函数法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;istream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define N 500010 // 定义数组的最大大小</span><br><span class="line">int a[N], cnt = 0; // a数组用于记录第k个插入的数，cnt是插入的计数器</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n; // 操作次数</span><br><span class="line">    multiset&lt;int&gt; s; // 使用multiset维护集合的有序性，允许重复元素</span><br><span class="line">    cin &gt;&gt; n; // 输入操作次数</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= n; i++) // 循环处理每个操作</span><br><span class="line">    &#123;</span><br><span class="line">        string t; // 操作指令</span><br><span class="line">        int x, y; // 操作参数</span><br><span class="line">        cin &gt;&gt; t; // 输入操作指令</span><br><span class="line"></span><br><span class="line">        if (t == &quot;I&quot;) // 插入操作</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x; // 输入要插入的数</span><br><span class="line">            s.insert(x); // 将x插入multiset</span><br><span class="line">            a[++cnt] = x; // 记录第cnt个插入的数为x</span><br><span class="line">        &#125;</span><br><span class="line">        if (t == &quot;PM&quot;) // 输出最小值操作</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; *s.begin() &lt;&lt; endl; // 输出multiset中的最小值</span><br><span class="line">        &#125;</span><br><span class="line">        if (t == &quot;DM&quot;) // 删除最小值操作</span><br><span class="line">        &#123;</span><br><span class="line">            s.erase(s.find(*s.begin())); // 找到最小值并删除</span><br><span class="line">        &#125;</span><br><span class="line">        if (t == &quot;D&quot;) // 删除第k个插入的数操作</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x; // 输入k</span><br><span class="line">            if (s.find(a[x]) != s.end()) // 如果第k个插入的数仍在multiset中</span><br><span class="line">            &#123;</span><br><span class="line">                s.erase(s.find(a[x])); // 删除该数</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (t == &quot;C&quot;) // 修改第k个插入的数操作</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y; // 输入k和新的值y</span><br><span class="line">            if (s.find(a[x]) != s.end()) // 如果第k个插入的数仍在multiset中</span><br><span class="line">            &#123;</span><br><span class="line">                s.erase(s.find(a[x])); // 删除旧值</span><br><span class="line">            &#125;</span><br><span class="line">            a[x] = y; // 更新第k个插入的数为y</span><br><span class="line">            s.insert(y); // 将新值插入multiset</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0; // 程序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-840.-模拟散列表">AcWing 840. 模拟散列表</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line">#include &quot;set&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n,x;</span><br><span class="line">set&lt;int&gt; s;</span><br><span class="line">char c;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;c&gt;&gt;x;</span><br><span class="line">        if(c==&#x27;I&#x27;)&#123;</span><br><span class="line">            s.insert(x);</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            cout &lt;&lt; (s.find(x) != s.end() ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-841.-字符串哈希">AcWing 841. 字符串哈希</h3>
<blockquote>
<p><strong>为什么需要 <code>p</code> 数组？</strong></p>
<p>正确的哈希值计算需要对齐前缀哈希值。例如，子串 <code>[l, r]</code>
的正确哈希值公式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h[r] - h[l-1] * p[r-l+1]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>p[r-l+1]</code> 的作用是将 <code>h[l-1]</code> 左移
<code>(r-l+1)</code> 位，使其与 <code>h[r]</code> 对齐。</li>
<li>如果没有 <code>p</code>
数组，哈希值无法正确对齐，导致哈希值错误。</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef unsigned long long ULL; // 定义无符号长整型别名，用于哈希值计算</span><br><span class="line">const int N = 100010, M = 11; // N: 字符串最大长度, M: 哈希基数（通常取质数）</span><br><span class="line"></span><br><span class="line">int n, m; // n: 字符串长度, m: 查询次数</span><br><span class="line">char str[N]; // 存储输入的字符串</span><br><span class="line">ULL p[N], h[N]; // p: 存储 M 的幂次方, h: 存储字符串的前缀哈希值</span><br><span class="line"></span><br><span class="line">// 获取子串 [l, r] 的哈希值</span><br><span class="line">ULL get(int l, int r) &#123;</span><br><span class="line">    return h[r] - h[l - 1] * p[r - l + 1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; // 输入字符串长度和查询次数</span><br><span class="line">    cin &gt;&gt; str + 1; // 输入字符串，从下标 1 开始存储</span><br><span class="line"></span><br><span class="line">    // 初始化 p[0] 和 h[0]</span><br><span class="line">    p[0] = 1; // M^0 = 1</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        h[i] = h[i - 1] * M + str[i]; // 计算前缀哈希值</span><br><span class="line">        p[i] = p[i - 1] * M; // 计算 M 的幂次方</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理每个查询</span><br><span class="line">    while (m--) &#123;</span><br><span class="line">        int l1, r1, l2, r2; // 查询的两个子串的区间</span><br><span class="line">        cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2; // 输入查询区间</span><br><span class="line"></span><br><span class="line">        // 比较两个子串的哈希值</span><br><span class="line">        if (get(l1, r1) == get(l2, r2)) &#123;</span><br><span class="line">            puts(&quot;Yes&quot;); // 哈希值相等，子串相等</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            puts(&quot;No&quot;); // 哈希值不等，子串不等</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0; // 程序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="第三讲-搜索与图论">第三讲 搜索与图论</h2>
<p><strong>2025.3.7</strong></p>
<h3 id="acwing-842.-排列数字">AcWing 842. 排列数字</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="acwing-843.-n-皇后问题">AcWing 843. n-皇后问题</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="acwing-844.-走迷宫">AcWing 844. 走迷宫</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="acwing-845.-八数码">AcWing 845. 八数码</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="acwing-846.-树的重心">AcWing 846. 树的重心</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="acwing-847.图中点的层次">AcWing 847.图中点的层次</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="acwing-848.有向图的拓扑序列">AcWing 848.有向图的拓扑序列</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="acwing-849.dijkstra求最短路ⅰ">AcWing 849.Dijkstra求最短路Ⅰ</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="acwing-850.dijkstra求最短路-ⅱ">AcWing 850.Dijkstra求最短路
Ⅱ</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="acwing-853.有边数限制的最短路">AcWing
853.有边数限制的最短路</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="acwing-851.-spfa求最短路">AcWing 851. spfa求最短路</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="acwing-852.-spfa判断负环">AcWing 852. spfa判断负环</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="acwing-854.floyd求最短路">AcWing 854.Floyd求最短路</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="acwing-858.prim算法求最小生成树">AcWing
858.Prim算法求最小生成树</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="acwing-859.kruskal算法求最小生成树">AcWing
859.Kruskal算法求最小生成树</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="acwing-860.染色法判定二分图">AcWing 860.染色法判定二分图</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="acwing-861.-二分图的最大匹配">AcWing 861. 二分图的最大匹配</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<hr />

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/09/08/14/" rel="prev" title="“高（岗）饶（漱石）反党集团”是一大冤案">
      <i class="fa fa-chevron-left"></i> “高（岗）饶（漱石）反党集团”是一大冤案
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE"><span class="nav-number">1.</span> <span class="nav-text">算法基础课</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E8%AE%B2-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.</span> <span class="nav-text">第一讲 基础算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-785.-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">1.1.1.</span> <span class="nav-text">AcWing 785. 快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-786.-%E7%AC%ACk%E4%B8%AA%E6%95%B0"><span class="nav-number">1.1.2.</span> <span class="nav-text">AcWing 786. 第k个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-787.-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">1.1.3.</span> <span class="nav-text">AcWing 787. 归并排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-788.-%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F"><span class="nav-number">1.1.4.</span> <span class="nav-text">AcWing 788. 逆序对的数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-789.-%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="nav-number">1.1.5.</span> <span class="nav-text">AcWing 789. 数的范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-790.-%E6%95%B0%E7%9A%84%E4%B8%89%E6%AC%A1%E6%96%B9%E6%A0%B9"><span class="nav-number">1.1.6.</span> <span class="nav-text">AcWing 790. 数的三次方根</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-791.-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95"><span class="nav-number">1.1.7.</span> <span class="nav-text">AcWing 791. 高精度加法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-792.-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95"><span class="nav-number">1.1.8.</span> <span class="nav-text">AcWing 792. 高精度减法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-793.-%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95"><span class="nav-number">1.1.9.</span> <span class="nav-text">AcWing 793. 高精度乘法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-794.-%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95"><span class="nav-number">1.1.10.</span> <span class="nav-text">AcWing 794. 高精度除法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-795.-%E5%89%8D%E7%BC%80%E5%92%8C"><span class="nav-number">1.1.11.</span> <span class="nav-text">AcWing 795. 前缀和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-796.-%E5%AD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E5%92%8C"><span class="nav-number">1.1.12.</span> <span class="nav-text">AcWing 796. 子矩阵的和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-797.-%E5%B7%AE%E5%88%86"><span class="nav-number">1.1.13.</span> <span class="nav-text">AcWing 797. 差分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-798.-%E5%B7%AE%E5%88%86%E7%9F%A9%E9%98%B5"><span class="nav-number">1.1.14.</span> <span class="nav-text">AcWing 798. 差分矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-799.-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">1.1.15.</span> <span class="nav-text">AcWing 799.
最长连续不重复子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-800.-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="nav-number">1.1.16.</span> <span class="nav-text">AcWing 800. 数组元素的目标和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-801.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">1.1.17.</span> <span class="nav-text">AcWing 801. 二进制中1的个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-802.-%E5%8C%BA%E9%97%B4%E5%92%8C"><span class="nav-number">1.1.18.</span> <span class="nav-text">AcWing 802. 区间和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-803.-%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6"><span class="nav-number">1.1.19.</span> <span class="nav-text">AcWing 803. 区间合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-2816.-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">1.1.20.</span> <span class="nav-text">AcWing 2816. 判断子序列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">第二讲 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-826.-%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-number">1.2.1.</span> <span class="nav-text">AcWing 826. 单链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-827.-%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="nav-number">1.2.2.</span> <span class="nav-text">AcWing 827. 双链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-828.-%E6%A8%A1%E6%8B%9F%E6%A0%88"><span class="nav-number">1.2.3.</span> <span class="nav-text">AcWing 828. 模拟栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-3302.-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-number">1.2.4.</span> <span class="nav-text">AcWing 3302. 表达式求值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-829.-%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97"><span class="nav-number">1.2.5.</span> <span class="nav-text">AcWing 829. 模拟队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-830.-%E5%8D%95%E8%B0%83%E6%A0%88"><span class="nav-number">1.2.6.</span> <span class="nav-text">AcWing 830. 单调栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-154.-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">1.2.7.</span> <span class="nav-text">AcWing 154. 滑动窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-831.-kmp%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.2.8.</span> <span class="nav-text">AcWing 831. KMP字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-835.-trie%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%9F%E8%AE%A1"><span class="nav-number">1.2.9.</span> <span class="nav-text">AcWing 835. Trie字符串统计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-143.-%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%AF%B9"><span class="nav-number">1.2.10.</span> <span class="nav-text">AcWing 143. 最大异或对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-836.-%E5%90%88%E5%B9%B6%E9%9B%86%E5%90%88"><span class="nav-number">1.2.11.</span> <span class="nav-text">AcWing 836. 合并集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-837.-%E8%BF%9E%E9%80%9A%E5%9D%97%E4%B8%AD%E7%82%B9%E7%9A%84%E6%95%B0%E9%87%8F"><span class="nav-number">1.2.12.</span> <span class="nav-text">AcWing 837. 连通块中点的数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-240.-%E9%A3%9F%E7%89%A9%E9%93%BE"><span class="nav-number">1.2.13.</span> <span class="nav-text">AcWing 240. 食物链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-838.-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">1.2.14.</span> <span class="nav-text">AcWing 838. 堆排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-839.-%E6%A8%A1%E6%8B%9F%E5%A0%86"><span class="nav-number">1.2.15.</span> <span class="nav-text">AcWing 839. 模拟堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-840.-%E6%A8%A1%E6%8B%9F%E6%95%A3%E5%88%97%E8%A1%A8"><span class="nav-number">1.2.16.</span> <span class="nav-text">AcWing 840. 模拟散列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-841.-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C"><span class="nav-number">1.2.17.</span> <span class="nav-text">AcWing 841. 字符串哈希</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E8%AE%B2-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA"><span class="nav-number">1.3.</span> <span class="nav-text">第三讲 搜索与图论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-842.-%E6%8E%92%E5%88%97%E6%95%B0%E5%AD%97"><span class="nav-number">1.3.1.</span> <span class="nav-text">AcWing 842. 排列数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-843.-n-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.2.</span> <span class="nav-text">AcWing 843. n-皇后问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-844.-%E8%B5%B0%E8%BF%B7%E5%AE%AB"><span class="nav-number">1.3.3.</span> <span class="nav-text">AcWing 844. 走迷宫</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-845.-%E5%85%AB%E6%95%B0%E7%A0%81"><span class="nav-number">1.3.4.</span> <span class="nav-text">AcWing 845. 八数码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-846.-%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83"><span class="nav-number">1.3.5.</span> <span class="nav-text">AcWing 846. 树的重心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-847.%E5%9B%BE%E4%B8%AD%E7%82%B9%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="nav-number">1.3.6.</span> <span class="nav-text">AcWing 847.图中点的层次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-848.%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97"><span class="nav-number">1.3.7.</span> <span class="nav-text">AcWing 848.有向图的拓扑序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-849.dijkstra%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%E2%85%B0"><span class="nav-number">1.3.8.</span> <span class="nav-text">AcWing 849.Dijkstra求最短路Ⅰ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-850.dijkstra%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF-%E2%85%B1"><span class="nav-number">1.3.9.</span> <span class="nav-text">AcWing 850.Dijkstra求最短路
Ⅱ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-853.%E6%9C%89%E8%BE%B9%E6%95%B0%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="nav-number">1.3.10.</span> <span class="nav-text">AcWing
853.有边数限制的最短路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-851.-spfa%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="nav-number">1.3.11.</span> <span class="nav-text">AcWing 851. spfa求最短路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-852.-spfa%E5%88%A4%E6%96%AD%E8%B4%9F%E7%8E%AF"><span class="nav-number">1.3.12.</span> <span class="nav-text">AcWing 852. spfa判断负环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-854.floyd%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="nav-number">1.3.13.</span> <span class="nav-text">AcWing 854.Floyd求最短路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-858.prim%E7%AE%97%E6%B3%95%E6%B1%82%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">1.3.14.</span> <span class="nav-text">AcWing
858.Prim算法求最小生成树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-859.kruskal%E7%AE%97%E6%B3%95%E6%B1%82%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">1.3.15.</span> <span class="nav-text">AcWing
859.Kruskal算法求最小生成树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-860.%E6%9F%93%E8%89%B2%E6%B3%95%E5%88%A4%E5%AE%9A%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="nav-number">1.3.16.</span> <span class="nav-text">AcWing 860.染色法判定二分图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-861.-%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D"><span class="nav-number">1.3.17.</span> <span class="nav-text">AcWing 861. 二分图的最大匹配</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="赋倖"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">赋倖</p>
  <div class="site-description" itemprop="description">长夜梦旅有尽时</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/SkyTravelar" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SkyTravelar" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://www.shilinli.com/" title="http:&#x2F;&#x2F;www.shilinli.com&#x2F;" rel="noopener" target="_blank">indexss's</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">赋倖</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
