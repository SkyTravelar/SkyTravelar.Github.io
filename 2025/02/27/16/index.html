<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"skytravelar.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="中南大学复试机试练手记录">
<meta property="og:type" content="article">
<meta property="og:title" content="中南大学复试机试练手 Based on Acwing">
<meta property="og:url" content="https://skytravelar.github.io/2025/02/27/16/index.html">
<meta property="og:site_name" content="賦幸の個人ブログ">
<meta property="og:description" content="中南大学复试机试练手记录">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-02-27T12:04:06.000Z">
<meta property="article:modified_time" content="2025-03-16T14:39:25.821Z">
<meta property="article:author" content="赋倖">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://skytravelar.github.io/2025/02/27/16/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>中南大学复试机试练手 Based on Acwing | 賦幸の個人ブログ</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">賦幸の個人ブログ</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://skytravelar.github.io/2025/02/27/16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="赋倖">
      <meta itemprop="description" content="长夜梦旅有尽时">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="賦幸の個人ブログ">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          中南大学复试机试练手 Based on Acwing
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-27 20:04:06" itemprop="dateCreated datePublished" datetime="2025-02-27T20:04:06+08:00">2025-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-16 22:39:25" itemprop="dateModified" datetime="2025-03-16T22:39:25+08:00">2025-03-16</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description">中南大学复试机试练手记录</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="算法基础课">算法基础课</h1>
<h2 id="第一讲-基础算法">第一讲 基础算法</h2>
<p><strong>2025.2.27</strong></p>
<h3 id="acwing-785.-快速排序">AcWing 785. 快速排序</h3>
<p>内置函数法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;int&gt; a(n);</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a.begin(),a.end());</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  // 引入输入输出流库</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010; // 定义最大数组长度</span><br><span class="line">int a[N];           // 全局数组用于存储原始数据</span><br><span class="line"></span><br><span class="line">// 函数功能：使用Hoare分区方案的快速排序算法对数组a[l..r]进行升序排序</span><br><span class="line">void quick_sort(int a[], int l, int r) &#123;</span><br><span class="line">    if (l &gt;= r) return; // 递归终止条件：区间长度为1时无需排序</span><br><span class="line">    </span><br><span class="line">    int x = a[l + r &gt;&gt; 1]; // 选取中间位置的元素作为基准值（位运算优化）</span><br><span class="line">    int i = l - 1, j = r + 1; // 初始化双指针（i左移一位，j右移一位）</span><br><span class="line">    </span><br><span class="line">    // Hoare分区核心逻辑：i向右找≥x的元素，j向左找≤x的元素，交换不符合条件的元素</span><br><span class="line">    while (i &lt; j) &#123;</span><br><span class="line">        // 找到第一个≥x的元素（跳过比x小的元素）</span><br><span class="line">        while (a[++i] &lt; x);</span><br><span class="line">        // 找到第一个≤x的元素（跳过比x大的元素）</span><br><span class="line">        while (a[--j] &gt; x);</span><br><span class="line">        if (i &lt; j)</span><br><span class="line">            swap(a[i], a[j]); // 交换不满足顺序的元素</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 递归排序左右子区间（注意：Hoare分区后的基准值位置在j）</span><br><span class="line">    quick_sort(a, l, j);</span><br><span class="line">    quick_sort(a, j + 1, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n; // 输入数组长度</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i]; // 输入数组元素</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    quick_sort(a, 0, n - 1); // 调用快速排序函数对整个数组排序</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; // 输出排序后的数组</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-786.-第k个数">AcWing 786. 第k个数</h3>
<p>内置函数法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    vector&lt;int&gt; a(n);</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a.begin(),a.end());</span><br><span class="line">    cout&lt;&lt;a[k-1]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  // 引入输入输出流库</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 函数功能：使用快速选择算法在数组a[l..r]范围内查找第k小的元素（k从1开始计数）</span><br><span class="line">// 参数：</span><br><span class="line">//   a[]：待查找的数组</span><br><span class="line">//   l：当前查找范围的左边界（包含）</span><br><span class="line">//   r：当前查找范围的右边界（包含）</span><br><span class="line">//   k：要查找的第k小的元素的序号（k &gt;= 1）</span><br><span class="line">int quicksortfind(int a[], int l, int r, int k) &#123;</span><br><span class="line">    if (l &gt;= r) return a[l]; // 当区间只有一个元素时，直接返回该元素</span><br><span class="line">    </span><br><span class="line">    int x = a[l + r &gt;&gt; 1]; // 选择中间位置的元素作为基准值（位运算优化）</span><br><span class="line">    int i = l - 1, j = r + 1; // i初始指向l左侧，j初始指向r右侧</span><br><span class="line">    </span><br><span class="line">    // Hoare分区核心逻辑：i向右找≥x的元素，j向左找≤x的元素，交换不符合条件的元素</span><br><span class="line">    while (i &lt; j) &#123;</span><br><span class="line">        // 找到第一个≥x的元素（跳过比x小的元素）</span><br><span class="line">        while (a[++i] &lt; x);</span><br><span class="line">        // 找到第一个≤x的元素（跳过比x大的元素）</span><br><span class="line">        while (a[--j] &gt; x);</span><br><span class="line">        if (i &lt; j)</span><br><span class="line">            swap(a[i], a[j]); // 交换不满足顺序的元素</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int sl = j - l + 1; // 当前基准值所在位置分割后的左半部分长度（包含基准值）</span><br><span class="line">    // 根据k的值决定递归方向</span><br><span class="line">    if (k &lt;= sl) </span><br><span class="line">        return quicksortfind(a, l, j, k); // 递归处理左半部分</span><br><span class="line">    else </span><br><span class="line">        return quicksortfind(a, j + 1, r, k - sl); // 递归处理右半部分</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k; // 输入数组长度和要查找的第k小的元素序号</span><br><span class="line">    int a[n]; // 定义数组（注意：C++标准不支持VLA，此处为GCC扩展语法）</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i]; // 输入数组元素</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; quicksortfind(a, 0, n - 1, k) &lt;&lt; endl; // 输出第k小的元素</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-787.-归并排序">AcWing 787. 归并排序</h3>
<p>内置函数法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;int&gt; a(n);</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a.begin(),a.end());</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  // 引入输入输出流库</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int temp[100010] = &#123;&#125;; // 全局临时数组，用于合并过程中的数据暂存</span><br><span class="line"></span><br><span class="line">// 归并排序函数声明：对数组a的[l, r]区间进行升序排序</span><br><span class="line">void merge_sort(int a[], int l, int r) &#123;</span><br><span class="line">    if (l &gt;= r) return; // 递归终止条件：单个元素已有序</span><br><span class="line">    int mid = (l + r) &gt;&gt; 1; // 计算中间索引（等价于(l+r)/2，位运算更高效）</span><br><span class="line">    </span><br><span class="line">    // 递归划分左右子数组</span><br><span class="line">    merge_sort(a, l, mid);   // 对左半部分排序 [l, mid]</span><br><span class="line">    merge_sort(a, mid+1, r); // 对右半部分排序 [mid+1, r]</span><br><span class="line">    </span><br><span class="line">    // 合并两个有序子数组为整体有序数组</span><br><span class="line">    int k = 0;            // temp数组的写入指针</span><br><span class="line">    int i = l, j = mid + 1; // 左右子数组的遍历指针</span><br><span class="line">    </span><br><span class="line">    // 比较左右子数组元素，按顺序存入temp数组</span><br><span class="line">    while (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        if (a[i] &lt; a[j]) &#123;</span><br><span class="line">            temp[k++] = a[i++];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            temp[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理左子数组剩余元素</span><br><span class="line">    while (i &lt;= mid) &#123;</span><br><span class="line">        temp[k++] = a[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理右子数组剩余元素</span><br><span class="line">    while (j &lt;= r) &#123;</span><br><span class="line">        temp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 将temp数组中的数据复制回原数组a的[l, r]区间</span><br><span class="line">    k = 0; // 重置temp数组的读取指针</span><br><span class="line">    for (int m = l; m &lt;= r; ++m) &#123;</span><br><span class="line">        a[m] = temp[k++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n; // 输入数组长度</span><br><span class="line">    </span><br><span class="line">    int a[n]; // 定义整型数组（注意：C++标准不支持VLA，此处为GCC扩展语法）</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i]; // 输入数组元素</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    merge_sort(a, 0, n-1); // 调用归并排序函数，对整个数组排序</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; // 输出排序后的数组，元素间以空格分隔</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-788.-逆序对的数量">AcWing 788. 逆序对的数量</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  // 引入输入输出流库</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010; // 定义最大数组长度</span><br><span class="line">int a[N];           // 全局数组用于存储原始数据</span><br><span class="line">int temp[N];        // 全局临时数组用于归并过程</span><br><span class="line"></span><br><span class="line">// 函数功能：使用归并排序计算数组a[l..r]范围内的逆序对总数</span><br><span class="line">// 参数：a为数组，l/r为当前处理区间的左右边界</span><br><span class="line">// 返回值：当前区间的逆序对数量</span><br><span class="line">long long find(int a[], int l, int r) &#123;</span><br><span class="line">    if (l &gt;= r) return 0; // 区间长度为1时无逆序对</span><br><span class="line">    </span><br><span class="line">    int mid = (l + r) &gt;&gt; 1; // 计算中间位置（位运算优化）</span><br><span class="line">    long long res = 0;</span><br><span class="line">    </span><br><span class="line">    // 递归计算左右子区间的逆序对数</span><br><span class="line">    res += find(a, l, mid);</span><br><span class="line">    res += find(a, mid + 1, r);</span><br><span class="line">    </span><br><span class="line">    // 合并两个有序子区间并统计跨越两区的逆序对</span><br><span class="line">    int i = l, j = mid + 1, k = 0;</span><br><span class="line">    while (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        if (a[i] &lt;= a[j]) &#123; // 左侧元素不大于右侧，无需统计逆序</span><br><span class="line">            temp[k++] = a[i++];</span><br><span class="line">        &#125; else &#123; // 右侧元素更小，左侧剩余元素全部构成逆序对</span><br><span class="line">            temp[k++] = a[j++];</span><br><span class="line">            res += mid - i + 1; // 统计逆序对数量</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理剩余元素</span><br><span class="line">    while (i &lt;= mid) temp[k++] = a[i++];</span><br><span class="line">    while (j &lt;= r) temp[k++] = a[j++];</span><br><span class="line">    </span><br><span class="line">    // 将合并结果复制回原数组a</span><br><span class="line">    for (int m = l, k = 0; m &lt;= r; ++m) &#123;</span><br><span class="line">        a[m] = temp[k++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return res; // 返回总逆序对数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n; // 输入数组长度</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i]; // 输入数组元素</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; find(a, 0, n - 1) &lt;&lt; endl; // 输出整个数组的逆序对总数</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-789.-数的范围">AcWing 789. 数的范围</h3>
<p>内置函数法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line">#include &quot;algorithm&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,q,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    int a[n];</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; q; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;k;</span><br><span class="line">        if(binary_search(a,a+n,k))&#123;</span><br><span class="line">            cout&lt;&lt;lower_bound(a,a+n,k) -a &lt;&lt;&quot; &quot;&lt;&lt;upper_bound(a,a+n,k) -a - 1&lt;&lt;endl;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            cout &lt;&lt; &quot;-1 -1&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-790.-数的三次方根">AcWing 790. 数的三次方根</h3>
<p>内置函数法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    double n;</span><br><span class="line">    scanf(&quot;%lf&quot;,&amp;n);</span><br><span class="line">    printf(&quot;%lf&quot;,cbrt(n));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line">#include &quot;iomanip&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    double n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    double l=-100000,r=100000;</span><br><span class="line">    while (r-l&gt;1e-8)&#123;</span><br><span class="line">        double mid = (l+r)/2;</span><br><span class="line">        if(mid*mid*mid&lt;n)</span><br><span class="line">            l=mid;</span><br><span class="line">        else</span><br><span class="line">            r=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;setprecision(6)&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-791.-高精度加法">AcWing 791. 高精度加法</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string a,b;</span><br><span class="line"></span><br><span class="line">string add(string s1,string s2)&#123;</span><br><span class="line">    string c;</span><br><span class="line">    int t=0;</span><br><span class="line">    for (int i = s1.size()-1,j=s2.size()-1; i &gt;=0||j&gt;=0||t&gt;0 ; --i,--j) &#123;</span><br><span class="line">        if (i&gt;=0) t+=(s1[i]-&#x27;0&#x27;);</span><br><span class="line">        if (j&gt;=0) t+=(s2[j]-&#x27;0&#x27;);</span><br><span class="line">        c+=((t%10)+&#x27;0&#x27;);</span><br><span class="line">        t/=10;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(c.begin(),c.end());</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    cout&lt;&lt;add(a,b)&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-792.-高精度减法">AcWing 792. 高精度减法</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;   // 引入输入输出流库</span><br><span class="line">#include &lt;algorithm&gt;  // 引入算法库，用于std::sort等函数</span><br><span class="line"></span><br><span class="line">using namespace std;  // 使用标准命名空间</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief 比较两个字符串表示的数字的大小</span><br><span class="line"> * </span><br><span class="line"> * @param s1 第一个字符串数字</span><br><span class="line"> * @param s2 第二个字符串数字</span><br><span class="line"> * @return bool 如果s1大于或等于s2，返回true；否则返回false</span><br><span class="line"> */</span><br><span class="line">bool cmp(string s1, string s2)&#123;</span><br><span class="line">    if(s1.size() != s2.size()) </span><br><span class="line">        return s1.size() &gt; s2.size();  // 如果长度不同，长度较长的数字更大</span><br><span class="line">    for (int i = 0; i &lt; s1.size(); ++i) &#123;</span><br><span class="line">        if(s1[i] != s2[i]) </span><br><span class="line">            return s1[i] &gt; s2[i];  // 从高位到低位逐位比较，较大的数字更大</span><br><span class="line">    &#125;</span><br><span class="line">    return true;  // 如果所有位都相同，返回true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief 计算两个字符串表示的数字的差值，s1 - s2</span><br><span class="line"> * </span><br><span class="line"> * @param s1 被减数，字符串形式的数字</span><br><span class="line"> * @param s2 减数，字符串形式的数字</span><br><span class="line"> * @return string 返回差值的字符串表示，保证没有前导零（除非结果为0）</span><br><span class="line"> */</span><br><span class="line">string sub(string s1, string s2)&#123;</span><br><span class="line">    string c;  // 存储结果的字符串</span><br><span class="line">    int t = 0; // 借位标志，初始为0</span><br><span class="line"></span><br><span class="line">    // 从字符串的末尾（即数字的最低位）开始逐位相减</span><br><span class="line">    for (int i = s1.size() - 1, j = s2.size() - 1; </span><br><span class="line">         i &gt;= 0 || j &gt;= 0 || t &gt; 0; --i, --j) &#123;</span><br><span class="line">        // 如果被减数的当前位有效，减去借位</span><br><span class="line">        if(i &gt;= 0) </span><br><span class="line">            t = (s1[i] - &#x27;0&#x27;) - t;</span><br><span class="line">        </span><br><span class="line">        // 如果减数的当前位有效，继续减去该位的值</span><br><span class="line">        if(j &gt;= 0) </span><br><span class="line">            t -= (s2[j] - &#x27;0&#x27;);</span><br><span class="line">        </span><br><span class="line">        // 将当前位的结果加上10后取模，确保结果为非负数，并转换为字符</span><br><span class="line">        c += ((t + 10) % 10) + &#x27;0&#x27;;</span><br><span class="line">        </span><br><span class="line">        // 更新借位标志</span><br><span class="line">        if(t &lt; 0) &#123;</span><br><span class="line">            t = 1;  // 需要继续借位</span><br><span class="line">        &#125; </span><br><span class="line">        else &#123;</span><br><span class="line">            t = 0;  // 不需要借位</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 移除结果中末尾多余的零（如果有的话），但保留至少一个零</span><br><span class="line">    while (c.size() &gt; 1 &amp;&amp; c.back() == &#x27;0&#x27;)</span><br><span class="line">        c.pop_back();</span><br><span class="line">    </span><br><span class="line">    reverse(c.begin(), c.end());  // 反转字符串，得到正确的顺序</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string a, b;  // 定义两个字符串变量，用于存储输入的数字</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;  // 从标准输入读取两个数字字符串</span><br><span class="line"></span><br><span class="line">    // 比较a和b的大小</span><br><span class="line">    if (cmp(a, b)) </span><br><span class="line">        cout &lt;&lt; sub(a, b) &lt;&lt; endl;  // 如果a &gt;= b，输出a - b的结果</span><br><span class="line">    else </span><br><span class="line">        cout &lt;&lt; &quot;-&quot; &lt;&lt; sub(b, a) &lt;&lt; endl;  // 如果a &lt; b，输出-(b - a)的结果</span><br><span class="line"></span><br><span class="line">    return 0;  // 程序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-793.-高精度乘法">AcWing 793. 高精度乘法</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 函数mul：实现一个大整数（用vector&lt;int&gt;表示）与一个整数的乘法</span><br><span class="line">// 参数v：大整数，每个元素表示一位数字，且低位在前，高位在后</span><br><span class="line">// 参数i：要乘的整数</span><br><span class="line">// 返回值：返回乘积，同样用vector&lt;int&gt;表示，低位在前，高位在后</span><br><span class="line">vector&lt;int&gt; mul(vector&lt;int&gt; v, int i) &#123;</span><br><span class="line">    vector&lt;int&gt; ve;  // 用于存储乘积的结果</span><br><span class="line">    int t = 0;       // 进位初始化为0</span><br><span class="line"></span><br><span class="line">    // 遍历输入的大整数v的每一位</span><br><span class="line">    for (int j = 0; j &lt; v.size(); ++j) &#123;</span><br><span class="line">        t += v[j] * i;          // 当前位乘以i并加上进位</span><br><span class="line">        ve.push_back(t % 10);   // 将当前位的结果（个位数）存入ve</span><br><span class="line">        t /= 10;                // 更新进位</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理剩余的进位</span><br><span class="line">    while (t) &#123;</span><br><span class="line">        ve.push_back(t % 10);</span><br><span class="line">        t /= 10;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 去除结果中高位的无效零（保证至少有一位有效数字）</span><br><span class="line">    while (ve.size() &gt; 1 &amp;&amp; ve.back() == 0)</span><br><span class="line">        ve.pop_back();</span><br><span class="line"></span><br><span class="line">    return ve;  // 返回乘积结果</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s;  // 用于存储输入的大整数（以字符串形式）</span><br><span class="line">    int a;     // 用于存储要乘的整数</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; s &gt;&gt; a;  // 输入大整数和乘数</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; aa;  // 用于存储转换后的大整数（低位在前）</span><br><span class="line"></span><br><span class="line">    // 将字符串形式的大整数s转换为vector&lt;int&gt;形式，低位在前</span><br><span class="line">    for (int i = s.size() - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">        aa.push_back(s[i] - &#x27;0&#x27;);  // 将字符转换为数字并存入aa</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto au = mul(aa, a);  // 调用mul函数计算乘积</span><br><span class="line"></span><br><span class="line">    // 输出乘积结果，从高位到低位</span><br><span class="line">    for (int i = au.size() - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">        cout &lt;&lt; au[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;  // 程序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-794.-高精度除法">AcWing 794. 高精度除法</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;       // 引入向量容器库</span><br><span class="line">#include &lt;algorithm&gt;    // 引入算法库（用于反转容器）</span><br><span class="line">#include &quot;iostream&quot;      // 引入输入输出流库</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 函数功能：对逆序存储的数字数组进行除法运算，返回商的各位数字（高位在前）</span><br><span class="line">// 参数：v表示逆序存储的被除数数字数组，i表示除数，y通过引用返回余数</span><br><span class="line">vector&lt;int&gt; div(vector&lt;int&gt; v, int i, int &amp;y) &#123;</span><br><span class="line">    vector&lt;int&gt; result; // 存储商的各位数字</span><br><span class="line">    y = 0;             // 初始化余数为0</span><br><span class="line">    </span><br><span class="line">    // 从最高位到最低位处理每一位数字（v的索引0对应个位，索引末尾对应最高位）</span><br><span class="line">    for (int j = v.size() - 1; j &gt;= 0; --j) &#123;</span><br><span class="line">        y = y * 10 + v[j]; // 累加当前位到余数y（模拟手动除法的逐位操作）</span><br><span class="line">        result.push_back(y / i); // 计算当前位的商并存储</span><br><span class="line">        y %= i;               // 更新余数</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    reverse(result.begin(), result.end()); // 反转商的顺序（使高位在前）</span><br><span class="line">    // 去除商末尾的零（例如：结果为[0, 2, 3]时，去除前导零变为[2, 3]）</span><br><span class="line">    while (result.size() &gt; 1 &amp;&amp; result.back() == 0) &#123;</span><br><span class="line">        result.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string s;           // 输入的整数字符串</span><br><span class="line">    int b, r;           // 除数b和余数r</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; s &gt;&gt; b;      // 读取输入的字符串和除数</span><br><span class="line">    vector&lt;int&gt; a;       // 存储逆序的数字位（例如：&quot;123&quot; -&gt; [3,2,1]）</span><br><span class="line">    </span><br><span class="line">    // 将字符串转换为逆序的数字数组</span><br><span class="line">    for (int i = s.size() - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">        a.push_back(s[i] - &#x27;0&#x27;); // 字符转数字并逆序存储</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    auto result = div(a, b, r); // 调用div函数进行除法运算</span><br><span class="line">    </span><br><span class="line">    // 输出商的结果（注意：result已经是高位到低位的顺序）</span><br><span class="line">    for (int i = result.size() - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">        cout &lt;&lt; result[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; endl&lt;&lt; r &lt;&lt; endl; // 输出余数</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-795.-前缀和">AcWing 795. 前缀和</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,l,r;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    int a[n],b[n];</span><br><span class="line">    for(int i = 1;i &lt;= n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    b[0]=0;</span><br><span class="line">    b[1]=a[1];</span><br><span class="line">    for (int i = 2; i &lt;= n; ++i)</span><br><span class="line">        b[i]=b[i-1]+a[i];</span><br><span class="line">    for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        cout&lt;&lt; b[r]-b[l-1]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-796.-子矩阵的和">AcWing 796. 子矩阵的和</h3>
<p>超时版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1010;</span><br><span class="line">int a[N][N],b[N][N];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,q,x1,x2,y1,y2,cnt;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt;= m; ++j) &#123;</span><br><span class="line">            if (j==0)&#123;</span><br><span class="line">                a[i][j]=0;</span><br><span class="line">                b[i][j]=0;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                cin&gt;&gt;a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; ++j) &#123;</span><br><span class="line">            b[i][j]=a[i][j]+b[i][j-1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= q ; ++i) &#123;</span><br><span class="line">        cnt=0;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">        for (int j = x1; j &lt;= x2 ; ++j) &#123;</span><br><span class="line">            cnt = cnt + b[j][y2]-b[j][y1-1];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>混元模型优化版</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1010;</span><br><span class="line">int a[N+1][N+1], b[N+1][N+1], s[N+1][N+1];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line"></span><br><span class="line">    int n, m, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    // 初始化数组并输入数据</span><br><span class="line">    memset(a, 0, sizeof a);</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 计算每行的前缀和</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; ++j) &#123;</span><br><span class="line">            b[i][j] = b[i][j-1] + a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 计算二维前缀和</span><br><span class="line">    memset(s, 0, sizeof s);</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; ++j) &#123;</span><br><span class="line">            s[i][j] = s[i-1][j] + b[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理查询</span><br><span class="line">    while (q--) &#123;</span><br><span class="line">        int x1, y1, x2, y2;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">        cout &lt;&lt; s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1] &lt;&lt; &#x27;\n&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-797.-差分">AcWing 797. 差分</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,l,r,c;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    int a[n+1],b[n+1];</span><br><span class="line">    a[0]=0;</span><br><span class="line">    b[0]=0;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        b[i]=a[i]-a[i-1];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line">        b[l]+=c;</span><br><span class="line">        b[r+1]-=c;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        b[i]+=b[i-1];</span><br><span class="line">        cout&lt;&lt;b[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-798.-差分矩阵">AcWing 798. 差分矩阵</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;  // 引入输入输出流库</span><br><span class="line"></span><br><span class="line">using namespace std;  // 使用标准命名空间</span><br><span class="line"></span><br><span class="line">const int N = 1010;  // 定义一个常量N，表示数组的最大尺寸</span><br><span class="line">int a[N][N] = &#123;&#125;, s[N][N] = &#123;&#125;;  // 定义两个二维数组a和s，并初始化为0</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m, q, x1, y1, x2, y2, c;  // 定义变量用于存储输入的数据</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;  // 输入矩阵的行数n、列数m，以及操作的次数q</span><br><span class="line"></span><br><span class="line">    // 输入初始矩阵的值，并存储在s数组中</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; ++j) &#123;</span><br><span class="line">            cin &gt;&gt; s[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 计算初始矩阵的前缀和，并存储在a数组中</span><br><span class="line">    // a[i][j]表示从(1,1)到(i,j)的子矩阵的和</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; ++j) &#123;</span><br><span class="line">            a[i][j] = s[i][j] + s[i - 1][j - 1] - s[i - 1][j] - s[i][j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理q次操作，每次操作给出一个子矩阵的左上角(x1,y1)和右下角(x2,y2)，以及要增加的值c</span><br><span class="line">    for (int i = 0; i &lt; q; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        // 使用差分数组的方法，对子矩阵进行加减操作</span><br><span class="line">        // 这样可以在O(1)的时间内完成子矩阵的加减操作</span><br><span class="line">        a[x1][y1] += c;</span><br><span class="line">        a[x1][y2 + 1] -= c;</span><br><span class="line">        a[x2 + 1][y1] -= c;</span><br><span class="line">        a[x2 + 1][y2 + 1] += c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据差分数组a，重新计算矩阵s的值</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= m; ++j) &#123;</span><br><span class="line">            // 通过前缀和的方式，计算出每个位置的值</span><br><span class="line">            s[i][j] = a[i][j] + s[i][j - 1] + s[i - 1][j] - s[i - 1][j - 1];</span><br><span class="line">            cout &lt;&lt; s[i][j] &lt;&lt; &quot; &quot;;  // 输出计算后的矩阵值</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;  // 换行，输出下一行的矩阵值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;  // 程序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-799.-最长连续不重复子序列">AcWing 799.
最长连续不重复子序列</h3>
<p>超时版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line">#include &quot;cstring&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,cnt=0,x=0;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    int a[n],b[100001]=&#123;0&#125;;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        if (b[a[i]]==0)&#123;</span><br><span class="line">            b[a[i]]=1;</span><br><span class="line">            cnt++;</span><br><span class="line">            x= max(cnt,x);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (b[a[i]]==1)&#123;</span><br><span class="line">            x= max(cnt,x);</span><br><span class="line">            i=i-cnt;</span><br><span class="line">            cnt=0;</span><br><span class="line">            memset(b, 0, sizeof(b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAX_VALUE = 100001; // 根据题目数据范围设置最大值</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(nullptr);</span><br><span class="line"></span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; a(n);</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; last_pos(MAX_VALUE, -1); // 记录每个元素最后出现的索引</span><br><span class="line">    int max_len = 0, left = 0;</span><br><span class="line"></span><br><span class="line">    for (int right = 0; right &lt; n; ++right) &#123;</span><br><span class="line">        if (last_pos[a[right]] &gt;= left) &#123; // 如果该元素在当前窗口中出现过</span><br><span class="line">            left = last_pos[a[right]] + 1; // 移动左边界到重复元素的下一个位置</span><br><span class="line">        &#125;</span><br><span class="line">        last_pos[a[right]] = right; // 更新最后一次出现的位置</span><br><span class="line">        max_len = max(max_len, right - left + 1); // 更新最大长度</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; max_len &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-800.-数组元素的目标和">AcWing 800. 数组元素的目标和</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,x;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x;</span><br><span class="line">    int a[n],b[m];</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0,j=m-1; i &lt; n; ++i) &#123;</span><br><span class="line">        while (a[i]+b[j]&gt;x&amp;&amp;j&gt;0) j--;</span><br><span class="line">        if(a[i]+b[j]==x)</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-801.-二进制中1的个数">AcWing 801. 二进制中1的个数</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int lowbit(int x)&#123;</span><br><span class="line">    return x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,x;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        while (x)&#123;</span><br><span class="line">            x-= lowbit(x);</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-802.-区间和">AcWing 802. 区间和</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义一个类型别名 p，用于表示键值对 (int, int)</span><br><span class="line">typedef pair&lt;int, int&gt; p;</span><br><span class="line"></span><br><span class="line">// 存储添加操作的区间及其对应的值</span><br><span class="line">vector&lt;p&gt; add;</span><br><span class="line">// 存储查询操作的区间</span><br><span class="line">vector&lt;p&gt; query;</span><br><span class="line">// 存储所有出现过的坐标，用于离散化</span><br><span class="line">vector&lt;int&gt; alls;</span><br><span class="line"></span><br><span class="line">// 定义常量 N，设定数组的最大大小</span><br><span class="line">const int N = 300010;</span><br><span class="line">// 数组 a 用于存储每个离散化后的位置的累加值</span><br><span class="line">int a[N];</span><br><span class="line">// 数组 s 用于存储前缀和，便于快速查询区间和</span><br><span class="line">int s[N];</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @brief 使用二分查找找到 x 在 alls 中的位置，并返回其在离散化后的索引（从1开始）</span><br><span class="line"> * </span><br><span class="line"> * @param x 需要查找的坐标</span><br><span class="line"> * @return int 离散化后的索引</span><br><span class="line"> */</span><br><span class="line">int find(int x) &#123;</span><br><span class="line">    int l = 0, r = alls.size() - 1, mid;</span><br><span class="line">    // 标准的二分查找，找到第一个 &gt;= x 的位置</span><br><span class="line">    while (l &lt; r) &#123;</span><br><span class="line">        mid = (l + r) / 2;</span><br><span class="line">        if (alls[mid] &gt;= x)</span><br><span class="line">            r = mid;</span><br><span class="line">        else</span><br><span class="line">            l = mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回离散化后的索引（假设 alls 已排序且唯一）</span><br><span class="line">    return r + 1; // 索引从1开始，方便后续前缀和计算</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m; // n 是添加操作的次数，m 是查询操作的次数</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    // 处理所有的添加操作</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        int x, c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.emplace_back(x, c); // 存储添加操作的坐标和值</span><br><span class="line">        alls.push_back(x);      // 将坐标记录下来，用于后续离散化</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理所有的查询操作</span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        int l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        query.emplace_back(l, r); // 存储查询操作的区间</span><br><span class="line">        alls.push_back(l);        // 记录查询区间的左右端点</span><br><span class="line">        alls.push_back(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 对所有记录的坐标进行排序</span><br><span class="line">    sort(alls.begin(), alls.end());</span><br><span class="line"></span><br><span class="line">    // 去除重复的坐标，并调整 alls 的大小</span><br><span class="line">    alls.erase(unique(alls.begin(), alls.end()), alls.end());</span><br><span class="line"></span><br><span class="line">    // 遍历所有的添加操作，将对应的值累加到离散化后的位置</span><br><span class="line">    for (auto aa : add) &#123;</span><br><span class="line">        // 找到坐标 aa.first 在离散化后的索引，并累加值 aa.second</span><br><span class="line">        a[find(aa.first)] += aa.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 计算前缀和数组 s，s[i] 表示前 i 个位置的累加总和</span><br><span class="line">    for (int i = 1; i &lt;= alls.size(); i++) &#123;</span><br><span class="line">        s[i] = s[i - 1] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理每一个查询操作，输出对应区间的累加和</span><br><span class="line">    for (auto q : query) &#123;</span><br><span class="line">        // 计算区间 [q.first, q.second] 的累加和</span><br><span class="line">        // find(q.second) 得到右端点的离散索引</span><br><span class="line">        // find(q.first) - 1 得到左端点前一个位置的离散索引</span><br><span class="line">        cout &lt;&lt; s[find(q.second)] - s[find(q.first) - 1] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-803.-区间合并">AcWing 803. 区间合并</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int, int&gt; p;    // 定义区间类型，方便后续使用</span><br><span class="line"></span><br><span class="line">vector&lt;p&gt; nums, res;         // nums存储原始区间，res存储合并后的结果</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, l, r;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    // 读取n个区间并存入nums容器</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        nums.emplace_back(l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 按照区间的起始点进行升序排序</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    </span><br><span class="line">    int start = -1, end = -1;</span><br><span class="line">    // 遍历每个区间，进行合并处理</span><br><span class="line">    for (auto num : nums) &#123;</span><br><span class="line">        if (num.first &gt; end) &#123; // 当前区间与已合并区间无重叠</span><br><span class="line">            if (end != -1) &#123; // 如果已有合并区间，则存入结果集</span><br><span class="line">                res.emplace_back(start, end);</span><br><span class="line">            &#125;</span><br><span class="line">            // 更新当前合并区间的起始和结束位置</span><br><span class="line">            start = num.first;</span><br><span class="line">            end = num.second;</span><br><span class="line">        &#125; else if (num.second &gt; end) &#123; // 当前区间与已合并区间有重叠，合并它们</span><br><span class="line">            end = num.second; // 扩展合并区间的结束位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理最后一个区间</span><br><span class="line">    res.emplace_back(start, end);</span><br><span class="line">    </span><br><span class="line">    // 输出合并后的不重叠区间数量</span><br><span class="line">    cout &lt;&lt; res.size() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-2816.-判断子序列">AcWing 2816. 判断子序列</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt; // 引入输入输出流库</span><br><span class="line"></span><br><span class="line">using namespace std; // 使用标准命名空间</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n, m, x = 0; // 声明并初始化变量 n 和 m，x 用于跟踪数组 a 的匹配索引</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; // 从标准输入读取两个整数 n 和 m</span><br><span class="line">    // n 表示第一个数组的大小，m 表示第二个数组的大小</span><br><span class="line">    </span><br><span class="line">    int a[n], b[m]; // 声明两个整型数组 a 和 b，大小分别为 n 和 m</span><br><span class="line">    // 注意：在 C++ 中，使用变量长度数组（VLA）是非标准的，建议使用 vector 替代</span><br><span class="line">    </span><br><span class="line">    // 读取 n 个整数存入数组 a</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 读取 m 个整数存入数组 b</span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 遍历数组 b，检查数组 a 中的元素是否按顺序出现在数组 b 中</span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123; // 遍历数组 b 的每一个元素</span><br><span class="line">        if(a[x] == b[i] &amp;&amp; x &lt; n) &#123; // 如果 a 的当前元素等于 b 的当前元素，并且 x 没有超出 a 的范围</span><br><span class="line">            x++; // 匹配成功，移动到 a 的下一个元素</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 检查是否所有 a 的元素都按顺序在 b 中找到了匹配</span><br><span class="line">    if(x != n) </span><br><span class="line">        cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; // 如果有 a 的元素未匹配，输出 &quot;No&quot;</span><br><span class="line">    else </span><br><span class="line">        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; // 如果所有 a 的元素都匹配，输出 &quot;Yes&quot;</span><br><span class="line">    </span><br><span class="line">    return 0; // 程序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="第二讲-数据结构">第二讲 数据结构</h2>
<p><strong>2025.3.4</strong></p>
<h3 id="acwing-826.-单链表">AcWing 826. 单链表</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;  // 引入输入输出流库</span><br><span class="line"></span><br><span class="line">using namespace std;  // 使用标准命名空间</span><br><span class="line"></span><br><span class="line">const int N = 100010;  // 定义一个常量N，表示链表的最大长度</span><br><span class="line">int e[N], ne[N], idx = 1, hh = 0;  // 定义数组e存储链表节点的值，ne存储下一个节点的索引，idx为当前节点索引，hh为头节点索引</span><br><span class="line"></span><br><span class="line">// 在链表头部添加一个值为x的节点</span><br><span class="line">void add_to_head(int x) &#123;</span><br><span class="line">    e[idx] = x;          // 将x存入当前节点的值</span><br><span class="line">    ne[idx] = hh;        // 将当前节点的下一个节点指向原来的头节点</span><br><span class="line">    hh = idx++;          // 更新头节点为当前节点，并将索引值自增</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除链表中第k个节点的下一个节点</span><br><span class="line">void Delete(int k) &#123;</span><br><span class="line">    if (k == 0) &#123;        // 如果k为0，表示删除头节点</span><br><span class="line">        hh = ne[hh];     // 更新头节点为下一个节点</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ne[k] = ne[ne[k]];  // 将第k个节点的下一个节点指向其下下个节点，从而删除第k+1个节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在链表中第k个节点后面添加一个值为x的节点</span><br><span class="line">void add(int k, int x) &#123;</span><br><span class="line">    e[idx] = x;          // 将x存入当前节点的值</span><br><span class="line">    ne[idx] = ne[k];     // 将当前节点的下一个节点指向第k个节点的下一个节点</span><br><span class="line">    ne[k] = idx++;       // 将第k个节点的下一个节点指向当前节点，并将索引值自增</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int m;               // 定义一个变量m表示操作次数</span><br><span class="line">    cin &gt;&gt; m;            // 输入操作次数</span><br><span class="line">    while (m--) &#123;        // 循环m次，执行相应操作</span><br><span class="line">        char c;          // 定义一个字符变量c表示操作类型</span><br><span class="line">        int k, x;        // 定义变量k和x，k表示节点位置，x表示节点值</span><br><span class="line">        cin &gt;&gt; c;        // 输入操作类型</span><br><span class="line">        if (c == &#x27;H&#x27;) &#123;  // 如果操作类型为&#x27;H&#x27;，表示在头部添加节点</span><br><span class="line">            cin &gt;&gt; x;    // 输入节点值</span><br><span class="line">            add_to_head(x);  // 调用add_to_head函数添加节点</span><br><span class="line">        &#125; else if (c == &#x27;D&#x27;) &#123;  // 如果操作类型为&#x27;D&#x27;，表示删除节点</span><br><span class="line">            cin &gt;&gt; k;    // 输入要删除的节点位置</span><br><span class="line">            Delete(k);   // 调用Delete函数删除节点</span><br><span class="line">        &#125; else &#123;         // 如果操作类型为其他，表示在指定位置后添加节点</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;  // 输入节点位置和节点值</span><br><span class="line">            add(k, x);      // 调用add函数添加节点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 遍历链表并输出所有节点的值</span><br><span class="line">    for (int i = hh; i != 0; i = ne[i]) &#123;  // 从头节点开始，依次遍历每个节点</span><br><span class="line">        cout &lt;&lt; e[i] &lt;&lt; &quot; &quot;;  // 输出当前节点的值，并在后面加一个空格</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;  // 程序正常结束，返回0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-827.-双链表">AcWing 827. 双链表</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot; // 引入输入输出流库</span><br><span class="line"></span><br><span class="line">using namespace std; // 使用标准命名空间</span><br><span class="line"></span><br><span class="line">const int N = 100010; // 定义数组的最大容量，假设最多有100,000个节点</span><br><span class="line"></span><br><span class="line">int m, x, k; // 定义变量：</span><br><span class="line">// m: 操作次数</span><br><span class="line">// x: 插入或删除的值</span><br><span class="line">// k: 节点编号相关的参数</span><br><span class="line">string c; // 操作类型字符串</span><br><span class="line"></span><br><span class="line">// 定义数组用于模拟双向链表：</span><br><span class="line">// e[N]: 存储每个节点的值</span><br><span class="line">// l[N]: 存储每个节点左边节点的索引</span><br><span class="line">// r[N]: 存储每个节点右边节点的索引</span><br><span class="line">// idx: 当前可用的节点索引，初始化为2（因为0和1已被占用）</span><br><span class="line">int e[N], l[N], r[N], idx = 2;</span><br><span class="line"></span><br><span class="line">// 在指定位置pos的右边插入值为i的新节点</span><br><span class="line">void insert(int pos, int i)&#123;</span><br><span class="line">    e[idx] = i;          // 将新节点的值设为i</span><br><span class="line">    l[idx] = pos;        // 新节点的左邻居设为pos</span><br><span class="line">    r[idx] = r[pos];     // 新节点的右邻居设为pos原来的右邻居</span><br><span class="line">    l[r[pos]] = idx;     // pos原来的右邻居的左邻居设为新节点</span><br><span class="line">    r[pos] = idx++;      // pos的右邻居更新为新节点，并递增idx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除指定位置pos的节点</span><br><span class="line">void remove(int pos)&#123;</span><br><span class="line">    l[r[pos]] = l[pos]; // pos左邻居的右邻居指向pos的右邻居</span><br><span class="line">    r[l[pos]] = r[pos]; // pos右邻居的左邻居指向pos的左邻居</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; m; // 输入操作次数</span><br><span class="line"></span><br><span class="line">    // 初始化双向链表的左右端点：</span><br><span class="line">    // 0表示最左端，1表示最右端</span><br><span class="line">    r[0] = 1; // 最左端的右邻居是最右端</span><br><span class="line">    l[1] = 0; // 最右端的左邻居是最左端</span><br><span class="line"></span><br><span class="line">    while (m--)&#123; // 循环处理每一个操作</span><br><span class="line">        cin &gt;&gt; c; // 输入操作类型</span><br><span class="line"></span><br><span class="line">        if (c == &quot;L&quot;)&#123; // 在最左端插入值x</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            insert(0, x); // 在位置0（最左端）插入x</span><br><span class="line">        &#125; </span><br><span class="line">        else if(c == &quot;R&quot;)&#123; // 在最右端插入值x</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            insert(l[1], x); // 在最右端的左邻居（即位置1）插入x</span><br><span class="line">        &#125; </span><br><span class="line">        else if(c == &quot;D&quot;)&#123; // 删除编号为k的节点</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            remove(k + 1); // 节点编号从1开始，数组索引从2开始，因此k对应的节点是k+1</span><br><span class="line">        &#125; </span><br><span class="line">        else if(c == &quot;IL&quot;)&#123; // 在编号为k的节点左边插入值x</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            insert(l[k + 1], x); // 在编号为k的节点的左邻居处插入x</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123; // 其他情况默认为在编号为k的节点右边插入值x</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            insert(k + 1, x); // 在编号为k的节点的右邻居处插入x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历并输出链表中的所有元素，从最左端开始，直到最右端</span><br><span class="line">    for (int i = r[0]; i != 1; i = r[i]) &#123; // r[0]是最左端，1是最右端</span><br><span class="line">        cout &lt;&lt; e[i] &lt;&lt; &quot; &quot;; // 输出当前节点的值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0; // 程序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-828.-模拟栈">AcWing 828. 模拟栈</h3>
<p>内置函数法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int M;</span><br><span class="line">    cin &gt;&gt; M; // 输入操作次数</span><br><span class="line"></span><br><span class="line">    stack&lt;int&gt; s; // 创建一个空栈</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; M; i++) &#123;</span><br><span class="line">        string operation;</span><br><span class="line">        cin &gt;&gt; operation; // 输入操作命令</span><br><span class="line"></span><br><span class="line">        if (operation == &quot;push&quot;) &#123;</span><br><span class="line">            int x;</span><br><span class="line">            cin &gt;&gt; x; // 输入要插入的数</span><br><span class="line">            s.push(x); // 将数压入栈</span><br><span class="line">        &#125; else if (operation == &quot;pop&quot;) &#123;</span><br><span class="line">            if (!s.empty()) &#123;</span><br><span class="line">                s.pop(); // 弹出栈顶元素</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (operation == &quot;empty&quot;) &#123;</span><br><span class="line">            if (s.empty()) &#123;</span><br><span class="line">                cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; // 栈为空，输出YES</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; // 栈不为空，输出NO</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (operation == &quot;query&quot;) &#123;</span><br><span class="line">            if (!s.empty()) &#123;</span><br><span class="line">                cout &lt;&lt; s.top() &lt;&lt; endl; // 输出栈顶元素</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot; // 引入输入输出流库</span><br><span class="line"></span><br><span class="line">using namespace std; // 使用标准命名空间</span><br><span class="line"></span><br><span class="line">const int N = 100010; // 定义栈的最大容量为100,000</span><br><span class="line"></span><br><span class="line">int st[N]; // 定义一个数组来模拟栈</span><br><span class="line">int top = -1; // 初始化栈顶指针，-1表示栈为空</span><br><span class="line">int n, a; // 定义变量：</span><br><span class="line">// n: 操作次数</span><br><span class="line">// a: 用于存储push操作的值</span><br><span class="line">string s; // 存储每次操作的命令</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n; // 输入操作次数</span><br><span class="line"></span><br><span class="line">    while (n--)&#123; // 循环处理每一个操作</span><br><span class="line">        cin &gt;&gt; s; // 输入操作类型</span><br><span class="line"></span><br><span class="line">        if (s == &quot;push&quot;)&#123; // 如果操作类型是&quot;push&quot;</span><br><span class="line">            cin &gt;&gt; a; // 输入要压入栈的值</span><br><span class="line">            st[++top] = a; // 栈顶指针先递增，然后将值a存入新的栈顶位置</span><br><span class="line">        &#125; </span><br><span class="line">        else if(s == &quot;pop&quot;)&#123; // 如果操作类型是&quot;pop&quot;</span><br><span class="line">            top--; // 栈顶指针递减，表示弹出栈顶元素</span><br><span class="line">        &#125; </span><br><span class="line">        else if(s == &quot;query&quot;)&#123; // 如果操作类型是&quot;query&quot;</span><br><span class="line">            cout &lt;&lt; st[top] &lt;&lt; endl; // 输出当前栈顶元素</span><br><span class="line">        &#125; </span><br><span class="line">        else&#123; // 其他情况默认为操作类型是&quot;empty&quot;</span><br><span class="line">            // 判断栈是否为空，并输出相应的结果</span><br><span class="line">            cout &lt;&lt; (top == -1 ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; endl; </span><br><span class="line">            // 如果栈顶指针为-1，表示栈为空，输出&quot;YES&quot;；否则输出&quot;NO&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0; // 程序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-3302.-表达式求值">AcWing 3302. 表达式求值</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string s; // 存储输入的表达式字符串</span><br><span class="line">stack&lt;int&gt; num; // 用于存放操作数的栈</span><br><span class="line">stack&lt;char&gt; op; // 用于存放运算符的栈</span><br><span class="line">unordered_map&lt;char, int&gt; h&#123;&#123;&#x27;+&#x27;,1&#125;, &#123;&#x27;-&#x27;,1&#125;, &#123;&#x27;*&#x27;,2&#125;, &#123;&#x27;/&#x27;,2&#125;&#125;; // 运算符优先级表</span><br><span class="line"></span><br><span class="line">// 执行栈顶的运算操作，将结果存回num栈</span><br><span class="line">void eval()&#123;</span><br><span class="line">    int a = num.top(); num.pop(); // 弹出第二个操作数</span><br><span class="line">    int b = num.top(); num.pop(); // 弹出第一个操作数</span><br><span class="line">    char p = op.top(); op.pop(); // 弹出运算符</span><br><span class="line">    </span><br><span class="line">    int r = 0;</span><br><span class="line">    switch (p) &#123;</span><br><span class="line">        case &#x27;+&#x27;: r = b + a; break; // 加法运算</span><br><span class="line">        case &#x27;-&#x27;: r = b - a; break; // 减法运算（注意顺序）</span><br><span class="line">        case &#x27;*&#x27;: r = b * a; break; // 乘法运算</span><br><span class="line">        case &#x27;/&#x27;: r = b / a; break; // 整除运算</span><br><span class="line">        default: break;</span><br><span class="line">    &#125;</span><br><span class="line">    num.push(r); // 将结果压入操作数栈</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; s; // 读取输入的中缀表达式</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; s.size(); ++i) &#123;</span><br><span class="line">        if (isdigit(s[i])) &#123; // 处理多位数字字符</span><br><span class="line">            int x = 0, j = i;</span><br><span class="line">            while (j &lt; s.size() &amp;&amp; isdigit(s[j])) &#123; // 提取完整数字</span><br><span class="line">                x = x * 10 + (s[j] - &#x27;0&#x27;);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            num.push(x); // 将数字压入栈</span><br><span class="line">            i = j - 1; // 调整索引以跳过已处理的数字</span><br><span class="line">        &#125; else if (s[i] == &#x27;(&#x27;) &#123; // 左括号直接入栈</span><br><span class="line">            op.push(s[i]);</span><br><span class="line">        &#125; else if (s[i] == &#x27;)&#x27;) &#123; // 右括号触发计算直到左括号</span><br><span class="line">            while (op.top() != &#x27;(&#x27;)</span><br><span class="line">                eval();</span><br><span class="line">            op.pop(); // 弹出左括号（不处理）</span><br><span class="line">        &#125; else &#123; // 处理运算符：保证优先级高的先计算</span><br><span class="line">            while (!op.empty() &amp;&amp; h[op.top()] &gt;= h[s[i]]) &#123; </span><br><span class="line">                eval();</span><br><span class="line">            &#125;</span><br><span class="line">            op.push(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理剩余的运算符</span><br><span class="line">    while (!op.empty())</span><br><span class="line">        eval();</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; num.top() &lt;&lt; endl; // 输出最终结果</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-829.-模拟队列">AcWing 829. 模拟队列</h3>
<p>内置函数法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line">#include &quot;queue&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">string s;</span><br><span class="line">int n,x;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    while (n--)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        if (s==&quot;push&quot;)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            q.push(x);</span><br><span class="line">        &#125;else if(s==&quot;empty&quot;)&#123;</span><br><span class="line">            if (q.empty())</span><br><span class="line">                cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">            else</span><br><span class="line">                cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;else if(s==&quot;query&quot;)&#123;</span><br><span class="line">            cout&lt;&lt;q.front()&lt;&lt;endl;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=100010;</span><br><span class="line">int qh=-1,qt=-1,n,x;</span><br><span class="line">int a[N];</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    while (n--)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        if(s==&quot;push&quot;)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            a[++qt]=x;</span><br><span class="line">        &#125; else if(s==&quot;pop&quot;)&#123;</span><br><span class="line">            qh++;</span><br><span class="line">        &#125;else if (s==&quot;empty&quot;)&#123;</span><br><span class="line">            if (qt==qh)</span><br><span class="line">                cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;</span><br><span class="line">            else</span><br><span class="line">                cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cout&lt;&lt;a[qh+1]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-830.-单调栈">AcWing 830. 单调栈</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;   // 引入输入输出流库</span><br><span class="line">#include &quot;stack&quot;      // 引入栈容器库</span><br><span class="line"></span><br><span class="line">using namespace std;  // 使用标准命名空间</span><br><span class="line"></span><br><span class="line">int n, x;              // 定义两个整数变量，n用于存储测试用例的数量，x用于临时存储每个输入的值</span><br><span class="line">stack&lt;int&gt; s;          // 定义一个整数类型的栈，用于辅助查找下一个更小的元素</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n;          // 从标准输入读取测试用例的数量</span><br><span class="line">    while (n--)&#123;       // 循环处理每一个测试用例</span><br><span class="line">        cin &gt;&gt; x;      // 从标准输入读取当前需要处理的整数x</span><br><span class="line">        </span><br><span class="line">        // 当栈不为空且栈顶元素大于等于当前输入的x时，持续弹出栈顶元素</span><br><span class="line">        // 这一步的目的是找到当前x左边第一个比它小的元素</span><br><span class="line">        while (!s.empty() &amp;&amp; s.top() &gt;= x)</span><br><span class="line">            s.pop();</span><br><span class="line">        </span><br><span class="line">        // 如果栈不为空，说明找到了一个比x小的元素，输出该元素</span><br><span class="line">        // 如果栈为空，说明x左边没有比它小的元素，输出-1</span><br><span class="line">        if (!s.empty())</span><br><span class="line">            cout &lt;&lt; s.top() &lt;&lt; &quot; &quot;;  // 输出栈顶元素，即当前x左边第一个更小的元素</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; -1 &lt;&lt; &quot; &quot;;       // 输出-1，表示没有更小的元素</span><br><span class="line">        </span><br><span class="line">        s.push(x);       // 将当前输入的x压入栈中，供后续元素比较使用</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;            // 程序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-154.-滑动窗口">AcWing 154. 滑动窗口</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1000010;</span><br><span class="line">int a[N]; // 存储输入的数组元素</span><br><span class="line">int n, k; // n为数组长度，k为滑动窗口大小</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    deque&lt;int&gt; dq; // 定义一个双端队列，用于维护滑动窗口内的最大值或最小值</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k; // 输入数组长度和滑动窗口大小</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i]; // 输入数组元素</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 求解滑动窗口内的最大值</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        // 当队列非空且队尾元素大于当前元素时，弹出队尾元素，保证队列单调递减</span><br><span class="line">        while (!dq.empty() &amp;&amp; dq.back() &gt; a[i])</span><br><span class="line">            dq.pop_back();</span><br><span class="line">        dq.push_back(a[i]); // 将当前元素加入队列</span><br><span class="line">        // 当窗口大小达到k时，检查队首元素是否等于窗口最左边的元素，若相等则弹出队首元素</span><br><span class="line">        if (i - k &gt;= 1 &amp;&amp; dq.front() == a[i - k])</span><br><span class="line">            dq.pop_front();</span><br><span class="line">        // 当窗口大小达到k时，输出队首元素，即当前窗口的最大值</span><br><span class="line">        if (i &gt;= k)</span><br><span class="line">            cout &lt;&lt; dq.front() &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    dq.clear(); // 清空队列，准备求解滑动窗口内的最小值</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // 求解滑动窗口内的最小值</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        // 当队列非空且队尾元素小于当前元素时，弹出队尾元素，保证队列单调递增</span><br><span class="line">        while (!dq.empty() &amp;&amp; dq.back() &lt; a[i])</span><br><span class="line">            dq.pop_back();</span><br><span class="line">        dq.push_back(a[i]); // 将当前元素加入队列</span><br><span class="line">        // 当窗口大小达到k时，检查队首元素是否等于窗口最左边的元素，若相等则弹出队首元素</span><br><span class="line">        if (i - k &gt;= 1 &amp;&amp; a[i - k] == dq.front())</span><br><span class="line">            dq.pop_front();</span><br><span class="line">        // 当窗口大小达到k时，输出队首元素，即当前窗口的最小值</span><br><span class="line">        if (i &gt;= k)</span><br><span class="line">            cout &lt;&lt; dq.front() &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-831.-kmp字符串">AcWing 831. KMP字符串</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot; // 引入输入输出流库</span><br><span class="line"></span><br><span class="line">using namespace std; // 使用标准命名空间</span><br><span class="line"></span><br><span class="line">// 定义常量N和M，设置模式串和主串的最大长度</span><br><span class="line">const int N = 100010, M = 1000010;</span><br><span class="line"></span><br><span class="line">// 全局变量声明</span><br><span class="line">int n, m, ne[N]; // n为模式串长度，m为主串长度，ne数组用于存储KMP算法的next值</span><br><span class="line">char p[N], s[M]; // p数组存储模式串，s数组存储主串</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 输入模式串的长度n，并将模式串p的输入从p[1]开始存储（为了方便后续处理，通常从1开始索引）</span><br><span class="line">    // 接着输入主串的长度m，并将主串s的输入从s[1]开始存储</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1;</span><br><span class="line"></span><br><span class="line">    // 构建模式串p的Next数组，用于KMP算法中的模式匹配</span><br><span class="line">    for (int i = 2, j = 0; i &lt;= n; ++i) &#123; // 从模式串的第二个字符开始遍历</span><br><span class="line">        // 当j不为0且当前字符p[i]与模式串中p[j+1]不匹配时，回退到上一个可能的匹配位置</span><br><span class="line">        while (j &amp;&amp; p[i] != p[j + 1])</span><br><span class="line">            j = ne[j];</span><br><span class="line">        </span><br><span class="line">        // 如果当前字符p[i]与模式串中p[j+1]匹配，增加匹配长度j</span><br><span class="line">        if (p[i] == p[j + 1])</span><br><span class="line">            j++;</span><br><span class="line">        </span><br><span class="line">        // 将当前的匹配长度j存储到Next数组中，供后续匹配使用</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 使用KMP算法在主串s中查找模式串p的所有出现位置</span><br><span class="line">    for (int i = 1, j = 0; i &lt;= m; ++i) &#123; // 从主串的第一个字符开始遍历</span><br><span class="line">        // 当j不为0且当前字符s[i]与模式串中p[j+1]不匹配时，回退到上一个可能的匹配位置</span><br><span class="line">        while (j &amp;&amp; s[i] != p[j + 1])</span><br><span class="line">            j = ne[j];</span><br><span class="line">        </span><br><span class="line">        // 如果当前字符s[i]与模式串中p[j+1]匹配，增加匹配长度j</span><br><span class="line">        if (s[i] == p[j + 1])</span><br><span class="line">            j++;</span><br><span class="line">        </span><br><span class="line">        // 如果j等于模式串的长度n，表示找到了一个完整的匹配</span><br><span class="line">        if (j == n) &#123;</span><br><span class="line">            // 输出匹配的起始位置（相对于主串的起始位置）</span><br><span class="line">            cout &lt;&lt; i - n &lt;&lt; &quot; &quot;;</span><br><span class="line">            </span><br><span class="line">            // 继续查找下一个可能的匹配，调整j的位置为ne[j]</span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0; // 程序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-835.-trie字符串统计">AcWing 835. Trie字符串统计</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;   // 引入输入输出流库</span><br><span class="line">#include &lt;map&gt;        // 引入map容器库，用于存储字符串及其对应的计数</span><br><span class="line">#include &lt;string&gt;     // 引入字符串处理库</span><br><span class="line"></span><br><span class="line">using namespace std;  // 使用标准命名空间，简化代码书写</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int N;                  // 定义一个整数变量N，用于存储操作的总次数</span><br><span class="line">    cin &gt;&gt; N;               // 从标准输入读取操作的总次数</span><br><span class="line"></span><br><span class="line">    map&lt;string, int&gt; countMap; // 定义一个map容器，键为string类型（字符串），值为int类型（计数）</span><br><span class="line">                             // 用于记录每个字符串出现的次数</span><br><span class="line"></span><br><span class="line">    string op, x;            // 定义两个字符串变量，op用于存储操作类型，x用于存储操作的字符串</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; N; ++i) &#123; // 循环N次，依次处理每一个操作</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x;          // 从标准输入读取操作类型和对应的字符串</span><br><span class="line"></span><br><span class="line">        if (op == &quot;I&quot;) &#123;         // 如果操作类型是&quot;I&quot;，表示插入操作</span><br><span class="line">            countMap[x]++;       // 将字符串x对应的计数加1</span><br><span class="line">                               // 如果x不存在于map中，会自动初始化为0，然后自增为1</span><br><span class="line">        &#125;</span><br><span class="line">        else if (op == &quot;Q&quot;) &#123;    // 如果操作类型是&quot;Q&quot;，表示查询操作</span><br><span class="line">            // 输出字符串x当前的计数，如果x不存在，map会返回默认值0</span><br><span class="line">            cout &lt;&lt; countMap[x] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果操作类型既不是&quot;I&quot;也不是&quot;Q&quot;，则忽略该操作</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0; // 程序结束，返回0表示成功</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-143.-最大异或对">AcWing 143. 最大异或对</h3>
<p>还是不咋会</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义常量N为100010，表示输入数组的最大长度</span><br><span class="line">// M为N*32，用于存储字典树节点，假设每个数最多32位</span><br><span class="line">const int N=100010,M=N*32;</span><br><span class="line">int n, ans=0, idx=0; // n为输入数组长度，ans存储最大异或值，idx为字典树节点索引</span><br><span class="line">int a[N], son[M][2]; // a为输入数组，son为字典树的左右子节点数组</span><br><span class="line"></span><br><span class="line">// 插入一个整数i到字典树中</span><br><span class="line">void insert(int i)&#123;</span><br><span class="line">    int p=0; // 从字典树的根节点开始</span><br><span class="line">    // 遍历整数i的每一位，从最高位到最低位</span><br><span class="line">    for (int j = 30; j &gt;=0 ; --j) &#123;</span><br><span class="line">        int u=i&gt;&gt;j&amp;1; // 提取整数i的第j位</span><br><span class="line">        if (!son[p][u]) // 如果当前位对应的子节点不存在</span><br><span class="line">            son[p][u]=++idx; // 创建新的子节点，并更新索引</span><br><span class="line">        p=son[p][u]; // 移动到下一个节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在字典树中查找与整数i异或结果最大的数</span><br><span class="line">int find(int i)&#123;</span><br><span class="line">    int p=0, res=0; // 从字典树的根节点开始，res存储当前最大异或值</span><br><span class="line">    // 遍历整数i的每一位，从最高位到最低位</span><br><span class="line">    for (int j = 30; j &gt;=0 ; --j) &#123;</span><br><span class="line">        int u=i&gt;&gt;j&amp;1; // 提取整数i的第j位</span><br><span class="line">        if (son[p][!u])&#123; // 如果存在与当前位相反的子节点</span><br><span class="line">            p=son[p][!u]; // 移动到该子节点</span><br><span class="line">            res=res*2+1; // 更新最大异或值</span><br><span class="line">        &#125; else &#123; // 如果不存在与当前位相反的子节点</span><br><span class="line">            p=son[p][u]; // 移动到当前位的子节点</span><br><span class="line">            res*=2; // 更新最大异或值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res; // 返回最大异或值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n; // 输入数组长度</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;a[i]; // 输入数组元素</span><br><span class="line">        insert(a[i]); // 将元素插入字典树</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        ans = max(ans, find(a[i])); // 查找与当前元素异或结果最大的数，并更新最大异或值</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl; // 输出最大异或值</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-836.-合并集合">AcWing 836. 合并集合</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义常量N为100010，表示元素的最大数量</span><br><span class="line">const int N = 100010;</span><br><span class="line"></span><br><span class="line">// 数组a用于存储每个元素的父节点，初始时每个元素的父节点指向自己</span><br><span class="line">int a[N];</span><br><span class="line">int n, m; // n表示元素的数量，m表示操作的数量</span><br><span class="line">int x, y; // 用于存储每次操作的参数</span><br><span class="line">char c;   // 存储操作类型，&#x27;M&#x27;表示合并，其他表示查找</span><br><span class="line"></span><br><span class="line">// 查找函数，使用路径压缩优化</span><br><span class="line">int Find(int i)&#123;</span><br><span class="line">    // 如果当前元素的父节点不是自己，递归查找父节点，并进行路径压缩</span><br><span class="line">    if (a[i] != i)</span><br><span class="line">        a[i] = Find(a[i]);</span><br><span class="line">    return a[i]; // 返回当前元素的根节点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; // 输入元素数量和操作数量</span><br><span class="line"></span><br><span class="line">    // 初始化并查集，每个元素的父节点指向自己</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理m个操作</span><br><span class="line">    while (m--)&#123;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; x &gt;&gt; y; // 输入操作类型和两个元素</span><br><span class="line"></span><br><span class="line">        if (c == &#x27;M&#x27;)&#123;</span><br><span class="line">            // 合并操作：将x所在的集合合并到y所在的集合</span><br><span class="line">            // 具体做法是将x的根节点的父节点指向y的根节点</span><br><span class="line">            a[Find(x)] = Find(y);</span><br><span class="line">            // 注意：这里原代码是a[Find(y)] = Find(x); 可能是笔误，通常合并是将一个集合的根指向另一个集合的根</span><br><span class="line">            // 如果要合并x到y，应该是a[Find(x)] = Find(y);</span><br><span class="line">            // 如果要合并y到x，应该是a[Find(y)] = Find(x);</span><br><span class="line">            // 根据具体需求调整</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            // 查找操作：判断x和y是否在同一个集合中</span><br><span class="line">            if (Find(x) == Find(y))</span><br><span class="line">                cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; // 如果根节点相同，说明在同一集合</span><br><span class="line">            else</span><br><span class="line">                cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;  // 否则不在同一集合</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-837.-连通块中点的数量">AcWing 837. 连通块中点的数量</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line">#include &quot;string&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义常量N为100010，用于数组大小</span><br><span class="line">const int N=100010;</span><br><span class="line"></span><br><span class="line">// a数组用于存储并查集的父节点信息</span><br><span class="line">int a[N];</span><br><span class="line">// S数组用于存储每个集合的大小</span><br><span class="line">int S[N];</span><br><span class="line"></span><br><span class="line">int n, m; // n表示元素的数量，m表示操作的次数</span><br><span class="line">string s; // 用于存储每次操作的类型</span><br><span class="line">int x, y; // 用于存储操作涉及的元素编号</span><br><span class="line"></span><br><span class="line">// 查找函数，使用路径压缩优化查找根节点</span><br><span class="line">int Find(int x)&#123;</span><br><span class="line">    if (a[x]==x) return x; // 如果x是根节点，直接返回x</span><br><span class="line">    else return a[x]= Find(a[x]); // 否则递归查找，并将x的父节点直接指向根节点，实现路径压缩</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 合并函数，将x和y所在的集合合并</span><br><span class="line">void merge(int x,int y)&#123;</span><br><span class="line">    x= Find(x); // 找到x所在集合的根节点</span><br><span class="line">    y= Find(y); // 找到y所在集合的根节点</span><br><span class="line">    a[x] = y; // 将x的根节点指向y的根节点，实现合并</span><br><span class="line">    S[y]+=S[x]; // 更新y所在集合的大小，加上x所在集合的大小</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 判断函数，判断x和y是否在同一个集合中</span><br><span class="line">bool same(int x,int y)&#123;</span><br><span class="line">    return Find(x) == Find(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m; // 输入元素的数量和操作的次数</span><br><span class="line">    for (int i = 1 ; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i]=i; // 初始化并查集，每个元素的父节点初始化为自身</span><br><span class="line">        S[i]=1; // 初始化每个集合的大小为1</span><br><span class="line">    &#125;</span><br><span class="line">    while (m--)&#123;</span><br><span class="line">        cin&gt;&gt;s; // 输入操作的类型</span><br><span class="line">        if (s==&quot;C&quot;)&#123; // 如果操作类型为&quot;C&quot;，表示合并操作</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y; // 输入要合并的两个元素</span><br><span class="line">            if (!same(x,y)) // 如果两个元素不在同一个集合中</span><br><span class="line">                merge(x,y); // 合并两个元素所在的集合</span><br><span class="line">        &#125;else if(s==&quot;Q1&quot;)&#123; // 如果操作类型为&quot;Q1&quot;，表示查询两个元素是否在同一个集合中</span><br><span class="line">            cin&gt;&gt;x&gt;&gt;y; // 输入要查询的两个元素</span><br><span class="line">            if(same(x,y)) // 如果两个元素在同一个集合中</span><br><span class="line">                cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; // 输出&quot;Yes&quot;</span><br><span class="line">            else</span><br><span class="line">                cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; // 输出&quot;No&quot;</span><br><span class="line">        &#125; else &#123; // 如果操作类型为其他，表示查询某个元素所在集合的大小</span><br><span class="line">            cin&gt;&gt;x; // 输入要查询的元素</span><br><span class="line">            cout &lt;&lt; S[Find(x)] &lt;&lt; endl; // 输出该元素所在集合的大小</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-240.-食物链">AcWing 240. 食物链</h3>
<p>这题也不是很懂</p>
<blockquote>
<p>这里的核心在于
<strong>根相同并不直接等同于同类</strong>，而是需要通过距离差来判断具体关系。</p>
<p>在食物链问题中：</p>
<ul>
<li><code>d[x] % 3 == 0</code> 表示 x 与根是同类</li>
<li><code>d[x] % 3 == 1</code> 表示 x 吃根</li>
<li><code>d[x] % 3 == 2</code> 表示 x 被根吃（或者说根吃 x）</li>
</ul>
<p>当 <code>rx == ry</code>（根相同）时，说明 x 和 y
<strong>已经被连接过</strong>，但它们的实际关系需要由 <code>d[x]</code>
和 <code>d[y]</code> 的差决定：</p>
<ul>
<li><code>(d[x] - d[y]) % 3 == 0</code> → 同类</li>
<li><code>(d[x] - d[y]) % 3 == 1</code> → x 吃 y</li>
<li><code>(d[x] - d[y]) % 3 == 2</code> → y 吃 x</li>
</ul>
<p><strong>为什么不能直接认为根相同就是同类？</strong>
因为并查集的树结构可能经过多次合并，虽然根相同，但路径上的权值差异可能代表不同的食物链关系。例如：</p>
<ul>
<li>可能存在 A→B→C 的链条，其中 A 吃 B，B 吃 C，此时 A 和 C 的根相同但 A
吃 C</li>
<li>通过权值差 <code>d[A] - d[C] = 2</code>，满足 <code>2 %3 == 2</code>
表示 C 吃 A 的反向关系</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 50010;</span><br><span class="line">int n, k, res;          // res记录假话数量</span><br><span class="line">int p[N];               // 并查集父节点数组</span><br><span class="line">int d[N];               // 到父节点的距离（用于表示关系，模3后 0同类，1吃父节点，2被父节点吃）</span><br><span class="line"></span><br><span class="line">// 带路径压缩的查找函数，同时维护节点到根节点的距离</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(p[x] != x)&#123;</span><br><span class="line">        int t = find(p[x]);   // 递归找到根节点</span><br><span class="line">        d[x] += d[p[x]];      // 路径压缩时累加路径上的权值（先累加父节点到根的权值）</span><br><span class="line">        p[x] = t;             // 路径压缩，直接指向根节点</span><br><span class="line">    &#125;</span><br><span class="line">    return p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    // 初始化并查集，每个节点父节点是自己，初始距离为0</span><br><span class="line">    for(int i = 1; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    while(k--)&#123;</span><br><span class="line">        int v, x, y;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        </span><br><span class="line">        // 规则1：编号超出范围直接判定为假</span><br><span class="line">        if(x &gt; n || y &gt; n) res++;</span><br><span class="line">        else&#123;</span><br><span class="line">            int rx = find(x), ry = find(y);  // 找到两个节点的根</span><br><span class="line">            </span><br><span class="line">            if(v == 1)&#123;  // 声称x和y是同类</span><br><span class="line">                // 如果根相同但距离差模3不为0，说明不是同类</span><br><span class="line">                if(rx == ry &amp;&amp; (d[y] - d[x]) % 3) res++;</span><br><span class="line">                // 根不同时需要合并集合</span><br><span class="line">                else if(rx != ry)&#123;</span><br><span class="line">                    p[rx] = ry;  // 将x的根挂到y的根</span><br><span class="line">                    // 设定rx到ry的距离：要满足(d[x]+d[rx]-d[y])%3 == 0</span><br><span class="line">                    d[rx] = d[y] - d[x];  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;  // 声称x吃y（v==2时）</span><br><span class="line">                // 规则2：自己吃自己是假话</span><br><span class="line">                if(x == y) res++;</span><br><span class="line">                // 根相同但距离差不符合捕食关系（d[x]应该比d[y]大1模3）</span><br><span class="line">                else if(rx == ry &amp;&amp; (d[x] - d[y] - 1) % 3) res++;</span><br><span class="line">                // 根不同时需要合并集合</span><br><span class="line">                else if(rx != ry)&#123;</span><br><span class="line">                    p[rx] = ry;  // 将x的根挂到y的根</span><br><span class="line">                    // 设定rx到ry的距离：要满足(d[x]+d[rx]-d[y])%3 == 1</span><br><span class="line">                    d[rx] = d[y] + 1 - d[x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-838.-堆排序">AcWing 838. 堆排序</h3>
<p>内置函数法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;int&gt; a(n);</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a.begin(),a.end());</span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010;  // 定义数组的最大大小</span><br><span class="line">int a[N];              // 用于存储数据的数组</span><br><span class="line">int n, m;              // n: 数组元素个数, m: 需要输出的最小值的个数</span><br><span class="line">int r;                 // 当前堆的大小</span><br><span class="line"></span><br><span class="line">// S函数用于维护堆的性质，u是当前节点的下标</span><br><span class="line">void S(int u)</span><br><span class="line">&#123;</span><br><span class="line">    int t = u;  // t用于记录最小值的下标</span><br><span class="line">    // 如果左子节点存在且比当前节点小，则更新t</span><br><span class="line">    if(2 * u &lt;= r &amp;&amp; a[2 * u] &lt; a[u]) t = 2 * u;</span><br><span class="line">    // 如果右子节点存在且比当前节点和左子节点都小，则更新t</span><br><span class="line">    if(2 * u + 1 &lt;= r &amp;&amp; a[2 * u + 1] &lt; a[t]) t = 2 * u + 1;</span><br><span class="line">    // 如果当前节点不是最小值，则交换并递归调整</span><br><span class="line">    if(u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(a[u], a[t]);</span><br><span class="line">        S(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;  // 输入数组元素个数n和需要输出的最小值的个数m</span><br><span class="line">    r = n;      // 初始化堆的大小为n</span><br><span class="line">    // 输入数组元素</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    // 从最后一个非叶子节点开始，自底向上构建最小堆</span><br><span class="line">    for (int i = n/2; i&gt;=1; --i) &#123;</span><br><span class="line">        S(i);</span><br><span class="line">    &#125;</span><br><span class="line">    // 输出前m个最小值</span><br><span class="line">    while (m--)&#123;</span><br><span class="line">        cout&lt;&lt;a[1]&lt;&lt;&quot; &quot;;  // 输出堆顶元素（当前最小值）</span><br><span class="line">        swap(a[1], a[r]); // 将堆顶元素与最后一个元素交换</span><br><span class="line">        r--;              // 缩小堆的大小</span><br><span class="line">        S(1);             // 调整堆，使其重新满足最小堆性质</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-839.-模拟堆">AcWing 839. 模拟堆</h3>
<p>内置函数法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;istream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define N 500010 // 定义数组的最大大小</span><br><span class="line">int a[N], cnt = 0; // a数组用于记录第k个插入的数，cnt是插入的计数器</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n; // 操作次数</span><br><span class="line">    multiset&lt;int&gt; s; // 使用multiset维护集合的有序性，允许重复元素</span><br><span class="line">    cin &gt;&gt; n; // 输入操作次数</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= n; i++) // 循环处理每个操作</span><br><span class="line">    &#123;</span><br><span class="line">        string t; // 操作指令</span><br><span class="line">        int x, y; // 操作参数</span><br><span class="line">        cin &gt;&gt; t; // 输入操作指令</span><br><span class="line"></span><br><span class="line">        if (t == &quot;I&quot;) // 插入操作</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x; // 输入要插入的数</span><br><span class="line">            s.insert(x); // 将x插入multiset</span><br><span class="line">            a[++cnt] = x; // 记录第cnt个插入的数为x</span><br><span class="line">        &#125;</span><br><span class="line">        if (t == &quot;PM&quot;) // 输出最小值操作</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; *s.begin() &lt;&lt; endl; // 输出multiset中的最小值</span><br><span class="line">        &#125;</span><br><span class="line">        if (t == &quot;DM&quot;) // 删除最小值操作</span><br><span class="line">        &#123;</span><br><span class="line">            s.erase(s.find(*s.begin())); // 找到最小值并删除</span><br><span class="line">        &#125;</span><br><span class="line">        if (t == &quot;D&quot;) // 删除第k个插入的数操作</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x; // 输入k</span><br><span class="line">            if (s.find(a[x]) != s.end()) // 如果第k个插入的数仍在multiset中</span><br><span class="line">            &#123;</span><br><span class="line">                s.erase(s.find(a[x])); // 删除该数</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (t == &quot;C&quot;) // 修改第k个插入的数操作</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y; // 输入k和新的值y</span><br><span class="line">            if (s.find(a[x]) != s.end()) // 如果第k个插入的数仍在multiset中</span><br><span class="line">            &#123;</span><br><span class="line">                s.erase(s.find(a[x])); // 删除旧值</span><br><span class="line">            &#125;</span><br><span class="line">            a[x] = y; // 更新第k个插入的数为y</span><br><span class="line">            s.insert(y); // 将新值插入multiset</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0; // 程序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-840.-模拟散列表">AcWing 840. 模拟散列表</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line">#include &quot;set&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n,x;</span><br><span class="line">set&lt;int&gt; s;</span><br><span class="line">char c;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;c&gt;&gt;x;</span><br><span class="line">        if(c==&#x27;I&#x27;)&#123;</span><br><span class="line">            s.insert(x);</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            cout &lt;&lt; (s.find(x) != s.end() ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-841.-字符串哈希">AcWing 841. 字符串哈希</h3>
<blockquote>
<p><strong>为什么需要 <code>p</code> 数组？</strong></p>
<p>正确的哈希值计算需要对齐前缀哈希值。例如，子串 <code>[l, r]</code>
的正确哈希值公式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h[r] - h[l-1] * p[r-l+1]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>p[r-l+1]</code> 的作用是将 <code>h[l-1]</code> 左移
<code>(r-l+1)</code> 位，使其与 <code>h[r]</code> 对齐。</li>
<li>如果没有 <code>p</code>
数组，哈希值无法正确对齐，导致哈希值错误。</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef unsigned long long ULL; // 定义无符号长整型别名，用于哈希值计算</span><br><span class="line">const int N = 100010, M = 11; // N: 字符串最大长度, M: 哈希基数（通常取质数）</span><br><span class="line"></span><br><span class="line">int n, m; // n: 字符串长度, m: 查询次数</span><br><span class="line">char str[N]; // 存储输入的字符串</span><br><span class="line">ULL p[N], h[N]; // p: 存储 M 的幂次方, h: 存储字符串的前缀哈希值</span><br><span class="line"></span><br><span class="line">// 获取子串 [l, r] 的哈希值</span><br><span class="line">ULL get(int l, int r) &#123;</span><br><span class="line">    return h[r] - h[l - 1] * p[r - l + 1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; // 输入字符串长度和查询次数</span><br><span class="line">    cin &gt;&gt; str + 1; // 输入字符串，从下标 1 开始存储</span><br><span class="line"></span><br><span class="line">    // 初始化 p[0] 和 h[0]</span><br><span class="line">    p[0] = 1; // M^0 = 1</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        h[i] = h[i - 1] * M + str[i]; // 计算前缀哈希值</span><br><span class="line">        p[i] = p[i - 1] * M; // 计算 M 的幂次方</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理每个查询</span><br><span class="line">    while (m--) &#123;</span><br><span class="line">        int l1, r1, l2, r2; // 查询的两个子串的区间</span><br><span class="line">        cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2; // 输入查询区间</span><br><span class="line"></span><br><span class="line">        // 比较两个子串的哈希值</span><br><span class="line">        if (get(l1, r1) == get(l2, r2)) &#123;</span><br><span class="line">            puts(&quot;Yes&quot;); // 哈希值相等，子串相等</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            puts(&quot;No&quot;); // 哈希值不等，子串不等</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0; // 程序结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="第三讲-搜索与图论">第三讲 搜索与图论</h2>
<p><strong>2025.3.7</strong></p>
<h3 id="acwing-842.-排列数字">AcWing 842. 排列数字</h3>
<p>此函数确保所有顺序都被遍历到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        // 如果数字i没有被使用过</span><br><span class="line">        if (!b[i]) &#123;</span><br><span class="line">            b[i] = true;  // 标记数字i为已使用</span><br><span class="line">            a[k] = i;     // 将数字i放入当前排列的第k个位置</span><br><span class="line">            dfs(k + 1);   // 递归生成下一个位置的数字</span><br><span class="line">            b[i] = false; // 回溯，标记数字i为未使用</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;iostream&quot;  // 引入输入输出流库</span><br><span class="line"></span><br><span class="line">using namespace std;  // 使用标准命名空间</span><br><span class="line"></span><br><span class="line">const int N = 10;  // 定义常量N，表示数组的最大长度</span><br><span class="line">int n, a[N];       // 定义全局变量n和数组a，n表示当前排列的长度，a用于存储当前排列</span><br><span class="line">bool b[N];         // 定义全局数组b，用于标记数字是否被使用过</span><br><span class="line"></span><br><span class="line">// 深度优先搜索（DFS）函数，用于生成全排列</span><br><span class="line">void dfs(int k) &#123;</span><br><span class="line">    // 如果当前排列的长度k等于n，说明已经生成了一个完整的排列</span><br><span class="line">    if (k == n) &#123;</span><br><span class="line">        // 输出当前排列</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;  // 换行</span><br><span class="line">        return;  // 返回上一层递归</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历所有可能的数字</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        // 如果数字i没有被使用过</span><br><span class="line">        if (!b[i]) &#123;</span><br><span class="line">            b[i] = true;  // 标记数字i为已使用</span><br><span class="line">            a[k] = i;     // 将数字i放入当前排列的第k个位置</span><br><span class="line">            dfs(k + 1);   // 递归生成下一个位置的数字</span><br><span class="line">            b[i] = false; // 回溯，标记数字i为未使用</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主函数</span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n;  // 输入排列的长度n</span><br><span class="line">    dfs(0);    // 从第0个位置开始生成全排列</span><br><span class="line">    return 0;  // 程序正常结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-843.-n-皇后问题">AcWing 843. n-皇后问题</h3>
<p><img
src="https://git.acwing.com/Hasity/jnu/-/raw/master/acwing/n-hh.png" /></p>
<p>注意如下函数判断对角线皇后是否相邻</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool valid(int u) &#123;</span><br><span class="line">    for (int i = 1; i &lt; u; i++) &#123;  // 遍历第1行到第u-1行已放置的皇后</span><br><span class="line">        if (abs(u - i) == abs(st[u] - st[i])) &#123;  // 对角线冲突判断</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;  // 无对角线冲突</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 10;   // 定义常量N为10，表示最大支持的棋盘尺寸为10x10</span><br><span class="line">int st[N];          // st数组：st[u]存储第u行皇后所在的列号（从1开始）</span><br><span class="line">int used[N];        //used数组：used[i]标记第i列是否已被占用（1:占用，0:未用）</span><br><span class="line">int n;              // 用户输入的棋盘尺寸，表示n皇后问题</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 检查第u行的皇后位置是否与之前的皇后位置冲突（对角线检查）</span><br><span class="line"> * @param u 当前处理的行号（从1开始）</span><br><span class="line"> * @return 无冲突返回true，否则返回false</span><br><span class="line"> *</span><br><span class="line"> * 数学原理：若两皇后位置的行差绝对值等于列差绝对值，则说明在同一对角线。</span><br><span class="line"> * 例如：皇后A在(2,3)，皇后B在(4,5)，行差2，列差2，在同一对角线。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">bool valid(int u) &#123;</span><br><span class="line">    for (int i = 1; i &lt; u; i++) &#123;  // 遍历第1行到第u-1行已放置的皇后</span><br><span class="line">        if (abs(u - i) == abs(st[u] - st[i])) &#123;  // 对角线冲突判断</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;  // 无对角线冲突</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 深度优先搜索函数，递归放置皇后并回溯</span><br><span class="line"> * @param u 当前处理的行号（从1开始）</span><br><span class="line"> *</span><br><span class="line"> * 核心逻辑：尝试在第u行的每一列放置皇后，检查冲突后递归处理下一行。</span><br><span class="line"> * 若成功放置n个皇后，则输出棋盘布局。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">void dfs(int u) &#123;</span><br><span class="line">    // 递归终止条件：已放置完所有n行皇后</span><br><span class="line">    if (u &gt; n) &#123;</span><br><span class="line">        // 打印当前棋盘布局</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;          // 遍历每一行</span><br><span class="line">            for (int j = 1; j &lt;= n; j++) &#123;      // 遍历每一列</span><br><span class="line">                if (j == st[i]) &#123;               // 若当前位置放置了皇后</span><br><span class="line">                    cout &lt;&lt; &#x27;Q&#x27;;                // 输出Q</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cout &lt;&lt; &#x27;.&#x27;;                // 否则输出.</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;  // 换行进入下一行</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;  // 不同解之间用空行分隔</span><br><span class="line">        return;  // 回溯至上一层递归</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 尝试在第u行的每一列放置皇后</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        if (!used[i]) &#123;  // 如果第i列未被占用</span><br><span class="line">            st[u] = i;   // 临时假设第u行的皇后放在第i列</span><br><span class="line"></span><br><span class="line">            // 检查当前列和对角线是否冲突</span><br><span class="line">            if (!valid(u)) &#123;   // 若存在冲突</span><br><span class="line">                st[u] = 0;     // 撤销当前列的放置（恢复为0）</span><br><span class="line">                continue;      // 跳过当前列，尝试下一列</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = 1;       // 正式占用第i列</span><br><span class="line">            dfs(u + 1);        // 递归处理下一行</span><br><span class="line">            used[i] = 0;       // 回溯：释放第i列</span><br><span class="line">            st[u] = 0;         // 回溯：清除第u行的列记录</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 主函数</span><br><span class="line"> * 流程：1.读取棋盘尺寸n 2.从第1行开始DFS搜索解</span><br><span class="line"> */</span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n;        // 输入棋盘尺寸（例如输入8表示解决8皇后问题）</span><br><span class="line">    dfs(1);          // 从第1行开始递归搜索</span><br><span class="line">    return 0;        // 程序正常退出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-844.-走迷宫">AcWing 844. 走迷宫</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义一个坐标对类型，用于存储二维平面上的点</span><br><span class="line">typedef pair&lt;int,int&gt; PII;</span><br><span class="line">// 定义二维数组的大小</span><br><span class="line">const int N=110;</span><br><span class="line">// a数组用于存储输入的二维矩阵，f数组用于存储从起点到每个点的最短距离</span><br><span class="line">int a[N][N],f[N][N];</span><br><span class="line">// 定义二维平面的行数和列数</span><br><span class="line">int n,m;</span><br><span class="line">// 定义四个方向，分别对应上下左右</span><br><span class="line">int dx[4]=&#123;0,1,0,-1&#125;;</span><br><span class="line">int dy[4]=&#123;-1,0,1,0&#125;;</span><br><span class="line"></span><br><span class="line">// 广度优先搜索函数，从(x,y)开始搜索</span><br><span class="line">void bfs(int x,int y)&#123;</span><br><span class="line">    // 创建一个队列，用于存储待处理的点</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    // 将起点加入队列</span><br><span class="line">    q.emplace(x,y);</span><br><span class="line">    // 当队列不为空时，继续搜索</span><br><span class="line">    while (!q.empty())&#123;</span><br><span class="line">        // 取出队首元素</span><br><span class="line">        PII start = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        // 将当前点标记为已访问</span><br><span class="line">        a[start.first][start.second]=1;</span><br><span class="line">        // 遍历当前点的四个邻居</span><br><span class="line">        for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">            // 计算邻居的坐标</span><br><span class="line">            int xx=start.first+dx[i];</span><br><span class="line">            int yy=start.second+dy[i];</span><br><span class="line">            // 如果邻居未被访问过</span><br><span class="line">            if (a[xx][yy]==0)&#123;</span><br><span class="line">                // 标记邻居为已访问</span><br><span class="line">                a[xx][yy]=1;</span><br><span class="line">                // 更新从起点到邻居的最短距离</span><br><span class="line">                f[xx][yy]=f[start.first][start.second]+1;</span><br><span class="line">                // 将邻居加入队列</span><br><span class="line">                q.emplace(xx,yy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 输出从起点到终点的最短距离</span><br><span class="line">    cout&lt;&lt;f[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    // 初始化a数组，将所有元素设置为1，表示所有点都未被访问过</span><br><span class="line">    memset(a,1,sizeof(a));</span><br><span class="line">    // 输入二维平面的行数和列数</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    // 输入二维矩阵</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">        for (int j = 1; j &lt;= m; ++j)</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">    // 从(1,1)开始进行广度优先搜索</span><br><span class="line">    bfs(1,1);</span><br><span class="line">    // 程序结束</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-845.-八数码">AcWing 845. 八数码</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unordered_map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 定义两个字符串，s用于存储初始状态，t用于临时存储当前状态</span><br><span class="line">string s, t;</span><br><span class="line">// 定义一个字符变量，用于接收输入</span><br><span class="line">char c;</span><br><span class="line">// 定义一个哈希表，用于记录每个状态的最小步数</span><br><span class="line">unordered_map&lt;string, int&gt; usi;</span><br><span class="line">// 定义一个队列，用于存储待处理的状态</span><br><span class="line">queue&lt;string&gt; q;</span><br><span class="line">// 定义四个方向，分别对应上下左右</span><br><span class="line">int dx[4] = &#123;-1, 0, 1, 0&#125;;</span><br><span class="line">int dy[4] = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">// 定义变量，用于存储当前状态中&#x27;x&#x27;的位置，以及临时坐标</span><br><span class="line">int pos, x, y, cnt, xx, yy;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 输入初始状态，将输入的字符拼接成字符串s</span><br><span class="line">    for (int i = 0; i &lt; 9; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; c;</span><br><span class="line">        s += c;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将初始状态的步数设置为0，并加入队列</span><br><span class="line">    usi[s] = 0;</span><br><span class="line">    q.push(s);</span><br><span class="line">    // 广度优先搜索（BFS）开始</span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        // 取出队首状态</span><br><span class="line">        t = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        // 如果当前状态是目标状态&quot;12345678x&quot;，则输出步数并结束程序</span><br><span class="line">        if (t == &quot;12345678x&quot;) &#123;</span><br><span class="line">            cout &lt;&lt; usi[t] &lt;&lt; endl;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // 找到当前状态中&#x27;x&#x27;的位置</span><br><span class="line">        pos = t.find(&#x27;x&#x27;);</span><br><span class="line">        // 将一维位置转换为二维坐标</span><br><span class="line">        x = pos / 3;</span><br><span class="line">        y = pos % 3;</span><br><span class="line">        // 获取当前状态的步数</span><br><span class="line">        cnt = usi[t];</span><br><span class="line">        // 遍历四个方向</span><br><span class="line">        for (int i = 0; i &lt; 4; ++i) &#123;</span><br><span class="line">            // 计算&#x27;x&#x27;移动后的新坐标</span><br><span class="line">            xx = x + dx[i];</span><br><span class="line">            yy = y + dy[i];</span><br><span class="line">            // 检查新坐标是否在合法范围内</span><br><span class="line">            if (xx &gt;= 0 &amp;&amp; xx &lt;= 2 &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt;= 2) &#123;</span><br><span class="line">                // 交换&#x27;x&#x27;和新坐标位置的字符</span><br><span class="line">                swap(t[pos], t[3 * xx + yy]);</span><br><span class="line">                // 如果新状态未被访问过</span><br><span class="line">                if (usi.find(t) == usi.end()) &#123;</span><br><span class="line">                    // 记录新状态的步数</span><br><span class="line">                    usi[t] = cnt + 1;</span><br><span class="line">                    // 将新状态加入队列</span><br><span class="line">                    q.push(t);</span><br><span class="line">                &#125;</span><br><span class="line">                // 恢复状态，以便尝试其他方向</span><br><span class="line">                swap(t[pos], t[3 * xx + yy]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果无法到达目标状态，输出-1</span><br><span class="line">    cout &lt;&lt; -1 &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-846.-树的重心">AcWing 846. 树的重心</h3>
<p>核心代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 深度优先搜索函数，u 是当前节点</span><br><span class="line">int dfs(int u)</span><br><span class="line">&#123;</span><br><span class="line">    int res = 1, t, h = 0; // res: 以u为根节点的树的大小，t: 存储子节点子树的大小，h: 当前子树的最大子树大小</span><br><span class="line">    st[u] = 1; // 标记当前节点为已访问</span><br><span class="line">    for(auto x : e[u]) // 遍历当前节点的所有邻接节点</span><br><span class="line">        if(!st[x]) // 如果邻接节点未被访问过</span><br><span class="line">        &#123;</span><br><span class="line">            t = dfs(x); // 递归计算子节点 x 的子树大小</span><br><span class="line">            res += t;   // 累加子节点子树的大小到 u 的子树</span><br><span class="line">            h = max(h, t); // 更新当前子树的最大子树大小</span><br><span class="line">        &#125;</span><br><span class="line">    h = max(h, n - res); // 计算当前子树的最大子树大小（包括父节点所在的子树），n-res：删除以u为根节点的子树后的剩余节点的数量。</span><br><span class="line">    m = min(m, h); // 更新全局最小化的最大连通块大小</span><br><span class="line">    return res; // 返回当前子树的大小</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define pb push_back // 定义宏，简化 vector 的 push_back 操作</span><br><span class="line"></span><br><span class="line">int n, a, b, m = 1e7; // n: 节点数，a, b: 临时变量，m: 最终结果（初始化为一个大值）</span><br><span class="line">bool st[100010];      // 记录节点是否被访问过</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; e[100010]; // 邻接表存储图</span><br><span class="line"></span><br><span class="line">// 深度优先搜索函数，u 是当前节点</span><br><span class="line">int dfs(int u)</span><br><span class="line">&#123;</span><br><span class="line">    int res = 1, t, h = 0; // res: 以u为根节点的树的大小，t: 存储子节点子树的大小，h: 当前子树的最大子树大小</span><br><span class="line">    st[u] = 1; // 标记当前节点为已访问</span><br><span class="line">    for(auto x : e[u]) // 遍历当前节点的所有邻接节点</span><br><span class="line">        if(!st[x]) // 如果邻接节点未被访问过</span><br><span class="line">        &#123;</span><br><span class="line">            t = dfs(x); // 递归计算子节点 x 的子树大小</span><br><span class="line">            res += t;   // 累加子节点子树的大小到 u 的子树</span><br><span class="line">            h = max(h, t); // 更新当前子树的最大子树大小</span><br><span class="line">        &#125;</span><br><span class="line">    h = max(h, n - res); // 计算当前子树的最大子树大小（包括父节点所在的子树），n-res：删除以u为根节点的子树后的剩余节点的数量。</span><br><span class="line">    m = min(m, h); // 更新全局最小化的最大连通块大小</span><br><span class="line">    return res; // 返回当前子树的大小</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n; // 输入节点数</span><br><span class="line">    for(int i = 1; i &lt; n; i ++) // 输入 n-1 条边</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        e[a].pb(b); // 添加边 a -&gt; b</span><br><span class="line">        e[b].pb(a); // 添加边 b -&gt; a</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(1); // 从节点 1 开始深度优先搜索</span><br><span class="line">    cout &lt;&lt; m; // 输出最终结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-847.-图中点的层次">AcWing 847. 图中点的层次</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=100010; // 定义最大节点数</span><br><span class="line">vector&lt;int&gt; v[N];   // 邻接表，用于存储图</span><br><span class="line">int n,m,a,b,d[N];   // n: 节点数, m: 边数, a,b: 临时变量, d[]: 存储每个节点到起点的距离</span><br><span class="line">queue&lt;int&gt; q;       // 用于BFS的队列</span><br><span class="line"></span><br><span class="line">// BFS函数，返回从节点1到节点n的最短距离</span><br><span class="line">int bfs()&#123;</span><br><span class="line">    memset(d,-1,sizeof d); // 初始化距离数组，-1表示未访问</span><br><span class="line">    q.push(1);             // 将起点1加入队列</span><br><span class="line">    d[1]=0;                // 起点到自身的距离为0</span><br><span class="line">    while (!q.empty())&#123;    // 当队列不为空时，继续搜索</span><br><span class="line">        int t=q.front();   // 取出队首节点</span><br><span class="line">        q.pop();           // 弹出队首节点</span><br><span class="line">        for(auto au:v[t])&#123; // 遍历当前节点的所有邻接节点</span><br><span class="line">            if (d[au]==-1)&#123; // 如果邻接节点未被访问过</span><br><span class="line">                d[au]=d[t]+1; // 更新邻接节点的距离</span><br><span class="line">                q.push(au);   // 将邻接节点加入队列</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return d[n]; // 返回终点n到起点1的最短距离</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m; // 输入节点数和边数</span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b; // 输入每条边的两个节点</span><br><span class="line">        v[a].push_back(b); // 将边加入邻接表</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt; bfs() &lt;&lt;endl; // 输出从节点1到节点n的最短距离</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-848.-有向图的拓扑序列">AcWing 848. 有向图的拓扑序列</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010; // 定义最大节点数</span><br><span class="line">int n, m;             // n: 顶点数, m: 边数</span><br><span class="line">vector&lt;int&gt; adj[N];   // 邻接表，用于存储图</span><br><span class="line">vector&lt;int&gt; inDegree(N, 0); // 存储每个节点的入度</span><br><span class="line"></span><br><span class="line">// 拓扑排序函数，返回拓扑排序结果</span><br><span class="line">vector&lt;int&gt; topologicalSort() &#123;</span><br><span class="line">    vector&lt;int&gt; result; // 存储拓扑排序的结果</span><br><span class="line">    queue&lt;int&gt; q;       // 用于BFS的队列</span><br><span class="line"></span><br><span class="line">    // 将所有初始入度为0的节点加入队列</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        if (inDegree[i] == 0) &#123;</span><br><span class="line">            q.push(i); // 入度为0的节点是拓扑排序的起点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // BFS遍历图</span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        int u = q.front(); // 取出队首节点</span><br><span class="line">        q.pop();           // 弹出队首节点</span><br><span class="line">        result.push_back(u); // 将当前节点加入拓扑排序结果</span><br><span class="line"></span><br><span class="line">        // 遍历当前节点的所有邻接节点</span><br><span class="line">        for (int v : adj[u]) &#123;</span><br><span class="line">            // 减少邻接节点的入度</span><br><span class="line">            if (--inDegree[v] == 0) &#123;</span><br><span class="line">                q.push(v); // 如果邻接节点的入度变为0，则加入队列</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果结果长度不等于n，说明存在环，无法进行拓扑排序</span><br><span class="line">    return (result.size() == n) ? result : vector&lt;int&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; // 输入顶点数和边数</span><br><span class="line"></span><br><span class="line">    // 建图并记录入度</span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        int x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y; // 输入每条边的两个节点</span><br><span class="line">        adj[x].push_back(y); // 将边加入邻接表</span><br><span class="line">        inDegree[y]++;       // 增加目标节点的入度</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 调用拓扑排序函数</span><br><span class="line">    vector&lt;int&gt; ans = topologicalSort();</span><br><span class="line"></span><br><span class="line">    // 输出结果</span><br><span class="line">    if (!ans.empty()) &#123;</span><br><span class="line">        // 如果拓扑排序成功，输出结果</span><br><span class="line">        for (int num : ans) cout &lt;&lt; num &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果存在环，输出-1</span><br><span class="line">        cout &lt;&lt; -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-849.-dijkstra求最短路ⅰ">AcWing 849.
Dijkstra求最短路Ⅰ</h3>
<blockquote>
<p>在算法竞赛或编程中，<code>0x3f</code>
经常被用作一个“无穷大”的近似值，尤其是在需要初始化一个较大但不会溢出的值时。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 510; // 定义最大节点数</span><br><span class="line">int n, m;          // n 是节点数，m 是边数</span><br><span class="line">bool visited[N];   // 记录节点是否被访问过</span><br><span class="line">int dist[N];       // 记录从起点到每个节点的最短距离</span><br><span class="line">int g[N][N];       // 图的邻接矩阵表示</span><br><span class="line">int a, b, c;       // 临时变量，用于输入边的信息</span><br><span class="line"></span><br><span class="line">int dijkstra() &#123;</span><br><span class="line">    dist[1] = 0; // 起点到自身的距离为 0</span><br><span class="line"></span><br><span class="line">    // 进行 n-1 次松弛操作</span><br><span class="line">    for (int i = 0; i &lt; n - 1; ++i) &#123;</span><br><span class="line">        int t = -1; // t 用于记录当前未访问节点中距离起点最近的节点</span><br><span class="line"></span><br><span class="line">        // 找到未访问节点中距离起点最近的节点</span><br><span class="line">        for (int j = 1; j &lt;= n; ++j) &#123;</span><br><span class="line">            if (!visited[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 通过节点 t 更新其他节点的距离</span><br><span class="line">        for (int j = 1; j &lt;= n; ++j) &#123;</span><br><span class="line">            dist[j] = min(dist[j], dist[t] + g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited[t] = 1; // 标记节点 t 为已访问</span><br><span class="line"></span><br><span class="line">        // 如果已经找到终点的最短距离，提前退出</span><br><span class="line">        if (t == n)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果终点的距离仍然大于等于初始值（表示无法到达），返回 -1</span><br><span class="line">    if (dist[n] &gt;= 10000 * n)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    return dist[n]; // 返回起点到终点的最短距离</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    memset(g, 0x3f, sizeof g);    // 初始化邻接矩阵，所有边的距离为“无穷大”</span><br><span class="line">    memset(dist, 0x3f, sizeof dist); // 初始化距离数组，所有节点的距离为“无穷大”</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; // 输入节点数和边数</span><br><span class="line"></span><br><span class="line">    // 输入边的信息并更新邻接矩阵</span><br><span class="line">    while (m--) &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        g[a][b] = min(g[a][b], c); // 如果有重边，保留最短的边</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dijkstra() &lt;&lt; endl; // 调用 Dijkstra 算法并输出结果</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>斐波那契堆</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;ctime&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int minimum = 1.7e-308;  //changed</span><br><span class="line">const int maximum = 1.7e308;</span><br><span class="line"></span><br><span class="line">struct fibonacci_heap_node &#123;</span><br><span class="line">    int key;</span><br><span class="line">    int degree;</span><br><span class="line">    bool mark;</span><br><span class="line">    int vertex;  //changed</span><br><span class="line">    fibonacci_heap_node* parent;</span><br><span class="line">    fibonacci_heap_node* left;</span><br><span class="line">    fibonacci_heap_node* right;</span><br><span class="line">    fibonacci_heap_node* child;</span><br><span class="line">&#125;;</span><br><span class="line">struct fibonacci_heap_head &#123;</span><br><span class="line">    fibonacci_heap_node* min;</span><br><span class="line">    int n;</span><br><span class="line">    fibonacci_heap_head() &#123;</span><br><span class="line">        n = 0;</span><br><span class="line">        min = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//同样约定，结点从1开始编号</span><br><span class="line">struct edge &#123;</span><br><span class="line">    int vertex;</span><br><span class="line">    int key;</span><br><span class="line">    edge* next;</span><br><span class="line">    edge(int v, int k, edge* e = NULL) &#123;</span><br><span class="line">        vertex = v;</span><br><span class="line">        key = k;</span><br><span class="line">        next = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void matrix_to_mapchain(int** matrix, edge** E, int size);</span><br><span class="line">int** get_matrix(int size);</span><br><span class="line">void format_matrix(int** matrix, int size);</span><br><span class="line">fibonacci_heap_head* make_fib_heap();</span><br><span class="line">fibonacci_heap_node* fib_heap_insert(fibonacci_heap_head* H, int k, int vertex);</span><br><span class="line">void fib_heap_insert(fibonacci_heap_head* H, fibonacci_heap_node* x);</span><br><span class="line">fibonacci_heap_head* fib_heap_union(fibonacci_heap_head* H1, fibonacci_heap_head* H2);</span><br><span class="line">fibonacci_heap_node* fib_heap_extract_min(fibonacci_heap_head* H);</span><br><span class="line">void consolidate_without_sentinel(fibonacci_heap_head* H);</span><br><span class="line">void consolidate_with_sentinel(fibonacci_heap_head* H);</span><br><span class="line">void fib_heap_link(fibonacci_heap_head* H, fibonacci_heap_node* y, fibonacci_heap_node* x);</span><br><span class="line">int fib_heap_decrease_key(fibonacci_heap_head* H, fibonacci_heap_node* x, int k);</span><br><span class="line">void cut(fibonacci_heap_head* H, fibonacci_heap_node* x, fibonacci_heap_node* y);</span><br><span class="line">void cascading_cut(fibonacci_heap_head* H, fibonacci_heap_node* y);</span><br><span class="line">fibonacci_heap_node* fib_heap_delete(fibonacci_heap_head* H, fibonacci_heap_node* x);</span><br><span class="line">void initialize(fibonacci_heap_head* H, fibonacci_heap_node** relate, int source, int size);</span><br><span class="line">void dijkstra(fibonacci_heap_head* H, edge** E, int** matrix, fibonacci_heap_node** relate, int source, int size);</span><br><span class="line">void fib_heap_print_vertex(fibonacci_heap_head* H, fibonacci_heap_node* y, int deep);</span><br><span class="line">void fib_heap_print_parent(fibonacci_heap_head* H, fibonacci_heap_node* y, int deep);</span><br><span class="line">void fib_heap_print_key(fibonacci_heap_head* H, fibonacci_heap_node* y, int deep);</span><br><span class="line">void print_mapchain(edge** E, int size);</span><br><span class="line">void print_shortest_value(fibonacci_heap_node** relate, int source, int size);</span><br><span class="line">void fib_heap_print_vertex_to_txt(fibonacci_heap_head* H, fibonacci_heap_node* y, int deep);</span><br><span class="line">//预处理函数</span><br><span class="line">void matrix_to_mapchain(int** matrix, edge** E, int size) &#123;  //并且将原来从0开始编号的矩阵转换为从1开始编号的邻接链表</span><br><span class="line">    for (int i = 0; i &lt; size + 1; i++) &#123;</span><br><span class="line">        E[i] = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; size; j++) &#123;</span><br><span class="line">            if (i != j &amp;&amp; matrix[i][j] != maximum) &#123;</span><br><span class="line">                E[i + 1] = new edge(j + 1, matrix[i][j], E[i + 1]);  //链条头插</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void format_matrix(int** matrix, int size) &#123;</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; size; j++) &#123;</span><br><span class="line">            if (i == j)</span><br><span class="line">                matrix[i][j] = 0;</span><br><span class="line">            else if (matrix[i][j] == 0)</span><br><span class="line">                matrix[i][j] = maximum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//堆操作函数</span><br><span class="line">fibonacci_heap_head* make_fib_heap() &#123;</span><br><span class="line">    return new fibonacci_heap_head();</span><br><span class="line">&#125;</span><br><span class="line">fibonacci_heap_node* fib_heap_insert(fibonacci_heap_head* H, int k, int vertex = 0) &#123;  //changed//外部只需要提供一个key值即可，其他的均不用管</span><br><span class="line">    fibonacci_heap_node* x = new fibonacci_heap_node();</span><br><span class="line">    x-&gt;key = k;</span><br><span class="line">    x-&gt;degree = 0;</span><br><span class="line">    x-&gt;parent = NULL;</span><br><span class="line">    x-&gt;child = NULL;</span><br><span class="line">    x-&gt;mark = false;</span><br><span class="line">    x-&gt;vertex = vertex;  //changed</span><br><span class="line">    if (H-&gt;min == NULL) &#123;</span><br><span class="line">        //create a root list for H containing just x(已完成)</span><br><span class="line">        x-&gt;left = x;</span><br><span class="line">        x-&gt;right = x;</span><br><span class="line">        H-&gt;min = x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //insert x into H&#x27;s root list(左插，在H-&gt;min左侧)</span><br><span class="line">        //逻辑点1</span><br><span class="line">        x-&gt;left = H-&gt;min-&gt;left;</span><br><span class="line">        x-&gt;right = H-&gt;min;</span><br><span class="line">        H-&gt;min-&gt;left-&gt;right = x;</span><br><span class="line">        H-&gt;min-&gt;left = x;</span><br><span class="line">        if (x-&gt;key &lt; H-&gt;min-&gt;key) &#123;</span><br><span class="line">            H-&gt;min = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    (H-&gt;n)++;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">void fib_heap_insert(fibonacci_heap_head* H, fibonacci_heap_node* x) &#123;  //外部需要申请节点x，并对x的key和vertex(//changed)做修改，其他的均不用管</span><br><span class="line">    x-&gt;degree = 0;</span><br><span class="line">    x-&gt;parent = NULL;</span><br><span class="line">    x-&gt;child = NULL;</span><br><span class="line">    x-&gt;mark = false;</span><br><span class="line">    if (H-&gt;min == NULL) &#123;</span><br><span class="line">        //create a root list for H containing just x(已完成)</span><br><span class="line">        x-&gt;left = x;</span><br><span class="line">        x-&gt;right = x;</span><br><span class="line">        H-&gt;min = x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //insert x into H&#x27;s root list(左插，在H-&gt;min左侧)</span><br><span class="line">        //逻辑点1</span><br><span class="line">        x-&gt;left = H-&gt;min-&gt;left;</span><br><span class="line">        x-&gt;right = H-&gt;min;</span><br><span class="line">        H-&gt;min-&gt;left-&gt;right = x;</span><br><span class="line">        H-&gt;min-&gt;left = x;</span><br><span class="line">        if (x-&gt;key &lt; H-&gt;min-&gt;key) &#123;</span><br><span class="line">            H-&gt;min = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    (H-&gt;n)++;</span><br><span class="line">&#125;</span><br><span class="line">fibonacci_heap_head* fib_heap_union(fibonacci_heap_head* H1, fibonacci_heap_head* H2) &#123;  //应用在最短路径上时，需注意结点序号vertex不可重复</span><br><span class="line">    //和算法导论上的不一样，算导上的没有显式处理H1-&gt;min为空时的情况</span><br><span class="line">    if (H1-&gt;min != NULL &amp;&amp; H2-&gt;min != NULL) &#123;</span><br><span class="line">        //逻辑点2</span><br><span class="line">        H1-&gt;min-&gt;right-&gt;left = H2-&gt;min-&gt;left;</span><br><span class="line">        H2-&gt;min-&gt;left-&gt;right = H1-&gt;min-&gt;right;</span><br><span class="line">        H1-&gt;min-&gt;right = H2-&gt;min;</span><br><span class="line">        H2-&gt;min-&gt;left = H1-&gt;min;</span><br><span class="line">        if (H1-&gt;min-&gt;key &gt; H2-&gt;min-&gt;key) &#123;</span><br><span class="line">            (H2-&gt;n) += (H1-&gt;n);</span><br><span class="line">            delete H1;</span><br><span class="line">            return H2;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            (H1-&gt;n) += (H2-&gt;n);</span><br><span class="line">            delete H2;</span><br><span class="line">            return H1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (H1-&gt;min == NULL) &#123;</span><br><span class="line">            delete H1;</span><br><span class="line">            return H2;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            delete H2;</span><br><span class="line">            return H1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fibonacci_heap_node* fib_heap_extract_min(fibonacci_heap_head* H) &#123;</span><br><span class="line">    fibonacci_heap_node* z = H-&gt;min;</span><br><span class="line">    if (z != NULL) &#123;</span><br><span class="line">        fibonacci_heap_node* c = z-&gt;child;</span><br><span class="line">        for (int i = 0; i &lt; z-&gt;degree; i++, c = c-&gt;right) &#123;  //循环条件已经确保了不会出现内存越界访问</span><br><span class="line">            c-&gt;parent = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        //逻辑点3</span><br><span class="line">        //注意和算法导论上的不一样，对于怎么处理孩子节点往根链表中插入，不同的处理方法和顺序影响到紧接着的if语句判断条件</span><br><span class="line">        //add c to the root list of H(c链条将z顶掉)</span><br><span class="line">        //remove z from the root list of H(已完成)</span><br><span class="line">        if (c != NULL &amp;&amp; z != z-&gt;right) &#123;  //revised</span><br><span class="line">            //z-&gt;left-&gt;right=c-&gt;left;//问题可能出在这儿</span><br><span class="line">            //c-&gt;left-&gt;right=z-&gt;left;</span><br><span class="line">            //z-&gt;right-&gt;left=c;</span><br><span class="line">            //c-&gt;left=z-&gt;right;</span><br><span class="line">            z-&gt;left-&gt;right = c;</span><br><span class="line">            z-&gt;right-&gt;left = c-&gt;left;</span><br><span class="line">            c-&gt;left-&gt;right = z-&gt;right;</span><br><span class="line">            c-&gt;left = z-&gt;left;</span><br><span class="line">            H-&gt;min = z-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        //特殊情况处理(revised)</span><br><span class="line">        else if (z == z-&gt;right &amp;&amp; c == NULL) &#123;  //也可以把z-&gt;child写成c</span><br><span class="line">            H-&gt;min = NULL;</span><br><span class="line">        &#125; else if (z == z-&gt;right &amp;&amp; c != NULL) &#123;</span><br><span class="line">            H-&gt;min = c;</span><br><span class="line">        &#125; else if (z != z-&gt;right &amp;&amp; c == NULL) &#123;</span><br><span class="line">            z-&gt;left-&gt;right = z-&gt;right;</span><br><span class="line">            z-&gt;right-&gt;left = z-&gt;left;</span><br><span class="line">            H-&gt;min = z-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        consolidate_with_sentinel(H);</span><br><span class="line">        //or consolidate_without_sentinel(H);</span><br><span class="line">        (H-&gt;n)--;</span><br><span class="line">    &#125;</span><br><span class="line">    return z;</span><br><span class="line">&#125;</span><br><span class="line">void consolidate_without_sentinel(fibonacci_heap_head* H) &#123;  //没有哨兵的根链表，consolidate的实现方法，和算法导论上的不一样，区别主要在for each w的遍历上和最后根链表的整理</span><br><span class="line">    if (H-&gt;min == NULL) return;</span><br><span class="line">    int size = 2 * log(H-&gt;n) / log(2) + 1;  //需验证H的最大度数的界(已验证)</span><br><span class="line">    //这里的size还是要大一些为好，因为dijkstra频繁的decrease key会造成结点的度局部堆积，从而大度结点遗留下来，在问题规模变小的时候出现内存越界访问</span><br><span class="line">    fibonacci_heap_node* A[size];</span><br><span class="line">    //也可以声明在堆中，不过实际上不需要，除非大于size一百万</span><br><span class="line">    //fibonacci_heap_node** A=new fibonacci_heap_node*[size];</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        A[i] = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    int d;</span><br><span class="line">    fibonacci_heap_node *w, *x, *y, *temp;                                                    //循环不变量w始终为正在访问的节点的下一个，也就是恰好在边界外，x,y,temp均在边界内，边界即为处理边界</span><br><span class="line">    for (w = H-&gt;min-&gt;right, A[w-&gt;left-&gt;degree] = w-&gt;left; A[w-&gt;degree] != w; w = w-&gt;right) &#123;  //最重要的是怎么实现for each node w in the root list of H(我写的神之一笔！)</span><br><span class="line">        x = w-&gt;left;</span><br><span class="line">        d = x-&gt;degree;</span><br><span class="line">        while (A[d] != NULL &amp;&amp; A[d] != x) &#123;</span><br><span class="line">            y = A[d];</span><br><span class="line">            if (x-&gt;key &gt; y-&gt;key) &#123;  //exchange x with y</span><br><span class="line">                temp = x;</span><br><span class="line">                x = y;</span><br><span class="line">                y = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            fib_heap_link(H, y, x);</span><br><span class="line">            A[d++] = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        A[d] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;  //因为没有哨兵，所以要多执行一次循环体内的代码</span><br><span class="line">        x = w-&gt;left;</span><br><span class="line">        d = x-&gt;degree;</span><br><span class="line">        while (A[d] != NULL &amp;&amp; A[d] != x) &#123;</span><br><span class="line">            y = A[d];</span><br><span class="line">            if (x-&gt;key &gt; y-&gt;key) &#123;  //exchange x with y</span><br><span class="line">                temp = x;</span><br><span class="line">                x = y;</span><br><span class="line">                y = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            fib_heap_link(H, y, x);</span><br><span class="line">            A[d++] = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        A[d] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    int i = 0;</span><br><span class="line">    fibonacci_heap_node *point, *mark;</span><br><span class="line">    while (A[i] == NULL) i++;  //利用A找到第一个根节点，之后利用fib_heap_link时维护好的根链表关系找到最小key，比书上只利用遍历A重建根链表效率高</span><br><span class="line">    for (H-&gt;min = mark = point = A[i]; point-&gt;right != mark; point = point-&gt;right) &#123;</span><br><span class="line">        if (point-&gt;key &lt; H-&gt;min-&gt;key) &#123;</span><br><span class="line">            H-&gt;min = point;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;  //同样，因为没有哨兵，要多执行一次循环体内的代码</span><br><span class="line">        if (point-&gt;key &lt; H-&gt;min-&gt;key) &#123;</span><br><span class="line">            H-&gt;min = point;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void consolidate_with_sentinel(fibonacci_heap_head* H) &#123;  //和算法导论上的不一样，区别主要在for each w的遍历上和最后根链表的整理</span><br><span class="line">    if (H-&gt;min == NULL) return;                           //revised</span><br><span class="line">    int size = log(H-&gt;n - 1) / log(2) + 2;                //需验证H的最大度数的界(已验证)(这个是最正确的紧确界！其他的包括算法导论里的都不是紧确界！修改自2018.4.24.5:14)</span><br><span class="line">    //这里的size还是要大一些为好，因为dijkstra频繁的decrease key会造成结点的度局部堆积，从而大度结点遗留下来，在问题规模变小的时候出现内存越界访问</span><br><span class="line">    fibonacci_heap_node* A[size];</span><br><span class="line">    //也可以声明在堆中，不过实际上不需要，除非大于size一百万</span><br><span class="line">    //fibonacci_heap_node** A=new fibonacci_heap_node*[size];</span><br><span class="line">    for (int i = 0; i &lt;= size; i++) &#123;</span><br><span class="line">        A[i] = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    int d;</span><br><span class="line">    fibonacci_heap_node *w, *x, *y, *temp;                           //循环不变量w始终为正在访问的节点的下一个，也就是恰好在边界外，x,y,temp均在边界内，边界即为处理边界</span><br><span class="line">    fibonacci_heap_node* sentinel = fib_heap_insert(H, maximum, 0);  //在H-&gt;min左侧插入哨兵用于之后的循环</span><br><span class="line">    //恰好循环是从H-&gt;min开始向右访问，所以sentinel的位置恰好是循环的最后一次，并且不参与进循环体中，也不会进入处理边界内</span><br><span class="line">    for (w = H-&gt;min-&gt;right, A[w-&gt;left-&gt;degree] = w-&gt;left; A[w-&gt;degree] != w; w = w-&gt;right) &#123;  //最重要的是怎么实现for each node w in the root list of H(我写的神之一笔！)</span><br><span class="line">        x = w-&gt;left;</span><br><span class="line">        d = x-&gt;degree;</span><br><span class="line">        while (A[d] != NULL &amp;&amp; A[d] != x) &#123;</span><br><span class="line">            y = A[d];</span><br><span class="line">            if (x-&gt;key &gt; y-&gt;key) &#123;  //exchange x with y</span><br><span class="line">                temp = x;</span><br><span class="line">                x = y;</span><br><span class="line">                y = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            fib_heap_link(H, y, x);</span><br><span class="line">            A[d++] = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        A[d] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    fibonacci_heap_node *point, *mark;</span><br><span class="line">    for (H-&gt;min = mark = point = sentinel-&gt;right; point-&gt;right != mark; point = point-&gt;right) &#123;  //利用sentinel找到根链表，直接开始遍历，和算法导论上的不同</span><br><span class="line">        if (point-&gt;key &lt; H-&gt;min-&gt;key) &#123;</span><br><span class="line">            H-&gt;min = point;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //删掉哨兵sentinel</span><br><span class="line">    sentinel-&gt;right-&gt;left = sentinel-&gt;left;</span><br><span class="line">    sentinel-&gt;left-&gt;right = sentinel-&gt;right;</span><br><span class="line">    (H-&gt;n)--;</span><br><span class="line">    delete sentinel;</span><br><span class="line">&#125;</span><br><span class="line">void fib_heap_link(fibonacci_heap_head* H, fibonacci_heap_node* y, fibonacci_heap_node* x) &#123;  //内部非递归简单函数其实可以直接写在父函数中，减少函数调用开销</span><br><span class="line">    //remove y from the root(any) list of H(y isn&#x27;t H.min)//changed</span><br><span class="line">    if (y-&gt;right != y) &#123;  //y isn&#x27;t single</span><br><span class="line">        y-&gt;right-&gt;left = y-&gt;left;</span><br><span class="line">        y-&gt;left-&gt;right = y-&gt;right;</span><br><span class="line">        if (y-&gt;parent != NULL) &#123;</span><br><span class="line">            if (y-&gt;parent-&gt;child == y) &#123;</span><br><span class="line">                y-&gt;parent-&gt;child = y-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            y-&gt;parent-&gt;degree--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;  //y is single(y must not in root)</span><br><span class="line">        y-&gt;parent-&gt;child = NULL;</span><br><span class="line">        y-&gt;parent-&gt;degree--;</span><br><span class="line">    &#125;</span><br><span class="line">    //make y a child of x,incrementing x-&gt;degree</span><br><span class="line">    if (x-&gt;child == NULL) &#123;</span><br><span class="line">        x-&gt;child = y;</span><br><span class="line">        y-&gt;left = y;</span><br><span class="line">        y-&gt;right = y;</span><br><span class="line">        y-&gt;parent = x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //逻辑点</span><br><span class="line">        y-&gt;left = x-&gt;child-&gt;left;</span><br><span class="line">        y-&gt;right = x-&gt;child;</span><br><span class="line">        x-&gt;child-&gt;left-&gt;right = y;</span><br><span class="line">        x-&gt;child-&gt;left = y;</span><br><span class="line">        y-&gt;parent = x;</span><br><span class="line">    &#125;</span><br><span class="line">    (x-&gt;degree)++;</span><br><span class="line">    y-&gt;mark = false;</span><br><span class="line">&#125;</span><br><span class="line">int fib_heap_decrease_key(fibonacci_heap_head* H, fibonacci_heap_node* x, int k) &#123;</span><br><span class="line">    if (k &lt; x-&gt;key) &#123;</span><br><span class="line">        x-&gt;key = k;</span><br><span class="line">        fibonacci_heap_node* y = x-&gt;parent;</span><br><span class="line">        if (y != NULL &amp;&amp; x-&gt;key &lt; y-&gt;key) &#123;</span><br><span class="line">            cut(H, x, y);</span><br><span class="line">            cascading_cut(H, y);</span><br><span class="line">        &#125;</span><br><span class="line">        if (x-&gt;key &lt; H-&gt;min-&gt;key) &#123;</span><br><span class="line">            H-&gt;min = x;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else</span><br><span class="line">        return -1;</span><br><span class="line">&#125;</span><br><span class="line">void cut(fibonacci_heap_head* H, fibonacci_heap_node* x, fibonacci_heap_node* y) &#123;  //切断，从属于fib_heap_decrease_key</span><br><span class="line">    //remove x from the child list of y,decrementing y-&gt;degree</span><br><span class="line">    if (x-&gt;right == x) &#123;  //remove</span><br><span class="line">        y-&gt;child = NULL;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        x-&gt;right-&gt;left = x-&gt;left;</span><br><span class="line">        x-&gt;left-&gt;right = x-&gt;right;</span><br><span class="line">        if (y-&gt;child == x) &#123;  //revised</span><br><span class="line">            y-&gt;child = x-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;degree--;</span><br><span class="line">    //add x to the root list of H(左插)</span><br><span class="line">    //逻辑点(有错误)(revised)</span><br><span class="line">    x-&gt;left = H-&gt;min-&gt;left;</span><br><span class="line">    x-&gt;right = H-&gt;min;</span><br><span class="line">    H-&gt;min-&gt;left-&gt;right = x;</span><br><span class="line">    H-&gt;min-&gt;left = x;</span><br><span class="line">    x-&gt;parent = NULL;</span><br><span class="line">    x-&gt;mark = false;</span><br><span class="line">&#125;</span><br><span class="line">void cascading_cut(fibonacci_heap_head* H, fibonacci_heap_node* y) &#123;  //级联切断，从属于fib_heap_decrease_key</span><br><span class="line">    fibonacci_heap_node* z = y-&gt;parent;</span><br><span class="line">    if (z != NULL) &#123;</span><br><span class="line">        if (y-&gt;mark == false) &#123;</span><br><span class="line">            y-&gt;mark = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cut(H, y, z);</span><br><span class="line">            cascading_cut(H, z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fibonacci_heap_node* fib_heap_delete(fibonacci_heap_head* H, fibonacci_heap_node* x) &#123;  //删除结点，不是单纯的删掉，用到decrease key和extract min联合操作</span><br><span class="line">    fib_heap_decrease_key(H, x, minimum);</span><br><span class="line">    return fib_heap_extract_min(H);</span><br><span class="line">&#125;</span><br><span class="line">//主算法函数</span><br><span class="line">void initialize(fibonacci_heap_head* H, fibonacci_heap_node** relate, int source, int size) &#123;  //建堆，relate数据关联</span><br><span class="line">    for (int i = 1; i &lt;= size; i++) &#123;</span><br><span class="line">        relate[i] = fib_heap_insert(H, maximum, i);  //在fibonacci堆实现的最小优先队列中，relate一旦设置好，就不用再更改</span><br><span class="line">    &#125;</span><br><span class="line">    fib_heap_decrease_key(H, relate[source], 0);</span><br><span class="line">&#125;</span><br><span class="line">void dijkstra(fibonacci_heap_head* H, edge** E, int** matrix, fibonacci_heap_node** relate, int source, int size) &#123;</span><br><span class="line">    initialize(H, relate, source, size);</span><br><span class="line">    fibonacci_heap_node* min;</span><br><span class="line">    edge* temp;</span><br><span class="line">    int re;</span><br><span class="line">    while (H-&gt;n &gt; 0) &#123;</span><br><span class="line">        min = fib_heap_extract_min(H);</span><br><span class="line">        for (temp = E[min-&gt;vertex]; temp != NULL; temp = temp-&gt;next) &#123;</span><br><span class="line">            re = fib_heap_decrease_key(H, relate[temp-&gt;vertex], relate[min-&gt;vertex]-&gt;key + matrix[min-&gt;vertex - 1][temp-&gt;vertex - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//额外显示函数</span><br><span class="line">void fib_heap_print_vertex(fibonacci_heap_head* H, fibonacci_heap_node* y = NULL, int deep = 1) &#123;  //右向遍历斐波那契堆，并递归输出，输出格式（下兄弟，右孩子）</span><br><span class="line">    static bool mark = false;</span><br><span class="line">    if (y != NULL) &#123;</span><br><span class="line">        if (deep == 1) &#123;</span><br><span class="line">            fibonacci_heap_node* x = H-&gt;min;</span><br><span class="line">            for (; x != H-&gt;min-&gt;left; x = x-&gt;right) &#123;</span><br><span class="line">                printf(&quot;%-7d &quot;, x-&gt;vertex);</span><br><span class="line">                mark = false;</span><br><span class="line">                fib_heap_print_vertex(H, x-&gt;child, deep + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;%-7d &quot;, x-&gt;vertex);</span><br><span class="line">                mark = false;</span><br><span class="line">                fib_heap_print_vertex(H, x-&gt;child, deep + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt; y-&gt;parent-&gt;degree; i++, y = y-&gt;right) &#123;</span><br><span class="line">                if (i != 0) &#123;</span><br><span class="line">                    for (int j = 1; j &lt; deep; j++) &#123;</span><br><span class="line">                        cout &lt;&lt; &quot;        &quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                printf(&quot;%-7d &quot;, y-&gt;vertex);</span><br><span class="line">                mark = false;</span><br><span class="line">                fib_heap_print_vertex(H, y-&gt;child, deep + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mark == false) &#123;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        mark = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void fib_heap_print_parent(fibonacci_heap_head* H, fibonacci_heap_node* y, int deep = 1) &#123;</span><br><span class="line">    static bool mark = false;</span><br><span class="line">    if (y != NULL) &#123;</span><br><span class="line">        if (deep == 1) &#123;</span><br><span class="line">            fibonacci_heap_node* x = H-&gt;min;</span><br><span class="line">            for (; x != H-&gt;min-&gt;left; x = x-&gt;right) &#123;</span><br><span class="line">                if (x-&gt;parent != NULL) &#123;</span><br><span class="line">                    cout &lt;&lt; x-&gt;parent &lt;&lt; &quot;  &quot;;</span><br><span class="line">                    mark = false;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cout &lt;&lt; x-&gt;parent &lt;&lt; &quot;          &quot;;</span><br><span class="line">                    mark = false;</span><br><span class="line">                &#125;</span><br><span class="line">                fib_heap_print_parent(H, x-&gt;child, deep + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            &#123;</span><br><span class="line">                if (x-&gt;parent != NULL) &#123;</span><br><span class="line">                    cout &lt;&lt; x-&gt;parent &lt;&lt; &quot;  &quot;;</span><br><span class="line">                    mark = false;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cout &lt;&lt; x-&gt;parent &lt;&lt; &quot;          &quot;;</span><br><span class="line">                    mark = false;</span><br><span class="line">                &#125;</span><br><span class="line">                fib_heap_print_parent(H, x-&gt;child, deep + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt; y-&gt;parent-&gt;degree; i++, y = y-&gt;right) &#123;</span><br><span class="line">                if (i != 0) &#123;</span><br><span class="line">                    for (int j = 1; j &lt; deep; j++) &#123;</span><br><span class="line">                        cout &lt;&lt; &quot;           &quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (y-&gt;parent != NULL) &#123;</span><br><span class="line">                    cout &lt;&lt; y-&gt;parent &lt;&lt; &quot;  &quot;;</span><br><span class="line">                    mark = false;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    cout &lt;&lt; y-&gt;parent &lt;&lt; &quot;          &quot;;</span><br><span class="line">                    mark = false;</span><br><span class="line">                &#125;</span><br><span class="line">                fib_heap_print_parent(H, y-&gt;child, deep + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mark == false) &#123;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        mark = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void fib_heap_print_key(fibonacci_heap_head* H, fibonacci_heap_node* y, int deep = 1) &#123;</span><br><span class="line">    static bool mark = false;</span><br><span class="line">    if (y != NULL) &#123;</span><br><span class="line">        if (deep == 1) &#123;</span><br><span class="line">            fibonacci_heap_node* x = H-&gt;min;</span><br><span class="line">            for (; x != H-&gt;min-&gt;left; x = x-&gt;right) &#123;</span><br><span class="line">                printf(&quot;%e  &quot;, x-&gt;key);</span><br><span class="line">                mark = false;</span><br><span class="line">                fib_heap_print_key(H, x-&gt;child, deep + 1);</span><br><span class="line">            &#125;</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;%e  &quot;, x-&gt;key);</span><br><span class="line">                mark = false;</span><br><span class="line">                fib_heap_print_key(H, x-&gt;child, deep + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt; y-&gt;parent-&gt;degree; i++, y = y-&gt;right) &#123;</span><br><span class="line">                if (i != 0) &#123;</span><br><span class="line">                    for (int j = 1; j &lt; deep; j++) &#123;</span><br><span class="line">                        cout &lt;&lt; &quot;               &quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                printf(&quot;%e  &quot;, y-&gt;key);</span><br><span class="line">                mark = false;</span><br><span class="line">                fib_heap_print_key(H, y-&gt;child, deep + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mark == false) &#123;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        mark = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void print_mapchain(edge** E, int size) &#123;</span><br><span class="line">    for (int i = 0; i &lt; size + 1; i++) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; &quot; --&gt; &quot;;</span><br><span class="line">        for (edge* temp = E[i]; temp != NULL; temp = temp-&gt;next) &#123;</span><br><span class="line">            cout &lt;&lt; temp-&gt;vertex &lt;&lt; &quot;-&quot; &lt;&lt; temp-&gt;key &lt;&lt; &quot; --&gt; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void print_shortest_value(fibonacci_heap_node** relate, int source, int size) &#123;</span><br><span class="line">        // for (int i = 1; i &lt;= size; i++) &#123;</span><br><span class="line">        //     cout &lt;&lt; source &lt;&lt; &quot;-&gt;&quot; &lt;&lt; i &lt;&lt; &quot;:&quot; &lt;&lt; relate[i]-&gt;key &lt;&lt; endl;</span><br><span class="line">        // &#125;</span><br><span class="line">    if(relate[size]-&gt;key &gt; 1e4)cout &lt;&lt; -1  &lt;&lt; endl;</span><br><span class="line">    else cout &lt;&lt; relate[size]-&gt;key &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    clock_t first, finish;</span><br><span class="line">    int size, source= 1,m;</span><br><span class="line">    cin &gt;&gt; size;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    //int A[size+1];//存最后结果，其实没用，因为可以从relate中得到</span><br><span class="line">    //int Atorelate[size+1];//其实没用，可以用A的i值来代表结点编号，只不过用Atorelate增强了鲁棒性而已</span><br><span class="line">    fibonacci_heap_node* relate[size + 1];  //下标对应图中结点号，如果结点冲突（出现在union时），可以直接用Atorelate来代替下标存储结点号</span><br><span class="line">    edge** E = new edge*[size + 1];</span><br><span class="line">    //int** matrix = get_matrix(size);</span><br><span class="line">    int** matrix = new int*[size];</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        matrix[i] = new int[size];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; size; j++) &#123;</span><br><span class="line">            matrix[i][j] = 100000;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0; i &lt; m; ++ i)&#123;</span><br><span class="line">        int x,y,z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line"></span><br><span class="line">        matrix[x - 1][y - 1] = min((int)matrix[x - 1][y - 1],z);</span><br><span class="line">       // matrix[y - 1][x - 1] = z;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    format_matrix(matrix, size);</span><br><span class="line">    matrix_to_mapchain(matrix, E, size);</span><br><span class="line">    fibonacci_heap_head* H = make_fib_heap();</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    first=clock();</span><br><span class="line">    dijkstra(H,E,matrix,relate,source,size);</span><br><span class="line">    //print_shortest_value(relate,source,size);</span><br><span class="line">    finish=clock();</span><br><span class="line">    cout&lt;&lt;&quot;use time&quot;&lt;&lt;finish-first&lt;&lt;&quot;ms&quot;&lt;&lt;endl;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    initialize(H,relate,source,size);</span><br><span class="line">    fib_heap_print_vertex(H,H-&gt;min);</span><br><span class="line">    cout&lt;&lt;&quot;----------------------------------------&quot;&lt;&lt;endl;</span><br><span class="line">    consolidate_with_sentinel(H);</span><br><span class="line">    freopen(output,&quot;a+&quot;,stdout);//输出重定向</span><br><span class="line">    fib_heap_print_vertex(H,H-&gt;min);</span><br><span class="line">    freopen(&quot;CON&quot;,&quot;w&quot;,stdout);//定向回来</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">    //print_mapchain(E,size);</span><br><span class="line">    // cout &lt;&lt; endl;</span><br><span class="line">    initialize(H, relate, source, size);</span><br><span class="line">    // fib_heap_print_vertex(H, H-&gt;min);</span><br><span class="line">    //  cout &lt;&lt; &quot;--------------------------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    // fib_heap_decrease_key(H,relate[6],-8);</span><br><span class="line">    // fib_heap_print(H);</span><br><span class="line"></span><br><span class="line">    fibonacci_heap_node* min;</span><br><span class="line">    edge* temp;</span><br><span class="line">    int re;</span><br><span class="line">    while (H-&gt;n &gt; 0) &#123;</span><br><span class="line">        min = fib_heap_extract_min(H);</span><br><span class="line">        for (temp = E[min-&gt;vertex]; temp != NULL; temp = temp-&gt;next) &#123;</span><br><span class="line">            re = fib_heap_decrease_key(H, relate[temp-&gt;vertex], relate[min-&gt;vertex]-&gt;key + matrix[min-&gt;vertex - 1][temp-&gt;vertex - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        //cout&lt;&lt;&quot;--------------------------------&quot;&lt;&lt;endl;</span><br><span class="line">        //fib_heap_print_vertex(H,H-&gt;min);</span><br><span class="line">        //cout&lt;&lt;&quot;--------------------------------&quot;&lt;&lt;endl;</span><br><span class="line">        //fib_heap_print_parent(H,H-&gt;min);</span><br><span class="line">        //cout&lt;&lt;&quot;--------------------------------&quot;&lt;&lt;endl;</span><br><span class="line">        //fib_heap_print_key(H,H-&gt;min);</span><br><span class="line">    &#125;</span><br><span class="line">    print_shortest_value(relate, source, size);</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>混元模型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;climits&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int, int&gt; pii; // &#123;distance, node&#125;</span><br><span class="line"></span><br><span class="line">int dijkstra(int n, vector&lt;vector&lt;pii&gt;&gt;&amp; graph) &#123;</span><br><span class="line">    vector&lt;int&gt; dist(n + 1, INT_MAX); // 初始化距离为无穷大</span><br><span class="line">    dist[1] = 0; // 起点到自身的距离为0</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq; // 小根堆，按距离排序</span><br><span class="line">    pq.push(&#123;0, 1&#125;); // 将起点加入堆</span><br><span class="line"></span><br><span class="line">    while (!pq.empty()) &#123;</span><br><span class="line">        int u = pq.top().second; // 当前节点</span><br><span class="line">        int d = pq.top().first;  // 当前距离</span><br><span class="line">        pq.pop();</span><br><span class="line"></span><br><span class="line">        if (d &gt; dist[u]) continue; // 如果当前距离大于已知距离，跳过</span><br><span class="line"></span><br><span class="line">        for (auto&amp; edge : graph[u]) &#123;</span><br><span class="line">            int v = edge.first;  // 邻接节点</span><br><span class="line">            int w = edge.second; // 边权</span><br><span class="line"></span><br><span class="line">            if (dist[u] + w &lt; dist[v]) &#123; // 松弛操作</span><br><span class="line">                dist[v] = dist[u] + w;</span><br><span class="line">                pq.push(&#123;dist[v], v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dist[n] == INT_MAX ? -1 : dist[n]; // 如果无法到达，返回-1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;pii&gt;&gt; graph(n + 1); // 图的邻接表表示</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        int x, y, z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        graph[x].push_back(&#123;y, z&#125;); // 添加有向边</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int result = dijkstra(n, graph);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-850.-dijkstra求最短路-ⅱ">AcWing 850. Dijkstra求最短路
Ⅱ</h3>
<blockquote>
<p><strong>模板参数的含义</strong></p>
<p><code>priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;&gt;&gt;</code>
中，模板参数的含义如下：</p>
<ul>
<li><strong><code>PII</code></strong>：这是优先队列中存储的元素类型。<code>PII</code>
是 <code>typedef pair&lt;int, int&gt;</code>
的别名，表示存储的元素是一个 <code>pair&lt;int, int&gt;</code>。
<ul>
<li>在这里，<code>pair&lt;int, int&gt;</code>
的第一个元素（<code>first</code>）表示<strong>距离</strong>，第二个元素（<code>second</code>）表示<strong>节点编号</strong>。</li>
<li>例如：<code>&#123;5, 3&#125;</code> 表示节点 3 到起点的距离为 5。</li>
</ul></li>
<li><strong><code>vector&lt;PII&gt;</code></strong>：这是优先队列的底层容器类型。<code>priority_queue</code>
默认使用 <code>vector</code> 作为底层容器来存储元素。</li>
<li><strong><code>greater&lt;&gt;</code></strong>：这是一个比较函数对象，用于定义优先队列中元素的优先级规则。
<ul>
<li>默认情况下，<code>priority_queue</code> 使用
<code>less&lt;&gt;</code>，即大根堆（最大值优先）。</li>
<li>这里使用
<code>greater&lt;&gt;</code>，表示<strong>小根堆</strong>，即最小值优先。</li>
<li>对于 <code>pair&lt;int, int&gt;</code>，<code>greater&lt;&gt;</code>
会按照 <code>pair</code>
的第一个元素（<code>first</code>，即距离）进行比较，距离较小的元素优先级更高。</li>
</ul></li>
</ul>
<p><strong><code>gra</code> 的作用</strong></p>
<p><code>gra</code> 用于表示 <strong>图的邻接表</strong>：</p>
<ul>
<li>图的邻接表是一种存储图的方式，其中每个节点对应一个列表，列表中存储该节点的所有邻接节点及其边的权重。</li>
<li><code>gra[i]</code>表示节点<code>i</code>的邻接表，是一个<code>vector&lt;pair&lt;int, int&gt;&gt;</code>。
<ul>
<li><code>gra[i][j].first</code> 是节点 <code>i</code> 的第
<code>j</code> 个邻接节点的编号。</li>
<li><code>gra[i][j].second</code> 是节点 <code>i</code>
到该邻接节点的边的权重。</li>
</ul></li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int, int&gt; PII;  // 定义PII为pair&lt;int, int&gt;，用于存储距离和节点编号</span><br><span class="line"></span><br><span class="line">const int N = 100010;  // 定义最大节点数</span><br><span class="line">vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; gra;  // 图的邻接表表示，gra[i]存储节点i的所有邻接节点及其边的权重</span><br><span class="line">int dist[N];  // dist[i]表示从起点到节点i的最短距离</span><br><span class="line">bool st[N];  // st[i]表示节点i是否已经被处理过</span><br><span class="line">int n, m;  // n表示节点数，m表示边数</span><br><span class="line">int a, b, c;  // 用于临时存储边的起点、终点和权重</span><br><span class="line"></span><br><span class="line">// Dijkstra算法实现，返回从节点1到节点n的最短路径长度，若不可达则返回-1</span><br><span class="line">int dijkstra() &#123;</span><br><span class="line">    dist[1] = 0;  // 起点到自身的距离为0</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;&gt;&gt; heap;  // 小根堆，用于存储待处理的节点及其距离</span><br><span class="line">    heap.emplace(0, 1);  // 将起点加入堆中</span><br><span class="line"></span><br><span class="line">    while (!heap.empty()) &#123;</span><br><span class="line">        auto t = heap.top();  // 取出堆顶元素，即当前距离起点最近的节点</span><br><span class="line">        heap.pop();</span><br><span class="line">        int node = t.second;  // 当前节点的编号</span><br><span class="line">        int distance = t.first;  // 当前节点到起点的距离</span><br><span class="line"></span><br><span class="line">        if (st[node]) continue;  // 如果该节点已经被处理过，则跳过</span><br><span class="line">        st[node] = true;  // 标记该节点为已处理</span><br><span class="line"></span><br><span class="line">        // 遍历当前节点的所有邻接节点</span><br><span class="line">        for (int i = 0; i &lt; gra[node].size(); ++i) &#123;</span><br><span class="line">            int newnode = gra[node][i].first;  // 邻接节点的编号</span><br><span class="line">            int len = gra[node][i].second;  // 当前节点到邻接节点的边的权重</span><br><span class="line"></span><br><span class="line">            // 如果通过当前节点到达邻接节点的距离比已知的最短距离更短，则更新最短距离</span><br><span class="line">            if (dist[newnode] &gt; dist[node] + len) &#123;</span><br><span class="line">                dist[newnode] = dist[node] + len;</span><br><span class="line">                heap.push(&#123;dist[newnode], newnode&#125;);  // 将更新后的邻接节点加入堆中</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果终点n的最短距离仍为初始值0x3f3f3f3f，说明不可达，返回-1</span><br><span class="line">    if (dist[n] == 0x3f3f3f3f)</span><br><span class="line">        return -1;</span><br><span class="line">    return dist[n];  // 返回终点n的最短距离</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    memset(dist, 0x3f, sizeof dist);  // 初始化所有节点的最短距离为无穷大</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  // 输入节点数和边数</span><br><span class="line">    gra.resize(n + 1);  // 调整邻接表的大小为n+1</span><br><span class="line"></span><br><span class="line">    // 输入每条边的信息，并构建邻接表</span><br><span class="line">    while (m--) &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        gra[a].emplace_back(b, c);  // 将边加入邻接表</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 调用Dijkstra算法并输出结果</span><br><span class="line">    cout &lt;&lt; dijkstra() &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-853.-有边数限制的最短路">AcWing 853.
有边数限制的最短路</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 510;  // 最大节点数</span><br><span class="line">const int M = 100010;  // 最大边数</span><br><span class="line"></span><br><span class="line">// 定义边的结构体，x 是起点，y 是终点，z 是边的权重</span><br><span class="line">struct edge &#123;</span><br><span class="line">    int x, y, z;</span><br><span class="line">&#125; e[M];</span><br><span class="line"></span><br><span class="line">int dist[N];  // dist[i] 表示从起点到节点 i 的最短距离</span><br><span class="line">int back[N];  // back[i] 用于保存上一次迭代的 dist[i]，防止更新时的干扰</span><br><span class="line">int n, m, k;  // n 是节点数，m 是边数，k 是最多允许的松弛次数</span><br><span class="line">int a, b, c;  // 用于临时存储边的起点、终点和权重</span><br><span class="line"></span><br><span class="line">// Bellman-Ford 算法的实现</span><br><span class="line">int solve() &#123;</span><br><span class="line">    dist[1] = 0;  // 起点到自身的距离为 0</span><br><span class="line">    for (int i = 0; i &lt; k; ++i) &#123;  // 最多进行 k 次松弛操作</span><br><span class="line">        memcpy(back, dist, sizeof dist);  // 将当前的 dist 数组复制到 back 中，避免更新时的干扰</span><br><span class="line">        for (int j = 1; j &lt;= m; ++j) &#123;  // 遍历所有边</span><br><span class="line">            int x = e[j].x;  // 边的起点</span><br><span class="line">            int y = e[j].y;  // 边的终点</span><br><span class="line">            int z = e[j].z;  // 边的权重</span><br><span class="line">            dist[y] = min(dist[y], back[x] + z);  // 松弛操作：更新终点 y 的最短距离</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;  // 输入节点数、边数和最多允许的松弛次数</span><br><span class="line">    memset(dist, 0x3f, sizeof dist);  // 初始化所有节点的最短距离为无穷大</span><br><span class="line">    for (int i = 1; i &lt;= m; ++i) &#123;  // 输入每条边的信息</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        e[i] = &#123;a, b, c&#125;;  // 将边存入数组 e 中</span><br><span class="line">    &#125;</span><br><span class="line">    solve();  // 调用 Bellman-Ford 算法求解最短路径</span><br><span class="line">    if (dist[n] &gt; m * 10000)  // 如果终点 n 的最短距离仍然很大，说明不可达</span><br><span class="line">        cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;</span><br><span class="line">    else  // 否则输出最短距离</span><br><span class="line">        cout &lt;&lt; dist[n] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-851.-spfa求最短路">AcWing 851. spfa求最短路</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e5 + 10;  // 最大节点数</span><br><span class="line">const int M = 1e5 + 10;  // 最大边数</span><br><span class="line"></span><br><span class="line">int n, m;  // n 是节点数，m 是边数</span><br><span class="line">int h[N], e[M], ne[M], w[M], idx;  // 邻接表存储图</span><br><span class="line">int dist[N];  // dist[i] 表示从起点到节点 i 的最短距离</span><br><span class="line">bool st[N];  // st[i] 表示节点 i 是否在队列中</span><br><span class="line">queue&lt;int&gt; q;  // 用于 SPFA 算法的队列</span><br><span class="line"></span><br><span class="line">// 添加一条边 a -&gt; b，权重为 c</span><br><span class="line">void add(int a, int b, int c) &#123;</span><br><span class="line">    e[idx] = b;      // 存储边的终点</span><br><span class="line">    ne[idx] = h[a];  // 存储下一条边的索引</span><br><span class="line">    w[idx] = c;      // 存储边的权重</span><br><span class="line">    h[a] = idx++;    // 更新节点 a 的第一条边的索引</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// SPFA 算法的实现</span><br><span class="line">void spfa() &#123;</span><br><span class="line">    memset(dist, 0x3f, sizeof dist);  // 初始化所有节点的最短距离为无穷大</span><br><span class="line">    dist[1] = 0;  // 起点到自身的距离为 0</span><br><span class="line">    q.push(1);    // 将起点加入队列</span><br><span class="line">    st[1] = true; // 标记起点在队列中</span><br><span class="line"></span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        auto front = q.front();  // 取出队首节点</span><br><span class="line">        q.pop();</span><br><span class="line">        st[front] = false;  // 标记该节点不在队列中</span><br><span class="line"></span><br><span class="line">        // 遍历该节点的所有邻接边</span><br><span class="line">        for (int i = h[front]; i != -1; i = ne[i]) &#123;</span><br><span class="line">            int node = e[i], weight = w[i];  // 邻接节点和边的权重</span><br><span class="line"></span><br><span class="line">            // 如果通过当前节点可以缩短邻接节点的距离，则更新距离</span><br><span class="line">            if (dist[node] &gt; dist[front] + weight) &#123;</span><br><span class="line">                dist[node] = dist[front] + weight;</span><br><span class="line"></span><br><span class="line">                // 如果邻接节点不在队列中，则将其加入队列</span><br><span class="line">                if (!st[node]) &#123;</span><br><span class="line">                    q.push(node);</span><br><span class="line">                    st[node] = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果终点 n 的最短距离仍大于 0x3f3f3f3f / 2，说明不可达</span><br><span class="line">    if (dist[n] &gt; 0x3f3f3f3f / 2) cout &lt;&lt; &quot;impossible&quot;;</span><br><span class="line">    else cout &lt;&lt; dist[n];  // 否则输出最短距离</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;  // 输入节点数和边数</span><br><span class="line">    memset(h, -1, sizeof h);  // 初始化邻接表，所有节点的第一条边索引为 -1</span><br><span class="line">    while (m--) &#123;</span><br><span class="line">        int x, y, z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;  // 输入边的起点、终点和权重</span><br><span class="line">        add(x, y, z);        // 将边加入邻接表</span><br><span class="line">    &#125;</span><br><span class="line">    spfa();  // 调用 SPFA 算法求解最短路径</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="acwing-852.-spfa判断负环">AcWing 852. spfa判断负环</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;  // 包含标准库头文件</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 2010, M = 10010;  // N为最大节点数，M为最大边数</span><br><span class="line"></span><br><span class="line">struct Edge &#123;  // 边的结构体，存储起点、终点和权重</span><br><span class="line">    int a, b, w;</span><br><span class="line">&#125; edges[M];</span><br><span class="line"></span><br><span class="line">int n, m;       // n为节点数，m为边数</span><br><span class="line">int dist[N]=&#123;&#125;; // 距离数组，初始化为0（用于检测是否存在负环，而非求最短路）</span><br><span class="line">bool updated;   // 标记是否在本次迭代中更新了距离</span><br><span class="line"></span><br><span class="line">// Bellman-Ford算法变种：检测图中是否存在负权回路</span><br><span class="line">// 返回true表示存在负环，false表示不存在</span><br><span class="line">bool bellmanFord() &#123;</span><br><span class="line">    // 进行n次松弛操作，正常情况下n-1次即可确定最短路，第n次用于检测负环</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        updated = false;</span><br><span class="line">        // 遍历所有边，尝试松弛操作</span><br><span class="line">        for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class="line">            int a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">            // 如果通过当前边能使b的距离缩短，则更新</span><br><span class="line">            if (dist[b] &gt; dist[a] + w) &#123;</span><br><span class="line">                dist[b] = dist[a] + w;</span><br><span class="line">                updated = true;</span><br><span class="line">                // 若在第n次迭代仍能更新，说明存在负环</span><br><span class="line">                if (i == n - 1) </span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 若本轮未更新，提前退出循环</span><br><span class="line">        if (!updated) </span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;  // 所有迭代完成未发现负环</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    // 读取所有边信息</span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        int a, b, w;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;</span><br><span class="line">        edges[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    // 调用算法并输出结果</span><br><span class="line">    if (bellmanFord()) </span><br><span class="line">        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;  // 存在负环</span><br><span class="line">    else </span><br><span class="line">        cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;   // 不存在负环</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-854.-floyd求最短路">AcWing 854. Floyd求最短路</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;  // 包含常用的头文件</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 210;  // 定义最大节点数</span><br><span class="line">int n, m, k;        // n: 节点数, m: 边数, k: 查询次数</span><br><span class="line">int x, y, z;        // x, y: 边的两个节点, z: 边的权重</span><br><span class="line">int d[N][N];        // d[i][j] 表示节点 i 到节点 j 的最短距离</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;  // 输入节点数、边数和查询次数</span><br><span class="line"></span><br><span class="line">    // 初始化距离矩阵，初始值为无穷大（0x3f3f3f3f）</span><br><span class="line">    memset(d, 0x3f, sizeof d);</span><br><span class="line"></span><br><span class="line">    // 对角线上的距离初始化为0，即节点到自身的距离为0</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= n; ++j) &#123;</span><br><span class="line">            if (i == j)</span><br><span class="line">                d[i][j] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 输入边的信息，并更新距离矩阵</span><br><span class="line">    while (m--) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        d[x][y] = min(d[x][y], z);  // 如果有重边，取最小的权重</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Floyd-Warshall算法，计算所有节点对之间的最短路径</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= n; ++j) &#123;</span><br><span class="line">            for (int l = 1; l &lt;= n; ++l) &#123;</span><br><span class="line">                // 如果通过节点 i 使得 j 到 l 的路径更短，则更新 d[j][l]</span><br><span class="line">                d[j][l] = min(d[j][l], d[j][i] + d[i][l]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理查询，输出最短路径或 &quot;impossible&quot;</span><br><span class="line">    while (k--) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        if (d[x][y] &gt; n * 10000)  // 如果距离仍然为初始值，说明不可达</span><br><span class="line">            cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; d[x][y] &lt;&lt; endl;  // 输出最短路径</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-858.-prim算法求最小生成树">AcWing 858.
Prim算法求最小生成树</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 510;  // 定义最大节点数</span><br><span class="line"></span><br><span class="line">int n, m;           // n: 节点数, m: 边数</span><br><span class="line">int u, v, w;        // u, v: 边的两个节点, w: 边的权重</span><br><span class="line">int g[N][N];        // g[i][j] 表示节点 i 到节点 j 的边的权重</span><br><span class="line">int d[N];           // d[i] 表示节点 i 到当前最小生成树的最小距离</span><br><span class="line">int res;            // 存储最小生成树的总权重</span><br><span class="line">bool st[N];         // st[i] 表示节点 i 是否已经加入最小生成树</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 初始化邻接矩阵和距离数组，初始值为无穷大（0x3f3f3f3f）</span><br><span class="line">    memset(g, 0x3f, sizeof g);</span><br><span class="line">    memset(d, 0x3f, sizeof d);</span><br><span class="line"></span><br><span class="line">    // 输入节点数和边数</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    // 输入边的信息，并更新邻接矩阵</span><br><span class="line">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        g[u][v] = g[v][u] = min(g[u][v], w);  // 无向图，取最小权重</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从节点 1 开始构建最小生成树</span><br><span class="line">    d[1] = 0;  // 节点 1 到最小生成树的距离为 0</span><br><span class="line"></span><br><span class="line">    // Prim 算法，构建最小生成树</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        int t = -1;  // t 用于存储当前距离最小生成树最近的节点</span><br><span class="line"></span><br><span class="line">        // 找到未加入最小生成树的节点中，距离最小的节点</span><br><span class="line">        for (int j = 1; j &lt;= n; ++j) &#123;</span><br><span class="line">            if (!st[j] &amp;&amp; (t == -1 || d[t] &gt; d[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果最小距离仍然为初始值，说明图不连通，输出 &quot;impossible&quot; 并结束程序</span><br><span class="line">        if (d[t] &gt; 10000 * n) &#123;</span><br><span class="line">            cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 将节点 t 加入最小生成树</span><br><span class="line">        st[t] = true;</span><br><span class="line">        res += d[t];  // 累加最小生成树的总权重</span><br><span class="line"></span><br><span class="line">        // 更新其他节点到最小生成树的最小距离</span><br><span class="line">        for (int j = 1; j &lt;= n; ++j) &#123;</span><br><span class="line">            if (!st[j] &amp;&amp; d[j] &gt; g[t][j]) &#123;</span><br><span class="line">                d[j] = g[t][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 输出最小生成树的总权重</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-859.-kruskal算法求最小生成树">AcWing 859.
Kruskal算法求最小生成树</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010;  // 定义最大节点数和边数</span><br><span class="line"></span><br><span class="line">int n, m;             // n: 节点数, m: 边数</span><br><span class="line">int u, v, w;          // u, v: 边的两个节点, w: 边的权重</span><br><span class="line">int parent[N];        // 并查集数组，用于判断两个节点是否在同一个连通分量中</span><br><span class="line">int rank_[N];         // 并查集的秩，用于优化合并操作</span><br><span class="line"></span><br><span class="line">struct Edge &#123;         // 定义边的结构体</span><br><span class="line">    int u, v, w;      // u, v: 边的两个节点, w: 边的权重</span><br><span class="line">    bool operator&lt;(const Edge&amp; other) const &#123;</span><br><span class="line">        return w &lt; other.w;  // 按权重从小到大排序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; edges;   // 存储所有边的数组</span><br><span class="line"></span><br><span class="line">// 并查集的查找操作，带路径压缩</span><br><span class="line">int find(int x) &#123;</span><br><span class="line">    if (parent[x] != x) &#123;</span><br><span class="line">        parent[x] = find(parent[x]);  // 路径压缩</span><br><span class="line">    &#125;</span><br><span class="line">    return parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 并查集的合并操作，带秩优化</span><br><span class="line">void unite(int x, int y) &#123;</span><br><span class="line">    int rootX = find(x);</span><br><span class="line">    int rootY = find(y);</span><br><span class="line">    if (rootX != rootY) &#123;</span><br><span class="line">        if (rank_[rootX] &gt; rank_[rootY]) &#123;</span><br><span class="line">            parent[rootY] = rootX;</span><br><span class="line">        &#125; else if (rank_[rootX] &lt; rank_[rootY]) &#123;</span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            parent[rootY] = rootX;</span><br><span class="line">            rank_[rootX]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 克鲁斯卡尔算法实现</span><br><span class="line">int kruskal() &#123;</span><br><span class="line">    int res = 0;  // 存储最小生成树的总权重</span><br><span class="line">    int cnt = 0;  // 记录已选边的数量</span><br><span class="line">    // 初始化并查集</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">        rank_[i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 按权重从小到大排序所有边</span><br><span class="line">    sort(edges.begin(), edges.end());</span><br><span class="line">    // 遍历所有边</span><br><span class="line">    for (const auto&amp; edge : edges) &#123;</span><br><span class="line">        int u = edge.u;</span><br><span class="line">        int v = edge.v;</span><br><span class="line">        int w = edge.w;</span><br><span class="line">        // 如果 u 和 v 不在同一个连通分量中，则选择这条边</span><br><span class="line">        if (find(u) != find(v)) &#123;</span><br><span class="line">            unite(u, v);  // 合并 u 和 v 的连通分量</span><br><span class="line">            res += w;     // 累加权重</span><br><span class="line">            cnt++;        // 已选边数加 1</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果已选边数达到 n-1，说明最小生成树已构建完成</span><br><span class="line">        if (cnt == n - 1) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果已选边数不足 n-1，说明图不连通</span><br><span class="line">    if (cnt &lt; n - 1) </span><br><span class="line">        return -1;  // 返回 -1 表示图不连通</span><br><span class="line">    return res;  // 返回最小生成树的总权重</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 输入节点数和边数</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    // 输入边的信息</span><br><span class="line">    while (m--) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        edges.push_back(&#123;u, v, w&#125;);  // 将边加入数组</span><br><span class="line">    &#125;</span><br><span class="line">    // 调用克鲁斯卡尔算法</span><br><span class="line">    int res = kruskal();</span><br><span class="line">    // 输出结果</span><br><span class="line">    if (res == -1) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-860.-染色法判定二分图">AcWing 860. 染色法判定二分图</h3>
<blockquote>
<p>合并并查集的代码亦可写作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[Find(node)] = Find(e[h[i]]);</span><br></pre></td></tr></table></figure>
<p>二者都可</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot; // 包含常用头文件</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010; // 定义常量，表示最大节点数</span><br><span class="line"></span><br><span class="line">int n, m; // n 表示节点数，m 表示边数</span><br><span class="line">int u, v; // u 和 v 用于临时存储边的两个端点</span><br><span class="line">int e[2 * N], h[N], ne[2 * N], idx; // 图的邻接表存储</span><br><span class="line">int f[N]; // 并查集的父节点数组</span><br><span class="line"></span><br><span class="line">// 添加边的函数</span><br><span class="line">void add(int x, int y) &#123;</span><br><span class="line">    e[idx] = y;      // 存储边的终点</span><br><span class="line">    ne[idx] = h[x];  // 将新边插入到节点 x 的邻接表头部</span><br><span class="line">    h[x] = idx++;    // 更新节点 x 的邻接表头，并增加边的索引</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 并查集的查找函数（带路径压缩）</span><br><span class="line">int Find(int x) &#123;</span><br><span class="line">    if (f[x] != x)         // 如果 x 不是自己的父节点</span><br><span class="line">        f[x] = Find(f[x]); // 递归查找 x 的根节点，并进行路径压缩</span><br><span class="line">    return f[x];           // 返回 x 的根节点</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    memset(h, -1, sizeof h); // 初始化邻接表头，全部设置为 -1</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;           // 输入节点数和边数</span><br><span class="line"></span><br><span class="line">    // 初始化并查集，每个节点自己是一个集合</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 输入边的信息，并构建邻接表</span><br><span class="line">    while (m--) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        add(u, v); // 添加边 u -&gt; v</span><br><span class="line">        add(v, u); // 添加边 v -&gt; u（无向图需要双向添加）</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历每个节点，检查是否存在环</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        for (int j = h[i]; ~j; j = ne[j]) &#123; // 遍历节点 i 的所有邻接节点</span><br><span class="line">            int node = e[j];               // 获取邻接节点</span><br><span class="line">            if (Find(node) == Find(i)) &#123;   // 如果节点 i 和邻接节点在同一个集合中</span><br><span class="line">                cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;      // 说明存在环，输出 &quot;No&quot;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            f[Find(e[h[i]])] = Find(node); // 合并节点 i 和邻接节点的集合</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; // 如果没有发现环，输出 &quot;Yes&quot;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-861.-二分图的最大匹配">AcWing 861. 二分图的最大匹配</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 510;  // 定义最大顶点数</span><br><span class="line">int n1, n2, m;      // n1: 左部图的顶点数，n2: 右部图的顶点数，m: 边数</span><br><span class="line">int u, v;           // 临时变量，用于输入边的两个顶点</span><br><span class="line">vector&lt;int&gt; edge[N];  // 邻接表，存储图的边信息</span><br><span class="line">int match[N];       // 记录匹配关系，match[v]表示右部图顶点v匹配的左部图顶点</span><br><span class="line">bool visited[N];    // 记录是否被访问过，用于DFS中避免重复访问</span><br><span class="line"></span><br><span class="line">// 匈牙利算法的DFS部分，用于寻找增广路径</span><br><span class="line">bool dfs(int u) &#123;</span><br><span class="line">    // 遍历u的所有邻接顶点v</span><br><span class="line">    for (int v : edge[u]) &#123;</span><br><span class="line">        // 如果v未被访问过</span><br><span class="line">        if (!visited[v]) &#123;</span><br><span class="line">            visited[v] = true;  // 标记v为已访问</span><br><span class="line">            // 如果v未被匹配，或者v的匹配顶点可以找到其他匹配</span><br><span class="line">            if (match[v] == 0 || dfs(match[v])) &#123;</span><br><span class="line">                match[v] = u;  // 将v匹配给u</span><br><span class="line">                return true;   // 返回true表示找到增广路径</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;  // 返回false表示未找到增广路径</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 输入左部图顶点数、右部图顶点数和边数</span><br><span class="line">    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; m;</span><br><span class="line">    // 输入每条边，并构建邻接表</span><br><span class="line">    while (m--) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        edge[u].push_back(v);  // 添加边u-&gt;v</span><br><span class="line">    &#125;</span><br><span class="line">    int cnt = 0;  // 记录最大匹配数</span><br><span class="line">    // 对左部图的每个顶点进行DFS，尝试找到匹配</span><br><span class="line">    for (int i = 1; i &lt;= n1; ++i) &#123;</span><br><span class="line">        memset(visited, false, sizeof(visited));  // 每次DFS前重置visited数组</span><br><span class="line">        if (dfs(i)) &#123;</span><br><span class="line">            cnt++;  // 如果找到匹配，计数加1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 输出最大匹配数</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="第四讲-数学知识">第四讲 数学知识</h2>
<p><strong>2025.3.10</strong></p>
<p>略</p>
<hr />
<h2 id="第五讲-动态规划">第五讲 动态规划</h2>
<p><strong>2025.3.10</strong></p>
<h3 id="acwing-2.-01背包问题">AcWing 2. 01背包问题</h3>
<blockquote>
<p>由于本题每个物品只有一个，顺序遍历的话某个物品可能会被选择两次</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1010; // 定义最大容量和物品数量的上限</span><br><span class="line">int n,v; // n表示物品的数量，v表示背包的容量</span><br><span class="line">int vi,wi; // vi表示当前物品的体积，wi表示当前物品的价值</span><br><span class="line">int f[N]; // f数组用于存储背包在不同容量下的最大价值</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;v; // 输入物品数量和背包容量</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        cin&gt;&gt;vi&gt;&gt;wi; // 输入当前物品的体积和价值</span><br><span class="line">        for (int i = v; i &gt;= vi ; --i) &#123; // 从背包的最大容量开始，倒序遍历到当前物品的体积</span><br><span class="line">            f[i]=max(f[i],f[i-vi]+wi); // 更新背包在容量i时的最大价值</span><br><span class="line">            // f[i]表示不选当前物品时的最大价值</span><br><span class="line">            // f[i-vi]+wi表示选当前物品时的最大价值</span><br><span class="line">            // 取两者的最大值作为背包在容量i时的最大价值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[v]&lt;&lt;endl; // 输出背包在容量v时的最大价值</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-3.-完全背包问题">AcWing 3. 完全背包问题</h3>
<blockquote>
<p>由于本题每个物品都有无限多个，所以采用正序遍历</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1010; // 定义最大容量和物品数量的上限</span><br><span class="line">int n,m; // n表示物品的数量，m表示背包的容量</span><br><span class="line">int v,w; // v表示当前物品的体积，w表示当前物品的价值</span><br><span class="line">int f[N]; // f数组用于存储背包在不同容量下的最大价值</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m; // 输入物品数量和背包容量</span><br><span class="line">    while(n--)&#123;</span><br><span class="line">        cin&gt;&gt;v&gt;&gt;w; // 输入当前物品的体积和价值</span><br><span class="line">        for (int i = v; i &lt;= m; ++i) &#123; // 从当前物品的体积开始，正序遍历到背包的最大容量</span><br><span class="line">            f[i]=max(f[i],f[i-v]+w); // 更新背包在容量i时的最大价值</span><br><span class="line">            // f[i]表示不选当前物品时的最大价值</span><br><span class="line">            // f[i-v]+w表示选当前物品时的最大价值</span><br><span class="line">            // 取两者的最大值作为背包在容量i时的最大价值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m]&lt;&lt;endl; // 输出背包在容量m时的最大价值</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-4.-多重背包问题">AcWing 4. 多重背包问题</h3>
<blockquote>
<p>对于有限个数的背包问题，都要倒序遍历</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, v; // n表示物品的种类数，v表示背包的容量</span><br><span class="line">int u, w, s; // u表示当前物品的体积，w表示当前物品的价值，s表示当前物品的数量</span><br><span class="line">int f[105]; // f数组用于存储背包在不同容量下的最大价值</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v; // 输入物品的种类数和背包容量</span><br><span class="line">    while (n--) &#123; // 遍历每一种物品</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; w &gt;&gt; s; // 输入当前物品的体积、价值和数量</span><br><span class="line">        while (s--) &#123; // 遍历当前物品的数量，确保最多选择s次</span><br><span class="line">            for (int i = v; i &gt;= u; i--) &#123; // 从背包的最大容量开始，倒序遍历到当前物品的体积</span><br><span class="line">                f[i] = max(f[i], f[i - u] + w); // 更新背包在容量i时的最大价值</span><br><span class="line">                // f[i]表示不选当前物品时的最大价值</span><br><span class="line">                // f[i - u] + w表示选当前物品时的最大价值</span><br><span class="line">                // 取两者的最大值作为背包在容量i时的最大价值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[v]; // 输出背包在容量v时的最大价值</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-898.-数字三角形">AcWing 898. 数字三角形</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 510; // 定义数组的最大大小</span><br><span class="line">int a[N][N]; // a数组用于存储输入的三角形数据</span><br><span class="line">int cnt[N][N]; // cnt数组用于存储从底部到当前位置的最大路径和</span><br><span class="line">int n; // n表示三角形的层数</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n; // 输入三角形的层数</span><br><span class="line">    // 输入三角形数据</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">        for (int j = 1; j &lt;= i; ++j)</span><br><span class="line">            cin &gt;&gt; a[i][j]; // 输入第i行第j列的值</span><br><span class="line"></span><br><span class="line">    // 初始化最后一行的cnt数组</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">        cnt[n][i] = a[n][i]; // 最后一行的最大路径和就是它本身</span><br><span class="line"></span><br><span class="line">    // 从倒数第二行开始，逐层向上计算最大路径和</span><br><span class="line">    for (int i = n - 1; i &gt;= 1; --i)</span><br><span class="line">        for (int j = 1; j &lt;= i; ++j)</span><br><span class="line">            cnt[i][j] = max(cnt[i + 1][j], cnt[i + 1][j + 1]) + a[i][j];</span><br><span class="line">            // cnt[i][j]表示从第i行第j列到底部的最大路径和</span><br><span class="line">            // max(cnt[i + 1][j], cnt[i + 1][j + 1])表示选择下一行的左或右路径中的较大值</span><br><span class="line">            // 加上当前节点的值a[i][j]，得到当前位置的最大路径和</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; cnt[1][1] &lt;&lt; endl; // 输出从顶部到底部的最大路径和</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-895.-最长上升子序列">AcWing 895. 最长上升子序列</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1010; // 定义数组的最大大小</span><br><span class="line">int cnt[N]; // cnt数组用于存储以a[i]结尾的最长递增子序列的长度</span><br><span class="line">int a[N]; // a数组用于存储输入的序列</span><br><span class="line">int n; // n表示序列的长度</span><br><span class="line">int ans; // ans用于存储最终的最长递增子序列的长度</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n; // 输入序列的长度</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i]; // 输入序列中的每个元素</span><br><span class="line">        cnt[i] = 1; // 初始化以a[i]结尾的最长递增子序列的长度为1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 动态规划求解最长递增子序列的长度</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        for (int j = i; j &gt;= 1; --j) &#123;</span><br><span class="line">            if (a[i] &gt; a[j]) // 如果a[i]大于a[j]，说明可以延长以a[j]结尾的子序列</span><br><span class="line">                cnt[i] = max(cnt[i], cnt[j] + 1); // 更新以a[i]结尾的最长递增子序列的长度</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans, cnt[i]); // 更新全局最长递增子序列的长度</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl; // 输出最长递增子序列的长度</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-897.-最长公共子序列">AcWing 897. 最长公共子序列</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1010;  // 定义最大字符串长度</span><br><span class="line">char a[N],b[N];    // 定义两个字符数组，用于存储输入的两个字符串</span><br><span class="line">int n,m;           // n和m分别表示字符串a和b的长度</span><br><span class="line">int f[N][N];       // f[i][j]表示字符串a的前i个字符和字符串b的前j个字符的最长公共子序列的长度</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;(a+1)&gt;&gt;(b+1);  // 输入字符串长度n和m，以及两个字符串a和b，注意从a[1]和b[1]开始存储</span><br><span class="line"></span><br><span class="line">    // 动态规划求解最长公共子序列</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;          // 遍历字符串a的每一个字符</span><br><span class="line">        for (int j = 1; j &lt;= m; ++j) &#123;      // 遍历字符串b的每一个字符</span><br><span class="line">            if(a[i]==b[j])                 // 如果当前字符相等</span><br><span class="line">                f[i][j]=f[i-1][j-1]+1;     // 则最长公共子序列的长度为f[i-1][j-1] + 1</span><br><span class="line">            else                            // 如果当前字符不相等</span><br><span class="line">                f[i][j]=max(f[i-1][j],f[i][j-1]);  // 则最长公共子序列的长度为f[i-1][j]和f[i][j-1]中的较大值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[n][m]&lt;&lt;endl;  // 输出字符串a和b的最长公共子序列的长度</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-902.-最短编辑距离">AcWing 902. 最短编辑距离</h3>
<blockquote>
<ul>
<li><p>把第一个字符串的前 <code>i</code> 个字母变为第二个字符串的前
<code>j - 1</code>
个字符，然后在第一个字符串后面增加第二个字符串的第<code>j</code>个字母。</p>
<p>这种情况下，<code>f[i][j] = f[i][j - 1] + 1</code>。</p>
<p>例如：把<code>AGT</code>变为<code>AGTAA</code>，可以先把<code>AGT</code>变为<code>AGTA</code>，然后再在最后面添加一个字符<code>A</code>。</p></li>
<li><p>把第一个字符串的前 <code>i - 1</code> 个字母变为第二个字符串的前
<code>j</code> 个字符，然后去掉最后一个字符。</p>
<p>例如：把<code>AGT</code>变为<code>AGTAA</code>，可以先把<code>AGT</code>变为<code>AGTAAT</code>，然后再去掉一个字符<code>T</code>。</p>
<p>这种情况下，<code>f[i][j] = f[i - 1][j] + 1</code>。</p></li>
<li><p>把第一个字符串的前 <code>i - 1</code> 个字母变为第二个字符串的前
<code>j - 1</code>个字符。变化之后，对比最后一个字符，如果相等，则变换完成，如果不同，把第一个字符串的最后一个字符变为第二个字符串的最后一个字符，</p>
<p>例如：把<code>AGT</code>变为<code>AGTAA</code>，可以先把<code>AGT</code>变为<code>AGTAT</code>，然后再在最后面添加一个字符<code>T</code>变为<code>A</code>。</p>
<p>例如：把<code>AGT</code>变为<code>AGTAT</code>，可以先把<code>AGT</code>变为<code>AGTAT</code>，因为最后一个字符相同，不再做处理。</p>
<p>这种情况下，<code>f[i][j] = f[i - 1][j - 1] + 1</code>(最一个字符不同)
或<code>f[i][j] = f[i - 1][j + 1]</code> (最一个字符相同)。</p></li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1010;  // 定义最大字符串长度</span><br><span class="line">int n,m;           // n和m分别表示字符串a和b的长度</span><br><span class="line">char a[N],b[N];    // 定义两个字符数组，用于存储输入的两个字符串</span><br><span class="line">int f[N][N];       // f[i][j]表示将字符串a的前i个字符转换为字符串b的前j个字符所需的最小编辑距离</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;(a+1)&gt;&gt;m&gt;&gt;(b+1);  // 输入字符串a的长度n、字符串a、字符串b的长度m以及字符串b，注意从a[1]和b[1]开始存储</span><br><span class="line"></span><br><span class="line">    // 初始化边界条件</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) f[i][0]=i;  // 将字符串a的前i个字符转换为空字符串，需要i次删除操作</span><br><span class="line">    for (int i = 1; i &lt;= m; ++i) f[0][i]=i;  // 将空字符串转换为字符串b的前i个字符，需要i次插入操作</span><br><span class="line"></span><br><span class="line">    // 动态规划求解最小编辑距离</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;          // 遍历字符串a的每一个字符</span><br><span class="line">        for (int j = 1; j &lt;= m; ++j) &#123;      // 遍历字符串b的每一个字符</span><br><span class="line">            // 计算删除或插入操作的代价</span><br><span class="line">            f[i][j]=min(f[i-1][j]+1,f[i][j-1]+1);</span><br><span class="line">            if (a[i]==b[j])                 // 如果当前字符相等</span><br><span class="line">                f[i][j]=min(f[i][j],f[i-1][j-1]);  // 则不需要替换操作，直接取f[i-1][j-1]</span><br><span class="line">            else                            // 如果当前字符不相等</span><br><span class="line">                f[i][j]=min(f[i][j],f[i-1][j-1]+1);  // 则需要一次替换操作，取f[i-1][j-1]+1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[n][m]&lt;&lt;endl;  // 输出将字符串a转换为字符串b所需的最小编辑距离</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-899.-编辑距离">AcWing 899. 编辑距离</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=1010;  // 定义最大字符串数量</span><br><span class="line">const int M=20;    // 定义单个字符串的最大长度</span><br><span class="line">int n,m;           // n表示字符串的数量，m表示查询的次数</span><br><span class="line">char s[N][M];      // 存储n个字符串，每个字符串从s[i][1]开始存储</span><br><span class="line">char ss[M];        // 存储查询的字符串，从ss[1]开始存储</span><br><span class="line">int cnt;           // 存储查询允许的最大编辑距离</span><br><span class="line">int f[M][M];       // f[i][j]用于动态规划计算编辑距离</span><br><span class="line"></span><br><span class="line">// 函数：计算字符串a和字符串b之间的最小编辑距离</span><br><span class="line">int solve(char a[],char b[])&#123;</span><br><span class="line">    int aa= strlen(a+1);  // 计算字符串a的长度，从a[1]开始</span><br><span class="line">    int bb= strlen(b+1);  // 计算字符串b的长度，从b[1]开始</span><br><span class="line"></span><br><span class="line">    // 初始化边界条件</span><br><span class="line">    for (int i = 1; i &lt;= aa; ++i) f[i][0]=i;  // 将a的前i个字符转换为空字符串，需要i次删除操作</span><br><span class="line">    for (int i = 1; i &lt;= bb; ++i) f[0][i]=i;  // 将空字符串转换为b的前i个字符，需要i次插入操作</span><br><span class="line"></span><br><span class="line">    // 动态规划求解最小编辑距离</span><br><span class="line">    for (int i = 1; i &lt;= aa; ++i) &#123;          // 遍历字符串a的每一个字符</span><br><span class="line">        for (int j = 1; j &lt;= bb; ++j) &#123;      // 遍历字符串b的每一个字符</span><br><span class="line">            // 计算删除或插入操作的代价</span><br><span class="line">            f[i][j]=min(f[i-1][j]+1,f[i][j-1]+1);</span><br><span class="line">            if (a[i]==b[j])                 // 如果当前字符相等</span><br><span class="line">                f[i][j]=min(f[i][j],f[i-1][j-1]);  // 则不需要替换操作，直接取f[i-1][j-1]</span><br><span class="line">            else                            // 如果当前字符不相等</span><br><span class="line">                f[i][j]=min(f[i][j],f[i-1][j-1]+1);  // 则需要一次替换操作，取f[i-1][j-1]+1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return f[aa][bb];  // 返回a和b之间的最小编辑距离</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;  // 输入字符串的数量n和查询的次数m</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">        cin&gt;&gt;(s[i]+1);  // 输入n个字符串，从s[i][1]开始存储</span><br><span class="line"></span><br><span class="line">    while(m--)&#123;  // 处理每个查询</span><br><span class="line">        int ans=0;  // 记录满足条件的字符串数量</span><br><span class="line">        cin&gt;&gt;(ss+1)&gt;&gt;cnt;  // 输入查询字符串ss和允许的最大编辑距离cnt</span><br><span class="line"></span><br><span class="line">        // 遍历所有字符串，检查与ss的编辑距离是否小于等于cnt</span><br><span class="line">        for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">            if (solve(ss,s[i])&lt;=cnt)  // 调用solve函数计算编辑距离</span><br><span class="line">                ans++;  // 如果满足条件，计数加1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;  // 输出满足条件的字符串数量</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-282.-石子合并">AcWing 282. 石子合并</h3>
<blockquote>
<p>还是不咋会</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=310;  // 定义最大石子堆数</span><br><span class="line">int s[N];         // s[i]表示前i堆石子的总重量（前缀和）</span><br><span class="line">int f[N][N];      // f[l][r]表示合并从第l堆到第r堆石子的最小代价</span><br><span class="line">int n;            // 输入石子的堆数</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;  // 输入石子的堆数</span><br><span class="line"></span><br><span class="line">    // 输入每堆石子的重量，并计算前缀和</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">        s[i]+=s[i-1];  // s[i]表示前i堆石子的总重量</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 动态规划求解合并石子的最小代价</span><br><span class="line">    for (int len = 2; len &lt;= n; len++) &#123;  // len表示当前合并的区间长度，从2开始</span><br><span class="line">        for (int i = 1; i + len - 1 &lt;= n; i++) &#123;  // i表示区间的左端点</span><br><span class="line">            int l = i, r = i + len - 1;  // l和r分别表示区间的左端点和右端点</span><br><span class="line">            f[l][r] = 1e9;  // 初始化f[l][r]为一个极大值，表示尚未计算</span><br><span class="line">            for (int k = l; k &lt;= r - 1; k++) &#123;  // 枚举分割点k</span><br><span class="line">                // 更新f[l][r]为：左边区间的最小代价 + 右边区间的最小代价 + 当前合并的代价</span><br><span class="line">                f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r] + s[r] - s[l - 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;f[1][n]&lt;&lt;endl;  // 输出合并所有石子的最小代价</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-900.-整数划分">AcWing 900. 整数划分</h3>
<blockquote>
<p>不是很懂</p>
</blockquote>
<blockquote>
<p><strong>动态规划中 <code>i</code> 和 <code>j</code>
的具体含义</strong></p>
<p><strong><code>i</code> 表示当前可以使用的最大正整数</strong>。</p>
<p>例如：当 <code>i=3</code> 时，表示当前允许在划分中使用数字
<code>3</code>，但后续划分中的其他元素不能超过
<code>3</code>（确保非递增顺序）。</p>
<p>遍历顺序保证非递增排列：外层循环从 <code>1</code> 到 <code>n</code>
遍历，从小到大依次允许使用更大的数。每次处理 <code>i</code> 时，相当于将
<code>i</code> 作为当前划分中的最大元素，后续的划分中不能再出现比
<code>i</code> 更大的数。</p>
<p><strong>内层循环变量 <code>j</code> 的含义</strong></p>
<p><code>j</code> 表示当前要组成的正整数。</p>
<p>例如：当 <code>j=5</code> 时，表示我们需要计算将 <code>5</code>
划分为若干数的总方法数。</p>
<p>动态规划状态更新的目标：通过遍历 <code>j</code> 从 <code>i</code> 到
<code>n</code>，逐步计算每个 <code>j</code> 的划分数。</p>
<p><strong>状态转移的解释</strong></p>
<p>核心操作 <code>dp[j] += dp[j - i]</code></p>
<ul>
<li><code>dp[j - i]</code> 表示不使用当前 <code>i</code> 时组成
<code>j - i</code> 的方法数。</li>
<li>通过加上 <code>i</code>，可以将这些方法扩展到组成 <code>j</code>
的方法（例如 <code>j=5</code>，<code>i=2</code>，则
<code>dp[5] += dp[3]</code>，表示在 <code>3</code> 的基础上加上
<code>2</code>）。</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MOD = 1e9 + 7;       // 题目要求的取模基数</span><br><span class="line">const int MAXN = 1001;         // 根据数据范围n≤1000设定</span><br><span class="line"></span><br><span class="line">int dp[MAXN];                  // dp[j]表示组成j的划分数</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;                  // 读取输入</span><br><span class="line">    dp[0] = 1;                 // 边界条件：组成0的方式有1种</span><br><span class="line">    </span><br><span class="line">    // 动态规划核心逻辑</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;           // 遍历物品(每个正整数)</span><br><span class="line">        for (int j = i; j &lt;= n; ++j) &#123;      // 遍历背包容量</span><br><span class="line">            dp[j] = (dp[j] + dp[j - i]) % MOD; // 状态转移</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; dp[n] &lt;&lt; endl;     // 输出结果</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-285.-没有上司的舞会">AcWing 285. 没有上司的舞会</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const ll N = 6e3 + 5; // 定义最大节点数</span><br><span class="line">ll n, r[N], u, v, num, head[N], dp[N][2], root; // 定义变量</span><br><span class="line">bool pd[N]; // 用于标记节点是否有父节点</span><br><span class="line"></span><br><span class="line">// 定义边的结构体</span><br><span class="line">struct node &#123;</span><br><span class="line">    ll to, next; // to: 边的终点，next: 下一条边的索引</span><br><span class="line">&#125; edge[N];</span><br><span class="line"></span><br><span class="line">// 添加边的函数</span><br><span class="line">void add(ll u, ll v) &#123;</span><br><span class="line">    num++; // 边的编号增加</span><br><span class="line">    edge[num].to = v; // 记录边的终点</span><br><span class="line">    edge[num].next = head[u]; // 将当前边加入u的邻接表</span><br><span class="line">    head[u] = num; // 更新u的头指针</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 深度优先搜索函数</span><br><span class="line">void dfs(ll u) &#123;</span><br><span class="line">    dp[u][1] = r[u]; // 初始化u节点被选中时的价值</span><br><span class="line">    for (ll i = head[u]; i &gt; 0; i = edge[i].next) &#123; // 遍历u的所有子节点</span><br><span class="line">        ll v = edge[i].to; // 获取子节点v</span><br><span class="line">        dfs(v); // 递归处理子节点</span><br><span class="line">        dp[u][0] += max(dp[v][0], dp[v][1]); // u不被选中时，累加子节点的最大价值</span><br><span class="line">        dp[u][1] += dp[v][0]; // u被选中时，累加子节点不被选中时的价值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signed main() &#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n; // 输入节点数</span><br><span class="line">    for (ll i = 1; i &lt;= n; i++) cin &gt;&gt; r[i]; // 输入每个节点的价值</span><br><span class="line"></span><br><span class="line">    // 构建树结构</span><br><span class="line">    for (ll i = 1; i &lt;= n - 1; i++) &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v; // 输入边的两个节点</span><br><span class="line">        pd[u] = true; // 标记u有父节点</span><br><span class="line">        add(v, u); // 添加边v-&gt;u</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 寻找根节点（没有父节点的节点）</span><br><span class="line">    root = 1;</span><br><span class="line">    while (pd[root]) root++;</span><br><span class="line"></span><br><span class="line">    // 从根节点开始进行DFS</span><br><span class="line">    dfs(root);</span><br><span class="line"></span><br><span class="line">    // 输出根节点被选中或不被选中时的最大价值</span><br><span class="line">    cout &lt;&lt; max(dp[root][0], dp[root][1]);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-901.-滑雪">AcWing 901. 滑雪</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 310; // 定义矩阵的最大大小</span><br><span class="line">int h[N][N], f[N][N], n, m; // h: 存储每个点的高度，f: 存储从每个点出发的最长路径长度</span><br><span class="line">int dx[] = &#123;-1, 0, 1, 0&#125;, dy[] = &#123;0, 1, 0, -1&#125;; // 四个方向的偏移量：上、右、下、左</span><br><span class="line"></span><br><span class="line">// 深度优先搜索函数，计算从(x, y)出发的最长滑雪路径</span><br><span class="line">int dfs(int x, int y) &#123;</span><br><span class="line">    int &amp;v = f[x][y]; // 使用引用简化代码，v表示f[x][y]</span><br><span class="line">    if (~v) // 如果f[x][y]已经计算过（不等于-1），直接返回</span><br><span class="line">        return v;</span><br><span class="line">    v = 1; // 初始化当前点的路径长度为1（至少包含自己）</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123; // 遍历四个方向</span><br><span class="line">        int to_x = dx[i] + x, to_y = dy[i] + y; // 计算下一个点的坐标</span><br><span class="line">        // 检查下一个点是否在矩阵范围内，并且高度比当前点低</span><br><span class="line">        if (to_x &gt;= 1 &amp;&amp; to_x &lt;= n &amp;&amp; to_y &gt;= 1 &amp;&amp; to_y &lt;= m &amp;&amp; h[to_x][to_y] &lt; h[x][y])</span><br><span class="line">            v = max(v, dfs(to_x, to_y) + 1); // 递归计算下一个点的路径长度，并更新当前点的路径长度</span><br><span class="line">    &#125;</span><br><span class="line">    return v; // 返回从(x, y)出发的最长路径长度</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; // 输入矩阵的行数和列数</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">        for (int j = 1; j &lt;= m; j++)</span><br><span class="line">            cin &gt;&gt; h[i][j]; // 输入每个点的高度</span><br><span class="line"></span><br><span class="line">    memset(f, -1, sizeof(f)); // 初始化f数组为-1，表示未计算过</span><br><span class="line">    int res = 0; // 存储最终的最长路径长度</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">        for (int j = 1; j &lt;= m; j++)</span><br><span class="line">            res = max(res, dfs(i, j)); // 对每个点调用dfs，更新最长路径长度</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res; // 输出结果</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="第六讲-贪心">第六讲 贪心</h2>
<p><strong>2025.3.12</strong></p>
<h3 id="acwing-905.-区间选点">AcWing 905. 区间选点</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot; </span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010; // 定义数组的最大大小</span><br><span class="line"></span><br><span class="line">int n; // 表示区间的数量</span><br><span class="line">int x, y; // 临时变量，用于输入区间的起点和终点</span><br><span class="line">pair&lt;int, int&gt; p[N]; // 数组p用于存储所有区间，每个元素是一个pair，表示区间的起点和终点</span><br><span class="line">int r = -1e9 - 1; // 用于记录当前合并后的区间的终点，初始值设置为一个极小的数</span><br><span class="line">int ans; // 用于记录最终合并后的区间数量</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n; // 输入区间的数量</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y; // 输入每个区间的起点和终点</span><br><span class="line">        p[i] = &#123;x, y&#125;; // 将区间存储到数组p中</span><br><span class="line">    &#125;</span><br><span class="line">    sort(p + 1, p + n + 1); // 对所有区间按照起点进行升序排序，注意从p[1]到p[n]排序</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        if (p[i].first &gt; r) &#123; // 如果当前区间的起点大于上一个合并后的区间的终点</span><br><span class="line">            ans++; // 说明当前区间无法与上一个区间合并，增加一个新的区间</span><br><span class="line">            r = p[i].second; // 更新当前合并后的区间的终点</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            r = min(p[i].second, r); // 如果当前区间可以与上一个区间合并，更新合并后的区间的终点为两者终点的最小值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl; // 输出最终合并后的区间数量</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-908.-最大不相交区间数量">AcWing 908.
最大不相交区间数量</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot; </span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010; // 定义数组的最大大小</span><br><span class="line"></span><br><span class="line">int n; // 表示区间的数量</span><br><span class="line">pair&lt;int, int&gt; p[N]; // 数组p用于存储所有区间，每个元素是一个pair，表示区间的起点和终点</span><br><span class="line">int r = 1e9; // 用于记录当前合并后的区间的终点，初始值设置为一个极大的数</span><br><span class="line">int ans; // 用于记录最终合并后的区间数量</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n; // 输入区间的数量</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; p[i].first &gt;&gt; p[i].second; // 输入每个区间的起点和终点</span><br><span class="line">    &#125;</span><br><span class="line">    // 对所有区间按照终点进行升序排序</span><br><span class="line">    sort(p + 1, p + n + 1, [&amp;](pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) &#123;</span><br><span class="line">        return a.second &lt; b.second;</span><br><span class="line">    &#125;);</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        if (!ans || r &lt; p[i].first) &#123; // 如果当前是第一个区间，或者当前区间的起点大于上一个合并后的区间的终点</span><br><span class="line">            ans++; // 说明当前区间无法与上一个区间合并，增加一个新的区间</span><br><span class="line">            r = p[i].second; // 更新当前合并后的区间的终点</span><br><span class="line">        &#125; else if (r &gt;= p[i].first &amp;&amp; r &lt;= p[i].second) &#123; // 如果当前区间与上一个合并后的区间有重叠</span><br><span class="line">            continue; // 不需要增加新的区间，直接跳过</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl; // 输出最终合并后的区间数量</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-906.-区间分组">AcWing 906. 区间分组</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot; </span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010; // 定义数组的最大大小</span><br><span class="line"></span><br><span class="line">int n; // 表示区间的数量</span><br><span class="line">pair&lt;int, int&gt; p[N]; // 数组p用于存储所有区间，每个元素是一个pair，表示区间的起点和终点</span><br><span class="line">int r = 1e9; // 用于记录当前合并后的区间的终点，初始值设置为一个极大的数（未使用）</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, greater&lt;&gt;&gt; heap; // 小根堆，用于存储区间的终点，按从小到大排序</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n; // 输入区间的数量</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; p[i].first &gt;&gt; p[i].second; // 输入每个区间的起点和终点</span><br><span class="line">    sort(p + 1, p + n + 1); // 对所有区间按照起点进行升序排序，默认按照pair的第一个元素（即起点）排序</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">        if (heap.empty() || heap.top() &gt;= p[i].first) // 如果堆为空，或者当前区间的起点小于等于堆顶区间的终点</span><br><span class="line">            heap.push(p[i].second); // 将当前区间的终点加入堆中</span><br><span class="line">        else &#123;</span><br><span class="line">            heap.pop(); // 否则，移除堆顶区间的终点</span><br><span class="line">            heap.push(p[i].second); // 将当前区间的终点加入堆中</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; heap.size() &lt;&lt; endl; // 输出堆的大小，即所需的最小分组数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-907.-区间覆盖">AcWing 907. 区间覆盖</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot; </span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010; // 定义数组的最大大小</span><br><span class="line"></span><br><span class="line">pair&lt;int, int&gt; p[N]; // 数组p用于存储所有区间，每个元素是一个pair，表示区间的起点和终点</span><br><span class="line">int s, t; // 表示目标区间的起点和终点</span><br><span class="line">int n; // 表示区间的数量</span><br><span class="line">bool finished; // 标记是否已经覆盖整个目标区间</span><br><span class="line">int ans; // 记录所需的最少区间数量</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t &gt;&gt; n; // 输入目标区间的起点s、终点t以及区间的数量n</span><br><span class="line">    for (int i = 0; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; p[i].first &gt;&gt; p[i].second; // 输入每个区间的起点和终点，并存储在数组p中</span><br><span class="line">    sort(p, p + n); // 对所有区间按照起点进行升序排序</span><br><span class="line"></span><br><span class="line">    finished = false; // 初始化标记为false，表示尚未覆盖整个目标区间</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        int j = i; // 从当前区间开始向后遍历</span><br><span class="line">        int r = -1e9 - 1; // 记录当前覆盖的最大终点，初始值设置为一个极小的数</span><br><span class="line">        // 找到所有起点小于等于s的区间，并记录它们的最大终点</span><br><span class="line">        while (j &lt; n &amp;&amp; s &gt;= p[j].first) &#123;</span><br><span class="line">            r = max(r, p[j].second); // 更新最大终点</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (r &lt; s) &#123; // 如果最大终点仍然小于s，说明无法覆盖目标区间</span><br><span class="line">            ans = -1; // 设置结果为-1，表示无法完成</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        ans++; // 增加一个区间</span><br><span class="line">        if (r &gt;= t) &#123; // 如果最大终点已经覆盖了目标区间的终点t</span><br><span class="line">            finished = true; // 标记为已完成</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        s = r; // 更新目标区间的起点为当前最大终点</span><br><span class="line">        i = j - 1; // 跳过已经处理过的区间</span><br><span class="line">    &#125;</span><br><span class="line">    if (!finished) // 如果循环结束后仍未覆盖整个目标区间</span><br><span class="line">        ans = -1; // 设置结果为-1，表示无法完成</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl; // 输出结果</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-148.-合并果子">AcWing 148. 合并果子</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=10010; // 定义一个常量N，但代码中并未使用</span><br><span class="line">int ans; // 用于存储最终的结果</span><br><span class="line">int n,m; // n表示输入的元素个数，m用于临时存储输入的元素</span><br><span class="line">int a,b; // a和b用于存储最小堆中的两个最小元素</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap; // 定义一个最小堆，存储整数类型</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n; // 输入元素个数n</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; m; // 依次输入每个元素</span><br><span class="line">        minHeap.push(m); // 将元素加入最小堆</span><br><span class="line">    &#125;</span><br><span class="line">    while (minHeap.size()!=1)&#123; // 当堆中元素个数大于1时，继续循环</span><br><span class="line">        a=minHeap.top(); // 取出堆中的最小元素</span><br><span class="line">        minHeap.pop(); // 将最小元素从堆中移除</span><br><span class="line">        b=minHeap.top(); // 取出堆中的次小元素</span><br><span class="line">        minHeap.pop(); // 将次小元素从堆中移除</span><br><span class="line">        ans+=(a+b); // 将这两个元素的和累加到结果中</span><br><span class="line">        minHeap.push(a+b); // 将这两个元素的和重新加入堆中</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl; // 输出最终的结果</span><br><span class="line">    return 0; // 程序正常结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-913.-排队打水">AcWing 913. 排队打水</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot; </span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, t; // n 表示输入的元素个数，t 用于临时存储输入的元素</span><br><span class="line">long long cnt; // cnt 用于存储最终的计算结果</span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, greater&lt;&gt;&gt; minheap; // 定义一个最小堆，存储整数类型</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n; // 输入元素个数 n</span><br><span class="line">    while (n--) &#123; // 循环读取 n 个元素</span><br><span class="line">        cin &gt;&gt; t; // 依次输入每个元素</span><br><span class="line">        minheap.push(t); // 将元素加入最小堆</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (!minheap.empty()) &#123; // 当最小堆不为空时，继续循环</span><br><span class="line">        // 将堆顶元素（最小元素）乘以（堆的大小 - 1），并累加到 cnt 中</span><br><span class="line">        cnt += minheap.top() * (minheap.size() - 1);</span><br><span class="line">        minheap.pop(); // 移除堆顶元素</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl; // 输出最终的计算结果</span><br><span class="line">    return 0; // 程序正常结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acwing-104.-货仓选址">AcWing 104. 货仓选址</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 100010; // 定义数组的最大长度</span><br><span class="line">int n; // n 表示输入的元素个数</span><br><span class="line">int a[N]; // 定义一个数组，用于存储输入的元素</span><br><span class="line">int mid; // mid 用于存储数组的中位数</span><br><span class="line">int cnt; // cnt 用于存储最终的计算结果</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n; // 输入元素个数 n</span><br><span class="line">    for (int i = 0; i &lt; n; ++i) // 循环读取 n 个元素</span><br><span class="line">        cin &gt;&gt; a[i]; // 将输入的元素存储到数组 a 中</span><br><span class="line"></span><br><span class="line">    sort(a, a + n); // 对数组 a 进行排序，从小到大排列</span><br><span class="line"></span><br><span class="line">    mid = a[n / 2]; // 获取数组的中位数（当 n 为偶数时，取中间靠左的元素）</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; ++i) &#123; // 遍历数组中的每个元素</span><br><span class="line">        cnt += (abs(mid - a[i])); // 计算当前元素与中位数的绝对差，并累加到 cnt 中</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl; // 输出最终的计算结果</span><br><span class="line">    return 0; // 程序正常结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="中南大学往年机试题目">中南大学往年机试题目</h1>
<p><strong>PIPIOJ Online Judge FAQ</strong></p>
<blockquote>
<p>Q:这个在线裁判系统使用什么样的编译器和编译选项? A:系统运行于<a
target="_blank" rel="noopener" href="http://www.debian.org/">Debian</a>/<a
target="_blank" rel="noopener" href="http://www.ubuntu.com/">Ubuntu</a> Linux. 使用<a
target="_blank" rel="noopener" href="http://gcc.gnu.org/">GNU GCC/G++</a> 作为C/C++编译器, <a
target="_blank" rel="noopener" href="http://www.freepascal.org/">Free Pascal</a> 作为pascal 编译器 ，用
<a target="_blank" rel="noopener" href="http://openjdk.java.net/">openjdk-7</a> 编译 Java.
对应的编译选项如下:</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th>Language</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>C:</td>
<td>gcc Main.c -o Main -fno-asm -Wall -lm --static -std=c99
-DONLINE_JUDGE<code>#pragma GCC optimize ("O2")</code>可以手工开启O2优化</td>
</tr>
<tr class="even">
<td>C++:</td>
<td>g++ -fno-asm -Wall -lm --static -std=c++11 -DONLINE_JUDGE -o Main
Main.cc</td>
</tr>
<tr class="odd">
<td>Pascal:</td>
<td>fpc Main.pas -oMain -O1 -Co -Cr -Ct -Ci</td>
</tr>
<tr class="even">
<td>Java:</td>
<td>javac -J-Xms32m -J-Xmx256m Main.java *Java has 2 more seconds and
512M more memory when running and judging.</td>
</tr>
</tbody>
</table>
<p>编译器版本为（系统可能升级编译器版本，这里仅供参考）: gcc version
4.8.4 (Ubuntu 4.8.4-2ubuntu1~14.04.3) glibc 2.19 Free Pascal Compiler
version 2.6.2 openjdk 1.7.0_151</p>
<hr />
<p>Q:程序怎样取得输入、进行输出? A:你的程序应该从标准输入
stdin('Standard Input')获取输入，并将结果输出到标准输出 stdout('Standard
Output').例如,在C语言可以使用 'scanf' ，在C++可以使用'cin'
进行输入；在C使用 'printf' ，在C++使用'cout'进行输出.</p>
<p>用户程序不允许直接读写文件, 如果这样做可能会判为运行时错误 "Runtime
Error"。</p>
</blockquote>
<h2 id="年中南大学研究生复试机试">2013年中南大学研究生复试机试</h2>
<h3 id="回文串问题">1000 回文串问题</h3>
<blockquote>
<h4 id="题目描述">题目描述</h4>
<p>“回文串”是一个正读和反读都一样的字符串，字符串由数字和小写字母组成，比如“level”或者“abcdcba”等等就是回文串。请写一个程序判断读入的字符串是否是“回文”。</p>
<h4 id="输入">输入</h4>
<p>输入包含多个测试实例，每一行对应一个字符串，串长最多100字母。</p>
<h4 id="输出">输出</h4>
<p>对每个字符串，输出它是第几个，如第一个输出为"case1:
"；如果一个字符串是回文串，则输出"yes",否则输出"no"，在yes/no之前用一个空格。</p>
<h4 id="样例输入">样例输入</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">level</span><br><span class="line">abcde</span><br><span class="line">noon</span><br><span class="line">haha</span><br></pre></td></tr></table></figure>
<h4 id="样例输出">样例输出</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">case1: yes</span><br><span class="line">case2: no</span><br><span class="line">case3: yes</span><br><span class="line">case4: no</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line">int cnt;</span><br><span class="line">int i;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cnt=0;</span><br><span class="line">    while(cin&gt;&gt;s)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        for ( i= 0; i &lt; s.size()/2; ++i) &#123;</span><br><span class="line">            if ((s[i]-&#x27;0&#x27;)!=(s[s.size()-i-1]-&#x27;0&#x27;))</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i==s.size()/2)</span><br><span class="line">            cout&lt;&lt;&quot;case&quot;&lt;&lt;cnt&lt;&lt;&quot;: yes&quot;&lt;&lt;endl;</span><br><span class="line">        else</span><br><span class="line">            cout&lt;&lt;&quot;case&quot;&lt;&lt;cnt&lt;&lt;&quot;: no&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="水仙花数">1001 水仙花数</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n,m;</span><br><span class="line">int cnt;</span><br><span class="line">bool ans[1000]=&#123;false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,true,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        cnt=0;</span><br><span class="line">        for (int i = n; i &lt;= m; ++i) &#123;</span><br><span class="line">            if (ans[i])&#123;</span><br><span class="line">                cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!cnt)</span><br><span class="line">            cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;</span><br><span class="line">        else</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="安全密码">1002 安全密码</h3>
<blockquote>
<h4 id="题目描述-1">题目描述</h4>
<p>网络上各类交易活动越来越普及，为了能够安安心心地上网，经常需要设置一个安全的密码。一般来说一个比较安全的密码至少应该满足下面两个条件：
(1)密码长度大于等于8。
(2)密码中的字符应该来自下面“字符类别”中四组中的至少三组。
这四个字符类别分别为： (1)大写字母：A,B,C...Z; (2)小写字母：a,b,c...z;
(3)数字：0,1,2...9; (4)特殊符号：~,!,@,#,$,%,^;
给你一个密码，你的任务就是判断它是不是一个安全的密码。</p>
<h4 id="输入-1">输入</h4>
<p>输入数据有多组，每组占一行，每行一个密码（长度最大可能为50），密码仅包括上面的四类字符。</p>
<h4 id="输出-1">输出</h4>
<p>对于每个测试实例，判断这个密码是不是一个安全的密码，是的话输出YES，否则输出NO。</p>
<h4 id="样例输入-1">样例输入</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a1b2c3d4</span><br><span class="line">Linle@ACM</span><br><span class="line">^~^@^@!%</span><br></pre></td></tr></table></figure>
<h4 id="样例输出-1">样例输出</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string s;</span><br><span class="line">    while(cin&gt;&gt;s)&#123;</span><br><span class="line">        bool cnt[4]=&#123;false,false,false, false&#125;;</span><br><span class="line">        int ans=0;</span><br><span class="line">        if (s.size()&lt;8)&#123;</span><br><span class="line">            cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            for (char c:s) &#123;</span><br><span class="line">                if (isdigit(c))</span><br><span class="line">                    cnt[0]= true;</span><br><span class="line">                else if(islower(c))</span><br><span class="line">                    cnt[1]= true;</span><br><span class="line">                else if (isupper(c))</span><br><span class="line">                    cnt[2]= true;</span><br><span class="line">                else if (ispunct(c))</span><br><span class="line">                    cnt[3]= true;</span><br><span class="line">            &#125;</span><br><span class="line">            for (bool i : cnt)</span><br><span class="line">                if(i)</span><br><span class="line">                    ans++;</span><br><span class="line">            cout&lt;&lt;(ans&gt;=3?&quot;YES&quot;:&quot;NO&quot;)&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最少钱币数">1003 最少钱币数</h3>
<blockquote>
<h4 id="题目描述-2">题目描述</h4>
<p>作为A公司的职员，最盼望的日子就是每月的8号了，因为这一天是发工资的日子，养家糊口就靠它了。但是对于公司财务处的工作人员来说，这一天则是很忙碌的一天，财务处的小胡最近就在考虑一个问题：如果每个员工的工资额都知道，最少需要准备多少张人民币，才能在给每位职员发工资的时候都不用老师找零呢？这里假设员工的工资都是正整数，单位元，人民币一共有100元、50元、10元、5元、2元和1元六种。</p>
<h4 id="输入-2">输入</h4>
<p>输入数据包含多个测试实例，每个测试实例的第一行是一个整数n（n&lt;=100），表示老师的人数，然后是n个老师的工资（工资&lt;5000）。</p>
<h4 id="输出-2">输出</h4>
<p>每个测试用例输出一行，即凑成钱数值M最少需要的钱币个数。如果凑钱失败，输出“Impossible”。你可以假设，每种待凑钱币的数量是无限多的。</p>
<h4 id="样例输入-2">样例输入</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">2</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>
<h4 id="样例输出-2">样例输出</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=110;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">int a[N];</span><br><span class="line">int cnt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    while(cin&gt;&gt;n)&#123;</span><br><span class="line">        cnt=0;</span><br><span class="line">        for (int i = 1; i &lt;= n; ++i)&#123;</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">            cnt+=a[i]/100;</span><br><span class="line">            a[i]%=100;</span><br><span class="line">            cnt+=a[i]/50;</span><br><span class="line">            a[i]%=50;</span><br><span class="line">            cnt+=a[i]/10;</span><br><span class="line">            a[i]%=10;</span><br><span class="line">            cnt+=a[i]/5;</span><br><span class="line">            a[i]%=5;</span><br><span class="line">            cnt+=a[i]/2;</span><br><span class="line">            cnt+=(a[i]%2);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="惠民工程">1004 惠民工程</h3>
<blockquote>
<h4 id="题目描述-3">题目描述</h4>
<p>市政府“惠民工程”的目标是在全市n个居民点间之架设煤气管道（但不一定有直接的管道相连，只要能间接通过管道可达即可）。很显然最多可架设
n(n-1)/2条管道,然而实际上要连通n个居民点只需架设n-1条管道就可以了。现请你编写程序，计算出该惠民工程需要的最低成本。</p>
<h4 id="输入-3">输入</h4>
<p>测试输入包含若干测试用例。每个测试用例的第1行给出居民点数目M ( &lt;
=100 )、 评估的管道条数 N；随后的 N
行对应居民点间管道的成本，每行给出一对正整数，分别是两个居民点的编号，以及此两居民点间管道的成本（也是正整数）。为简单起见，居民点从1到M编号。</p>
<h4 id="输出-3">输出</h4>
<p>对每个测试用例，在1行里输出全市管道畅通所需要的最低成本。若统计数据不足以保证畅通，则输出“?”。</p>
<h4 id="样例输入-3">样例输入</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 1</span><br><span class="line">1 3 2</span><br><span class="line">2 3 4</span><br><span class="line">3 1</span><br><span class="line">2 3 2</span><br></pre></td></tr></table></figure>
<h4 id="样例输出-3">样例输出</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">?</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="年中南大学研究生复试机试题">2017年中南大学研究生复试机试题</h2>
<h3 id="切木棍">1020 切木棍</h3>
<blockquote>
<h4 id="题目描述-4">题目描述</h4>
<p>你有一根长度为n的木棍(n是整数)，现在需要你用这个木棍做一个矩形（但是不能是正方形），矩形的每条边的长度为整数。你可以将这个木棍切成四份，作为矩形的四条边，请问你组成多少种不同的矩形？</p>
<h4 id="输入-4">输入</h4>
<p>对于每组数据，输入一个整数，即为木棍的长度n（1&lt;=n&lt;=105）</p>
<h4 id="输出-4">输出</h4>
<p>对于每组数据，输出一个整数，表示能组成的矩形种数。</p>
<h4 id="样例输入-4">样例输入</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<h4 id="样例输出-4">样例输出</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h4 id="提示">提示</h4>
<p>数据量巨大，请使用scanf代替cin</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;n)!=-1)&#123;</span><br><span class="line">        if (n%4==0)</span><br><span class="line">            printf(&quot;%d\n&quot;,(n/2)/2-1);</span><br><span class="line">        else if(n%2!=0)</span><br><span class="line">            printf(&quot;0\n&quot;);</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;%d\n&quot;,n/2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="机器人走迷宫">1021 机器人走迷宫</h3>
<blockquote>

</blockquote>
<h3 id="淘金">1022 淘金</h3>
<p>先整行按规则取得最大值，再将所得最大值继续按规则取最大值</p>
<blockquote>
<h4 id="题目描述-5">题目描述</h4>
<p>在一片n*m的土地上，每一块1*1的区域里都有一定数量的金子。这一天，你到这里来淘金，然而当地人告诉你，如果你挖了某一区域的金子，上一行，下一行，左边，右边的金子你都不能被允许挖了。那么问题来了：你最多能淘金多少？</p>
<h4 id="输入-5">输入</h4>
<p>对于每组数据，第一行两个数n,m，表示土地的长和宽(1&lt;=n,m&lt;=200)</p>
<p>接下来n行,每行m个数，表示每个区域的金子数量，每个区域的金子数量不超过1000</p>
<h4 id="输出-5">输出</h4>
<p>对于每组数据，输出最多得到的金子数量</p>
<h4 id="样例输入-5">样例输入</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 6</span><br><span class="line">11 0 7 5 13 9</span><br><span class="line">78 4 81 6 22 4</span><br><span class="line">1 40 9 34 16 10</span><br><span class="line">11 22 0 33 39 6</span><br></pre></td></tr></table></figure>
<h4 id="样例输出-5">样例输出</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">242</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=210;</span><br><span class="line">int n,m;</span><br><span class="line">int a[N][N],dp[N][N]=&#123;&#125;,ans[N]=&#123;&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    while (cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">            for (int j = 1; j &lt;= m; ++j)</span><br><span class="line">                cin&gt;&gt;a[i][j];</span><br><span class="line">        for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i][1]=a[i][1];</span><br><span class="line">            dp[i][2]=max(a[i][1],a[i][2]);</span><br><span class="line">            for (int j = 3; j &lt;= m; ++j)</span><br><span class="line">                dp[i][j]=max(dp[i][j-2]+a[i][j],dp[i][j-1]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans[1]=dp[1][m];</span><br><span class="line">        ans[2]=max(dp[1][m],dp[2][m]);</span><br><span class="line">        for (int i = 3; i &lt;= n; ++i)</span><br><span class="line">            ans[i]=max(ans[i-1],ans[i-2]+dp[i][m]);</span><br><span class="line">        cout&lt;&lt;ans[n]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="巨人排队">1023 巨人排队</h3>
<h3 id="走路还是坐公交">1024 走路还是坐公交</h3>
<h2
id="年中南大学研究生复试机试题-1">2019年中南大学研究生复试机试题</h2>
<h2
id="年中南大学研究生复试机试题-2">2023年中南大学研究生复试机试题</h2>
<h3 id="进制转换">1595 进制转换</h3>
<blockquote>
<h4 id="题目描述-6">题目描述</h4>
<p>请写出一段程序，将十进制数字转为八进制。</p>
<h4 id="输入-6">输入</h4>
<p>第一行输入T(1&lt;=T&lt;=100)表示测试样例个数。
对于每一组样例，包含一个数字N(0&lt;=N&lt;=1e9)。</p>
<h4 id="输出-6">输出</h4>
<p>输出T个数字，代表转换成的八进制数（无前导0）。</p>
<h4 id="样例输入-6">样例输入</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">8</span><br><span class="line">100</span><br></pre></td></tr></table></figure>
<h4 id="样例输出-6">样例输出</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">144</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    long long x;</span><br><span class="line">    stack&lt;int&gt; q;</span><br><span class="line">    while (cin&gt;&gt;t)&#123;</span><br><span class="line">        while (t--)&#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            if (x==0)&#123;</span><br><span class="line">                cout&lt;&lt;0&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                while (x)&#123;</span><br><span class="line">                    q.push(x%8);</span><br><span class="line">                    x/=8;</span><br><span class="line">                &#125;</span><br><span class="line">                while (!q.empty())&#123;</span><br><span class="line">                    cout&lt;&lt;q.top();</span><br><span class="line">                    q.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                cout&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pipi数兔">1596 PIPI数兔</h3>
<blockquote>
<h4 id="题目描述-7">题目描述</h4>
<p>一对刚出生的小兔一个月后就能长大成大兔，再过一个月就能生下一对小兔，并且此后每个月都生一对小兔，假设兔子不会死亡。
PIPI有一对刚出生的兔子，n个月后繁殖成多少对兔子？</p>
<h4 id="输入-7">输入</h4>
<p>多组输入。每组样例输入一个正整数n(1&lt;=n&lt;=50)，表示月数。</p>
<h4 id="输出-7">输出</h4>
<p>对于每组样例输出一个正整数，表示最终兔子的数量。</p>
<h4 id="样例输入-7">样例输入</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h4 id="样例输出-7">样例输出</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>时间超限版本</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int solve(int x)&#123;</span><br><span class="line">    if (x==1||x==2)</span><br><span class="line">        return x;</span><br><span class="line">    else</span><br><span class="line">        return solve(x-1)+ solve(x-2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    while (cin&gt;&gt;n)&#123;</span><br><span class="line">        cout&lt;&lt;solve(n)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;bits/stdc++.h&quot;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">long long ans[50]=&#123;1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155,165580141,267914296,433494437,701408733,1134903170,1836311903,2971215073,4807526976,7778742049,12586269025,20365011074&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    while(cin&gt;&gt;n)&#123;</span><br><span class="line">        cout&lt;&lt;ans[n-1]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组查找">1597 数组查找</h3>
<blockquote>
<h4 id="题目描述-8">题目描述</h4>
<p>给定一个包含n个整数的升序序列和m个待查询的数字x，请你查找序列中x第一次出现的位置，如果不存在输出-1。</p>
<h4 id="输入-8">输入</h4>
<p>第一行输入序列长度n(1&lt;=n&lt;=1e5)和查询数量m(1&lt;=m&lt;=1e5)。
第二行输入n个整数，代表序列的值，序列每个元素的值x满足(0&lt;=x&lt;=1e6)。
接下来输入m个要查询的整数x(0&lt;=x&lt;=1e6)。</p>
<h4 id="输出-8">输出</h4>
<p>对于每个查询，输出要查询的整数在序列中第一次出现的位置，若不存在，输出-1。</p>
<h4 id="样例输入-8">样例输入</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br><span class="line">0 2 2 4 5</span><br><span class="line">2 4 3</span><br></pre></td></tr></table></figure>
<h4 id="样例输出-8">样例输出</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e5 + 10; // 定义数组的最大长度</span><br><span class="line"></span><br><span class="line">int n, m, a[N], x; // n: 数组长度，m: 查询次数，a[N]: 存储数组，x: 查询的目标值</span><br><span class="line"></span><br><span class="line">// 二分查找函数，返回目标值在数组中的下标，若不存在则返回-1</span><br><span class="line">int check(int x)&#123;</span><br><span class="line">    int l = -1, r = n, mid; // 设置成开区间(l,r)，以便处理边界</span><br><span class="line">    while(l + 1 &lt; r)&#123; // 当区间长度大于1时继续循环</span><br><span class="line">        mid = (l + r)/2; // 计算中间位置</span><br><span class="line">        if(a[mid] &gt;= x) r = mid; // 如果中间值大于等于目标值，将右边界移到中间位置</span><br><span class="line">        else l = mid; // 否则将左边界移到中间位置</span><br><span class="line">    &#125;</span><br><span class="line">    return (a[r] == x ? r : -1); // 最终检查右边界是否等于目标值，是则返回下标，否则返回-1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m); // 输入数组长度和查询次数</span><br><span class="line">    for(int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]); // 输入数组元素</span><br><span class="line"></span><br><span class="line">    while(m--)&#123; // 处理每个查询</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;x); // 输入查询的目标值</span><br><span class="line">        printf(&quot;%d\n&quot;, check(x)); // 调用二分查找函数并输出结果</span><br><span class="line">    &#125;</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="旋转矩阵">1598 旋转矩阵</h3>
<blockquote>
<h4 id="题目描述-9">题目描述</h4>
<p>给定一个n*n的矩阵M，请将M顺时针旋转90°后输出。</p>
<h4 id="输入-9">输入</h4>
<p>第一行输入T(1&lt;=T&lt;=100)表示测试样例个数。
对于每一组样例，第一行输入数字n(1&lt;=n&lt;=100)，代表矩阵大小。
接下来输入一个n*n的二维整数数组，代表需要旋转的矩阵。</p>
<h4 id="输出-9">输出</h4>
<p>对于每一组样例，输出按顺时针旋转90°后的矩阵。</p>
<h4 id="样例输入-9">样例输入</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br></pre></td></tr></table></figure>
<h4 id="样例输出-9">样例输出</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">7 4 1</span><br><span class="line">8 5 2</span><br><span class="line">9 6 3</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 110;</span><br><span class="line"> </span><br><span class="line">int t, n, mp[N][N];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            for(int j = 1; j &lt;= n; j++)scanf(&quot;%d&quot;, &amp;mp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        // 顺时针旋转90度</span><br><span class="line">        // 针对每列的输出：从第1列的最后一行开始，到第1列的第一行依次输出，再处理第2列，...第n列</span><br><span class="line">        for(int j = 1; j &lt;= n; j++)&#123;</span><br><span class="line">            for(int i = n; i &gt;= 1; i --)&#123;</span><br><span class="line">                printf(&quot;%d &quot;, mp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="pipi的数字游戏">1599 PIPI的数字游戏</h3>
<blockquote>
<h4 id="题目描述-10">题目描述</h4>
<p>PIPI有n个数字，每个数字都可以重复选取。他想用这些数字累加出一个目标数m，请问他至少用多少个数字才能凑出m？如果无法凑出，输出-1。</p>
<h4 id="输入-10">输入</h4>
<p>第一行输入T（1&lt;=T&lt;=100）表示测试样例个数。
对于每一组样例，第一行有两个整数n（1&lt;=n&lt;=500）和 m
(1&lt;=m&lt;=1000)。
第二行包含n个整数，每个整数的值x满足（0&lt;=x&lt;=1000）。</p>
<h4 id="输出-10">输出</h4>
<p>对于每组样例，输出最少需要的数字数量，不能凑出输出-1。</p>
<h4 id="样例输入-10">样例输入</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 6</span><br><span class="line">1 2 3</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure>
<h4 id="样例输出-10">样例输出</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line">int t, n, m, dp[1010], nums[505];</span><br><span class="line"></span><br><span class="line">int solve() &#123;</span><br><span class="line">    memset(dp, 0x3f, sizeof dp); // dp[i]表示凑出数字i所需要的最少数字个数</span><br><span class="line">    dp[0] = 0;  // 凑出数字0不需要任何数字</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= m; ++i) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            if (i &gt;= nums[j] &amp;&amp; dp[i - nums[j]] != INF) &#123;</span><br><span class="line">                dp[i] = min(dp[i], dp[i - nums[j]] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[m] == INF ? -1 : dp[m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    while (t--) &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) cin &gt;&gt; nums[i];</span><br><span class="line">        cout &lt;&lt; solve() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="赛车游戏">1600 赛车游戏</h3>
<blockquote>
<h4 id="题目描述-11">题目描述</h4>
<p>一条赛道上有n个停车点，每个停车点都有一辆车，第i辆车可以最多行驶a[i]个停车点。
PIPI可以在任意一个停车点换车，问PIPI最少换几次车可以到达终点（第n个停车点）。</p>
<h4 id="输入-11">输入</h4>
<p>第一行输入T（1&lt;=T&lt;=100）表示测试样例个数。
对于每组样例，第一行输入停车点数量n(1&lt;=n&lt;=1e5)。
第二行输入n个整数，代表第i辆车最多可以行驶a[i]个停车点(0&lt;=a[i]&lt;=1000)。</p>
<h4 id="输出-11">输出</h4>
<p>对于每组测试用例，输出到达终点的最少换车次数。如果不能到达终点，输出-1。</p>
<h4 id="样例输入-11">样例输入</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br><span class="line">2 3 1 1 4</span><br><span class="line">3</span><br><span class="line">3 2 1</span><br><span class="line">3</span><br><span class="line">1 0 2</span><br></pre></td></tr></table></figure>
<h4 id="样例输出-11">样例输出</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e5 + 10;</span><br><span class="line"> </span><br><span class="line">int t, n, a[N];</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">        </span><br><span class="line">        int start = 1,end = 1, pos; </span><br><span class="line">        int ans = 0; // ans表示到达[start,end]所需的最少步数</span><br><span class="line">        while(ans &lt;= n)&#123; //ans最大为n - 1步，每个停车点走一步，这里也可以将条件改成ans &lt; n</span><br><span class="line">            pos = end;</span><br><span class="line">            for(int j = start; j &lt;= end; j++) pos = max(pos, j + a[j]); //pos表示当前步数下，所能到达的最远位置</span><br><span class="line">            if(pos &gt;= n) break; // 当前步数下，已经可以到达终点，结束</span><br><span class="line">            start = end + 1;  // 下一步遍历的最左端</span><br><span class="line">            end = pos; // 下一步遍历的最右端</span><br><span class="line">            ans++; // 步数+1</span><br><span class="line">        &#125;</span><br><span class="line">        if(pos &lt; n) printf(&quot;-1\n&quot;);</span><br><span class="line">        else printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/09/08/14/" rel="prev" title="“高（岗）饶（漱石）反党集团”是一大冤案">
      <i class="fa fa-chevron-left"></i> “高（岗）饶（漱石）反党集团”是一大冤案
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE"><span class="nav-number">1.</span> <span class="nav-text">算法基础课</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E8%AE%B2-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.</span> <span class="nav-text">第一讲 基础算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-785.-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">1.1.1.</span> <span class="nav-text">AcWing 785. 快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-786.-%E7%AC%ACk%E4%B8%AA%E6%95%B0"><span class="nav-number">1.1.2.</span> <span class="nav-text">AcWing 786. 第k个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-787.-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">1.1.3.</span> <span class="nav-text">AcWing 787. 归并排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-788.-%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F"><span class="nav-number">1.1.4.</span> <span class="nav-text">AcWing 788. 逆序对的数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-789.-%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="nav-number">1.1.5.</span> <span class="nav-text">AcWing 789. 数的范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-790.-%E6%95%B0%E7%9A%84%E4%B8%89%E6%AC%A1%E6%96%B9%E6%A0%B9"><span class="nav-number">1.1.6.</span> <span class="nav-text">AcWing 790. 数的三次方根</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-791.-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95"><span class="nav-number">1.1.7.</span> <span class="nav-text">AcWing 791. 高精度加法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-792.-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95"><span class="nav-number">1.1.8.</span> <span class="nav-text">AcWing 792. 高精度减法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-793.-%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95"><span class="nav-number">1.1.9.</span> <span class="nav-text">AcWing 793. 高精度乘法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-794.-%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95"><span class="nav-number">1.1.10.</span> <span class="nav-text">AcWing 794. 高精度除法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-795.-%E5%89%8D%E7%BC%80%E5%92%8C"><span class="nav-number">1.1.11.</span> <span class="nav-text">AcWing 795. 前缀和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-796.-%E5%AD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E5%92%8C"><span class="nav-number">1.1.12.</span> <span class="nav-text">AcWing 796. 子矩阵的和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-797.-%E5%B7%AE%E5%88%86"><span class="nav-number">1.1.13.</span> <span class="nav-text">AcWing 797. 差分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-798.-%E5%B7%AE%E5%88%86%E7%9F%A9%E9%98%B5"><span class="nav-number">1.1.14.</span> <span class="nav-text">AcWing 798. 差分矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-799.-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">1.1.15.</span> <span class="nav-text">AcWing 799.
最长连续不重复子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-800.-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="nav-number">1.1.16.</span> <span class="nav-text">AcWing 800. 数组元素的目标和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-801.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">1.1.17.</span> <span class="nav-text">AcWing 801. 二进制中1的个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-802.-%E5%8C%BA%E9%97%B4%E5%92%8C"><span class="nav-number">1.1.18.</span> <span class="nav-text">AcWing 802. 区间和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-803.-%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6"><span class="nav-number">1.1.19.</span> <span class="nav-text">AcWing 803. 区间合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-2816.-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">1.1.20.</span> <span class="nav-text">AcWing 2816. 判断子序列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">第二讲 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-826.-%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-number">1.2.1.</span> <span class="nav-text">AcWing 826. 单链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-827.-%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="nav-number">1.2.2.</span> <span class="nav-text">AcWing 827. 双链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-828.-%E6%A8%A1%E6%8B%9F%E6%A0%88"><span class="nav-number">1.2.3.</span> <span class="nav-text">AcWing 828. 模拟栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-3302.-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-number">1.2.4.</span> <span class="nav-text">AcWing 3302. 表达式求值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-829.-%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97"><span class="nav-number">1.2.5.</span> <span class="nav-text">AcWing 829. 模拟队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-830.-%E5%8D%95%E8%B0%83%E6%A0%88"><span class="nav-number">1.2.6.</span> <span class="nav-text">AcWing 830. 单调栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-154.-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">1.2.7.</span> <span class="nav-text">AcWing 154. 滑动窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-831.-kmp%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.2.8.</span> <span class="nav-text">AcWing 831. KMP字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-835.-trie%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%9F%E8%AE%A1"><span class="nav-number">1.2.9.</span> <span class="nav-text">AcWing 835. Trie字符串统计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-143.-%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%AF%B9"><span class="nav-number">1.2.10.</span> <span class="nav-text">AcWing 143. 最大异或对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-836.-%E5%90%88%E5%B9%B6%E9%9B%86%E5%90%88"><span class="nav-number">1.2.11.</span> <span class="nav-text">AcWing 836. 合并集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-837.-%E8%BF%9E%E9%80%9A%E5%9D%97%E4%B8%AD%E7%82%B9%E7%9A%84%E6%95%B0%E9%87%8F"><span class="nav-number">1.2.12.</span> <span class="nav-text">AcWing 837. 连通块中点的数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-240.-%E9%A3%9F%E7%89%A9%E9%93%BE"><span class="nav-number">1.2.13.</span> <span class="nav-text">AcWing 240. 食物链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-838.-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">1.2.14.</span> <span class="nav-text">AcWing 838. 堆排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-839.-%E6%A8%A1%E6%8B%9F%E5%A0%86"><span class="nav-number">1.2.15.</span> <span class="nav-text">AcWing 839. 模拟堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-840.-%E6%A8%A1%E6%8B%9F%E6%95%A3%E5%88%97%E8%A1%A8"><span class="nav-number">1.2.16.</span> <span class="nav-text">AcWing 840. 模拟散列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-841.-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C"><span class="nav-number">1.2.17.</span> <span class="nav-text">AcWing 841. 字符串哈希</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E8%AE%B2-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA"><span class="nav-number">1.3.</span> <span class="nav-text">第三讲 搜索与图论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-842.-%E6%8E%92%E5%88%97%E6%95%B0%E5%AD%97"><span class="nav-number">1.3.1.</span> <span class="nav-text">AcWing 842. 排列数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-843.-n-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.2.</span> <span class="nav-text">AcWing 843. n-皇后问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-844.-%E8%B5%B0%E8%BF%B7%E5%AE%AB"><span class="nav-number">1.3.3.</span> <span class="nav-text">AcWing 844. 走迷宫</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-845.-%E5%85%AB%E6%95%B0%E7%A0%81"><span class="nav-number">1.3.4.</span> <span class="nav-text">AcWing 845. 八数码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-846.-%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83"><span class="nav-number">1.3.5.</span> <span class="nav-text">AcWing 846. 树的重心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-847.-%E5%9B%BE%E4%B8%AD%E7%82%B9%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="nav-number">1.3.6.</span> <span class="nav-text">AcWing 847. 图中点的层次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-848.-%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E5%BA%8F%E5%88%97"><span class="nav-number">1.3.7.</span> <span class="nav-text">AcWing 848. 有向图的拓扑序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-849.-dijkstra%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%E2%85%B0"><span class="nav-number">1.3.8.</span> <span class="nav-text">AcWing 849.
Dijkstra求最短路Ⅰ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-850.-dijkstra%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF-%E2%85%B1"><span class="nav-number">1.3.9.</span> <span class="nav-text">AcWing 850. Dijkstra求最短路
Ⅱ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-853.-%E6%9C%89%E8%BE%B9%E6%95%B0%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="nav-number">1.3.10.</span> <span class="nav-text">AcWing 853.
有边数限制的最短路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-851.-spfa%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="nav-number">1.3.11.</span> <span class="nav-text">AcWing 851. spfa求最短路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-852.-spfa%E5%88%A4%E6%96%AD%E8%B4%9F%E7%8E%AF"><span class="nav-number">1.3.12.</span> <span class="nav-text">AcWing 852. spfa判断负环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-854.-floyd%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="nav-number">1.3.13.</span> <span class="nav-text">AcWing 854. Floyd求最短路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-858.-prim%E7%AE%97%E6%B3%95%E6%B1%82%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">1.3.14.</span> <span class="nav-text">AcWing 858.
Prim算法求最小生成树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-859.-kruskal%E7%AE%97%E6%B3%95%E6%B1%82%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">1.3.15.</span> <span class="nav-text">AcWing 859.
Kruskal算法求最小生成树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-860.-%E6%9F%93%E8%89%B2%E6%B3%95%E5%88%A4%E5%AE%9A%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="nav-number">1.3.16.</span> <span class="nav-text">AcWing 860. 染色法判定二分图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-861.-%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D"><span class="nav-number">1.3.17.</span> <span class="nav-text">AcWing 861. 二分图的最大匹配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86"><span class="nav-number">1.4.</span> <span class="nav-text">第四讲 数学知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E8%AE%B2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">1.5.</span> <span class="nav-text">第五讲 动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-2.-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">1.5.1.</span> <span class="nav-text">AcWing 2. 01背包问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-3.-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">1.5.2.</span> <span class="nav-text">AcWing 3. 完全背包问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-4.-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">1.5.3.</span> <span class="nav-text">AcWing 4. 多重背包问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-898.-%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="nav-number">1.5.4.</span> <span class="nav-text">AcWing 898. 数字三角形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-895.-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">1.5.5.</span> <span class="nav-text">AcWing 895. 最长上升子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-897.-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">1.5.6.</span> <span class="nav-text">AcWing 897. 最长公共子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-902.-%E6%9C%80%E7%9F%AD%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="nav-number">1.5.7.</span> <span class="nav-text">AcWing 902. 最短编辑距离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-899.-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="nav-number">1.5.8.</span> <span class="nav-text">AcWing 899. 编辑距离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-282.-%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6"><span class="nav-number">1.5.9.</span> <span class="nav-text">AcWing 282. 石子合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-900.-%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86"><span class="nav-number">1.5.10.</span> <span class="nav-text">AcWing 900. 整数划分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-285.-%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A"><span class="nav-number">1.5.11.</span> <span class="nav-text">AcWing 285. 没有上司的舞会</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-901.-%E6%BB%91%E9%9B%AA"><span class="nav-number">1.5.12.</span> <span class="nav-text">AcWing 901. 滑雪</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E8%AE%B2-%E8%B4%AA%E5%BF%83"><span class="nav-number">1.6.</span> <span class="nav-text">第六讲 贪心</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-905.-%E5%8C%BA%E9%97%B4%E9%80%89%E7%82%B9"><span class="nav-number">1.6.1.</span> <span class="nav-text">AcWing 905. 区间选点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-908.-%E6%9C%80%E5%A4%A7%E4%B8%8D%E7%9B%B8%E4%BA%A4%E5%8C%BA%E9%97%B4%E6%95%B0%E9%87%8F"><span class="nav-number">1.6.2.</span> <span class="nav-text">AcWing 908.
最大不相交区间数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-906.-%E5%8C%BA%E9%97%B4%E5%88%86%E7%BB%84"><span class="nav-number">1.6.3.</span> <span class="nav-text">AcWing 906. 区间分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-907.-%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96"><span class="nav-number">1.6.4.</span> <span class="nav-text">AcWing 907. 区间覆盖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-148.-%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90"><span class="nav-number">1.6.5.</span> <span class="nav-text">AcWing 148. 合并果子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-913.-%E6%8E%92%E9%98%9F%E6%89%93%E6%B0%B4"><span class="nav-number">1.6.6.</span> <span class="nav-text">AcWing 913. 排队打水</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#acwing-104.-%E8%B4%A7%E4%BB%93%E9%80%89%E5%9D%80"><span class="nav-number">1.6.7.</span> <span class="nav-text">AcWing 104. 货仓选址</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%AD%E5%8D%97%E5%A4%A7%E5%AD%A6%E5%BE%80%E5%B9%B4%E6%9C%BA%E8%AF%95%E9%A2%98%E7%9B%AE"><span class="nav-number">2.</span> <span class="nav-text">中南大学往年机试题目</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B4%E4%B8%AD%E5%8D%97%E5%A4%A7%E5%AD%A6%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95%E6%9C%BA%E8%AF%95"><span class="nav-number">2.1.</span> <span class="nav-text">2013年中南大学研究生复试机试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E6%96%87%E4%B8%B2%E9%97%AE%E9%A2%98"><span class="nav-number">2.1.1.</span> <span class="nav-text">1000 回文串问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">样例输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA"><span class="nav-number">2.1.1.5.</span> <span class="nav-text">样例输出</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0"><span class="nav-number">2.1.2.</span> <span class="nav-text">1001 水仙花数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E5%AF%86%E7%A0%81"><span class="nav-number">2.1.3.</span> <span class="nav-text">1002 安全密码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-1"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5-1"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA-1"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-1"><span class="nav-number">2.1.3.4.</span> <span class="nav-text">样例输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-1"><span class="nav-number">2.1.3.5.</span> <span class="nav-text">样例输出</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B0%91%E9%92%B1%E5%B8%81%E6%95%B0"><span class="nav-number">2.1.4.</span> <span class="nav-text">1003 最少钱币数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5-2"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA-2"><span class="nav-number">2.1.4.3.</span> <span class="nav-text">输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-2"><span class="nav-number">2.1.4.4.</span> <span class="nav-text">样例输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-2"><span class="nav-number">2.1.4.5.</span> <span class="nav-text">样例输出</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%83%A0%E6%B0%91%E5%B7%A5%E7%A8%8B"><span class="nav-number">2.1.5.</span> <span class="nav-text">1004 惠民工程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="nav-number">2.1.5.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5-3"><span class="nav-number">2.1.5.2.</span> <span class="nav-text">输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA-3"><span class="nav-number">2.1.5.3.</span> <span class="nav-text">输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-3"><span class="nav-number">2.1.5.4.</span> <span class="nav-text">样例输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-3"><span class="nav-number">2.1.5.5.</span> <span class="nav-text">样例输出</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B4%E4%B8%AD%E5%8D%97%E5%A4%A7%E5%AD%A6%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95%E6%9C%BA%E8%AF%95%E9%A2%98"><span class="nav-number">2.2.</span> <span class="nav-text">2017年中南大学研究生复试机试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E6%9C%A8%E6%A3%8D"><span class="nav-number">2.2.1.</span> <span class="nav-text">1020 切木棍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5-4"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA-4"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-4"><span class="nav-number">2.2.1.4.</span> <span class="nav-text">样例输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-4"><span class="nav-number">2.2.1.5.</span> <span class="nav-text">样例输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%90%E7%A4%BA"><span class="nav-number">2.2.1.6.</span> <span class="nav-text">提示</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B5%B0%E8%BF%B7%E5%AE%AB"><span class="nav-number">2.2.2.</span> <span class="nav-text">1021 机器人走迷宫</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%98%E9%87%91"><span class="nav-number">2.2.3.</span> <span class="nav-text">1022 淘金</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-5"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5-5"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA-5"><span class="nav-number">2.2.3.3.</span> <span class="nav-text">输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-5"><span class="nav-number">2.2.3.4.</span> <span class="nav-text">样例输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-5"><span class="nav-number">2.2.3.5.</span> <span class="nav-text">样例输出</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A8%E4%BA%BA%E6%8E%92%E9%98%9F"><span class="nav-number">2.2.4.</span> <span class="nav-text">1023 巨人排队</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%B0%E8%B7%AF%E8%BF%98%E6%98%AF%E5%9D%90%E5%85%AC%E4%BA%A4"><span class="nav-number">2.2.5.</span> <span class="nav-text">1024 走路还是坐公交</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B4%E4%B8%AD%E5%8D%97%E5%A4%A7%E5%AD%A6%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95%E6%9C%BA%E8%AF%95%E9%A2%98-1"><span class="nav-number">2.3.</span> <span class="nav-text">2019年中南大学研究生复试机试题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B4%E4%B8%AD%E5%8D%97%E5%A4%A7%E5%AD%A6%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95%E6%9C%BA%E8%AF%95%E9%A2%98-2"><span class="nav-number">2.4.</span> <span class="nav-text">2023年中南大学研究生复试机试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.4.1.</span> <span class="nav-text">1595 进制转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-6"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5-6"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA-6"><span class="nav-number">2.4.1.3.</span> <span class="nav-text">输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-6"><span class="nav-number">2.4.1.4.</span> <span class="nav-text">样例输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-6"><span class="nav-number">2.4.1.5.</span> <span class="nav-text">样例输出</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pipi%E6%95%B0%E5%85%94"><span class="nav-number">2.4.2.</span> <span class="nav-text">1596 PIPI数兔</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-7"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5-7"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA-7"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-7"><span class="nav-number">2.4.2.4.</span> <span class="nav-text">样例输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-7"><span class="nav-number">2.4.2.5.</span> <span class="nav-text">样例输出</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE"><span class="nav-number">2.4.3.</span> <span class="nav-text">1597 数组查找</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-8"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5-8"><span class="nav-number">2.4.3.2.</span> <span class="nav-text">输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA-8"><span class="nav-number">2.4.3.3.</span> <span class="nav-text">输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-8"><span class="nav-number">2.4.3.4.</span> <span class="nav-text">样例输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-8"><span class="nav-number">2.4.3.5.</span> <span class="nav-text">样例输出</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5"><span class="nav-number">2.4.4.</span> <span class="nav-text">1598 旋转矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-9"><span class="nav-number">2.4.4.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5-9"><span class="nav-number">2.4.4.2.</span> <span class="nav-text">输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA-9"><span class="nav-number">2.4.4.3.</span> <span class="nav-text">输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-9"><span class="nav-number">2.4.4.4.</span> <span class="nav-text">样例输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-9"><span class="nav-number">2.4.4.5.</span> <span class="nav-text">样例输出</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pipi%E7%9A%84%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F"><span class="nav-number">2.4.5.</span> <span class="nav-text">1599 PIPI的数字游戏</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-10"><span class="nav-number">2.4.5.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5-10"><span class="nav-number">2.4.5.2.</span> <span class="nav-text">输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA-10"><span class="nav-number">2.4.5.3.</span> <span class="nav-text">输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-10"><span class="nav-number">2.4.5.4.</span> <span class="nav-text">样例输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-10"><span class="nav-number">2.4.5.5.</span> <span class="nav-text">样例输出</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%9B%E8%BD%A6%E6%B8%B8%E6%88%8F"><span class="nav-number">2.4.6.</span> <span class="nav-text">1600 赛车游戏</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-11"><span class="nav-number">2.4.6.1.</span> <span class="nav-text">题目描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5-11"><span class="nav-number">2.4.6.2.</span> <span class="nav-text">输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA-11"><span class="nav-number">2.4.6.3.</span> <span class="nav-text">输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%85%A5-11"><span class="nav-number">2.4.6.4.</span> <span class="nav-text">样例输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-11"><span class="nav-number">2.4.6.5.</span> <span class="nav-text">样例输出</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="赋倖"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">赋倖</p>
  <div class="site-description" itemprop="description">长夜梦旅有尽时</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/SkyTravelar" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SkyTravelar" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://www.shilinli.com/" title="http:&#x2F;&#x2F;www.shilinli.com&#x2F;" rel="noopener" target="_blank">indexss's</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">赋倖</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
