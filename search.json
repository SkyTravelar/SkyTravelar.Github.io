[{"title":"对二十个数进行排序","url":"/2022/12/12/10/","content":"```\ndata segment\narray \tdw 40 dup(0)\nten \tdb 10 \nfuyi \tdw -1\t\nflag\tdb 0\ndata ends\n\nstack segment \n\tdw 40 dup(0)\nstack ends\n\nassume cs:code, ds:data, ss:stack\n\ncode segment\n\tstart:\t\t\n\t\tmov ax,data\n        mov ds,ax\n        mov ax,stack\n        mov ss,ax\n        mov sp,80\n        mov si,0 \n        mov cx,20\t\n        call scan\t\n        mov cx,20\n        call sort\n        mov si,0\n        mov cx,20\n        call to_char\n        mov ax,4c00h\n        int 21h\n\tscan:\t\t\n\t\tpush ax\n        push bx\n        push dx\n\tl1:\t\t\n\t\tmov dx,0\t\t\t\n\tll2:\t\n\t\tmov ah,1\n        int 21h\t\t\t\t\n        cmp al,' '\n        je continue\t\t\t\n        cmp al,'-'\n        je negtive\t\t\t\n        sub al,30h\n        mov bl,al \n        mov ax,array[si]\n        mul ten\n        mov bh,0\n        add ax,bx\n        mov array[si],ax\n        jmp ll2\t\t\nnegtive:\n        inc dx\t\n        jmp ll2\t\t\t\ncontinue:\t\t\t\t\t\t\t\n        cmp dx,0\t\t\t\n        je l\t\n        mov ax,array[si]\n        imul fuyi\n        mov array[si],ax\n\t\tl:\t\n        add si,2\n        loop l1\n        pop dx\n        pop bx\n        pop ax\n        ret\n\tsort:\t\t\n\t\tpush di\n        push bx\n        push ax\t\t\t\n\t\tdec cx\n\ts1:\t\t\n\t\tmov di,cx\n\t\tmov bx,0\n    s2:\t\t\n    \tmov ax,array[bx]\n        cmp ax,array[bx+2]\n        jle s3\n        xchg ax,array[bx+2]\n        mov array[bx],ax\n\ts3:\t\t\n\t\tadd bx,2\n        loop s2\t\t\t\n        mov cx,di\n        loop s1\t\t\t\n        pop ax\n        pop bx\n        pop di\n        ret\t\t\t\nto_char:\n    \tpush ax\n    \tpush bx\n    \tpush dx\n    \tpush di   \t\n    \tmov dl,0ah\t\n    \tmov ah,2\n    \tint 21h    \t\n\tl2:\t\t\n\t\tpush cx\n\t\tmov bx,0\n\t\tmov flag,0\n\tl3:\t\t\t\t\t\t\t\t\t\t\t\n\t\tmov ax,[si]\n\t\tand ah,10000000b\n\t\tcmp ah,0\n\t\tje b\t\t\t\t\n\t\tmov ax,[si]\t\t\t\n\t\timul fuyi\n\t\tmov [si],ax\n\t\tmov flag,1\t\t\t\t\t\n\tb:\t\n\t\tinc bx\t\n\t\tmov cx,10\n\t\tcall divtw\n    \tmov dh,7\n    \tadd dl,30h\n    \tpush dx\t\n    \tcmp word ptr [si],0\n    \tje j\n    \tloop l3    \t\n    j:\t\n    \tcmp flag,1\n    \tjne q\n    \tinc bx\n\t\tmov dh,7\n\t\tmov dl,'-'\n\t\tpush dx    \t\n    q:\t\n    \tmov cx,bx\n    k:\t\n    \tpop dx\n    \tmov ah,2\n    \tint 21h\n    \tloop k\n    \tmov dl,' '\n    \tmov ah,2\n    \tint 21h    \t\n    \tpop cx\n   \t\tadd si,2\n    \tloop l2    \t\n    \tpop di\n    \tpop dx\n    \tpop bx\n    \tpop ax\n    \tret    \t\n divtw:\n \t\tpush ax\t\t\n\t\tmov dx,0\n\t\tmov ax,[si]\n\t\tdiv cx\n\t\tmov [si],ax\t\t\n\t\tpop ax\n\t\tret\t\t\t\t\t\t\t\t\ncode ends\nend start\n```\n\n","tags":["汇编"]},{"title":"输出斐波拉契数列前20项","url":"/2022/12/12/9/","content":"```\nDATAS SEGMENT\n VAL    DW 20 DUP(0)\nDATAS ENDS\nSTACKS SEGMENT\n DW 30 DUP(0)\nSTACKS ENDS\nCODES SEGMENT\n    ASSUME CS:CODES,DS:DATAS,SS:DATAS\nSTART:\n    MOV AX,DATAS\n    MOV DS,AX\n    MOV AX,STACKS\n    MOV SS,AX\n    MOV DI,0\n    MOV AX,1\n    MOV DX,1\n    JMP FIBO\n    \nFIBO:   MOV VAL[DI],AX\n\t\tADD DI,2\n\t\tMOV VAL[DI],DX\n\t\tADD DI,2\n\t\tADD AX,DX\n\t\tADD DX,AX\n\t\tCMP DI,40\n\t\tJAE  BACK\n\t\tCALL FIBO\n\t\tRET\n\t  \nBACK:   \n  MOV DI,0\n   MOV CX,20\n   MOV DX,0\n   \nL1:    \n        MOV AX,VAL[DI]\n  ADD DI,2\n  CMP AX,1000\n  JNB P1\n  CMP AX,100\n  JNB P2\n  CMP AX,10\n  JNB P3\n  CMP AX,1\n  JNB P4\n\n  \nP1:  MOV BX,1000\n  DIV BX\n  PUSH DX\n  MOV DX,AX\n  ADD DL,30H\n  MOV AH,2H\n  INT 21H\n  POP AX\n  MOV DX,0\n  \nP2:  MOV BX,100\n  DIV BX\n  PUSH DX\n  MOV DX,AX\n  ADD DL,30H\n  MOV AH,2H\n  INT 21H\n  POP AX\n  MOV DX,0\n  \nP3:     MOV BX,10\n  DIV BX\n  PUSH DX\n  MOV DX,AX\n  ADD DL,30H\n  MOV AH,2H\n  INT 21H\n  POP AX\n  MOV DX,0\n  \nP4:    \n        MOV BX,1\n  DIV BX\n  PUSH DX\n  MOV DX,AX\n  ADD DL,30H\n  MOV AH,2H\n  INT 21H\n  POP AX\n  \n  MOV DL,32\n  MOV AH,2H\n  INT 21H\n  MOV DX,0\n  LOOP L1\n  \n  MOV AX,4C00H\n  INT 21H\nCODES ENDS\n    END START\n\n```\n\n","tags":["汇编"]},{"title":"输出斐波拉契数列前50项","url":"/2022/12/12/8/","content":"```\nDATAS SEGMENT\n\tDW 200 DUP(0)\n   \nDATAS ENDS\n\nSTACKS SEGMENT\n    DW 30 DUP(0)\nSTACKS ENDS\n\nCODES SEGMENT\n    ASSUME CS:CODES,DS:DATAS,SS:STACKS\nSTART:\n\t.386\n\tMOV AX,DATAS\n\tMOV DS,AX\n\tMOV AX,STACKS\n\tMOV SS,AX\n\tMOV SI,0\n\tMOV DI,0 \n\tMOV EAX,1\n\tMOV EDX,0\n\tJMP PRINT11\nA:\n\tCALL FIBO\n\nFIBO:\n\tCMP DI,392\n\tJE BACK\n\t\n\tCMP DI,0\t\n\tJE SET1\n\nSET1BACK:\n\tCMP DI,8\n\tJE SET2\n\nSET2BACK:\n\tADD DI,8\n\tMOV EAX,DS:[DI-8]\n\tMOV EDX,DS:[DI-4]\n\tMOV ECX,DS:[DI-12]\n\tMOV EBX,DS:[DI-16]\n\tADD EAX,EBX\n\tADC EDX,ECX\n\tMOV DS:[DI],EAX\n\tMOV DS:[DI+4],EDX\n\tCALL PRINT\n\nPRINTBACK:\t\n\tCALL FIBO\n\t\n;==================================================\nSET1:\n\tMOV DS:[0],EAX\n\tMOV DS:[4],EDX\n\tADD DI,8\n\tJMP SET1BACK\n;==================================================\nSET2:\n\tMOV DS:[8],EAX\n\tMOV DS:[12],EDX\n\tJMP SET2BACK\n;==================================================\t\n\n;PRINT EDX EAX\nPRINT:\n\tPUSH EAX\n\tPUSH EBX\n\tPUSH ECX\n\tPUSH EDX\n\tCMP EDX,10B\n\tJNB P1\n\tCMP EDX,0\n\tJA  P2\n\tCMP EAX,1000000000\n\tJNB P2\n\tCMP EAX,100000000\n\tJNB P3\n\tCMP EAX,10000000\n\tJNB P4\n\tCMP EAX,1000000\n\tJNB P5\n\tCMP EAX,100000\n\tJNB P6\n\tCMP EAX,10000\n\tJNB P7\n\tCMP EAX,1000\n\tJNB P8\n\tCMP EAX,100\n\tJNB P9\n\tCMP EAX,10\n\tJNB P10\n\tCMP EAX,1\n\tJNB P11\n\nP1:\n\tMOV DL,1\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tMOV EAX,10011010001001110101010101100001B\n\tMOV EDX,0\n\nP2:\n\tMOV EBX,1000000000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP3:\n\tMOV EBX,100000000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP4:\n\tMOV EBX,10000000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP5:\n\tMOV EBX,1000000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP6:\n\tMOV EBX,100000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP7:\n\tMOV EBX,10000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP8:\n\tMOV EBX,1000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP9:\n\tMOV EBX,100\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP10:\n\tMOV EBX,10\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\t\n\nP11:\n\tMOV EBX,1\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\tMOV DL,32\n\tMOV AH,2H\n\tINT 21H\n\t\n\tPOP EDX\n\tPOP ECX\n\tPOP EBX\n\tPOP EAX\n\tJMP PRINTBACK\n;PRINT END\n\n\n;PRINT11\nPRINT11:\n\tPUSH EDX\n\tPUSH EAX\n\t\n\tMOV DL,1\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tMOV DL,32\n\tMOV AH,2H\n\tINT 21H\n\t\n\tMOV DL,1\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tMOV DL,32\n\tMOV AH,2H\n\tINT 21H\n\t\n\tPOP EAX\n\tPOP EDX\n\t\n\tJMP A\n\nBACK:\n\tMOV AX,4C00H\n   \tINT 21H\nCODES ENDS\n    END START\n```\n\n","tags":["汇编"]},{"title":"航班信息管理系统","url":"/2022/12/12/7/","content":"```\n#include <iostream>\n#include <string>   \n#include <iomanip>   \n#include <fstream> \n#include <random> \n#include <ctime>   \n#include <windows.h> \n\nusing namespace std;\n\ntypedef struct flightnode\n{\n\tstring flight_num;       //航班号\n\tstring time;             //起飞时间\n\tint date = 0;            //起飞日期\n\tstring start_place;      //出发地\n\tstring end_place;        //目的地\n\tfloat discount = 0;      //折扣\n\tint left = 0;            //余票\n\tfloat price = 0;         //价格\n\tflightnode* next = NULL;\n}*flightlist;\n\nstruct ticket\n{\n\tstring flight_num;\t  //航班号\n\tstring time;\t\t  //起飞时间\n\tstring start_place;\t  //出发地\n\tstring end_place;     //目的地\n\tfloat price = 0;      //价格\n\tint date = 0;         //起飞日期\n\tstring order_num;\t  //订单编号\n};\n\ntypedef struct passengernode\n{\n\tstring name;        //名字\n\tstring ID_num;      //证件号\n\tticket ticket;      //票\n\tint full = 0;       //预约标志  1表示预约状态\n\tpassengernode* next = NULL;\n}*passengerlist;\n\n//航班类信息\nvoid Init_flight(flightlist& h);\t\t//初始化航班\nvoid Load_flight(flightlist& h);\t\t//载入航班\nvoid Add_flight(flightlist& h);\t\t\t//添加航班\nvoid Check_flight(flightlist& h);\t\t//查找航班\nvoid Check_flightnum(flightlist& h);\t//航班号查找\nvoid Check_seplace(flightlist& h);\t\t//起始地查找\nvoid Check_all(flightlist& h);\t\t\t//浏览全部航班\nvoid Revise_flight(flightlist& h);\t\t//修改航班信息\nvoid Delete_flight(flightlist& h);\t\t//删除航班\nvoid Revise_time(flightlist& h);\t\t//修改起飞抵达时间\nvoid Revise_price(flightlist& h);\t\t//修改价格\nvoid Save_flight(flightlist& h);\t\t//保存航班信息\n//用户信息\nvoid Init_passenger(passengerlist& c);\t\t\t//初始化用户\nvoid Load_passenger(passengerlist& c);\t\t\t//载入用户信息\nvoid Book(flightlist& h, passengerlist& c);\t\t//定票\nvoid Qbook(flightlist& h, passengerlist& c);\t//退票\nvoid Check_book(passengerlist& c);\t\t\t\t//查询订单\nvoid Save_passenger(passengerlist& c);\t\t\t//保存用户信息\n//管理操作\nvoid manage(flightlist& flight, passengerlist& passenger);\nvoid password();//密码管理\n//通用\nvoid wait();\n\n\n\n\nvoid manage(flightlist& flight, passengerlist& passenger)\n{\n\twhile (1) {\n\t\tcout << \"航班信息管理系统\" << endl << endl;\n\t\tcout << \"主菜单\" << endl;\n\t\tcout << \"1.录入航班信息\" << endl;\n\t\tcout << \"2.查询航班\" << endl;\n\t\tcout << \"3.订票\" << endl;\n\t\tcout << \"4.退票\" << endl;\n\t\tcout << \"5.查询订单\" << endl;\n\t\tcout << \"6.修改航班信息\" << endl;\n\t\tcout << \"0.退出系统 \" << endl;\n\t\tcout << \"请输入您想要进行的功能：\";\n\t\tint i;\n\t\tcin >> i;\n\t\tsystem(\"cls\");\n\t\tswitch (i) {\n\t\tcase 1:Add_flight(flight); Save_flight(flight); wait(); break;\n\t\tcase 2:Check_flight(flight); wait(); break;\n\t\tcase 3:Book(flight, passenger); Save_flight(flight); Save_passenger(passenger); wait(); break;\n\t\tcase 4:Qbook(flight, passenger); Save_flight(flight); Save_passenger(passenger); wait(); break;\n\t\tcase 5:Check_book(passenger); wait(); break;\n\t\tcase 6:Revise_flight(flight); Save_flight(flight); wait(); break;\n\t\tcase 0:exit(0); break;\n\t\tdefault:cout << \"请检查你的输入！\" << endl; break;\n\t\t}\n\t}\n}\n\nvoid Sort_flight(flightlist& h)\n{\n\tflightlist p = h->next;  //指向第一个结点\n\twhile (p != NULL) {\n\t\tflightlist q = h->next;   //指向p后一个结点\n\t\twhile (q) {\n\t\t\tif (q->date > p->date) {\n\t\t\t\tflightnode temp = *p;   //临时保存指针交换\n\t\t\t\ttemp.next = q->next;\n\t\t\t\tq->next = p->next;\n\t\t\t\t*p = *q;\n\t\t\t\t*q = temp;\n\t\t\t}\n\t\t\tq = q->next;   //指针移动\n\t\t}\n\t\tp = p->next;    //指针移动\n\t}\n\n}\n\nvoid Init_flight(flightlist& h)//初始化航班\n{\n\th = new flightnode;  //头指针\n\th->next = NULL;\n}\n\nvoid Load_flight(flightlist& h)//载入航班\n{\n\tflightlist f = h;\n\tflightlist newp = new flightnode;\n\tifstream ifs(\"FlightList.txt\");\n\tif (!ifs.is_open()) {\n\t\tcout << \"文件未被打开！\" << endl;\n\t\treturn;\n\t}\n\twhile (ifs >> newp->flight_num >> newp->date >> newp->time >> newp->start_place >> newp->end_place >> newp->price >> newp->discount >> newp->left) {\n\t\tf->next = newp;\n\t\tf = f->next;\n\t\tnewp = new flightnode;\n\t}\n\tf->next = NULL;\n\tdelete newp;\n}\n\nvoid Add_flight(flightlist& h)//添加航班\n{\n\tchar mark = 'y';\n\tflightlist s, rear;\n\tfor (rear = h; rear->next != NULL; rear = rear->next) {}  // rear移动结点尾\n\twhile (mark == 'y' || mark == 'Y') {\n\t\ts = new flightnode;\n\t\tcout << \"请输入航班号：\";\n\t\tcin >> s->flight_num;\n\t\tcout << \"请输入起飞日期：\";\n\t\tcin >> s->date;\n\t\tcout << \"请输入起飞时间：\";\n\t\tcin >> s->time;\n\t\tcout << \"请输入出发地：\";\n\t\tcin >> s->start_place;\n\t\tcout << \"请输入目的地：\";\n\t\tcin >> s->end_place;\n\t\tcout << \"请输入价格：\";\n\t\tcin >> s->price;\n\t\tcout << \"请输入折扣：\";\n\t\tcin >> s->discount;\n\t\tcout << \"请输入余票：\";\n\t\tcin >> s->left;\n\t\trear->next = s;\n\t\trear = s;\n\t\tcout << \"添加成功！\" << endl;\n\t\tcout << \"是否继续添加？（是“y”/否“n”）：\";\n\t\tcin >> mark;\n\t}\n\trear->next = NULL;\n}\n\nvoid Check_flight(flightlist& h)//查找航班\n{\n\tint i;\n\tcout << \"查找方式\" << endl;\n\tcout << \"1.航班查找\" << endl;\n\tcout << \"2.起始地查找\" << endl;\n\tcout << \"3.浏览全部航班\" << endl;\n\tcout << \"请输入查找方式：\";\n\tcin >> i;\n\tswitch (i) {\n\tcase 1:Check_flightnum(h); break;\n\tcase 2:Check_seplace(h); break;\n\tcase 3:Check_all(h); break;\n\tdefault:break;\n\t}\n}\n\nvoid Check_flightnum(flightlist& h)//航班号查找\n{\n\tstring flightnum;\n\tflightlist p = h->next;\n\tcout << \"请输入航班号：\";\n\tcin >> flightnum;\n\tcout << setw(6) << \"航班号\" << setw(17) << \"起飞日期\" << setw(15) << \"起飞时间\" << setw(15) << \"出发地\" << setw(15) << \"目的地\" << setw(15) << \"价格\" << setw(15) << \"折扣\" << setw(15) << \"余票\" << endl;\n\twhile (p != NULL) {\n\t\tif (p->flight_num == flightnum) {\n\t\t\tcout << setw(6) << p->flight_num << setw(15) << p->date << \"日\" << setw(15) << p->time << setw(15) << p->start_place << setw(15) << p->end_place << setw(15) << p->price << setw(15) << p->discount << setw(15) << p->left << endl;\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t\tp = p->next;\n\t}\n\tcout << setw(32) << \"未查到任何信息。\";\n\twait();\n}\n\nvoid Check_seplace(flightlist& h)//起始地查找\n{\n\tstring start_place, end_place;\n\tcout << \"请输入出发地：\";\n\tcin >> start_place;\n\tcout << \"请输入目的地：\";\n\tcin >> end_place;\n\tflightlist p = h->next;\n\tcout << setw(6) << \"航班号\" << setw(17) << \"起飞日期\" << setw(15) << \"起飞时间\" << setw(15) << \"出发地\" << setw(15) << \"目的地\" << setw(15) << \"价格\" << setw(15) << \"折扣\" << setw(15) << \"余票\" << endl;\n\twhile (p != NULL) {\n\t\tif (p->start_place == start_place && p->end_place == end_place) {\n\t\t\tcout << setw(6) << p->flight_num << setw(15) << p->date << \"号\" << setw(15) << p->time << setw(15) << p->start_place << setw(15) << p->end_place << setw(15) << p->price << setw(15) << p->discount << setw(15) << p->left << endl;\n\t\t\treturn;\n\t\t}\n\t\tp = p->next;        //移动\n\t}\n\tcout << \"未查到任何信息\" << endl;\n\twait();\n}\n\nvoid Check_all(flightlist& h)//浏览全部航班\n{\n\tSort_flight(h);  //日期排序\n\tflightlist p = h->next;\n\tcout << setw(6) << \"航班号\" << setw(17) << \"起飞日期\" << setw(15) << \"起飞时间\" << setw(15) << \"出发地\" << setw(15) << \"目的地\" << setw(15) << \"价格\" << setw(15) << \"折扣\" << setw(15) << \"余票\" << endl;\n\twhile (p != NULL)\n\t{\n\t\tcout << setw(6) << p->flight_num << setw(15) << p->date << \"号\" << setw(15) << p->time << setw(15) << p->start_place << setw(15) << p->end_place << setw(15) << p->price << setw(15) << p->discount << setw(15) << p->left << endl;\n\t\tp = p->next;   //移动\n\t}\n}\n\nvoid Revise_flight(flightlist& h)//修改航班信息\n{\n\tflightlist f = h->next;\n\tint i;\n\tcout << \"修改内容:\" << endl;\n\tcout << \"1.删除航班\" << endl;\n\tcout << \"2.修改起飞时间\" << endl;\n\tcout << \"3.修改航班价格\" << endl;\n\tcout << \"4.返回\" << endl;\n\tcout << \"请输入查找方式：\";\n\tcin >> i;\n\tCheck_all(h);     //浏览全部\n\tswitch (i) {\n\tcase 1:Delete_flight(h); break;\n\tcase 2:Revise_time(h); break;\n\tcase 3:Revise_price(h); break;\n\tcase 4:return; break;\n\tdefault:cout << \"请检查你的输入！\" << endl; break;\n\t}\n}\n\nvoid Delete_flight(flightlist& h)//删除航班\n{\n\tflightlist p = h->next, q = h;  //q是p的前驱\n\tstring flightnum;\n\tcout << \"请输入您想要修改的航班号：\";\n\tcin >> flightnum;\n\twhile (p != NULL) {\n\t\tif (p->flight_num == flightnum) {\n\t\t\tq->next = p->next;      //p是要删除的结点，q是前一个结点\n\t\t\tdelete p;\n\t\t\tcout << \"删除成功！\";\n\t\t\twait();\n\t\t\treturn;\n\t\t}\n\t\tq = q->next;\n\t\tp = q->next;\n\t}\n\tcout << \"未查找到相关航班！\";\n\twait();\n}\n\nvoid Revise_time(flightlist& h)//修改起飞抵达时间\n{\n\tstring flightnum;\n\tflightlist p = h->next;\n\tcout << \"请输入您想要修改的航班号：\";\n\tcin >> flightnum;\n\twhile (p != NULL) {\n\t\tif (p->flight_num == flightnum) {\n\t\t\tcout << \"请输入新的起飞日期：\";\n\t\t\tcin >> p->date;\n\t\t\tcout << \"请输入新的起飞时间：\";\n\t\t\tcin >> p->time;\n\t\t\tcout << \"修改成功！\";\n\t\t\twait();\n\t\t\treturn;\n\t\t}\n\t\tp = p->next;\n\t}\n\tcout << \"没有您想要修改的航班号!\";\n\twait();\n}\n\nvoid Revise_price(flightlist& h)//修改价格\n{\n\tstring flightnum;\n\tflightlist p = h->next;\n\tcout << \"请输入您想要修改的航班号：\";\n\tcin >> flightnum;\n\twhile (p != NULL) {\n\t\tif (p->flight_num == flightnum) {\n\t\t\tcout << \"请输入新的价格：\";\n\t\t\tcin >> p->price;\n\t\t\tcout << \"请输入新的折扣：\";\n\t\t\tcin >> p->discount;\n\t\t\tcout << \"修改成功！\t\";\n\t\t\twait();\n\t\t\treturn;\n\t\t}\n\t\tp = p->next;\n\t}\n\tcout << \"没有您想要修改的航班号!\";\n\twait();\n}\n\nvoid Save_flight(flightlist& h)//保存航班信息\n{\n\tflightlist f = h->next;\n\tSort_flight(h);\n\tofstream ofs(\"FlightList.txt\");\n\tif (!ofs)\n\t{\n\t\tcout << \"存储失败！\";\n\t\treturn;\n\t}\n\twhile (f != NULL)\n\t{\n\t\tofs << f->flight_num << \" \" << f->date << \" \" << f->time << \" \" << f->start_place << \" \" << f->end_place << \" \" << f->price << \" \" << f->discount << \" \" << f->left << endl;\n\t\tf = f->next;\n\t}\n\tofs.close();   //关闭文件\n}\n\nvoid Init_passenger(passengerlist& c)//初始化用户\n{\n\tc = new passengernode;   //头结点\n\tc->next = NULL;\n}\n\nvoid Load_passenger(passengerlist& c)\n{\n\tpassengerlist p = c;\n\tpassengerlist newp = new passengernode;\n\tifstream ifs(\"PassengerList.txt\");\n\tif (!ifs.is_open()) {\n\t\tcout << \"文件未被打开！\" << endl;\n\t\treturn;\n\t}\n\tcout << \"数据读取成功！\" << endl;\n\tsystem(\"cls\");\n\twhile (ifs >> newp->name >> newp->ID_num >> newp->ticket.flight_num >> newp->ticket.date >> newp->ticket.time >> newp->ticket.start_place >> newp->ticket.end_place >> newp->ticket.price >> newp->ticket.order_num)\n\t{\n\t\tp->next = newp;\n\t\tp = p->next;\n\t\tnewp = new passengernode;\n\t}\n\tp->next = NULL;\n\tdelete newp;\n}\n\nvoid Book(flightlist& h, passengerlist& c)//订票\n{\n\tstring start_place, end_place, flightnum;\n\tint date;//航班信息\n\tflightlist p = h->next, q = h->next;\n\tpassengerlist s, r = c;\n\tchar mark, check = '1';\n\tchar mark02 = '1';         //标志\n\tfor (; r->next != NULL; r = r->next) {}   //r移动到结点尾\n\ts = new passengernode;\n\tcout << \"请输入乘客的姓名：\";\n\tcin >> s->name;\n\tcout << \"请输入乘客的证件号：\";\n\tcin >> s->ID_num;\n\tcout << \"请输入出发地：\";\n\tcin >> start_place;\n\tcout << \"请输入目的地：\";\n\tcin >> end_place;\n\tcout << \"请选择出发日期：\";\n\tcin >> date;\n\tcout << setw(6) << \"航班号\" << setw(17) << \"起飞日期\" << setw(15) << \"起飞时间\" << setw(15) << \"出发地\" << setw(15) << \"目的地\" << setw(15) << \"价格\" << setw(15) << \"折扣\" << setw(15) << \"余票\" << endl;\n\twhile (p != NULL)\n\t{\n\t\tif (p->start_place == start_place && p->end_place == end_place && p->date == date)//匹配日期相符的航班\n\t\t{\n\t\t\tcout << setw(6) << p->flight_num << setw(15) << p->date << \"号\" << setw(15) << p->time << setw(15) << p->start_place << setw(15) << p->end_place << setw(15) << p->price << setw(15) << p->discount << setw(15) << p->left << endl;\n\t\t\tcheck = '0';\n\t\t}\n\t\tp = p->next;\n\t}\n\tif (check == '1') {\n\t\tp = h->next;\n\t\tcout << \"无\" << setw(15) << \"无\" << setw(17) << \"无\" << setw(15) << \"无\" << setw(15) << \"无\" << setw(15) << \"无\" << setw(15) << \"无\" << setw(15) << \"无\" << endl;\n\t\tcout << \"该天没相关的航班\" << endl;\n\t\tif (mark02 == '1')\n\t\t\treturn;//结束\n\t}\n\tcout << \"是否进行购买？（Y/N）\";\n\tcin >> mark;\n\tif (mark == 'y' || mark == 'Y') {\n\t\tcout << \"请输入您想要购买的航班号：\";\n\t\tcin >> flightnum;\n\t\twhile (q != NULL) {\n\t\t\tif (q->flight_num == flightnum && q->start_place == start_place && q->end_place == end_place) {\n\t\t\t\tif (q->left == 0) {\n\t\t\t\t\tcout << \"余票不足，请选择是否预约（Y/N）\";\n\t\t\t\t\tcin >> mark;\n\t\t\t\t\tif (mark == 'y' || mark == 'Y') {\n\t\t\t\t\t\ts->full = 1;  //修改预约标志\n\t\t\t\t\t\ts->ticket.flight_num = flightnum;\n\t\t\t\t\t\ts->ticket.start_place = start_place;\n\t\t\t\t\t\ts->ticket.end_place = end_place;\n\t\t\t\t\t\ts->ticket.time = \"预约\";\n\t\t\t\t\t\ts->ticket.price = 000;\n\t\t\t\t\t\ts->ticket.date = date;\n\t\t\t\t\t\ts->ticket.order_num = \"预约\";\n\t\t\t\t\t\tcout << \" 预约成功\";\n\t\t\t\t\t\tr->next = s;\n\t\t\t\t\t\tr = s;\n\t\t\t\t\t\tr->next = NULL;\n\t\t\t\t\t\twait();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\treturn;  //不预约直接结束\n\t\t\t\t}\n\t\t\t\ts->ticket.flight_num = flightnum;\n\t\t\t\ts->ticket.start_place = start_place;\n\t\t\t\ts->ticket.end_place = end_place;\n\t\t\t\ts->ticket.time = q->time;\n\t\t\t\ts->ticket.price = q->price;\n\t\t\t\ts->ticket.date = q->date;\n\t\t\t\tsrand((unsigned int)time(0));\n\t\t\t\ts->ticket.order_num = q->flight_num + to_string(rand()) + to_string(rand());//订单编号\n\t\t\t\tr->next = s;\n\t\t\t\tr = s;\n\t\t\t\tr->next = NULL;\n\t\t\t\tcout << \"购票成功！\" << \"订单号为\" + s->ticket.order_num << endl;\n\t\t\t\tq->left--;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t\tq = q->next;\n\t\t}\n\t\tcout << \"航班号填入错误！\" << endl;\n\t\twait();\n\t}\n\telse {\n\t\treturn;//不进行购买直接结束\n\t}\n}\n\nvoid Qbook(flightlist& h, passengerlist& c)//退票\n{\n\tstring name, ID_num;\n\tbool mark = false;\n\tflightlist f = h->next;\n\tpassengerlist p = c->next, q = c, t = c->next;\n\tcout << \"请输入乘客的姓名：\";\n\tcin >> name;\n\tcout << \"请输入乘客的证件号：\";\n\tcin >> ID_num;\n\twhile (p != NULL) {\n\t\tif (p->name == name && p->ID_num == ID_num) {\n\t\t\tmark = true;   //找到乘客\n\t\t\twhile (f != NULL) {\n\t\t\t\tif (p->ticket.flight_num == f->flight_num) {\n\t\t\t\t\tf->left++;  //票数更新\n\t\t\t\t\twhile (t != NULL) {\n\t\t\t\t\t\tif (t->ticket.flight_num == p->ticket.flight_num && t->full == 1) {\n\t\t\t\t\t\t\tt->ticket.start_place = p->ticket.start_place;\n\t\t\t\t\t\t\tt->ticket.end_place = p->ticket.end_place;\n\t\t\t\t\t\t\tt->ticket.time = p->ticket.time;\n\t\t\t\t\t\t\tt->ticket.price = p->ticket.price;\n\t\t\t\t\t\t\tt->ticket.date = p->ticket.date;\n\t\t\t\t\t\t\tsrand((unsigned int)time(0));\n\t\t\t\t\t\t\tt->ticket.order_num = p->ticket.flight_num.c_str() + to_string(rand()) + to_string(rand());\n\t\t\t\t\t\t\tf->left--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt = t->next;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tf = f->next;\n\t\t\t}\n\t\t\tq->next = p->next;\n\t\t\tdelete p;\n\t\t\tcout << \"退票成功！\";\n\t\t\treturn;\n\t\t}\n\t\tq = q->next;\n\t\tp = q->next;\n\t}\n\tif (!mark) {\n\t\tcout << \"未找到相关乘客的订单\";\n\t\twait();\n\t}\n}\n\nvoid Check_book(passengerlist& c)//查询订票\n{\n\tstring name, ID_num;\n\tpassengerlist p = c->next;\n\tcout << \"请输入乘客的姓名：\";\n\tcin >> name;\n\tcout << \"请输入乘客的证件号：\";\n\tcin >> ID_num;\n\tcout << setw(8) << \"姓名\" << setw(15) << \"航班号\" << setw(17) << \"起飞日期\" << setw(15) << \"起飞时间\" << setw(15) << \"出发地\" << setw(15) << \"目的地\" << setw(15) << \"价格\" << setw(18) << \"订单编号\" << endl;\n\twhile (p != NULL) {\n\t\tif (p->name == name && p->ID_num == ID_num) {\n\t\t\tcout << setw(8) << p->name << setw(15) << p->ticket.flight_num << setw(15) << p->ticket.date << \"号\" << setw(15) << p->ticket.time << setw(15) << p->ticket.start_place << setw(15) << p->ticket.end_place << setw(15) << p->ticket.price << setw(18) << p->ticket.order_num << endl;\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t\tp = p->next;\n\t}\n\tcout << setw(32) << \"未查到任何信息。\";\n\twait();\n\treturn;\n}\n\nvoid Save_passenger(passengerlist& c)\n{\n\tpassengerlist p = c->next;\n\tofstream ofs(\"PassengerList.txt\");\n\tif (!ofs) {\n\t\tcout << \"存储失败！\";\n\t\treturn;\n\t}\n\twhile (p != NULL) {\n\t\tofs << p->name << \" \" << p->ID_num << \" \" << p->ticket.flight_num << \" \" << p->ticket.date << \" \" << p->ticket.time << \" \" << p->ticket.start_place << \" \" << p->ticket.end_place << \" \" << p->ticket.price << \" \" << p->ticket.order_num << endl;\n\t\tp = p->next;\n\t}\n\tofs.close();\n}\n\nvoid wait() {\n\tint a = getchar();\n\ta = getchar();\n\tsystem(\"cls\");\n}\n\nint main()\n{\n\tflightlist flight;\n\tpassengerlist passenger;\n\tInit_passenger(passenger); //初始用户信息\n\tLoad_passenger(passenger); //载入用户信息\n\tInit_flight(flight);       //初始化航班\n\tLoad_flight(flight);       //载入航班\n\tmanage(flight, passenger); //封装管理函数\n\treturn 0;\n}\n\n```\n\n","tags":["C++"]},{"title":"面向对象编程","url":"/2022/12/11/6/","content":"\n# C++核心编程\n\n本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。\n\n\n\n## 1 内存分区模型\n\nC++程序在执行时，将内存大方向划分为**4个区域**\n\n- 代码区：存放函数体的二进制代码，由操作系统进行管理的\n- 全局区：存放全局变量和静态变量以及常量\n- 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等\n- 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收\n\n\n\n\n\n\n\n**内存四区意义：**\n\n不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程\n\n\n\n\n\n### 1.1 程序运行前\n\n\t在程序编译后，生成了exe可执行程序，**未执行该程序前**分为两个区域\n\t\n\t**代码区：**\n\t\n\t\t存放 CPU 执行的机器指令\n\t\n\t\t代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可\n\t\n\t\t代码区是**只读**的，使其只读的原因是防止程序意外地修改了它的指令\n\t\n\t**全局区：**\n\t\n\t\t全局变量和静态变量存放在此.\n\t\n\t\t全局区还包含了常量区, 字符串常量和其他常量也存放在此.\n\t\n\t\t==该区域的数据在程序结束后由操作系统释放==.\n\n\n\n\n\n\n\n\n\n\n\n\n\n**示例：**\n\n```c++\n//全局变量\nint g_a = 10;\nint g_b = 10;\n\n//全局常量\nconst int c_g_a = 10;\nconst int c_g_b = 10;\n\nint main() {\n\n\t//局部变量\n\tint a = 10;\n\tint b = 10;\n\n\t//打印地址\n\tcout << \"局部变量a地址为： \" << (int)&a << endl;\n\tcout << \"局部变量b地址为： \" << (int)&b << endl;\n\n\tcout << \"全局变量g_a地址为： \" <<  (int)&g_a << endl;\n\tcout << \"全局变量g_b地址为： \" <<  (int)&g_b << endl;\n\n\t//静态变量\n\tstatic int s_a = 10;\n\tstatic int s_b = 10;\n\n\tcout << \"静态变量s_a地址为： \" << (int)&s_a << endl;\n\tcout << \"静态变量s_b地址为： \" << (int)&s_b << endl;\n\n\tcout << \"字符串常量地址为： \" << (int)&\"hello world\" << endl;\n\tcout << \"字符串常量地址为： \" << (int)&\"hello world1\" << endl;\n\n\tcout << \"全局常量c_g_a地址为： \" << (int)&c_g_a << endl;\n\tcout << \"全局常量c_g_b地址为： \" << (int)&c_g_b << endl;\n\n\tconst int c_l_a = 10;\n\tconst int c_l_b = 10;\n\tcout << \"局部常量c_l_a地址为： \" << (int)&c_l_a << endl;\n\tcout << \"局部常量c_l_b地址为： \" << (int)&c_l_b << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n打印结果：\n\n![1545017602518](assets/1545017602518.png)\n\n\n\n总结：\n\n* C++中在程序运行前分为全局区和代码区\n* 代码区特点是共享和只读\n* 全局区中存放全局变量、静态变量、常量\n* 常量区中存放 const修饰的全局常量  和 字符串常量\n\n\n\n\n\n\n### 1.2 程序运行后\n\n\n\n\t**栈区：**\n\t\n\t\t由编译器自动分配释放, 存放函数的参数值,局部变量等\n\t\n\t\t注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放\n\n\n\n**示例：**\n\n```c++\nint * func()\n{\n\tint a = 10;\n\treturn &a;\n}\n\nint main() {\n\n\tint *p = func();\n\n\tcout << *p << endl;\n\tcout << *p << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\t**堆区：**\n\t\n\t\t由程序员分配释放,若程序员不释放,程序结束时由操作系统回收\n\t\n\t\t在C++中主要利用new在堆区开辟内存\n\n**示例：**\n\n```c++\nint* func()\n{\n\tint* a = new int(10);\n\treturn a;\n}\n\nint main() {\n\n\tint *p = func();\n\n\tcout << *p << endl;\n\tcout << *p << endl;\n    \n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n**总结：**\n\n堆区数据由程序员管理开辟和释放\n\n堆区数据利用new关键字进行开辟内存\n\n\n\n\n\n\n\n\n\n### 1.3 new操作符\n\n\n\n\tC++中利用==new==操作符在堆区开辟数据\n\t\n\t堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==\n\t\n\t语法：` new 数据类型`\n\t\n\t利用new创建的数据，会返回该数据对应的类型的指针\n\n\n\n**示例1： 基本语法**\n\n```c++\nint* func()\n{\n\tint* a = new int(10);\n\treturn a;\n}\n\nint main() {\n\n\tint *p = func();\n\n\tcout << *p << endl;\n\tcout << *p << endl;\n\n\t//利用delete释放堆区数据\n\tdelete p;\n\n\t//cout << *p << endl; //报错，释放的空间不可访问\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n**示例2：开辟数组**\n\n```c++\n//堆区开辟数组\nint main() {\n\n\tint* arr = new int[10];\n\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tarr[i] = i + 100;\n\t}\n\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tcout << arr[i] << endl;\n\t}\n\t//释放数组 delete 后加 []\n\tdelete[] arr;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n## 2 引用\n\n### 2.1 引用的基本使用\n\n**作用： **给变量起别名\n\n**语法：** `数据类型 &别名 = 原名`\n\n\n\n**示例：**\n\n```C++\nint main() {\n\n\tint a = 10;\n\tint &b = a;\n\n\tcout << \"a = \" << a << endl;\n\tcout << \"b = \" << b << endl;\n\n\tb = 100;\n\n\tcout << \"a = \" << a << endl;\n\tcout << \"b = \" << b << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n### 2.2 引用注意事项\n\n* 引用必须初始化\n* 引用在初始化后，不可以改变\n\n示例：\n\n```C++\nint main() {\n\n\tint a = 10;\n\tint b = 20;\n\t//int &c; //错误，引用必须初始化\n\tint &c = a; //一旦初始化后，就不可以更改\n\tc = b; //这是赋值操作，不是更改引用\n\n\tcout << \"a = \" << a << endl;\n\tcout << \"b = \" << b << endl;\n\tcout << \"c = \" << c << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n### 2.3 引用做函数参数\n\n**作用：**函数传参时，可以利用引用的技术让形参修饰实参\n\n**优点：**可以简化指针修改实参\n\n\n\n**示例：**\n\n```C++\n//1. 值传递\nvoid mySwap01(int a, int b) {\n\tint temp = a;\n\ta = b;\n\tb = temp;\n}\n\n//2. 地址传递\nvoid mySwap02(int* a, int* b) {\n\tint temp = *a;\n\t*a = *b;\n\t*b = temp;\n}\n\n//3. 引用传递\nvoid mySwap03(int& a, int& b) {\n\tint temp = a;\n\ta = b;\n\tb = temp;\n}\n\nint main() {\n\n\tint a = 10;\n\tint b = 20;\n\n\tmySwap01(a, b);\n\tcout << \"a:\" << a << \" b:\" << b << endl;\n\n\tmySwap02(&a, &b);\n\tcout << \"a:\" << a << \" b:\" << b << endl;\n\n\tmySwap03(a, b);\n\tcout << \"a:\" << a << \" b:\" << b << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n\n```\n\n\n\n> 总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 2.4 引用做函数返回值\n\n\n\n作用：引用是可以作为函数的返回值存在的\n\n\n\n注意：**不要返回局部变量引用**\n\n用法：函数调用作为左值\n\n\n\n**示例：**\n\n```C++\n//返回局部变量引用\nint& test01() {\n\tint a = 10; //局部变量\n\treturn a;\n}\n\n//返回静态变量引用\nint& test02() {\n\tstatic int a = 20;\n\treturn a;\n}\n\nint main() {\n\n\t//不能返回局部变量的引用\n\tint& ref = test01();\n\tcout << \"ref = \" << ref << endl;\n\tcout << \"ref = \" << ref << endl;\n\n\t//如果函数做左值，那么必须返回引用\n\tint& ref2 = test02();\n\tcout << \"ref2 = \" << ref2 << endl;\n\tcout << \"ref2 = \" << ref2 << endl;\n\n\ttest02() = 1000;\n\n\tcout << \"ref2 = \" << ref2 << endl;\n\tcout << \"ref2 = \" << ref2 << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n​\t\n\n\n\n\n\n\n\n\n\n### 2.5 引用的本质\n\n本质：**引用的本质在c++内部实现是一个指针常量.**\n\n讲解示例：\n\n```C++\n//发现是引用，转换为 int* const ref = &a;\nvoid func(int& ref){\n\tref = 100; // ref是引用，转换为*ref = 100\n}\nint main(){\n\tint a = 10;\n    \n    //自动转换为 int* const ref = &a; 指针常量是指针指向不可改，也说明为什么引用不可更改\n\tint& ref = a; \n\tref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20;\n    \n\tcout << \"a:\" << a << endl;\n\tcout << \"ref:\" << ref << endl;\n    \n\tfunc(a);\n\treturn 0;\n}\n```\n\n结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 2.6 常量引用\n\n\n\n**作用：**常量引用主要用来修饰形参，防止误操作\n\n\n\n在函数形参列表中，可以加==const修饰形参==，防止形参改变实参\n\n\n\n**示例：**\n\n\n\n```C++\n//引用使用的场景，通常用来修饰形参\nvoid showValue(const int& v) {\n\t//v += 10;\n\tcout << v << endl;\n}\n\nint main() {\n\n\t//int& ref = 10;  引用本身需要一个合法的内存空间，因此这行错误\n\t//加入const就可以了，编译器优化代码，int temp = 10; const int& ref = temp;\n\tconst int& ref = 10;\n\n\t//ref = 100;  //加入const后不可以修改变量\n\tcout << ref << endl;\n\n\t//函数中利用常量引用防止误操作修改实参\n\tint a = 10;\n\tshowValue(a);\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n## 3 函数提高\n\n### 3.1 函数默认参数\n\n\n\n在C++中，函数的形参列表中的形参是可以有默认值的。\n\n语法：` 返回值类型  函数名 （参数= 默认值）{}`\n\n\n\n**示例：**\n\n```C++\nint func(int a, int b = 10, int c = 10) {\n\treturn a + b + c;\n}\n\n//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值\n//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数\nint func2(int a = 10, int b = 10);\nint func2(int a, int b) {\n\treturn a + b;\n}\n\nint main() {\n\n\tcout << \"ret = \" << func(20, 20) << endl;\n\tcout << \"ret = \" << func(100) << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n### 3.2 函数占位参数\n\n\n\nC++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置\n\n\n\n**语法：** `返回值类型 函数名 (数据类型){}`\n\n\n\n在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术\n\n\n\n**示例：**\n\n```C++\n//函数占位参数 ，占位参数也可以有默认参数\nvoid func(int a, int) {\n\tcout << \"this is func\" << endl;\n}\n\nint main() {\n\n\tfunc(10,10); //占位参数必须填补\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n### 3.3 函数重载\n\n#### 3.3.1 函数重载概述\n\n\n\n**作用：**函数名可以相同，提高复用性\n\n\n\n**函数重载满足条件：**\n\n* 同一个作用域下\n* 函数名称相同\n* 函数参数**类型不同**  或者 **个数不同** 或者 **顺序不同**\n\n\n\n**注意:**  函数的返回值不可以作为函数重载的条件\n\n\n\n**示例：**\n\n```C++\n//函数重载需要函数都在同一个作用域下\nvoid func()\n{\n\tcout << \"func 的调用！\" << endl;\n}\nvoid func(int a)\n{\n\tcout << \"func (int a) 的调用！\" << endl;\n}\nvoid func(double a)\n{\n\tcout << \"func (double a)的调用！\" << endl;\n}\nvoid func(int a ,double b)\n{\n\tcout << \"func (int a ,double b) 的调用！\" << endl;\n}\nvoid func(double a ,int b)\n{\n\tcout << \"func (double a ,int b)的调用！\" << endl;\n}\n\n//函数返回值不可以作为函数重载条件\n//int func(double a, int b)\n//{\n//\tcout << \"func (double a ,int b)的调用！\" << endl;\n//}\n\n\nint main() {\n\n\tfunc();\n\tfunc(10);\n\tfunc(3.14);\n\tfunc(10,3.14);\n\tfunc(3.14 , 10);\n\t\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 3.3.2 函数重载注意事项\n\n\n\n* 引用作为重载条件\n* 函数重载碰到函数默认参数\n\n\n\n\n\n**示例：**\n\n```C++\n//函数重载注意事项\n//1、引用作为重载条件\n\nvoid func(int &a)\n{\n\tcout << \"func (int &a) 调用 \" << endl;\n}\n\nvoid func(const int &a)\n{\n\tcout << \"func (const int &a) 调用 \" << endl;\n}\n\n\n//2、函数重载碰到函数默认参数\n\nvoid func2(int a, int b = 10)\n{\n\tcout << \"func2(int a, int b = 10) 调用\" << endl;\n}\n\nvoid func2(int a)\n{\n\tcout << \"func2(int a) 调用\" << endl;\n}\n\nint main() {\n\t\n\tint a = 10;\n\tfunc(a); //调用无const\n\tfunc(10);//调用有const\n\n\n\t//func2(10); //碰到默认参数产生歧义，需要避免\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n## **4** 类和对象\n\n\n\nC++面向对象的三大特性为：==封装、继承、多态==\n\n\n\nC++认为==万事万物都皆为对象==，对象上有其属性和行为\n\n\n\n**例如：**\n\n\t人可以作为对象，属性有姓名、年龄、身高、体重...，行为有走、跑、跳、吃饭、唱歌...\n\t\n\t车也可以作为对象，属性有轮胎、方向盘、车灯...,行为有载人、放音乐、放空调...\n\t\n\t具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类\n\n### 4.1 封装\n\n#### 4.1.1  封装的意义\n\n封装是C++面向对象三大特性之一\n\n封装的意义：\n\n* 将属性和行为作为一个整体，表现生活中的事物\n* 将属性和行为加以权限控制\n\n\n\n**封装意义一：**\n\n\t在设计类的时候，属性和行为写在一起，表现事物\n\n**语法：** `class 类名{   访问权限： 属性  / 行为  };`\n\n\n\n**示例1：**设计一个圆类，求圆的周长\n\n**示例代码：**\n\n```C++\n//圆周率\nconst double PI = 3.14;\n\n//1、封装的意义\n//将属性和行为作为一个整体，用来表现生活中的事物\n\n//封装一个圆类，求圆的周长\n//class代表设计一个类，后面跟着的是类名\nclass Circle\n{\npublic:  //访问权限  公共的权限\n\n\t//属性\n\tint m_r;//半径\n\n\t//行为\n\t//获取到圆的周长\n\tdouble calculateZC()\n\t{\n\t\t//2 * pi  * r\n\t\t//获取圆的周长\n\t\treturn  2 * PI * m_r;\n\t}\n};\n\nint main() {\n\n\t//通过圆类，创建圆的对象\n\t// c1就是一个具体的圆\n\tCircle c1;\n\tc1.m_r = 10; //给圆对象的半径 进行赋值操作\n\n\t//2 * pi * 10 = = 62.8\n\tcout << \"圆的周长为： \" << c1.calculateZC() << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n**示例2：**设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号\n\n\n\n\n\n**示例2代码：**\n\n```C++\n//学生类\nclass Student {\npublic:\n\tvoid setName(string name) {\n\t\tm_name = name;\n\t}\n\tvoid setID(int id) {\n\t\tm_id = id;\n\t}\n\n\tvoid showStudent() {\n\t\tcout << \"name:\" << m_name << \" ID:\" << m_id << endl;\n\t}\npublic:\n\tstring m_name;\n\tint m_id;\n};\n\nint main() {\n\n\tStudent stu;\n\tstu.setName(\"德玛西亚\");\n\tstu.setID(250);\n\tstu.showStudent();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n\n```\n\n\n\n\n\n\n\n\n\n**封装意义二：**\n\n类在设计时，可以把属性和行为放在不同的权限下，加以控制\n\n访问权限有三种：\n\n\n\n1. public        公共权限  \n2. protected 保护权限\n3. private      私有权限\n\n\n\n\n\n\n\n**示例：**\n\n```C++\n//三种权限\n//公共权限  public     类内可以访问  类外可以访问\n//保护权限  protected  类内可以访问  类外不可以访问\n//私有权限  private    类内可以访问  类外不可以访问\n\nclass Person\n{\n\t//姓名  公共权限\npublic:\n\tstring m_Name;\n\n\t//汽车  保护权限\nprotected:\n\tstring m_Car;\n\n\t//银行卡密码  私有权限\nprivate:\n\tint m_Password;\n\npublic:\n\tvoid func()\n\t{\n\t\tm_Name = \"张三\";\n\t\tm_Car = \"拖拉机\";\n\t\tm_Password = 123456;\n\t}\n};\n\nint main() {\n\n\tPerson p;\n\tp.m_Name = \"李四\";\n\t//p.m_Car = \"奔驰\";  //保护权限类外访问不到\n\t//p.m_Password = 123; //私有权限类外访问不到\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n#### 4.1.2 struct和class区别\n\n\n\n在C++中 struct和class唯一的**区别**就在于 **默认的访问权限不同**\n\n区别：\n\n* struct 默认权限为公共\n* class   默认权限为私有\n\n\n\n```C++\nclass C1\n{\n\tint  m_A; //默认是私有权限\n};\n\nstruct C2\n{\n\tint m_A;  //默认是公共权限\n};\n\nint main() {\n\n\tC1 c1;\n\tc1.m_A = 10; //错误，访问权限是私有\n\n\tC2 c2;\n\tc2.m_A = 10; //正确，访问权限是公共\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.1.3 成员属性设置为私有\n\n\n\n**优点1：**将所有成员属性设置为私有，可以自己控制读写权限\n\n**优点2：**对于写权限，我们可以检测数据的有效性\n\n\n\n**示例：**\n\n```C++\nclass Person {\npublic:\n\n\t//姓名设置可读可写\n\tvoid setName(string name) {\n\t\tm_Name = name;\n\t}\n\tstring getName()\n\t{\n\t\treturn m_Name;\n\t}\n\n\n\t//获取年龄 \n\tint getAge() {\n\t\treturn m_Age;\n\t}\n\t//设置年龄\n\tvoid setAge(int age) {\n\t\tif (age < 0 || age > 150) {\n\t\t\tcout << \"你个老妖精!\" << endl;\n\t\t\treturn;\n\t\t}\n\t\tm_Age = age;\n\t}\n\n\t//情人设置为只写\n\tvoid setLover(string lover) {\n\t\tm_Lover = lover;\n\t}\n\nprivate:\n\tstring m_Name; //可读可写  姓名\n\t\n\tint m_Age; //只读  年龄\n\n\tstring m_Lover; //只写  情人\n};\n\n\nint main() {\n\n\tPerson p;\n\t//姓名设置\n\tp.setName(\"张三\");\n\tcout << \"姓名： \" << p.getName() << endl;\n\n\t//年龄设置\n\tp.setAge(50);\n\tcout << \"年龄： \" << p.getAge() << endl;\n\n\t//情人设置\n\tp.setLover(\"苍井\");\n\t//cout << \"情人： \" << p.m_Lover << endl;  //只写属性，不可以读取\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n**练习案例1：设计立方体类**\n\n设计立方体类(Cube)\n\n求出立方体的面积和体积\n\n分别用全局函数和成员函数判断两个立方体是否相等。\n\n\n\n![1545533548532](assets/1545533548532.png)\n\n\n\n\n\n\n\n\n\n\n\n**练习案例2：点和圆的关系**\n\n设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。\n\n\n\n![1545533829184](assets/1545533829184.png)\n\n\n\n\n\n\n\n### 4.2 对象的初始化和清理\n\n\n\n*  生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全\n*  C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。\n\n\n\n\n\n#### 4.2.1 构造函数和析构函数\n\n对象的**初始化和清理**也是两个非常重要的安全问题\n\n\t一个对象或者变量没有初始状态，对其使用后果是未知\n\t\n\t同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题\n\n\n\nc++利用了**构造函数**和**析构函数**解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。\n\n对象的初始化和清理工作是编译器强制要我们做的事情，因此如果**我们不提供构造和析构，编译器会提供**\n\n**编译器提供的构造函数和析构函数是空实现。**\n\n\n\n* 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。\n* 析构函数：主要作用在于对象**销毁前**系统自动调用，执行一些清理工作。\n\n\n\n\n\n**构造函数语法：**`类名(){}`\n\n1. 构造函数，没有返回值也不写void\n2. 函数名称与类名相同\n3. 构造函数可以有参数，因此可以发生重载\n4. 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次\n\n\n\n\n\n**析构函数语法：** `~类名(){}`\n\n1. 析构函数，没有返回值也不写void\n2. 函数名称与类名相同,在名称前加上符号  ~\n3. 析构函数不可以有参数，因此不可以发生重载\n4. 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次\n\n\n\n\n\n```C++\nclass Person\n{\npublic:\n\t//构造函数\n\tPerson()\n\t{\n\t\tcout << \"Person的构造函数调用\" << endl;\n\t}\n\t//析构函数\n\t~Person()\n\t{\n\t\tcout << \"Person的析构函数调用\" << endl;\n\t}\n\n};\n\nvoid test01()\n{\n\tPerson p;\n}\n\nint main() {\n\t\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n#### 4.2.2 构造函数的分类及调用\n\n两种分类方式：\n\n\t按参数分为： 有参构造和无参构造\n\t\n\t按类型分为： 普通构造和拷贝构造\n\n三种调用方式：\n\n\t括号法\n\t\n\t显示法\n\t\n\t隐式转换法\n\n\n\n**示例：**\n\n```C++\n//1、构造函数分类\n// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数\n// 按照类型分类分为 普通构造和拷贝构造\n\nclass Person {\npublic:\n\t//无参（默认）构造函数\n\tPerson() {\n\t\tcout << \"无参构造函数!\" << endl;\n\t}\n\t//有参构造函数\n\tPerson(int a) {\n\t\tage = a;\n\t\tcout << \"有参构造函数!\" << endl;\n\t}\n\t//拷贝构造函数\n\tPerson(const Person& p) {\n\t\tage = p.age;\n\t\tcout << \"拷贝构造函数!\" << endl;\n\t}\n\t//析构函数\n\t~Person() {\n\t\tcout << \"析构函数!\" << endl;\n\t}\npublic:\n\tint age;\n};\n\n//2、构造函数的调用\n//调用无参构造函数\nvoid test01() {\n\tPerson p; //调用无参构造函数\n}\n\n//调用有参的构造函数\nvoid test02() {\n\n\t//2.1  括号法，常用\n\tPerson p1(10);\n\t//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明\n\t//Person p2();\n\n\t//2.2 显式法\n\tPerson p2 = Person(10); \n\tPerson p3 = Person(p2);\n\t//Person(10)单独写就是匿名对象  当前行结束之后，马上析构\n\n\t//2.3 隐式转换法\n\tPerson p4 = 10; // Person p4 = Person(10); \n\tPerson p5 = p4; // Person p5 = Person(p4); \n\n\t//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明\n\t//Person p5(p4);\n}\n\nint main() {\n\n\ttest01();\n\t//test02();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n#### 4.2.3 拷贝构造函数调用时机\n\n\n\nC++中拷贝构造函数调用时机通常有三种情况\n\n* 使用一个已经创建完毕的对象来初始化一个新对象\n* 值传递的方式给函数参数传值\n* 以值方式返回局部对象\n\n\n\n**示例：**\n\n```C++\nclass Person {\npublic:\n\tPerson() {\n\t\tcout << \"无参构造函数!\" << endl;\n\t\tmAge = 0;\n\t}\n\tPerson(int age) {\n\t\tcout << \"有参构造函数!\" << endl;\n\t\tmAge = age;\n\t}\n\tPerson(const Person& p) {\n\t\tcout << \"拷贝构造函数!\" << endl;\n\t\tmAge = p.mAge;\n\t}\n\t//析构函数在释放内存之前调用\n\t~Person() {\n\t\tcout << \"析构函数!\" << endl;\n\t}\npublic:\n\tint mAge;\n};\n\n//1. 使用一个已经创建完毕的对象来初始化一个新对象\nvoid test01() {\n\n\tPerson man(100); //p对象已经创建完毕\n\tPerson newman(man); //调用拷贝构造函数\n\tPerson newman2 = man; //拷贝构造\n\n\t//Person newman3;\n\t//newman3 = man; //不是调用拷贝构造函数，赋值操作\n}\n\n//2. 值传递的方式给函数参数传值\n//相当于Person p1 = p;\nvoid doWork(Person p1) {}\nvoid test02() {\n\tPerson p; //无参构造函数\n\tdoWork(p);\n}\n\n//3. 以值方式返回局部对象\nPerson doWork2()\n{\n\tPerson p1;\n\tcout << (int *)&p1 << endl;\n\treturn p1;\n}\n\nvoid test03()\n{\n\tPerson p = doWork2();\n\tcout << (int *)&p << endl;\n}\n\n\nint main() {\n\n\t//test01();\n\t//test02();\n\ttest03();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n#### 4.2.4 构造函数调用规则\n\n默认情况下，c++编译器至少给一个类添加3个函数\n\n1．默认构造函数(无参，函数体为空)\n\n2．默认析构函数(无参，函数体为空)\n\n3．默认拷贝构造函数，对属性进行值拷贝\n\n\n\n构造函数调用规则如下：\n\n* 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造\n\n\n* 如果用户定义拷贝构造函数，c++不会再提供其他构造函数\n\n\n\n示例：\n\n```C++\nclass Person {\npublic:\n\t//无参（默认）构造函数\n\tPerson() {\n\t\tcout << \"无参构造函数!\" << endl;\n\t}\n\t//有参构造函数\n\tPerson(int a) {\n\t\tage = a;\n\t\tcout << \"有参构造函数!\" << endl;\n\t}\n\t//拷贝构造函数\n\tPerson(const Person& p) {\n\t\tage = p.age;\n\t\tcout << \"拷贝构造函数!\" << endl;\n\t}\n\t//析构函数\n\t~Person() {\n\t\tcout << \"析构函数!\" << endl;\n\t}\npublic:\n\tint age;\n};\n\nvoid test01()\n{\n\tPerson p1(18);\n\t//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作\n\tPerson p2(p1);\n\n\tcout << \"p2的年龄为： \" << p2.age << endl;\n}\n\nvoid test02()\n{\n\t//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造\n\tPerson p1; //此时如果用户自己没有提供默认构造，会出错\n\tPerson p2(10); //用户提供的有参\n\tPerson p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供\n\n\t//如果用户提供拷贝构造，编译器不会提供其他构造函数\n\tPerson p4; //此时如果用户自己没有提供默认构造，会出错\n\tPerson p5(10); //此时如果用户自己没有提供有参，会出错\n\tPerson p6(p5); //用户自己提供拷贝构造\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n#### 4.2.5 深拷贝与浅拷贝\n\n\n\n深浅拷贝是面试经典问题，也是常见的一个坑\n\n\n\n浅拷贝：简单的赋值拷贝操作\n\n\n\n深拷贝：在堆区重新申请空间，进行拷贝操作\n\n\n\n**示例：**\n\n```C++\nclass Person {\npublic:\n\t//无参（默认）构造函数\n\tPerson() {\n\t\tcout << \"无参构造函数!\" << endl;\n\t}\n\t//有参构造函数\n\tPerson(int age ,int height) {\n\t\t\n\t\tcout << \"有参构造函数!\" << endl;\n\n\t\tm_age = age;\n\t\tm_height = new int(height);\n\t\t\n\t}\n\t//拷贝构造函数  \n\tPerson(const Person& p) {\n\t\tcout << \"拷贝构造函数!\" << endl;\n\t\t//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题\n\t\tm_age = p.m_age;\n\t\tm_height = new int(*p.m_height);\n\t\t\n\t}\n\n\t//析构函数\n\t~Person() {\n\t\tcout << \"析构函数!\" << endl;\n\t\tif (m_height != NULL)\n\t\t{\n\t\t\tdelete m_height;\n\t\t}\n\t}\npublic:\n\tint m_age;\n\tint* m_height;\n};\n\nvoid test01()\n{\n\tPerson p1(18, 180);\n\n\tPerson p2(p1);\n\n\tcout << \"p1的年龄： \" << p1.m_age << \" 身高： \" << *p1.m_height << endl;\n\n\tcout << \"p2的年龄： \" << p2.m_age << \" 身高： \" << *p2.m_height << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n> 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题\n\n\n\n\n\n\n\n\n\n#### 4.2.6 初始化列表\n\n\n\n**作用：**\n\nC++提供了初始化列表语法，用来初始化属性\n\n\n\n**语法：**`构造函数()：属性1(值1),属性2（值2）... {}`\n\n\n\n**示例：**\n\n```C++\nclass Person {\npublic:\n\n\t////传统方式初始化\n\t//Person(int a, int b, int c) {\n\t//\tm_A = a;\n\t//\tm_B = b;\n\t//\tm_C = c;\n\t//}\n\n\t//初始化列表方式初始化\n\tPerson(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}\n\tvoid PrintPerson() {\n\t\tcout << \"mA:\" << m_A << endl;\n\t\tcout << \"mB:\" << m_B << endl;\n\t\tcout << \"mC:\" << m_C << endl;\n\t}\nprivate:\n\tint m_A;\n\tint m_B;\n\tint m_C;\n};\n\nint main() {\n\n\tPerson p(1, 2, 3);\n\tp.PrintPerson();\n\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n#### 4.2.7 类对象作为类成员\n\n\n\nC++类中的成员可以是另一个类的对象，我们称该成员为 对象成员\n\n\n\n例如：\n\n```C++\nclass A {}\nclass B\n{\n    A a；\n}\n```\n\n\n\nB类中有对象A作为成员，A为对象成员\n\n\n\n那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？\n\n\n\n**示例：**\n\n```C++\nclass Phone\n{\npublic:\n\tPhone(string name)\n\t{\n\t\tm_PhoneName = name;\n\t\tcout << \"Phone构造\" << endl;\n\t}\n\n\t~Phone()\n\t{\n\t\tcout << \"Phone析构\" << endl;\n\t}\n\n\tstring m_PhoneName;\n\n};\n\n\nclass Person\n{\npublic:\n\n\t//初始化列表可以告诉编译器调用哪一个构造函数\n\tPerson(string name, string pName) :m_Name(name), m_Phone(pName)\n\t{\n\t\tcout << \"Person构造\" << endl;\n\t}\n\n\t~Person()\n\t{\n\t\tcout << \"Person析构\" << endl;\n\t}\n\n\tvoid playGame()\n\t{\n\t\tcout << m_Name << \" 使用\" << m_Phone.m_PhoneName << \" 牌手机! \" << endl;\n\t}\n\n\tstring m_Name;\n\tPhone m_Phone;\n\n};\nvoid test01()\n{\n\t//当类中成员是其他类对象时，我们称该成员为 对象成员\n\t//构造的顺序是 ：先调用对象成员的构造，再调用本类构造\n\t//析构顺序与构造相反\n\tPerson p(\"张三\" , \"苹果X\");\n\tp.playGame();\n\n}\n\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n#### 4.2.8 静态成员\n\n静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员\n\n静态成员分为：\n\n\n\n*  静态成员变量\n   *  所有对象共享同一份数据\n   *  在编译阶段分配内存\n   *  类内声明，类外初始化\n*  静态成员函数\n   *  所有对象共享同一个函数\n   *  静态成员函数只能访问静态成员变量\n\n\n\n\n\n\n\n**示例1 ：**静态成员变量\n\n```C++\nclass Person\n{\n\t\npublic:\n\n\tstatic int m_A; //静态成员变量\n\n\t//静态成员变量特点：\n\t//1 在编译阶段分配内存\n\t//2 类内声明，类外初始化\n\t//3 所有对象共享同一份数据\n\nprivate:\n\tstatic int m_B; //静态成员变量也是有访问权限的\n};\nint Person::m_A = 10;\nint Person::m_B = 10;\n\nvoid test01()\n{\n\t//静态成员变量两种访问方式\n\n\t//1、通过对象\n\tPerson p1;\n\tp1.m_A = 100;\n\tcout << \"p1.m_A = \" << p1.m_A << endl;\n\n\tPerson p2;\n\tp2.m_A = 200;\n\tcout << \"p1.m_A = \" << p1.m_A << endl; //共享同一份数据\n\tcout << \"p2.m_A = \" << p2.m_A << endl;\n\n\t//2、通过类名\n\tcout << \"m_A = \" << Person::m_A << endl;\n\n\n\t//cout << \"m_B = \" << Person::m_B << endl; //私有权限访问不到\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n**示例2：**静态成员函数\n\n```C++\nclass Person\n{\n\npublic:\n\n\t//静态成员函数特点：\n\t//1 程序共享一个函数\n\t//2 静态成员函数只能访问静态成员变量\n\t\n\tstatic void func()\n\t{\n\t\tcout << \"func调用\" << endl;\n\t\tm_A = 100;\n\t\t//m_B = 100; //错误，不可以访问非静态成员变量\n\t}\n\n\tstatic int m_A; //静态成员变量\n\tint m_B; // \nprivate:\n\n\t//静态成员函数也是有访问权限的\n\tstatic void func2()\n\t{\n\t\tcout << \"func2调用\" << endl;\n\t}\n};\nint Person::m_A = 10;\n\n\nvoid test01()\n{\n\t//静态成员变量两种访问方式\n\n\t//1、通过对象\n\tPerson p1;\n\tp1.func();\n\n\t//2、通过类名\n\tPerson::func();\n\n\n\t//Person::func2(); //私有权限访问不到\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n### 4.3 C++对象模型和this指针\n\n\n\n#### 4.3.1 成员变量和成员函数分开存储\n\n\n\n在C++中，类内的成员变量和成员函数分开存储\n\n只有非静态成员变量才属于类的对象上\n\n\n\n```C++\nclass Person {\npublic:\n\tPerson() {\n\t\tmA = 0;\n\t}\n\t//非静态成员变量占对象空间\n\tint mA;\n\t//静态成员变量不占对象空间\n\tstatic int mB; \n\t//函数也不占对象空间，所有函数共享一个函数实例\n\tvoid func() {\n\t\tcout << \"mA:\" << this->mA << endl;\n\t}\n\t//静态成员函数也不占对象空间\n\tstatic void sfunc() {\n\t}\n};\n\nint main() {\n\n\tcout << sizeof(Person) << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n#### 4.3.2 this指针概念\n\n通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的\n\n每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码\n\n那么问题是：这一块代码是如何区分那个对象调用自己的呢？\n\n\n\nc++通过提供特殊的对象指针，this指针，解决上述问题。**this指针指向被调用的成员函数所属的对象**\n\n\n\nthis指针是隐含每一个非静态成员函数内的一种指针\n\nthis指针不需要定义，直接使用即可\n\n\n\nthis指针的用途：\n\n*  当形参和成员变量同名时，可用this指针来区分\n*  在类的非静态成员函数中返回对象本身，可使用return *this\n\n```C++\nclass Person\n{\npublic:\n\n\tPerson(int age)\n\t{\n\t\t//1、当形参和成员变量同名时，可用this指针来区分\n\t\tthis->age = age;\n\t}\n\n\tPerson& PersonAddPerson(Person p)\n\t{\n\t\tthis->age += p.age;\n\t\t//返回对象本身\n\t\treturn *this;\n\t}\n\n\tint age;\n};\n\nvoid test01()\n{\n\tPerson p1(10);\n\tcout << \"p1.age = \" << p1.age << endl;\n\n\tPerson p2(10);\n\tp2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);\n\tcout << \"p2.age = \" << p2.age << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n#### 4.3.3 空指针访问成员函数\n\n\n\nC++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针\n\n\n\n如果用到this指针，需要加以判断保证代码的健壮性\n\n\n\n**示例：**\n\n```C++\n//空指针访问成员函数\nclass Person {\npublic:\n\n\tvoid ShowClassName() {\n\t\tcout << \"我是Person类!\" << endl;\n\t}\n\n\tvoid ShowPerson() {\n\t\tif (this == NULL) {\n\t\t\treturn;\n\t\t}\n\t\tcout << mAge << endl;\n\t}\n\npublic:\n\tint mAge;\n};\n\nvoid test01()\n{\n\tPerson * p = NULL;\n\tp->ShowClassName(); //空指针，可以调用成员函数\n\tp->ShowPerson();  //但是如果成员函数中用到了this指针，就不可以了\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n#### 4.3.4 const修饰成员函数\n\n\n\n**常函数：**\n\n* 成员函数后加const后我们称为这个函数为**常函数**\n* 常函数内不可以修改成员属性\n* 成员属性声明时加关键字mutable后，在常函数中依然可以修改\n\n\n\n**常对象：**\n\n* 声明对象前加const称该对象为常对象\n* 常对象只能调用常函数\n\n\n\n\n\n\n\n**示例：**\n\n```C++\nclass Person {\npublic:\n\tPerson() {\n\t\tm_A = 0;\n\t\tm_B = 0;\n\t}\n\n\t//this指针的本质是一个指针常量，指针的指向不可修改\n\t//如果想让指针指向的值也不可以修改，需要声明常函数\n\tvoid ShowPerson() const {\n\t\t//const Type* const pointer;\n\t\t//this = NULL; //不能修改指针的指向 Person* const this;\n\t\t//this->mA = 100; //但是this指针指向的对象的数据是可以修改的\n\n\t\t//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量\n\t\tthis->m_B = 100;\n\t}\n\n\tvoid MyFunc() const {\n\t\t//mA = 10000;\n\t}\n\npublic:\n\tint m_A;\n\tmutable int m_B; //可修改 可变的\n};\n\n\n//const修饰对象  常对象\nvoid test01() {\n\n\tconst Person person; //常量对象  \n\tcout << person.m_A << endl;\n\t//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问\n\tperson.m_B = 100; //但是常对象可以修改mutable修饰成员变量\n\n\t//常对象访问成员函数\n\tperson.MyFunc(); //常对象不能调用const的函数\n\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n### 4.4 友元\n\n\n\n生活中你的家有客厅(Public)，有你的卧室(Private)\n\n客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去\n\n但是呢，你也可以允许你的好闺蜜好基友进去。\n\n\n\n在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术\n\n\n\n友元的目的就是让一个函数或者类 访问另一个类中私有成员\n\n\n\n友元的关键字为  ==friend==\n\n\n\n友元的三种实现\n\n* 全局函数做友元\n* 类做友元\n* 成员函数做友元\n\n\n\n\n\n#### 4.4.1 全局函数做友元\n\n```C++\nclass Building\n{\n\t//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容\n\tfriend void goodGay(Building * building);\n\npublic:\n\n\tBuilding()\n\t{\n\t\tthis->m_SittingRoom = \"客厅\";\n\t\tthis->m_BedRoom = \"卧室\";\n\t}\n\n\npublic:\n\tstring m_SittingRoom; //客厅\n\nprivate:\n\tstring m_BedRoom; //卧室\n};\n\n\nvoid goodGay(Building * building)\n{\n\tcout << \"好基友正在访问： \" << building->m_SittingRoom << endl;\n\tcout << \"好基友正在访问： \" << building->m_BedRoom << endl;\n}\n\n\nvoid test01()\n{\n\tBuilding b;\n\tgoodGay(&b);\n}\n\nint main(){\n\n\ttest01();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n\n#### 4.4.2 类做友元\n\n\n\n```C++\nclass Building;\nclass goodGay\n{\npublic:\n\n\tgoodGay();\n\tvoid visit();\n\nprivate:\n\tBuilding *building;\n};\n\n\nclass Building\n{\n\t//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容\n\tfriend class goodGay;\n\npublic:\n\tBuilding();\n\npublic:\n\tstring m_SittingRoom; //客厅\nprivate:\n\tstring m_BedRoom;//卧室\n};\n\nBuilding::Building()\n{\n\tthis->m_SittingRoom = \"客厅\";\n\tthis->m_BedRoom = \"卧室\";\n}\n\ngoodGay::goodGay()\n{\n\tbuilding = new Building;\n}\n\nvoid goodGay::visit()\n{\n\tcout << \"好基友正在访问\" << building->m_SittingRoom << endl;\n\tcout << \"好基友正在访问\" << building->m_BedRoom << endl;\n}\n\nvoid test01()\n{\n\tgoodGay gg;\n\tgg.visit();\n\n}\n\nint main(){\n\n\ttest01();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n\n\n\n#### 4.4.3 成员函数做友元\n\n\n\n```C++\nclass Building;\nclass goodGay\n{\npublic:\n\n\tgoodGay();\n\tvoid visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容\n\tvoid visit2(); \n\nprivate:\n\tBuilding *building;\n};\n\n\nclass Building\n{\n\t//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容\n\tfriend void goodGay::visit();\n\npublic:\n\tBuilding();\n\npublic:\n\tstring m_SittingRoom; //客厅\nprivate:\n\tstring m_BedRoom;//卧室\n};\n\nBuilding::Building()\n{\n\tthis->m_SittingRoom = \"客厅\";\n\tthis->m_BedRoom = \"卧室\";\n}\n\ngoodGay::goodGay()\n{\n\tbuilding = new Building;\n}\n\nvoid goodGay::visit()\n{\n\tcout << \"好基友正在访问\" << building->m_SittingRoom << endl;\n\tcout << \"好基友正在访问\" << building->m_BedRoom << endl;\n}\n\nvoid goodGay::visit2()\n{\n\tcout << \"好基友正在访问\" << building->m_SittingRoom << endl;\n\t//cout << \"好基友正在访问\" << building->m_BedRoom << endl;\n}\n\nvoid test01()\n{\n\tgoodGay  gg;\n\tgg.visit();\n\n}\n\nint main(){\n    \n\ttest01();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n### 4.5 运算符重载\n\n\n\n运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型\n\n\n\n#### 4.5.1 加号运算符重载\n\n\n\n作用：实现两个自定义数据类型相加的运算\n\n\n\n```C++\nclass Person {\npublic:\n\tPerson() {};\n\tPerson(int a, int b)\n\t{\n\t\tthis->m_A = a;\n\t\tthis->m_B = b;\n\t}\n\t//成员函数实现 + 号运算符重载\n\tPerson operator+(const Person& p) {\n\t\tPerson temp;\n\t\ttemp.m_A = this->m_A + p.m_A;\n\t\ttemp.m_B = this->m_B + p.m_B;\n\t\treturn temp;\n\t}\n\n\npublic:\n\tint m_A;\n\tint m_B;\n};\n\n//全局函数实现 + 号运算符重载\n//Person operator+(const Person& p1, const Person& p2) {\n//\tPerson temp(0, 0);\n//\ttemp.m_A = p1.m_A + p2.m_A;\n//\ttemp.m_B = p1.m_B + p2.m_B;\n//\treturn temp;\n//}\n\n//运算符重载 可以发生函数重载 \nPerson operator+(const Person& p2, int val)  \n{\n\tPerson temp;\n\ttemp.m_A = p2.m_A + val;\n\ttemp.m_B = p2.m_B + val;\n\treturn temp;\n}\n\nvoid test() {\n\n\tPerson p1(10, 10);\n\tPerson p2(20, 20);\n\n\t//成员函数方式\n\tPerson p3 = p2 + p1;  //相当于 p2.operaor+(p1)\n\tcout << \"mA:\" << p3.m_A << \" mB:\" << p3.m_B << endl;\n\n\n\tPerson p4 = p3 + 10; //相当于 operator+(p3,10)\n\tcout << \"mA:\" << p4.m_A << \" mB:\" << p4.m_B << endl;\n\n}\n\nint main() {\n\n\ttest();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n> 总结1：对于内置的数据类型的表达式的的运算符是不可能改变的\n\n> 总结2：不要滥用运算符重载\n\n\n\n\n\n\n\n#### 4.5.2 左移运算符重载\n\n\n\n作用：可以输出自定义数据类型\n\n\n\n```C++\nclass Person {\n\tfriend ostream& operator<<(ostream& out, Person& p);\n\npublic:\n\n\tPerson(int a, int b)\n\t{\n\t\tthis->m_A = a;\n\t\tthis->m_B = b;\n\t}\n\n\t//成员函数 实现不了  p << cout 不是我们想要的效果\n\t//void operator<<(Person& p){\n\t//}\n\nprivate:\n\tint m_A;\n\tint m_B;\n};\n\n//全局函数实现左移重载\n//ostream对象只能有一个\nostream& operator<<(ostream& out, Person& p) {\n\tout << \"a:\" << p.m_A << \" b:\" << p.m_B;\n\treturn out;\n}\n\nvoid test() {\n\n\tPerson p1(10, 20);\n\n\tcout << p1 << \"hello world\" << endl; //链式编程\n}\n\nint main() {\n\n\ttest();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n> 总结：重载左移运算符配合友元可以实现输出自定义数据类型\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.5.3 递增运算符重载\n\n\n\n作用： 通过重载递增运算符，实现自己的整型数据\n\n\n\n```C++\nclass MyInteger {\n\n\tfriend ostream& operator<<(ostream& out, MyInteger myint);\n\npublic:\n\tMyInteger() {\n\t\tm_Num = 0;\n\t}\n\t//前置++\n\tMyInteger& operator++() {\n\t\t//先++\n\t\tm_Num++;\n\t\t//再返回\n\t\treturn *this;\n\t}\n\n\t//后置++\n\tMyInteger operator++(int) {\n\t\t//先返回\n\t\tMyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；\n\t\tm_Num++;\n\t\treturn temp;\n\t}\n\nprivate:\n\tint m_Num;\n};\n\n\nostream& operator<<(ostream& out, MyInteger myint) {\n\tout << myint.m_Num;\n\treturn out;\n}\n\n\n//前置++ 先++ 再返回\nvoid test01() {\n\tMyInteger myInt;\n\tcout << ++myInt << endl;\n\tcout << myInt << endl;\n}\n\n//后置++ 先返回 再++\nvoid test02() {\n\n\tMyInteger myInt;\n\tcout << myInt++ << endl;\n\tcout << myInt << endl;\n}\n\nint main() {\n\n\ttest01();\n\t//test02();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n> 总结： 前置递增返回引用，后置递增返回值\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.5.4 赋值运算符重载\n\n\n\nc++编译器至少给一个类添加4个函数\n\n1. 默认构造函数(无参，函数体为空)\n2. 默认析构函数(无参，函数体为空)\n3. 默认拷贝构造函数，对属性进行值拷贝\n4. 赋值运算符 operator=, 对属性进行值拷贝\n\n\n\n\n\n如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题\n\n\n\n\n\n**示例：**\n\n```C++\nclass Person\n{\npublic:\n\n\tPerson(int age)\n\t{\n\t\t//将年龄数据开辟到堆区\n\t\tm_Age = new int(age);\n\t}\n\n\t//重载赋值运算符 \n\tPerson& operator=(Person &p)\n\t{\n\t\tif (m_Age != NULL)\n\t\t{\n\t\t\tdelete m_Age;\n\t\t\tm_Age = NULL;\n\t\t}\n\t\t//编译器提供的代码是浅拷贝\n\t\t//m_Age = p.m_Age;\n\n\t\t//提供深拷贝 解决浅拷贝的问题\n\t\tm_Age = new int(*p.m_Age);\n\n\t\t//返回自身\n\t\treturn *this;\n\t}\n\n\n\t~Person()\n\t{\n\t\tif (m_Age != NULL)\n\t\t{\n\t\t\tdelete m_Age;\n\t\t\tm_Age = NULL;\n\t\t}\n\t}\n\n\t//年龄的指针\n\tint *m_Age;\n\n};\n\n\nvoid test01()\n{\n\tPerson p1(18);\n\n\tPerson p2(20);\n\n\tPerson p3(30);\n\n\tp3 = p2 = p1; //赋值操作\n\n\tcout << \"p1的年龄为：\" << *p1.m_Age << endl;\n\n\tcout << \"p2的年龄为：\" << *p2.m_Age << endl;\n\n\tcout << \"p3的年龄为：\" << *p3.m_Age << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\t//int a = 10;\n\t//int b = 20;\n\t//int c = 30;\n\n\t//c = b = a;\n\t//cout << \"a = \" << a << endl;\n\t//cout << \"b = \" << b << endl;\n\t//cout << \"c = \" << c << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n#### 4.5.5 关系运算符重载\n\n\n\n**作用：**重载关系运算符，可以让两个自定义类型对象进行对比操作\n\n\n\n**示例：**\n\n```C++\nclass Person\n{\npublic:\n\tPerson(string name, int age)\n\t{\n\t\tthis->m_Name = name;\n\t\tthis->m_Age = age;\n\t};\n\n\tbool operator==(Person & p)\n\t{\n\t\tif (this->m_Name == p.m_Name && this->m_Age == p.m_Age)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tbool operator!=(Person & p)\n\t{\n\t\tif (this->m_Name == p.m_Name && this->m_Age == p.m_Age)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstring m_Name;\n\tint m_Age;\n};\n\nvoid test01()\n{\n\t//int a = 0;\n\t//int b = 0;\n\n\tPerson a(\"孙悟空\", 18);\n\tPerson b(\"孙悟空\", 18);\n\n\tif (a == b)\n\t{\n\t\tcout << \"a和b相等\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"a和b不相等\" << endl;\n\t}\n\n\tif (a != b)\n\t{\n\t\tcout << \"a和b不相等\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"a和b相等\" << endl;\n\t}\n}\n\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n#### 4.5.6 函数调用运算符重载\n\n\n\n* 函数调用运算符 ()  也可以重载\n* 由于重载后使用的方式非常像函数的调用，因此称为仿函数\n* 仿函数没有固定写法，非常灵活\n\n\n\n**示例：**\n\n```C++\nclass MyPrint\n{\npublic:\n\tvoid operator()(string text)\n\t{\n\t\tcout << text << endl;\n\t}\n\n};\nvoid test01()\n{\n\t//重载的（）操作符 也称为仿函数\n\tMyPrint myFunc;\n\tmyFunc(\"hello world\");\n}\n\n\nclass MyAdd\n{\npublic:\n\tint operator()(int v1, int v2)\n\t{\n\t\treturn v1 + v2;\n\t}\n};\n\nvoid test02()\n{\n\tMyAdd add;\n\tint ret = add(10, 10);\n\tcout << \"ret = \" << ret << endl;\n\n\t//匿名对象调用  \n\tcout << \"MyAdd()(100,100) = \" << MyAdd()(100, 100) << endl;\n}\n\nint main() {\n\n\ttest01();\n\ttest02();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n### 4.6  继承\n\n**继承是面向对象三大特性之一**\n\n有些类与类之间存在特殊的关系，例如下图中：\n\n![1544861202252](assets/1544861202252.png)\n\n我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。\n\n这个时候我们就可以考虑利用继承的技术，减少重复代码\n\n\n\n#### 4.6.1 继承的基本语法\n\n\n\n例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同\n\n接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处\n\n\n\n**普通实现：**\n\n```C++\n//Java页面\nclass Java \n{\npublic:\n\tvoid header()\n\t{\n\t\tcout << \"首页、公开课、登录、注册...（公共头部）\" << endl;\n\t}\n\tvoid footer()\n\t{\n\t\tcout << \"帮助中心、交流合作、站内地图...(公共底部)\" << endl;\n\t}\n\tvoid left()\n\t{\n\t\tcout << \"Java,Python,C++...(公共分类列表)\" << endl;\n\t}\n\tvoid content()\n\t{\n\t\tcout << \"JAVA学科视频\" << endl;\n\t}\n};\n//Python页面\nclass Python\n{\npublic:\n\tvoid header()\n\t{\n\t\tcout << \"首页、公开课、登录、注册...（公共头部）\" << endl;\n\t}\n\tvoid footer()\n\t{\n\t\tcout << \"帮助中心、交流合作、站内地图...(公共底部)\" << endl;\n\t}\n\tvoid left()\n\t{\n\t\tcout << \"Java,Python,C++...(公共分类列表)\" << endl;\n\t}\n\tvoid content()\n\t{\n\t\tcout << \"Python学科视频\" << endl;\n\t}\n};\n//C++页面\nclass CPP \n{\npublic:\n\tvoid header()\n\t{\n\t\tcout << \"首页、公开课、登录、注册...（公共头部）\" << endl;\n\t}\n\tvoid footer()\n\t{\n\t\tcout << \"帮助中心、交流合作、站内地图...(公共底部)\" << endl;\n\t}\n\tvoid left()\n\t{\n\t\tcout << \"Java,Python,C++...(公共分类列表)\" << endl;\n\t}\n\tvoid content()\n\t{\n\t\tcout << \"C++学科视频\" << endl;\n\t}\n};\n\nvoid test01()\n{\n\t//Java页面\n\tcout << \"Java下载视频页面如下： \" << endl;\n\tJava ja;\n\tja.header();\n\tja.footer();\n\tja.left();\n\tja.content();\n\tcout << \"--------------------\" << endl;\n\n\t//Python页面\n\tcout << \"Python下载视频页面如下： \" << endl;\n\tPython py;\n\tpy.header();\n\tpy.footer();\n\tpy.left();\n\tpy.content();\n\tcout << \"--------------------\" << endl;\n\n\t//C++页面\n\tcout << \"C++下载视频页面如下： \" << endl;\n\tCPP cp;\n\tcp.header();\n\tcp.footer();\n\tcp.left();\n\tcp.content();\n\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n**继承实现：**\n\n```C++\n//公共页面\nclass BasePage\n{\npublic:\n\tvoid header()\n\t{\n\t\tcout << \"首页、公开课、登录、注册...（公共头部）\" << endl;\n\t}\n\n\tvoid footer()\n\t{\n\t\tcout << \"帮助中心、交流合作、站内地图...(公共底部)\" << endl;\n\t}\n\tvoid left()\n\t{\n\t\tcout << \"Java,Python,C++...(公共分类列表)\" << endl;\n\t}\n\n};\n\n//Java页面\nclass Java : public BasePage\n{\npublic:\n\tvoid content()\n\t{\n\t\tcout << \"JAVA学科视频\" << endl;\n\t}\n};\n//Python页面\nclass Python : public BasePage\n{\npublic:\n\tvoid content()\n\t{\n\t\tcout << \"Python学科视频\" << endl;\n\t}\n};\n//C++页面\nclass CPP : public BasePage\n{\npublic:\n\tvoid content()\n\t{\n\t\tcout << \"C++学科视频\" << endl;\n\t}\n};\n\nvoid test01()\n{\n\t//Java页面\n\tcout << \"Java下载视频页面如下： \" << endl;\n\tJava ja;\n\tja.header();\n\tja.footer();\n\tja.left();\n\tja.content();\n\tcout << \"--------------------\" << endl;\n\n\t//Python页面\n\tcout << \"Python下载视频页面如下： \" << endl;\n\tPython py;\n\tpy.header();\n\tpy.footer();\n\tpy.left();\n\tpy.content();\n\tcout << \"--------------------\" << endl;\n\n\t//C++页面\n\tcout << \"C++下载视频页面如下： \" << endl;\n\tCPP cp;\n\tcp.header();\n\tcp.footer();\n\tcp.left();\n\tcp.content();\n\n\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n**总结：**\n\n继承的好处：==可以减少重复的代码==\n\nclass A : public B; \n\nA 类称为子类 或 派生类\n\nB 类称为父类 或 基类\n\n\n\n**派生类中的成员，包含两大部分**：\n\n一类是从基类继承过来的，一类是自己增加的成员。\n\n从基类继承过过来的表现其共性，而新增的成员体现了其个性。\n\n\n\n\n\n\n\n\n\n#### 4.6.2 继承方式\n\n\n\n继承的语法：`class 子类 : 继承方式  父类`\n\n\n\n**继承方式一共有三种：**\n\n* 公共继承\n* 保护继承\n* 私有继承\n\n\n\n\n\n![img](assets/clip_image002.png)\n\n\n\n\n\n**示例：**\n\n```C++\nclass Base1\n{\npublic: \n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C;\n};\n\n//公共继承\nclass Son1 :public Base1\n{\npublic:\n\tvoid func()\n\t{\n\t\tm_A; //可访问 public权限\n\t\tm_B; //可访问 protected权限\n\t\t//m_C; //不可访问\n\t}\n};\n\nvoid myClass()\n{\n\tSon1 s1;\n\ts1.m_A; //其他类只能访问到公共权限\n}\n\n//保护继承\nclass Base2\n{\npublic:\n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C;\n};\nclass Son2:protected Base2\n{\npublic:\n\tvoid func()\n\t{\n\t\tm_A; //可访问 protected权限\n\t\tm_B; //可访问 protected权限\n\t\t//m_C; //不可访问\n\t}\n};\nvoid myClass2()\n{\n\tSon2 s;\n\t//s.m_A; //不可访问\n}\n\n//私有继承\nclass Base3\n{\npublic:\n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C;\n};\nclass Son3:private Base3\n{\npublic:\n\tvoid func()\n\t{\n\t\tm_A; //可访问 private权限\n\t\tm_B; //可访问 private权限\n\t\t//m_C; //不可访问\n\t}\n};\nclass GrandSon3 :public Son3\n{\npublic:\n\tvoid func()\n\t{\n\t\t//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到\n\t\t//m_A;\n\t\t//m_B;\n\t\t//m_C;\n\t}\n};\n```\n\n\n\n\n\n\n\n\n\n#### 4.6.3 继承中的对象模型\n\n\n\n**问题：**从父类继承过来的成员，哪些属于子类对象中？\n\n\n\n**示例：**\n\n```C++\nclass Base\n{\npublic:\n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C; //私有成员只是被隐藏了，但是还是会继承下去\n};\n\n//公共继承\nclass Son :public Base\n{\npublic:\n\tint m_D;\n};\n\nvoid test01()\n{\n\tcout << \"sizeof Son = \" << sizeof(Son) << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n利用工具查看：\n\n\n\n![1545881904150](assets/1545881904150.png)\n\n\n\n打开工具窗口后，定位到当前CPP文件的盘符\n\n然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名\n\n\n\n效果如下图：\n\n\n\n![1545882158050](assets/1545882158050.png)\n\n\n\n> 结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.6.4 继承中构造和析构顺序\n\n\n\n子类继承父类后，当创建子类对象，也会调用父类的构造函数\n\n\n\n问题：父类和子类的构造和析构顺序是谁先谁后？\n\n\n\n**示例：**\n\n```C++\nclass Base \n{\npublic:\n\tBase()\n\t{\n\t\tcout << \"Base构造函数!\" << endl;\n\t}\n\t~Base()\n\t{\n\t\tcout << \"Base析构函数!\" << endl;\n\t}\n};\n\nclass Son : public Base\n{\npublic:\n\tSon()\n\t{\n\t\tcout << \"Son构造函数!\" << endl;\n\t}\n\t~Son()\n\t{\n\t\tcout << \"Son析构函数!\" << endl;\n\t}\n\n};\n\n\nvoid test01()\n{\n\t//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反\n\tSon s;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n> 总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反\n\n\n\n\n\n\n\n\n\n\n\n#### 4.6.5 继承同名成员处理方式\n\n\n\n问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？\n\n\n\n* 访问子类同名成员   直接访问即可\n* 访问父类同名成员   需要加作用域\n\n\n\n**示例：**\n\n```C++\nclass Base {\npublic:\n\tBase()\n\t{\n\t\tm_A = 100;\n\t}\n\n\tvoid func()\n\t{\n\t\tcout << \"Base - func()调用\" << endl;\n\t}\n\n\tvoid func(int a)\n\t{\n\t\tcout << \"Base - func(int a)调用\" << endl;\n\t}\n\npublic:\n\tint m_A;\n};\n\n\nclass Son : public Base {\npublic:\n\tSon()\n\t{\n\t\tm_A = 200;\n\t}\n\n\t//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数\n\t//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域\n\tvoid func()\n\t{\n\t\tcout << \"Son - func()调用\" << endl;\n\t}\npublic:\n\tint m_A;\n};\n\nvoid test01()\n{\n\tSon s;\n\n\tcout << \"Son下的m_A = \" << s.m_A << endl;\n\tcout << \"Base下的m_A = \" << s.Base::m_A << endl;\n\n\ts.func();\n\ts.Base::func();\n\ts.Base::func(10);\n\n}\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\treturn EXIT_SUCCESS;\n}\n```\n\n总结：\n\n1. 子类对象可以直接访问到子类中同名成员\n2. 子类对象加作用域可以访问到父类同名成员\n3. 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.6.6 继承同名静态成员处理方式\n\n\n\n问题：继承中同名的静态成员在子类对象上如何进行访问？\n\n\n\n静态成员和非静态成员出现同名，处理方式一致\n\n\n\n- 访问子类同名成员   直接访问即可\n- 访问父类同名成员   需要加作用域\n\n\n\n**示例：**\n\n```C++\nclass Base {\npublic:\n\tstatic void func()\n\t{\n\t\tcout << \"Base - static void func()\" << endl;\n\t}\n\tstatic void func(int a)\n\t{\n\t\tcout << \"Base - static void func(int a)\" << endl;\n\t}\n\n\tstatic int m_A;\n};\n\nint Base::m_A = 100;\n\nclass Son : public Base {\npublic:\n\tstatic void func()\n\t{\n\t\tcout << \"Son - static void func()\" << endl;\n\t}\n\tstatic int m_A;\n};\n\nint Son::m_A = 200;\n\n//同名成员属性\nvoid test01()\n{\n\t//通过对象访问\n\tcout << \"通过对象访问： \" << endl;\n\tSon s;\n\tcout << \"Son  下 m_A = \" << s.m_A << endl;\n\tcout << \"Base 下 m_A = \" << s.Base::m_A << endl;\n\n\t//通过类名访问\n\tcout << \"通过类名访问： \" << endl;\n\tcout << \"Son  下 m_A = \" << Son::m_A << endl;\n\tcout << \"Base 下 m_A = \" << Son::Base::m_A << endl;\n}\n\n//同名成员函数\nvoid test02()\n{\n\t//通过对象访问\n\tcout << \"通过对象访问： \" << endl;\n\tSon s;\n\ts.func();\n\ts.Base::func();\n\n\tcout << \"通过类名访问： \" << endl;\n\tSon::func();\n\tSon::Base::func();\n\t//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问\n\tSon::Base::func(100);\n}\nint main() {\n\n\t//test01();\n\ttest02();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n> 总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.6.7 多继承语法\n\n\n\nC++允许**一个类继承多个类**\n\n\n\n语法：` class 子类 ：继承方式 父类1 ， 继承方式 父类2...`\n\n\n\n多继承可能会引发父类中有同名成员出现，需要加作用域区分\n\n\n\n**C++实际开发中不建议用多继承**\n\n\n\n\n\n\n\n**示例：**\n\n```C++\nclass Base1 {\npublic:\n\tBase1()\n\t{\n\t\tm_A = 100;\n\t}\npublic:\n\tint m_A;\n};\n\nclass Base2 {\npublic:\n\tBase2()\n\t{\n\t\tm_A = 200;  //开始是m_B 不会出问题，但是改为mA就会出现不明确\n\t}\npublic:\n\tint m_A;\n};\n\n//语法：class 子类：继承方式 父类1 ，继承方式 父类2 \nclass Son : public Base2, public Base1 \n{\npublic:\n\tSon()\n\t{\n\t\tm_C = 300;\n\t\tm_D = 400;\n\t}\npublic:\n\tint m_C;\n\tint m_D;\n};\n\n\n//多继承容易产生成员同名的情况\n//通过使用类名作用域可以区分调用哪一个基类的成员\nvoid test01()\n{\n\tSon s;\n\tcout << \"sizeof Son = \" << sizeof(s) << endl;\n\tcout << s.Base1::m_A << endl;\n\tcout << s.Base2::m_A << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n> 总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域\n\n\n\n\n\n\n\n\n\n\n\n#### 4.6.8 菱形继承\n\n\n\n**菱形继承概念：**\n\n\t两个派生类继承同一个基类\n\t\n\t又有某个类同时继承者两个派生类\n\t\n\t这种继承被称为菱形继承，或者钻石继承\n\n\n\n**典型的菱形继承案例：**\n\n\n\n![IMG_256](assets/clip_image002.jpg)\n\n\n\n**菱形继承问题：**\n\n\n\n1.     羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。\n\n2.     草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。\n\n\n\n**示例：**\n\n```C++\nclass Animal\n{\npublic:\n\tint m_Age;\n};\n\n//继承前加virtual关键字后，变为虚继承\n//此时公共的父类Animal称为虚基类\nclass Sheep : virtual public Animal {};\nclass Tuo   : virtual public Animal {};\nclass SheepTuo : public Sheep, public Tuo {};\n\nvoid test01()\n{\n\tSheepTuo st;\n\tst.Sheep::m_Age = 100;\n\tst.Tuo::m_Age = 200;\n\n\tcout << \"st.Sheep::m_Age = \" << st.Sheep::m_Age << endl;\n\tcout << \"st.Tuo::m_Age = \" <<  st.Tuo::m_Age << endl;\n\tcout << \"st.m_Age = \" << st.m_Age << endl;\n}\n\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n总结：\n\n* 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义\n* 利用虚继承可以解决菱形继承问题\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 4.7  多态\n\n#### 4.7.1 多态的基本概念\n\n\n\n**多态是C++面向对象三大特性之一**\n\n多态分为两类\n\n* 静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名\n* 动态多态: 派生类和虚函数实现运行时多态\n\n\n\n静态多态和动态多态区别：\n\n* 静态多态的函数地址早绑定  -  编译阶段确定函数地址\n* 动态多态的函数地址晚绑定  -  运行阶段确定函数地址\n\n\n\n下面通过案例进行讲解多态\n\n\n\n```C++\nclass Animal\n{\npublic:\n\t//Speak函数就是虚函数\n\t//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。\n\tvirtual void speak()\n\t{\n\t\tcout << \"动物在说话\" << endl;\n\t}\n};\n\nclass Cat :public Animal\n{\npublic:\n\tvoid speak()\n\t{\n\t\tcout << \"小猫在说话\" << endl;\n\t}\n};\n\nclass Dog :public Animal\n{\npublic:\n\n\tvoid speak()\n\t{\n\t\tcout << \"小狗在说话\" << endl;\n\t}\n\n};\n//我们希望传入什么对象，那么就调用什么对象的函数\n//如果函数地址在编译阶段就能确定，那么静态联编\n//如果函数地址在运行阶段才能确定，就是动态联编\n\nvoid DoSpeak(Animal & animal)\n{\n\tanimal.speak();\n}\n//\n//多态满足条件： \n//1、有继承关系\n//2、子类重写父类中的虚函数\n//多态使用：\n//父类指针或引用指向子类对象\n\nvoid test01()\n{\n\tCat cat;\n\tDoSpeak(cat);\n\n\n\tDog dog;\n\tDoSpeak(dog);\n}\n\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n总结：\n\n多态满足条件\n\n* 有继承关系\n* 子类重写父类中的虚函数\n\n多态使用条件\n\n* 父类指针或引用指向子类对象\n\n重写：函数返回值类型  函数名 参数列表 完全一致称为重写\n\n\n\n\n\n\n\n\n\n#### 4.7.2 多态案例一-计算器类\n\n\n\n案例描述：\n\n分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类\n\n\n\n多态的优点：\n\n* 代码组织结构清晰\n* 可读性强\n* 利于前期和后期的扩展以及维护\n\n\n\n**示例：**\n\n```C++\n//普通实现\nclass Calculator {\npublic:\n\tint getResult(string oper)\n\t{\n\t\tif (oper == \"+\") {\n\t\t\treturn m_Num1 + m_Num2;\n\t\t}\n\t\telse if (oper == \"-\") {\n\t\t\treturn m_Num1 - m_Num2;\n\t\t}\n\t\telse if (oper == \"*\") {\n\t\t\treturn m_Num1 * m_Num2;\n\t\t}\n\t\t//如果要提供新的运算，需要修改源码\n\t}\npublic:\n\tint m_Num1;\n\tint m_Num2;\n};\n\nvoid test01()\n{\n\t//普通实现测试\n\tCalculator c;\n\tc.m_Num1 = 10;\n\tc.m_Num2 = 10;\n\tcout << c.m_Num1 << \" + \" << c.m_Num2 << \" = \" << c.getResult(\"+\") << endl;\n\n\tcout << c.m_Num1 << \" - \" << c.m_Num2 << \" = \" << c.getResult(\"-\") << endl;\n\n\tcout << c.m_Num1 << \" * \" << c.m_Num2 << \" = \" << c.getResult(\"*\") << endl;\n}\n\n\n\n//多态实现\n//抽象计算器类\n//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护\nclass AbstractCalculator\n{\npublic :\n\n\tvirtual int getResult()\n\t{\n\t\treturn 0;\n\t}\n\n\tint m_Num1;\n\tint m_Num2;\n};\n\n//加法计算器\nclass AddCalculator :public AbstractCalculator\n{\npublic:\n\tint getResult()\n\t{\n\t\treturn m_Num1 + m_Num2;\n\t}\n};\n\n//减法计算器\nclass SubCalculator :public AbstractCalculator\n{\npublic:\n\tint getResult()\n\t{\n\t\treturn m_Num1 - m_Num2;\n\t}\n};\n\n//乘法计算器\nclass MulCalculator :public AbstractCalculator\n{\npublic:\n\tint getResult()\n\t{\n\t\treturn m_Num1 * m_Num2;\n\t}\n};\n\n\nvoid test02()\n{\n\t//创建加法计算器\n\tAbstractCalculator *abc = new AddCalculator;\n\tabc->m_Num1 = 10;\n\tabc->m_Num2 = 10;\n\tcout << abc->m_Num1 << \" + \" << abc->m_Num2 << \" = \" << abc->getResult() << endl;\n\tdelete abc;  //用完了记得销毁\n\n\t//创建减法计算器\n\tabc = new SubCalculator;\n\tabc->m_Num1 = 10;\n\tabc->m_Num2 = 10;\n\tcout << abc->m_Num1 << \" - \" << abc->m_Num2 << \" = \" << abc->getResult() << endl;\n\tdelete abc;  \n\n\t//创建乘法计算器\n\tabc = new MulCalculator;\n\tabc->m_Num1 = 10;\n\tabc->m_Num2 = 10;\n\tcout << abc->m_Num1 << \" * \" << abc->m_Num2 << \" = \" << abc->getResult() << endl;\n\tdelete abc;\n}\n\nint main() {\n\n\t//test01();\n\n\ttest02();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n> 总结：C++开发提倡利用多态设计程序架构，因为多态优点很多\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.7.3 纯虚函数和抽象类\n\n\n\n在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容\n\n\n\n因此可以将虚函数改为**纯虚函数**\n\n\n\n纯虚函数语法：`virtual 返回值类型 函数名 （参数列表）= 0 ;`\n\n\n\n当类中有了纯虚函数，这个类也称为==抽象类==\n\n\n\n**抽象类特点**：\n\n * 无法实例化对象\n * 子类必须重写抽象类中的纯虚函数，否则也属于抽象类\n\n\n\n\n\n**示例：**\n\n```C++\nclass Base\n{\npublic:\n\t//纯虚函数\n\t//类中只要有一个纯虚函数就称为抽象类\n\t//抽象类无法实例化对象\n\t//子类必须重写父类中的纯虚函数，否则也属于抽象类\n\tvirtual void func() = 0;\n};\n\nclass Son :public Base\n{\npublic:\n\tvirtual void func() \n\t{\n\t\tcout << \"func调用\" << endl;\n\t};\n};\n\nvoid test01()\n{\n\tBase * base = NULL;\n\t//base = new Base; // 错误，抽象类无法实例化对象\n\tbase = new Son;\n\tbase->func();\n\tdelete base;//记得销毁\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.7.4 多态案例二-制作饮品\n\n**案例描述：**\n\n制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料\n\n\n\n利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶\n\n\n\n![1545985945198](assets/1545985945198.png)\n\n\n\n**示例：**\n\n```C++\n//抽象制作饮品\nclass AbstractDrinking {\npublic:\n\t//烧水\n\tvirtual void Boil() = 0;\n\t//冲泡\n\tvirtual void Brew() = 0;\n\t//倒入杯中\n\tvirtual void PourInCup() = 0;\n\t//加入辅料\n\tvirtual void PutSomething() = 0;\n\t//规定流程\n\tvoid MakeDrink() {\n\t\tBoil();\n\t\tBrew();\n\t\tPourInCup();\n\t\tPutSomething();\n\t}\n};\n\n//制作咖啡\nclass Coffee : public AbstractDrinking {\npublic:\n\t//烧水\n\tvirtual void Boil() {\n\t\tcout << \"煮农夫山泉!\" << endl;\n\t}\n\t//冲泡\n\tvirtual void Brew() {\n\t\tcout << \"冲泡咖啡!\" << endl;\n\t}\n\t//倒入杯中\n\tvirtual void PourInCup() {\n\t\tcout << \"将咖啡倒入杯中!\" << endl;\n\t}\n\t//加入辅料\n\tvirtual void PutSomething() {\n\t\tcout << \"加入牛奶!\" << endl;\n\t}\n};\n\n//制作茶水\nclass Tea : public AbstractDrinking {\npublic:\n\t//烧水\n\tvirtual void Boil() {\n\t\tcout << \"煮自来水!\" << endl;\n\t}\n\t//冲泡\n\tvirtual void Brew() {\n\t\tcout << \"冲泡茶叶!\" << endl;\n\t}\n\t//倒入杯中\n\tvirtual void PourInCup() {\n\t\tcout << \"将茶水倒入杯中!\" << endl;\n\t}\n\t//加入辅料\n\tvirtual void PutSomething() {\n\t\tcout << \"加入枸杞!\" << endl;\n\t}\n};\n\n//业务函数\nvoid DoWork(AbstractDrinking* drink) {\n\tdrink->MakeDrink();\n\tdelete drink;\n}\n\nvoid test01() {\n\tDoWork(new Coffee);\n\tcout << \"--------------\" << endl;\n\tDoWork(new Tea);\n}\n\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.7.5 虚析构和纯虚析构\n\n\n\n多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码\n\n\n\n解决方式：将父类中的析构函数改为**虚析构**或者**纯虚析构**\n\n\n\n虚析构和纯虚析构共性：\n\n* 可以解决父类指针释放子类对象\n* 都需要有具体的函数实现\n\n虚析构和纯虚析构区别：\n\n* 如果是纯虚析构，该类属于抽象类，无法实例化对象\n\n\n\n虚析构语法：\n\n`virtual ~类名(){}`\n\n纯虚析构语法：\n\n` virtual ~类名() = 0;`\n\n`类名::~类名(){}`\n\n\n\n**示例：**\n\n```C++\nclass Animal {\npublic:\n\n\tAnimal()\n\t{\n\t\tcout << \"Animal 构造函数调用！\" << endl;\n\t}\n\tvirtual void Speak() = 0;\n\n\t//析构函数加上virtual关键字，变成虚析构函数\n\t//virtual ~Animal()\n\t//{\n\t//\tcout << \"Animal虚析构函数调用！\" << endl;\n\t//}\n\n\n\tvirtual ~Animal() = 0;\n};\n\nAnimal::~Animal()\n{\n\tcout << \"Animal 纯虚析构函数调用！\" << endl;\n}\n\n//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。\n\nclass Cat : public Animal {\npublic:\n\tCat(string name)\n\t{\n\t\tcout << \"Cat构造函数调用！\" << endl;\n\t\tm_Name = new string(name);\n\t}\n\tvirtual void Speak()\n\t{\n\t\tcout << *m_Name <<  \"小猫在说话!\" << endl;\n\t}\n\t~Cat()\n\t{\n\t\tcout << \"Cat析构函数调用!\" << endl;\n\t\tif (this->m_Name != NULL) {\n\t\t\tdelete m_Name;\n\t\t\tm_Name = NULL;\n\t\t}\n\t}\n\npublic:\n\tstring *m_Name;\n};\n\nvoid test01()\n{\n\tAnimal *animal = new Cat(\"Tom\");\n\tanimal->Speak();\n\n\t//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏\n\t//怎么解决？给基类增加一个虚析构函数\n\t//虚析构函数就是用来解决通过父类指针释放子类对象\n\tdelete animal;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n总结：\n\n\t1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象\n\t\n\t2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构\n\t\n\t3. 拥有纯虚析构函数的类也属于抽象类\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.7.6 多态案例三-电脑组装\n\n\n\n**案例描述：**\n\n\n\n电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）\n\n将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商\n\n创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口\n\n测试时组装三台不同的电脑进行工作\n\n\n\n\n\n**示例：**\n\n```C++\n#include<iostream>\nusing namespace std;\n\n//抽象CPU类\nclass CPU\n{\npublic:\n\t//抽象的计算函数\n\tvirtual void calculate() = 0;\n};\n\n//抽象显卡类\nclass VideoCard\n{\npublic:\n\t//抽象的显示函数\n\tvirtual void display() = 0;\n};\n\n//抽象内存条类\nclass Memory\n{\npublic:\n\t//抽象的存储函数\n\tvirtual void storage() = 0;\n};\n\n//电脑类\nclass Computer\n{\npublic:\n\tComputer(CPU * cpu, VideoCard * vc, Memory * mem)\n\t{\n\t\tm_cpu = cpu;\n\t\tm_vc = vc;\n\t\tm_mem = mem;\n\t}\n\n\t//提供工作的函数\n\tvoid work()\n\t{\n\t\t//让零件工作起来，调用接口\n\t\tm_cpu->calculate();\n\n\t\tm_vc->display();\n\n\t\tm_mem->storage();\n\t}\n\n\t//提供析构函数 释放3个电脑零件\n\t~Computer()\n\t{\n\n\t\t//释放CPU零件\n\t\tif (m_cpu != NULL)\n\t\t{\n\t\t\tdelete m_cpu;\n\t\t\tm_cpu = NULL;\n\t\t}\n\n\t\t//释放显卡零件\n\t\tif (m_vc != NULL)\n\t\t{\n\t\t\tdelete m_vc;\n\t\t\tm_vc = NULL;\n\t\t}\n\n\t\t//释放内存条零件\n\t\tif (m_mem != NULL)\n\t\t{\n\t\t\tdelete m_mem;\n\t\t\tm_mem = NULL;\n\t\t}\n\t}\n\nprivate:\n\n\tCPU * m_cpu; //CPU的零件指针\n\tVideoCard * m_vc; //显卡零件指针\n\tMemory * m_mem; //内存条零件指针\n};\n\n//具体厂商\n//Intel厂商\nclass IntelCPU :public CPU\n{\npublic:\n\tvirtual void calculate()\n\t{\n\t\tcout << \"Intel的CPU开始计算了！\" << endl;\n\t}\n};\n\nclass IntelVideoCard :public VideoCard\n{\npublic:\n\tvirtual void display()\n\t{\n\t\tcout << \"Intel的显卡开始显示了！\" << endl;\n\t}\n};\n\nclass IntelMemory :public Memory\n{\npublic:\n\tvirtual void storage()\n\t{\n\t\tcout << \"Intel的内存条开始存储了！\" << endl;\n\t}\n};\n\n//Lenovo厂商\nclass LenovoCPU :public CPU\n{\npublic:\n\tvirtual void calculate()\n\t{\n\t\tcout << \"Lenovo的CPU开始计算了！\" << endl;\n\t}\n};\n\nclass LenovoVideoCard :public VideoCard\n{\npublic:\n\tvirtual void display()\n\t{\n\t\tcout << \"Lenovo的显卡开始显示了！\" << endl;\n\t}\n};\n\nclass LenovoMemory :public Memory\n{\npublic:\n\tvirtual void storage()\n\t{\n\t\tcout << \"Lenovo的内存条开始存储了！\" << endl;\n\t}\n};\n\n\nvoid test01()\n{\n\t//第一台电脑零件\n\tCPU * intelCpu = new IntelCPU;\n\tVideoCard * intelCard = new IntelVideoCard;\n\tMemory * intelMem = new IntelMemory;\n\n\tcout << \"第一台电脑开始工作：\" << endl;\n\t//创建第一台电脑\n\tComputer * computer1 = new Computer(intelCpu, intelCard, intelMem);\n\tcomputer1->work();\n\tdelete computer1;\n\n\tcout << \"-----------------------\" << endl;\n\tcout << \"第二台电脑开始工作：\" << endl;\n\t//第二台电脑组装\n\tComputer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);;\n\tcomputer2->work();\n\tdelete computer2;\n\n\tcout << \"-----------------------\" << endl;\n\tcout << \"第三台电脑开始工作：\" << endl;\n\t//第三台电脑组装\n\tComputer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;\n\tcomputer3->work();\n\tdelete computer3;\n\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 5 文件操作\n\n\n\n程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放\n\n通过**文件可以将数据持久化**\n\nC++中对文件操作需要包含头文件 ==&lt; fstream &gt;==\n\n\n\n文件类型分为两种：\n\n1. **文本文件**     -  文件以文本的**ASCII码**形式存储在计算机中\n2. **二进制文件** -  文件以文本的**二进制**形式存储在计算机中，用户一般不能直接读懂它们\n\n\n\n操作文件的三大类:\n\n1. ofstream：写操作\n2. ifstream： 读操作\n3. fstream ： 读写操作\n\n\n\n### 5.1文本文件\n\n#### 5.1.1写文件\n\n   写文件步骤如下：\n\n1. 包含头文件   \n\n   \\#include <fstream\\>\n\n2. 创建流对象  \n\n   ofstream ofs;\n\n3. 打开文件\n\n   ofs.open(\"文件路径\",打开方式);\n\n4. 写数据\n\n   ofs << \"写入的数据\";\n\n5. 关闭文件\n\n   ofs.close();\n\n   \n\n文件打开方式：\n\n| 打开方式    | 解释                       |\n| ----------- | -------------------------- |\n| ios::in     | 为读文件而打开文件         |\n| ios::out    | 为写文件而打开文件         |\n| ios::ate    | 初始位置：文件尾           |\n| ios::app    | 追加方式写文件             |\n| ios::trunc  | 如果文件存在先删除，再创建 |\n| ios::binary | 二进制方式                 |\n\n**注意：** 文件打开方式可以配合使用，利用|操作符\n\n**例如：**用二进制方式写文件 `ios::binary |  ios:: out`\n\n\n\n\n\n**示例：**\n\n```C++\n#include <fstream>\n\nvoid test01()\n{\n\tofstream ofs;\n\tofs.open(\"test.txt\", ios::out);\n\n\tofs << \"姓名：张三\" << endl;\n\tofs << \"性别：男\" << endl;\n\tofs << \"年龄：18\" << endl;\n\n\tofs.close();\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n总结：\n\n* 文件操作必须包含头文件 fstream\n* 读文件可以利用 ofstream  ，或者fstream类\n* 打开文件时候需要指定操作文件的路径，以及打开方式\n* 利用<<可以向文件中写数据\n* 操作完毕，要关闭文件\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 5.1.2读文件\n\n\n\n读文件与写文件步骤相似，但是读取方式相对于比较多\n\n\n\n读文件步骤如下：\n\n1. 包含头文件   \n\n   \\#include <fstream\\>\n\n2. 创建流对象  \n\n   ifstream ifs;\n\n3. 打开文件并判断文件是否打开成功\n\n   ifs.open(\"文件路径\",打开方式);\n\n4. 读数据\n\n   四种方式读取\n\n5. 关闭文件\n\n   ifs.close();\n\n\n\n**示例：**\n\n```C++\n#include <fstream>\n#include <string>\nvoid test01()\n{\n\tifstream ifs;\n\tifs.open(\"test.txt\", ios::in);\n\n\tif (!ifs.is_open())\n\t{\n\t\tcout << \"文件打开失败\" << endl;\n\t\treturn;\n\t}\n\n\t//第一种方式\n\t//char buf[1024] = { 0 };\n\t//while (ifs >> buf)\n\t//{\n\t//\tcout << buf << endl;\n\t//}\n\n\t//第二种\n\t//char buf[1024] = { 0 };\n\t//while (ifs.getline(buf,sizeof(buf)))\n\t//{\n\t//\tcout << buf << endl;\n\t//}\n\n\t//第三种\n\t//string buf;\n\t//while (getline(ifs, buf))\n\t//{\n\t//\tcout << buf << endl;\n\t//}\n\n\tchar c;\n\twhile ((c = ifs.get()) != EOF)\n\t{\n\t\tcout << c;\n\t}\n\n\tifs.close();\n\n\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n总结：\n\n- 读文件可以利用 ifstream  ，或者fstream类\n- 利用is_open函数可以判断文件是否打开成功\n- close 关闭文件 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 5.2 二进制文件\n\n以二进制的方式对文件进行读写操作\n\n打开方式要指定为 ==ios::binary==\n\n\n\n#### 5.2.1 写文件\n\n二进制方式写文件主要利用流对象调用成员函数write\n\n函数原型 ：`ostream& write(const char * buffer,int len);`\n\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n\n\n\n**示例：**\n\n```C++\n#include <fstream>\n#include <string>\n\nclass Person\n{\npublic:\n\tchar m_Name[64];\n\tint m_Age;\n};\n\n//二进制文件  写文件\nvoid test01()\n{\n\t//1、包含头文件\n\n\t//2、创建输出流对象\n\tofstream ofs(\"person.txt\", ios::out | ios::binary);\n\t\n\t//3、打开文件\n\t//ofs.open(\"person.txt\", ios::out | ios::binary);\n\n\tPerson p = {\"张三\"  , 18};\n\n\t//4、写文件\n\tofs.write((const char *)&p, sizeof(p));\n\n\t//5、关闭文件\n\tofs.close();\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n总结：\n\n* 文件输出流对象 可以通过write函数，以二进制方式写数据\n\n\n\n\n\n\n\n\n\n\n\n#### 5.2.2 读文件\n\n二进制方式读文件主要利用流对象调用成员函数read\n\n函数原型：`istream& read(char *buffer,int len);`\n\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n\n示例：\n\n```C++\n#include <fstream>\n#include <string>\n\nclass Person\n{\npublic:\n\tchar m_Name[64];\n\tint m_Age;\n};\n\nvoid test01()\n{\n\tifstream ifs(\"person.txt\", ios::in | ios::binary);\n\tif (!ifs.is_open())\n\t{\n\t\tcout << \"文件打开失败\" << endl;\n\t}\n\n\tPerson p;\n\tifs.read((char *)&p, sizeof(p));\n\n\tcout << \"姓名： \" << p.m_Name << \" 年龄： \" << p.m_Age << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n- 文件输入流对象 可以通过read函数，以二进制方式读数据\n","tags":["C++"]},{"title":"日期类","url":"/2022/12/11/5/","content":"```\n#include<iostream>\n\nusing namespace std;\n\nclass Date\n{\npublic:\n    void set(int year, int month, int day)\n    {\n        this->year = year;\n        this->month = month;\n        this->day = day;\n    }\n    //前置++\n    Date& operator++()\n    {\n        if (day < 28)\n        {\n            day++;\n            return *this;\n        }\n        else if (month == 2)\n        {\n            if (day == 28 && !(year % 400 == 0 || (year % 4 == 0 && year % 100 != 0)))\n            {\n                day++;\n                return *this;\n            }\n            month++, day = 1;\n            return *this;\n        }\n        else if (day == 29)\n        {\n            day++;\n            return *this;\n        }\n        else if (day == 30)\n        {\n            switch (month)\n            {\n            case 4:case 6:case 9:case 11:\n                day = 1;\n                month++;\n                return *this;\n                break;\n            }\n            day++;\n            return *this;\n        }\n        else if (month == 12)\n        {\n            year++, month = 1, day = 1;\n            return *this;\n        }\n        else\n        {\n            month++;\n            day = 1;\n            return *this;\n        }\n    }\n    //后置++\n    Date operator++(int)\n    {\n        Date* temp = this;\n        return *temp;\n        ++(*this);\n    }\n    //前置--\n    Date& operator--()\n    {\n        if (day == 1)\n        {\n            switch (month)\n            {\n            case 2:case4:case 6:case 8:case 9:case 11:\n                day = 31;\n                month--;\n                break;\n            case 5:case 7:case 10:case 12:\n                day = 30;\n                month--;\n                break;\n            case 1:\n                month = 12;\n                year--;\n                day = 31;\n            case 3:\n                if (year % 4 != 0)\n                    month--;\n                day = 28;\n                month--;\n                day = 29;\n                break;\n            default:\n                break;\n            }\n\n        }\n        else\n            day--;\n        return *this;\n    }\n    //后置--\n    Date operator--(int)\n    {\n        Date* temp = this;\n        return *temp;\n        --(*this);\n    }\npublic:\n    int year;\n    int month;\n    int day;\n};\n\nvoid show(Date data)\n{\n    cout << \"年：\" << data.year << \"月：\" << data.month << \"日：\" << data.day << endl;\n}\n\nint main()\n{\n    Date data;\n    data.set(2012, 4, 29);\n    show(data);\n    int a;\n    cout << \"选择：1、后置递增\\t 2、前置递增\\t 3、后置递减\\t 4、前置递减\" << endl;\n    cin >> a;\n    switch (a)\n    {\n    case 1:\n        show(data++);\n        break;\n    case 2:\n        show(++data);\n        break;\n    case 3:\n        show(data--);\n        break;\n    case 4:\n        show(--data);\n        break;\n    default:\n        break;\n    }\n    return 0;\n}\n```\n","tags":["C++"]},{"title":"学生信息管理系统","url":"/2022/12/11/4/","content":"\n```\n#include<iostream>\n#include<string>\n#include<vector>\n#include<windows.h>\n#include<algorithm>\n\nusing namespace std;\n\nclass student\n{\npublic:\n    string s_name;\n    int s_id = 0;\n    int y_score = 0;//语文成绩\n    int s_score = 0;//数学成绩\n    int e_score = 0;//英语成绩\n    int s_total = 0;\n};\n\nvector<student> v;\nvector<student>z;\n\nvoid showmenu()\n{\n    cout << \"*******************************\" << endl;\n    cout << \"欢迎来到学生管理系统\" << endl;\n    cout << \"请选择您的操作\" << endl;\n    cout << \"1.添加学生\" << endl;\n    cout << \"2.输出学生列表\" << endl;\n    cout << \"3.对成绩进行排序\" << endl;\n    cout << \"4.根据学号查找学生信息\" << endl;\n    cout << \"输入其他字符退出程序\" << endl;\n    cout << \"*******************************\" << endl;\n}\n\nvoid showstudent(vector<student>& a)\n{\n    for (vector<student>::iterator it = a.begin(); it != a.end(); it++)\n    {\n        cout << \"姓名：\" << (*it).s_name << \"\\t学号：\" << (*it).s_id << \"\\t语文成绩：\" << (*it).y_score << \"\\t数学成绩：\" << (*it).s_score << \"\\t英语成绩：\" << (*it).e_score << \"\\t总成绩：\" << (*it).s_total << endl;\n    }\n}\n\nvoid showstudent1(vector<student>& a)\n{\n    int i = 1;\n    for (vector<student>::iterator it = a.begin(); it != a.end(); it++, i++)\n    {\n        cout << \"第\" << i << \"名： 姓名：\" << (*it).s_name << \"\\t学号：\" << (*it).s_id << \"\\t语文成绩：\" << (*it).y_score << \"\\t数学成绩：\" << (*it).s_score << \"\\t英语成绩：\" << (*it).e_score << \"\\t总成绩：\" << (*it).s_total << endl;\n    }\n}\n\nbool comp(const student& a, const student& b)\n{\n    return a.s_total > b.s_total;\n}\n\nint main()\n{\n    while (true)\n    {\n    aaa:\n        showmenu();\n        int a;\n        cin >> a;\n        system(\"cls\");\n        switch (a)\n        {\n        case 1:\n        {\n            student stu;\n            cout << \"姓名：\" << endl;\n            cin >> stu.s_name;\n            cout << \"学生号：\" << endl;\n            cin >> stu.s_id;\n            cout << \"语文成绩\" << endl;\n            cin >> stu.y_score;\n            cout << \"数学成绩\" << endl;\n            cin >> stu.s_score;\n            cout << \"英语成绩\" << endl;\n            cin >> stu.e_score;\n            stu.s_total = stu.y_score + stu.s_score + stu.e_score;\n            v.push_back(stu);\n            cout << \"添加成功！\" << endl;\n            Sleep(1000);\n            system(\"cls\");\n            break;\n        }\n        case 2:\n        {\n            showstudent(v);\n            system(\"pause\");\n            system(\"cls\");\n            break;\n        }\n        case 3:\n        {\n            z = v;\n            sort(z.begin(), z.end(), comp);\n            showstudent1(z);\n            system(\"pause\");\n            system(\"cls\");\n            break;\n        }\n        case 4:\n        {\n            int id;\n            cout << \"请输入学生id号：\" << endl;\n            cin >> id;\n            for (vector<student>::iterator it = v.begin(); it != v.end(); it++)\n            {\n                if ((*it).s_id == id)\n                {\n                    cout << \"查找成功 学生信息如下：\" << endl;\n                    cout << \"姓名：\" << (*it).s_name << \"\\t学号：\" << (*it).s_id << \"\\t语文成绩：\" << (*it).y_score << \"\\t数学成绩：\" << (*it).s_score << \"\\t英语成绩：\" << (*it).e_score << \"\\t总成绩：\" << (*it).s_total << endl;\n                    system(\"pause\");\n                    system(\"cls\");\n                    goto aaa;\n                }\n            }\n            cout << \"查无此人！\" << endl;\n            system(\"pause\");\n            system(\"cls\");\n            break;\n        }\n        default:\n        {\n            goto bbb;\n        }\n        }\n\n    }\nbbb:\n    return 0;\n}\n```\n\n","tags":["C++"]},{"title":"糖果机","url":"/2022/12/11/3/","content":"\n```\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<windows.h>\n\nusing namespace std;\n\nclass Users {\nprivate:\n\tmap<string, string> m;\npublic:\n\tUsers()\n\t{\n\t\tm[\"Administrator\"] = string(\"114514\");\n\t}\n\n\tbool check(string username, string password)\n\t{\n\t\tauto it = m.find(username);\n\t\tif (it == m.end())\n\t\t\treturn false;\n\t\tif (it->second != password)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tbool login()\n\t{\n\t\tputs(\"输入用户名:\");\n\t\tstring uname;\n\t\tcin >> uname;\n\t\tputs(\"输入密码:\");\n\t\tstring passw;\n\t\tcin >> passw;\n\t\tif (!check(uname, passw))\n\t\t{\n\t\t\tputs(\"用户名或密码错误\");\n\t\t\tSleep(600);\n\t\t\treturn false;\n\t\t}\n\t\tputs(\"登录成功\");\n\t\tSleep(600);\n\t\tsystem(\"cls\");\n\t\treturn true;\n\t}\n}users;\n\nclass CandyList {\nprivate:\n\tmap<string, int> list;//名字到id的映射\n\tvector<string> nameList;\npublic:\n\tCandyList()\n\t{\n\t\tnameList.resize(1);\n\t}\n\n\tint queryId(string name)//传入名字，返回id，不存在返回0\n\t{\n\t\tauto it = list.find(name);\n\t\tif (it != list.end())\n\t\t\treturn it->second;\n\t\treturn 0;\n\t}\n\n\tstring queryName(int id)//传入ID 返回名字\n\t{\n\t\tif (id > nameList.size())\n\t\t\treturn string(\"\");\n\t\treturn nameList[id];\n\t}\n\n\tint addCandyKind(string name)//无论有没有，都返回id\n\t{\n\t\tint id = queryId(name);\n\t\tif (id)\n\t\t\treturn id;\n\t\tid = list.size() + 1;\n\t\tlist[name] = id;\n\t\tnameList.push_back(name);\n\t\treturn id;\n\t}\n}candyList;\n\nclass Store {//仓库\nprivate:\n\tvector<pair<int, int> > s; //数量、单价\n\tint sum;\npublic:\n\tStore()\n\t{\n\t\ts.clear();\n\t\ts.resize(100);\n\t\tsum = 0;\n\t}\n\tint getSum()\n\t{\n\t\treturn sum;\n\t}\n\n\tint getPrice(int id)\n\t{\n\t\treturn s[id].second;\n\t}\n\n\tvoid displayCandy()\n\t{\n\t\tcout << \"编号\\t品名\\t剩余数量 单价\" << endl;\n\t\tfor (int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\tif (s[i].first > 0)\n\t\t\t{\n\t\t\t\tcout << i << \"\\t\" << candyList.queryName(i) << \"\\t\" << s[i].first << \"\\t \" << s[i].second << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid addCandy(string name, int num, int price = -1)\n\t{\n\t\tbool ok = 1;\n\t\tif (num < 1)\n\t\t\tok = 0, puts(\"数量错误\");\n\t\tif (price < -1 || price == 0)\n\t\t\tok = 0, puts(\"价格错误\");\n\t\tif (!ok)\n\t\t\treturn;\n\t\tint id = candyList.addCandyKind(name);\n\t\ts[id].first += num;\n\t\tsum += num;\n\t\tif (~price)\n\t\t\ts[id].second = price;//更新价格\n\t}\n\n\tint rmCandy(int id, int num, int pay)//卖糖\n\t{\n\t\tif (!id)\n\t\t{\n\t\t\tputs(\"编号错误！\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (s[id].first < num)\n\t\t{\n\t\t\tputs(\"数量不足\");\n\t\t\treturn 0;\n\t\t}\n\t\tint totPrice = num * s[id].second;\n\t\tif (pay < totPrice)\n\t\t{\n\t\t\tputs(\"钱不够\");\n\t\t\treturn -1;\n\t\t}\n\t\ts[id].first -= num;\n\t\tsum -= num;\n\t\treturn pay - totPrice;\n\t}\n}store;\n\nclass Show {//前端\nprivate:\n\tinline void read(int& x)\n\t{\n\t\tint s = 0, w = 1;\n\t\tchar ch = getchar();\n\t\twhile (ch < '0' || ch > '9')\n\t\t{\n\t\t\tif (ch == '-')\n\t\t\t\tw = -1;\n\t\t\tch = getchar();\n\t\t}\n\t\twhile (ch >= '0' && ch <= '9')\n\t\t\ts = s * 10 + ch - '0', ch = getchar();\n\t\tx = s * w;\n\t}\n\npublic:\n\tShow()\n\t{\n\t\tstore.addCandy(string(\"白砂糖\"), 10, 10);\n\t}\n\tvoid run()\n\t{\n\t\tprintf(\"启动中\");\n\t\tfor (int i = 0; i < 5; i++)\n\t\t{\n\t\t\tSleep(100);\n\t\t\tprintf(\".\");\n\t\t}\n\t\twhile (1)\n\t\t{\n\t\taa:\n\t\t\tsystem(\"cls\");\n\t\t\tif (store.getSum())\n\t\t\t\tprintf(\"营业中!\\n买糖请输入1\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"缺货 暂停营业！\\n\");\n\t\t\tputs(\"加糖请输入2\\n退出系统输入3\");\n\t\t\tint type = 0;\n\t\t\t//read(type);//提高容错性\n\t\t\tcin >> type;\n\t\t\tswitch (type)\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t{\n\t\t\t\tcout << \"欢迎光临！\" << endl;\n\t\t\t\tstore.displayCandy();\n\t\t\t\tputs(\"输入编号：\");\n\t\t\t\tint id;\n\t\t\t\tread(id);\n\t\t\t\tputs(\"输入数量：\");\n\t\t\t\tint num;\n\t\t\t\tread(num);\n\t\t\t\tputs(\"请付款：\");\n\t\t\t\tint pay;\n\t\t\t\tread(pay);\n\t\t\t\tint temp = store.rmCandy(id, num, pay);\n\t\t\t\tif (temp > 0)\n\t\t\t\t\tcout << \"给你找零:\" << temp << endl << \"\\n欢迎下次光临！\";\n\t\t\t\telse if (temp == 0)\n\t\t\t\t\tcout << \"交易成功 欢迎下次光临！\" << endl;\n\t\t\t\tSleep(1000);\n\t\t\t\tsystem(\"cls\");\n\t\t\t\tgoto aa;\n\t\t\t}\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\tif (!users.login())\n\t\t\t\t\tcontinue;\n\t\t\t\tputs(\"请输入品名\");\n\t\t\t\tstring name;\n\t\t\t\tcin >> name;\n\t\t\t\tint id = candyList.queryId(name);//不存在这个糖 id==0\n\t\t\t\tputs(\"请输入数量\");\n\t\t\t\tint num, price;\n\t\t\t\tbool transPrice = 0;\n\t\t\t\tread(num);\n\t\t\t\tif (!id)\n\t\t\t\t\tputs(\"输入定价(分/个)\"), read(price), transPrice = 1;\n\t\t\t\tif (transPrice)\n\t\t\t\t\tstore.addCandy(name, num, price);\n\t\t\t\telse\n\t\t\t\t\tstore.addCandy(name, num);\n\t\t\t\tgoto aa;\n\t\t\t}\n\t\t\tcase 3:\n\t\t\t{\n\t\t\t\tgoto flag;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tcout << \"输入错误！请重新输入！\" << endl;\n\t\t\t\tSleep(1000);\n\t\t\t\tgoto aa;\n\t\t\t}\n\t\t\t}\n\t\tflag:\n\t\t\tcout << \"正在退出\";\n\t\t\tfor (int i = 0; i < 5; i++)\n\t\t\t{\n\t\t\t\tSleep(100);\n\t\t\t\tprintf(\".\");\n\t\t\t}\n\t\t\tcout << \"\\n已退出！再见！\" << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n};\n\nint main()\n{\n\tShow machine;\n\tmachine.run();\n\tsystem(\"pause\");\n}\n```\n\n","tags":["C++"]},{"title":"打印玫瑰花","url":"/2022/12/11/2/","content":"\n```\n#include <stdio.h>\n#include <math.h>\n\nconst int max_iterations = 128;\nconst float stop_threshold = 0.01f;\nconst float grad_step = 0.01f;\nconst float clip_far = 10.0f;\n\nconst float PI = 3.14159265359f;\nconst float PI2 = 6.28318530718f;\nconst float DEG_TO_RAD = PI / 180.0f;\n\ntypedef struct { float x, y; } vec2;\ntypedef struct { float x, y, z; } vec3;\ntypedef struct { float m[9]; } mat3;\n\nconst vec3 light_pos = { 20.0f, 50.0f, 20.0f };\n\nfloat min(float a, float b) { return a < b ? a : b; }\nfloat max(float a, float b) { return a > b ? a : b; }\nfloat clamp(float f, float a, float b) { return max(min(f, b), a); }\nvec2 make2(float x, float y) { vec2 r = { x, y }; return r; }\nvec2 add2(vec2 a, vec2 b) { vec2 r = { a.x + b.x, a.y + b.y }; return r; }\nvec2 sub2(vec2 a, vec2 b) { vec2 r = { a.x - b.x, a.y - b.y }; return r; }\nfloat dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat length2(vec2 v) { return sqrt(dot2(v, v)); }\nvec3 make3(float x, float y, float z) { vec3 r = { x, y, z }; return r; }\nvec3 add3(vec3 a, vec3 b) { vec3 r = { a.x + b.x, a.y + b.y, a.z + b.z }; return r; }\nvec3 sub3(vec3 a, vec3 b) { vec3 r = { a.x - b.x, a.y - b.y, a.z - b.z }; return r; }\nvec3 mul3(vec3 a, vec3 b) { vec3 r = { a.x * b.x, a.y * b.y, a.z * b.z }; return r; }\nvec3 scale3(vec3 v, float s) { vec3 r = { v.x * s, v.y * s, v.z * s }; return r; }\nfloat dot3(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat length3(vec3 v) { return sqrt(dot3(v, v)); }\nvec3 normalize3(vec3 v) { return scale3(v, 1.0f / length3(v)); }\nvec3 mul(mat3 m, vec3 v) {\n    return make3(\n        m.m[0] * v.x + m.m[3] * v.y + m.m[6] * v.z,\n        m.m[1] * v.x + m.m[4] * v.y + m.m[7] * v.z,\n        m.m[2] * v.x + m.m[5] * v.y + m.m[8] * v.z);\n}\n\nmat3 rotationXY(float x, float y) {\n    vec2 c = { cos(x), cos(y) }, s = { sin(x), sin(y) };\n    mat3 m = {\n        c.y      , 0.0f, -s.y,\n        s.y * s.x,  c.x,  c.y * s.x,\n        s.y * c.x, -s.x,  c.y * c.x\n    };\n    return m;\n}\n\nfloat opI(float d1, float d2) { return max(d1, d2); }\nfloat opU(float d1, float d2) { return min(d1, d2); }\nfloat opS(float d1, float d2) { return max(-d1, d2); }\n\nfloat sdPetal(vec3 p, float s) {\n    p = add3(mul3(p, make3(0.8f, 1.5f, 0.8f)), make3(0.1f, 0.0f, 0.0f));\n    vec2 q = make2(length2(make2(p.x, p.z)), p.y);\n\n    float lower = length2(q) - 1.0f;\n    lower = opS(length2(q) - 0.97f, lower);\n    lower = opI(lower, q.y);\n\n    float upper = length2(sub2(q, make2(s, 0.0f))) + 1.0f - s;\n    upper = opS(upper, length2(sub2(q, make2(s, 0.0f))) + 0.97f - s);\n    upper = opI(upper, -q.y);\n    upper = opI(upper, q.x - 2.0f);\n\n    float region = length3(sub3(p, make3(1.0f, 0.0f, 0.0f))) - 1.0f;\n    return opI(opU(upper, lower), region);\n}\n\nfloat map(vec3 p) {\n    float d = 1000.0f, s = 2.0f;\n    mat3 r = rotationXY(0.1f, PI2 * 0.618034f);\n    r.m[0] *= 1.08f;  r.m[1] *= 1.08f;  r.m[2] *= 1.08f;\n    r.m[3] *= 0.995f; r.m[4] *= 0.995f; r.m[5] *= 0.995f;\n    r.m[6] *= 1.08f;  r.m[7] *= 1.08f;  r.m[8] *= 1.08f;\n    for (int i = 0; i < 21; i++) {\n        d = opU(d, sdPetal(p, s));\n        p = mul(r, p);\n        p = add3(p, make3(0.0, -0.02, 0.0));\n        s *= 1.05f;\n    }\n    return d;\n}\n\nvec3 gradient(vec3 pos) {\n    const vec3 dx = { grad_step, 0.0, 0.0 };\n    const vec3 dy = { 0.0, grad_step, 0.0 };\n    const vec3 dz = { 0.0, 0.0, grad_step };\n    return normalize3(make3(\n        map(add3(pos, dx)) - map(sub3(pos, dx)),\n        map(add3(pos, dy)) - map(sub3(pos, dy)),\n        map(add3(pos, dz)) - map(sub3(pos, dz))));\n}\n\nfloat ray_marching(vec3 origin, vec3 dir, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < max_iterations; i++) {\n        float dist = map(add3(origin, scale3(dir, depth)));\n        if (dist < stop_threshold)\n            return depth;\n        depth += dist * 0.3;\n        if (depth >= end)\n            return end;\n    }\n    return end;\n}\n\nfloat shading(vec3 v, vec3 n, vec3 eye) {\n    vec3 ev = normalize3(sub3(v, eye));\n    vec3 vl = normalize3(sub3(light_pos, v));\n    float diffuse = dot3(vl, n) * 0.5f + 0.5f;\n    vec3 h = normalize3(sub3(vl, ev));\n    float rim = pow(1.0f - max(-dot3(n, ev), 0.0f), 2.0f) * 0.15f;\n    float ao = clamp(v.y * 0.5f + 0.5f, 0.0f, 1.0f);\n    return (diffuse + rim) * ao;\n}\n\nvec3 ray_dir(float fov, vec2 pos) {\n    vec3 r = { pos.x, pos.y, -tan((90.0f - fov * 0.5f) * DEG_TO_RAD) };\n    return normalize3(r);\n}\n\nfloat f(vec2 fragCoord) {\n    vec3 dir = ray_dir(45.0f, fragCoord);\n    vec3 eye = { 0.0f, 0.0f, 4.5f };\n    mat3 rot = rotationXY(-1.0f, 1.0f);\n\n    dir = mul(rot, dir);\n    eye = mul(rot, eye);\n\n    float depth = ray_marching(eye, dir, 0.0f, clip_far);\n    vec3 pos = add3(eye, scale3(dir, depth));\n    if (depth >= clip_far)\n        return 0.0f;\n    else\n        return shading(pos, gradient(pos), eye);\n}\n\nint main() {\n    puts(\"\\033[91m\");\n    for (int y = 0; y < 80; y++) {\n        for (int x = 0; x < 160; x++)\n            putchar(\"  .,-:;+=*#@\"[(int)(f(make2((x / 160.0f - 0.5f) * 2.0f, (y / 80.0f - 0.5f) * -2.0f)) * 12.0f)]);\n        putchar('\\n');\n    }\n}\n```\n\n","tags":["C++"]},{"title":"ATM机","url":"/2022/12/11/1/","content":"\n```\n#include <string>\n#include <iostream>\n#include <vector>\n#include <Windows.h>\n#include <stdlib.h>\n#include <fstream>\n#include <ctime>\n\nusing namespace std;\n\nclass Account\n{\npublic:\n    string name;//姓名\n    int accountNumber = 0;//账号\n    int pinNumber = 0;//密码\n    int balance = 0;//余额\npublic:\n    bool welcome();//初始界面\n    void show();//打印菜单\n    void deposit();//存款\n    void withdrawal();//取款\n    void tran();//转账\n    void change();//修改密码\n    void getbalance();//查询余额\n    void print();//打印账号信息\n};\n\nvector<Account> account;\nAccount ATM;\nvector<Account>::iterator atm;\n\nvoid wait() {\n    int a = getchar();\n    a = getchar();\n}\n\nvoid keep() {\n    ofstream ofs(\"ATM.txt\");\n    if (ofs.is_open()) {\n        vector<Account>::iterator it;\n        for (it = account.begin(); it != account.end(); it++) {\n            ofs << it->name << \"\\t\" << it->accountNumber << \"\\t\" << it->pinNumber << \"\\t\" << it->balance << \"\\t\" << endl;\n        }\n        ofs.close();\n    }\n}\n\nvoid open() {\n    ifstream ifs(\"ATM.txt\");\n    if (ifs.is_open()) {\n        cout << \"文件打开成功！\" << endl;\n        system(\"cls\");\n        Account a;\n        while (ifs >> a.name >> a.accountNumber >> a.pinNumber >> a.balance) {\n            account.push_back(a);\n        }\n        ifs.close();\n    }\n    else {\n        cout << \"文件不存在！\" << endl;\n    }\n}\n\nbool Account::welcome() {\n    Account temp;\n    cout << \"欢迎使用！\\n请选择操作：\\n 1、登录\\n 2、开户\\n 3、退出\" << endl;\n    int a;\n    cin >> a;\n    system(\"cls\");\n    switch (a)\n    {\n    case 1: {\n        if (account.begin() == account.end()) {\n            cout << \"没有账号，无法登录！\" << endl;\n            wait();\n            return false;\n        }\n        else {\n            cout << \"请输入账号：\" << endl;\n            cin >> temp.accountNumber;\n            for (vector<Account>::iterator it = account.begin(); it != account.end(); it++) {\n                if (it->accountNumber == temp.accountNumber) {\n                    cout << \"请输入密码：\" << endl;\n                    cin >> temp.pinNumber;\n                    if (it->pinNumber == temp.pinNumber) {\n                        atm = it;\n                        cout << \"登陆成功！\" << endl;\n                        wait();\n                        return true;\n                    }\n                    else {\n                        cout << \"密码错误，无法登录！\" << endl;\n                        wait();\n                        return false;\n                    }\n                }\n            }\n            cout << \"账号不存在！\" << endl;\n            return false;\n        }\n    }\n    case 2: {\n        cout << \"请输入姓名：\" << endl;\n        cin >> temp.name;\n        cout << \"请输入密码：\" << endl;\n        cin >> temp.pinNumber;\n        srand(unsigned int(time(0)));\n        srand(temp.pinNumber + rand());\n        temp.accountNumber = rand() * 10000000 % 10000000 + 60000000;\n        cout << \"开户成功，您的账号为：\" << temp.accountNumber << endl;\n        account.push_back(temp);\n        wait();\n        return false;\n        break;\n    }\n    case 3: {\n        keep();\n        cout << \"感谢使用，再见！\" << endl;\n        exit(0);\n    }\n    default:return false; break;\n    }\n}\n\nvoid Account::show() {\n    system(\"cls\");\n    cout << \"请选择你需要的服务\" << endl;\n    cout << \"1、存款\" << endl;\n    cout << \"2、取款\" << endl;\n    cout << \"3、转账\" << endl;\n    cout << \"4、查询余额\" << endl;\n    cout << \"5、修改密码\" << endl;\n    cout << \"6、显示账号信息\" << endl;\n    cout << \"7、退出\" << endl;\n}\n\nvoid Account::deposit() {\n    int temp;\n    cout << \"请输入存款金额：\" << endl;\n    cin >> temp;\n    atm->balance += temp;\n    cout << \"存款成功！\" << endl;\n}\n\nvoid Account::withdrawal() {\n    cout << \"请输入取款金额：\" << endl;\n    int temp;\n    cin >> temp;\n    if (temp > atm->balance)\n        cout << \"余额不足！\" << endl;\n    else\n        atm->balance -= temp;\n    cout << \"成功！\" << endl;\n}\n\nvoid Account::tran() {\n    Account temp;\n    cout << \"请输入对方账户：\" << endl;\n    cin >> temp.accountNumber;\n    for (vector<Account>::iterator it = account.begin(); it != account.end(); it++) {\n        if (temp.accountNumber == it->accountNumber)\n        {\n            int a;\n            cout << \"请输入转账金额：\" << endl;\n            cin >> a;\n            if (a < atm->balance && a > 0) {\n                atm->balance -= a;\n                it->balance += a;\n                cout << \"转账成功！\" << endl;\n                return;\n            }\n            else if (a > atm->balance) {\n                cout << \"余额不足！\" << endl;\n                return;\n            }\n            else {\n                cout << \"输入错误！\" << endl;\n                return;\n            }\n        }\n    }\n    cout << \"账户不存在！\" << endl;\n    return;\n}\n\nvoid Account::change() {\n    cout << \"请输入新密码\" << endl;\n    cin >> atm->pinNumber;\n    cout << \"修改成功！\" << endl;\n}\n\nvoid Account::getbalance() {\n    cout << \"余额为：\" << atm->balance << endl;\n}\n\nvoid Account::print() {\n    cout << \"姓名：\" << atm->name << endl;\n    cout << \"账户名：\" << atm->accountNumber << endl;\n    cout << \"余额：\" << atm->balance << endl;\n}\n\nint main() {\n    open();\naaa:\n    system(\"cls\");\n    bool b = ATM.welcome();\n    while (b) {\n        int a;\n        ATM.show();\n        cin >> a;\n        switch (a) {\n        case 1:system(\"cls\"); (*atm).deposit(); wait(); break;\n        case 2:system(\"cls\"); (*atm).withdrawal(); wait(); break;\n        case 3:system(\"cls\"); (*atm).tran(); wait(); break;\n        case 4:system(\"cls\"); (*atm).getbalance(); wait(); break;\n        case 5:system(\"cls\"); (*atm).change(); wait(); break;\n        case 6:system(\"cls\"); (*atm).print(); wait(); break;\n        case 7:system(\"cls\"); keep(); cout << \"感谢使用，再见！\" << endl; b = false; break;\n        default:break;\n        }\n    }\n    goto aaa;\n}\n```\n\n","tags":["C++"]}]