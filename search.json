[{"title":"十六进制转二进制并输出","url":"/2023/04/26/12/","content":"<div class=\"hbe hbe-container\" id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"4d35220c272171e7b414ae3ee830b1cfbbe0708e01c89607dbc13bcb411dd1b7\">8ef851a927cd6b9ea5d9c7ab2590da3e48e1bd47d4f71bdea42ec43c611d3c2930dc7d716f80da197847311ff81042ebff3cf14be6f8144fafd306e18602115513a62ec5d176a45f6369582de175233550a87610634de2a399da2585b6d8a42ad54ac03e0958e8b38b71343fb90444bacb9ef59e7b19ef5740679a33e2c03fb5b7f05cf03b418ee9b02aeba9900b844fe451f8d2ae9d8e0114d63c2f49e34c6bba8fddd961b2d7cb0b26e3846b8c5e4a91c51cd0f145116122673e6de4e6cfefa2466a5484a111feab4f87cd79c6dd5dbe434b32553f6a9b3c0bb328a7115d57bbb5b6cdb6e5ea6b6ef2c8a76b0458c970e6daaacc614f99b22238f243d741f51c57d59d7c7d490a6e8dc3e08615a067289cb1cc7707b0220993783bd94f81da8906d4ea20816098da1c7ba62318cd6cf2748ce550745e40f289940ab9fd0b36204bd6a0c2ab9b7989d81a490feb8ae68d00545ad8587fb0c294f3dffe8a384df0f6dc0994b49747ebad9267202c8b19680ef2caccb8998cc579d597fd06de7ca4ba740fba797b7db25e74c89deaa297a107ff241ca0bf7b70e00ed9b0f1b18c682941f39f82bc8623c9b515971043a21e33accd2cdcd43dd2331b33cd2950cd68d9538f4ba5ae89b1f87484956a80330f4cad4dbd22cd35d6e4afbd7c98e03c8bf43248d46d664e08760277a28d3d757656dd741a11413961fd8ad49d8c8e4b4dcf29f22a3017e0d3851f747e7184d97ecca66e6027e28bb258070dd3c3dea3dfdd33ae9f05fc619b5c1be45c01c61802e8f4ad4aa5e50bcc4ebae5fe2f0ad7770ccf482f0755497b555d823649d13d81ea756589cf1b3931f2148491b24cba52aa2288835e3492d2338a1603fbf4901e49f4d2bcaadda16ae7acfc1156c4cfcf7486af8fc8a7f6b740a2491ba64b40b112c937fadc73293bc718dc5caff2d5e5e61e9f2ff60642e8d04ba5f44863c8cdd2c814e67e8de0c34da81dc737ec3e8d6b4c2075a436e7d060ee5acf9bdac6ac483d14249bec72d7c0cf99aa1b8c9f67cb74a9a9192118ef36ce7514bf247445f821f6646b399df481e860117c37a7296968907ca96e70fad7fc445ee964b4bf0baeb672137cf59aa193cf85e02f0a4f175279109ab8f4c1e1a3cd37a8146f46e8f8e9e4e7a52258bcfec975dea5e7448ab9f07fb3f9bdb59678149f2a97cd7a330ade152ca3c845cb81c4829386c105033cd06bfcbd9b0479ea44fcd0cc734906926b38b72ce20109557e7aaa1fcdc06c82df06d1ab869a283d135c30f647aea27e89a9532f11f7bc5fd803b8f46f68c21b6e4b5316645eb88ce72db3e0d9a861765de9eca48318770d405b17ad9363422996715a680d3c2c2a4f7c46b05feed087d4b5cc1289de3bf5c23b0922c049822dce981e0ef7ee4c7a11d9c00633423c3db34042adc5475c57fea089678032d37654d915e7d3f42a2cc98a058a345122061e0eeb8421fe36fac273d12d215466daff36a38e308808e6d036aea1a7a190b2f32ae81a92887bd79569135b90e36cc59e04d970400f197245ad0680a2e7ecca0f9c1d1cd69571359a1929ba5fe0f14e1b9e3fba12b2e031a84debd3b458a02f066f80b6651474daea4c2649b93725a0437f25c26f3cedd1182a0fadb7af30227925c4d42ba8bff6ac153d56e0449d7756fcaac341cb5ca317bfb6e1b033f04f8df768c41ae44d8d7de9f58397b582c6c93ac1f4fd02a99c57370015cf55b846770b3e8ce295328c1c8b23b7f6169c712c2b6e32c919a9630a7420105f90cf4428af178bb64e7354f4ed5d39693447d81baea1656df4c1c1a927e597c72aa20f24157250a3d0a467562c4f3b9ffff068fc28b25cd4011d775bada94e0efcf4f15a1a5068a76d841b9e8354dbe9d672f271524e8150ee2d3ebc55548dca69213a5ca7930e6fffe4f7116c6c3a13b1dc6c5048f5a5396e494f451a032184cc99f2f3c99d0ff3b80148de3bbd922b55a469032a67010e7f57ed1013eb355c39cff892f0f9e54b8beafeedbaf3039efaccde2eaba4a62828919c4b5a1cf8e0be7c16a5b4a165eec2b1f5218944474e690cb1c9047daa29eaa1b9c64f8416bf51558faa0bd7f5a3fd3ab08a85ecc967b630192a9105a6944eb4ae659f5319f3470364c7dd471228581cf741204154d095ac2a1840642ba68bb9788c96c6b02353468074ac1e58579d1e807c19e44c9e2faa49bad49a92ab802d1c04bb9768d00cf67e5b4404dfa0d76a258e72ad094ee24cf0852e00d05c19586fdbd02b5338bddb6472e234461a4dddd41273bfa97561cc98b2e9b132f98e9c7f62e366f0afdaa7907484c0fc73a24865279c10c822adbb3d3c10081a9aa9f80777f7fb2e80adb8d851c917d80d10fd4048c5b0756fe6d61140d5579fea501cff14b8074dc966bb1620e108979ecf540ab97cc1ae6e783929bffdefc7d93cee442ea71001d4b896cf1c48ced73cc81d74c6377d269cf9a88513c710e9d6bb14ca5f6ba020578d6537b8d3f274a9a5c28e671c67083ed8b254b4e5caefcd9a64da05a47c3133f4d1140e5ff526b6eadf3678695db597e6fd083ac1fffdf4b6a091e9c67fdd382bb0e8c5ea00ced3350c68169d9eedb35d4d3c30b02948935b0666a6d991413a0743a68bcb7dde356de402e55f754852c954eebb22f457e5b468c8c0fece47cd520a30efd249aa1f1f95774b1e468a875059f9b5bd29af607b95c7d805726de9b63ef482d3fa03ff24ea034e5072a5d1cf7c347f35ea3a2f0a19d15ffaad60c43b513e5cff59ff32fe070e3882dfabb882216e304fcaf5bd2a05266e0f672af1179896b9bc6bcccc51d926d63056880bfdd71906c85286b896b9c78d3fb777c136ed9aaec2a72ba6ac2a9af28c168e1b65342b8d77784d664615478a192296cff082f3164d154e48993d41c0bff61996d97260aa667db61f91988864fd85aad25f2caa8bd009331959e829d469bc4237e1975e12f5662956272b0802df49c90357c97f207eea48b0eaa74eab698d42d64b02ca4a848bd1d7ff0b769f347dce0bb4cfcef2db0cab5950f472f8ad39e11f72d7d018e7ada386fb3cc47cc016fd2481c5b7c7208634580e3b19fe1e95a68d75cc12a9056ce1eaf6902e609d6430c16fbde3c27d7e7c2e530f9ce49f24105a69b449a8b89d27c42a42c2e6bace8c224f18be035407e9bf7d318e63b1636076de5b88befb3f949107c895452f730128d1ba3486536be3316103704d4223a47cb0226c2ff951fa34ce4805913fa52671c9fe1e1a4c709771ed1275dcb37c98e6a285ac0db9a1cb3465668d1320350a658a62210ebade18ef68a8984d59ef84fa5d685b66e119ac840c5fb2eeb1f484814c20f84884b21d01bb764fcde1c43261d48c4227e74275d35a2156f42b8c192a6cddba16362be4edade14afbfdfc02a542500bab553349961f60165f7524aa3ffe1ed2cdff5619c8b327e3246d081d97195f57eaba19a479380a5c8b7f14deaffbda311a9404bdd92476dd464cda64e22d8a3d0f1f66e3a515252082287668bcae2153a439e5f099ec419666342c8c5afbbbdd3ef12502d6f71c20703f40bb51df1df2b08651970e219100e7bcdeafe56ee70f24d77443de04a293414cde483321b41548432a7de8e63a372ae5c3ef77c9584f52fa530223466c1f33c46415fe63367ef73c84c69cc40e0bf65ba47f61d49f8b6b9d5018d340907b415f46192147fd2e58c046f3488d2f02cfed7962d846d33097ac4cec6be039a86ccfc8e0a66608501c3ae26bbf289d93b80480ab067102969f82b8d482b97b7dfb28e46cdf6b414f06dc34a77327316b7f06120406dba69e938904b96d1e2e22c030d6d019a5e7a6646f3343c6ce48dc91783e0289447484341b273a837767f9bcd88d79edef501e5fd2e4dfb039b77488bc086aacc4e19190f79790f88716f4813d7a038fa95a4fc4fe501b1d946cf33402d35be14194165b928ec81de1598578ef3fe603a66da993b3fe32b289615b0b849167c13a71c4904ef67d507e1c2849ac873dec2089565d8671cc9fd98b200c8dae2e171b621cc8f6c383215ef6a2d902b73aab8dfa5523a73aaa34465083a22fa3d87910ad0bda0c90e897a2f5a2446498e83e0a3b49662d89bc698eb56c6fc9465ef2e586ea061b00ac94350b54a31ea31098a138c3b819e584ebc0db780ea1514fca99cefb63c78324bc5d885e6d194858f51ec456bfd8b2ab23a0327081c03469eda76d8c85975f52528017bf1e7383b4f9630bd9ff12f09aa79550e91e6c07a34a5d3ff1f7589c647441d9b2e02f3b581bfc39455a4616484c04f3955ae10534f568be886ebb3c344dc5eb136c75f65b580ff1636b3a12310c065a6f2f55a78602478ae38c332e83a73258074f1f8b5b9e746cf60feeb0187365a4e2288cf5c6faed8960f9bc6ea6e20aaf60112e2d726dc1916781b6d891f72d1c477fdf44e4e256e86ab951ef5db9aefc85935319cb9df63a6ba2bd7a8e270704e925df72d5119213000940efe8742d397b35b74db8315b209a0f2ebc542f45b952875feb2ec2fc39a988aa20566a219d458a9b04128e6a5b98292aaa2f546ed647e72178417b01daf294177e9a76a2519d40e91b21786d67decc7dcd20a13179111f5cafbaa7d17650b0362e7af7eb2fe8faa5652a122f17f0d9b290b4a8bea07aa5723322f973ac097ca74d58775ae7236f7d933f827e01b2c49fb734c902d07998b85865e2e6f62d2f5d33ed6f617ff09f41a6b29a7b461516564887dd663af9877431edf28e2b9beb2a4cdb3ce4b3b103a63b3d169ac515572136d463d07594061c51f4fa4d22d6765f7cec496332c399584be5f76f491979ab034eee7eacdbdb4b38133e23b0646bf6d1dcdeae15cee1cdf9526995b367217d9ee533785b1ec480e419c548bd08e6946bbbb29ed924306cd17cba2ec54f5406f49a04fe10a00ddc3e3fe710f98b714a9fa9bc180c41addc33d8911be9449cb2a9af42664a6e8d83488bf55ab2db18d12d8afe9988f253ff67c2133c2f5793d2ef33f2c43f872931cd96c988fa19e35ba8c4a8ab34024d819fc35753eda741e03c6c09d5a20583662a0144ff48532f9764ae29efc59bc84913f9df64ae900763dacc7335a47e4b7435cf885fda3914e6c458bd02ed83d62bd6c3e8e7ba82d87eea34300bbf097ec2e17018b2257cb47a5f2ce17e02ca307bbfb0bd01760f99ee0596eb0e78c09a48a06971626882c15c6379f885221e4a1733fff664871e4244840a3cb00ce3728d0565777582ef6b75c8d7f6f6843aa216c17c634a7978c8a66bdf02c10662208131d8e05186e9a76636784a9fe964f2da43231d44a7b5a207ecc34d9a74528600f34ecd9cf6962f5d343dfe70a91ba03309c447a0ed9af28771d1246141f53dec8e185e1aef49861a01b48dc6d0e890081b34c322a889c28be138b8064ee004465bff805196faeb94eb1b6bc9097eec3e63e4c52a9de932a5d6cadc3f34cd9cc66c68d5dd01aa4a42e163eccdfb65e6e08f90ba8b7e6b17e6790212745ac14d9bd6cd703bcb3b95b6868ee1600c67bf08a31f8723145a9de427ee80d718de94ba3324d8b11beccb0a8086e40c6570eb46577856882bab223727185fa592a89284df21e4061e5b767cb8b1bfe330fa9bb27c2f47457030751adc2a42411c8dc70dad49173ae287358d1a60189003033107de3a836df9ab20df2afc55f8bfd83b8292ca0c8b63240c66124477d86045acb40cc05509e93c220d225ed0d03c911dc2ca94dc5e1b3802f09afb046988d847f05e7f8771d717f63e5ee278a65860f3b539d891158b401e5a74e0932ad37b153361ef2164ed349162f68a4fafb8c87d07f805e48393a9a9282720fb08908fb535ab7d9e263fe670d565997471b285e8c611c5d20b0a5d5a5bc37544d9d3bd3f5cd1a0f16bbfa137b5f0d7364edcd17b9afb45efd552b35cfa85b357308b178688685515adddc83d7231e4b127de2b2c81074ab805eea33b96d574196c8dd4e2e947dc58f8eafae1af14fb652c92e348f0ef185e94a78b202cb8659c447462cfd98aa74197570d52f95e48287049e60e138b7585d0492913bed3cea2c8768423d5781a55b6ef68abe13436f7dfccc0c4a2130b2da1d6dbc68a26df524ad43b8986be02e3df0c294914c3163584b24be2a0aff0eecbc759292cfcbb73b27d362772b168aa6b4697ef5a4f73c31a24402b661dfc4aaaa081fccc8f7de14dd0dad3155912a51780b3519627a33e30495f7e740185f0b8926026cf92e7718834cf22962915a94f078d62937fbf6299007365ace491c07f166b87780ce0d7665f9239e1514e5626c5827cb5b6608081cff6756607be6a9d261137b74ab22861d1113daa8e41f07649680c02847a8a4b543e4e5237dcce71dd48ef909d1e63f224bb350b0e698b37ae7d0f14b55a7d04c4a4d0d5342fee34dc921acc2aced29826ec587a9bf229b7d0f767cb0670708ec70a0116936f188d09247852051ffaf9a330ed36f3442308c9d6e07481ebf5ecde91837cbbcc62dc6efa173bdb2e3872fe505d66e1c3daf004bcbfe52cf49220e301d4e9dae56e51b97e8b4c2ea3669f79569f400fd152ea7c63a592f0f3f6efc6f6970b1073253cf4fb2c00e5bfab47b91eaf92ac173dbce798aaa3e50820b71d48ebce1a39c190554eb523445673df87697acaf6f29bec6eafd9ca73c3724fceeca74794527fc6198f049153a75377ed806ad0c00727fa5010e86f7405f8fadbe1aa3f39fecbfc018c4eee0e0bc72d32919453122f22ca3a08ec556f4075f1f2b84c53eb8f546bbf5c64a8e2ee812f6c53c5fa94540c1829b016dd0a34ff144842a76192c996d6bae82be41230595e9bbe3ea41624ebde281d6d0a8ea2bd639ce878ab7628fad48c41cf14b64c362c2c63a3e103fcd64f825deda165ee10283332600d36ffd89aa02dc2fe1e5c3ad508d563cccbf5a7835d0e8677ef5392f132e17b70704f5887c55742909e0b0f23f287e5aa7366a48150b88370475761994d49ba95d33c795cdf94dd63cdcb7cc4095383052303856e2b8bc2022272d9f99ac96aecc78a50d95ca86012250311cfce149936b207becbad2aeec0e6adeb63a6dfeb95bdfe2683a2d64d83a3a6a86747924c8e3a7061112ae2f9f0d48e2955ed637ab2313ed6227c29b9526b904f75b206219df049b6b875589cb36b29869edc46af6ea97a13da0f4c7f78c8fac6a7ed0ed2ad0ea3747368c22637dc77401811aad1b237b740d8c55b13b9b782a9d4d2300c0665237894a27bbe8a8502c16d8fd06e2e92236781160ab75e4bf1d439d2959be887bd321ba92d15f711bddabac10a0ce92cc9081a72e2deb2adf59ee5e72b5d9a5af26314a7883d8fba3316df09fcbe88371e7e92d2390eb745a7e6a089c0ee40105e556bb8ba151ecbfd819948088c1f7f2e6ab73f041c7395aed4c1b01fcf5a8b04ce26c289ebd2b356bc2fc2c320e107326ea5ae6d09cb5b14b2bcba6e8650434ba937b0acec65176fb7beeaa0a04b99bcba449bb64d93961e065c32937c57e0ad13201270a10080941277e543158c6aa621ac9965c84c6ad2bf351ee39b4aab740599c5cb2b303c536786fc4520bba81c46e43be574948174d78fd754aa7d6113c887392786128a700cd07603ae70b8d588d0735afbe1269801b530f6b0c5ad80049e1c980c3d55d30b961d48e642bfcc996e27980b443c21be8be79aab7e207480b14d262ea491665d51da3234c373cdbbc14d19fe280281355675525b0269c05bd1d0c6c7636be2b863708e76d436efb55fa128ae016f903970fa263c5ca39bc8321321e1ccf7a050dd08e1b0fd6658e401660719d493cf5f7023121ba4c33dbe800dd73a2f588533ccd1ef8e6c6169b41e7ddfd7370b27bb7620f9d6365a9bf4360cec48b88f1c6f4804266cf9e05373d69ac550bd65d02ecba3404d30a11ccbc13b5ea41521974f1f88bc39be0499d4b7e06925872c999630d660308cd3f39d79209ce929b9517c21b001bed560c63774b3abbf4dfc9a656e0311e2cd12239042f99a47ad7147d8131f5c9122d59d52ea32926fc49982b62ad306fe2f8a2a1bd4d5ff1821ab57f71c7511c4a72d95c1b8a932b5888a965281571913df9fee6ca83719fcca57d92e7dc761d0e51ca4d67f6894b3bf3932e1dc7bc909ac5dee0d6ca110230da08360ce6c6790a73bea2e32441edaf1a529ef147b760437c45c5356a317c7f65c05da49bcc8d3a51d1bce9b31d0bbd3da97ce6cbbbc00894a584abb0eab77920a876b4076dafe0e3ca875638e7568d5210328d8293adfae914d3d7b52f1e3816d963e884c33e56a5b7ddd0a65ed48ff41c43a2703262ce9257273dda74b6e754ee93b285945a86d508975ddef7c608252cd704c9d9cc4be08e7b8550efbd302a33d46ca976d5832949779e48bc86c59510ae41d01f4ff33a5d38baf76c5a27e6ab88ff5511aebfb941ad567190fe9d2fde72d6e7df98f15977a6ed0465e80f7e5fb1b03308e29c44926ecf63012a5326da8e3417e70f84d9c9830002eaf866af8e395eb58e985d89018e8938cc44d8b0829bfb89fb1c4b579d011a1d1f07f9b7683a944f843638ef8286e82137d9a09f9d0dcfc18944c90a3acd67c4a285cf5f0f1f847dc3d10a5915ea03bd09ef8fcea06d4a3b61ca6e3efeeb3f5a2a1c4b4868ae0ef9989e1a40a606c11a7cd563fe405f66083bea4f8a7ce826d857df10351e0b5ede916aa2169cae57a91dea9d67e6294c0bb2e2f43d16a2b4235d5eef6805ed85e9eda11be661d0e7dcb40d7609f52f6cd37f77fe09ad2a0e14dda428b798d2fdae2b7808c8990b6a17ebc00ceecaa252bbd4589a264b4835db8f8d7a9a15f8f1b7b4c187351ea4fa1db1b9e5644b695ffc98d1ab04e35f7c9c6cd4d799060ee603db486d49e6cbc697106650470404aeff6db7aa0a3e1168cd028ec95bef5651972f6fe0d0c30bfbe358a303dae9b24e1d522d538467edf2050c09db13cbbb86fb3c6370576f2b4f483bd125136ee0f12c21be50a9d2abb07176eb87933c875ca3a3c6694d9d141f4effee71e30fef41616c36d6b30e1fe6d15d345516315fdb951c09de96b8072c10a81df053a7940da8cfaf06009e99705b9dc81783fd2ec1be9fc9b3452fce36cb2a76576245ce9ba19a5a63271cbaf6e29c7c59317885903d0063ea9f46f52c83ee4a0d4fc4a573140dc00e67f46d19a2039dff025ca3625130c045ad7ac74ad684674b77e478c8e15d9aae8eb374d3474d0e04721ccfdf2885232e07a0003ccdfd9849b430e5c718e725253012267c36f316bd5d8a2ac3d15c62208e73c760764d63ec377461172793403f900982223c0b3510fb4c7c08f43781b371abfbec924f1bda91a77175b96a8c5615f90bd3f4554f5ba9a80d128b34270ce713ce348bfe77ec0de693b5388636b5812a7d0448e94cba20735c2ebbf8703fe5e94dd16543cb29264ad764b23779da2082dff7bdb66d7c813f654ec76d8da196e8a982a330c3b402ea643749aa5a8bde1e3f74e06532f8cdaf12864219f607bb7571512a2427f45c921efbdef58fad238486436845ff2c7528afa02477a1a9d3bfc7a2d8ab3eb279276df9b1ff1029019ad22609019cc0da15d02ffeb062b628c373404634cf02b045cf38877c54fb63f365a7538562bb2995614b84ae29402ca150192388e0edf2c466e068847be8f7349212ccbfebeb157cb5bc41260cc9e9a0436b153f95d23f0d82bc000ffb9dbcec8bb91719131a61b654c2711ac55d46b52fda297e354775086b3d9fe595281916b7cf9589ab674baf545d86ba187516bd267488cf43a7e19f373ff240ba9bf4202d77be3d2bc415542f9f28e249bcb0f776bc6dce4571060a3aada3d6899e849e96e072e1c9150d6c5aa604ec78bb2d5107633e9a97da507d72181ba5abccd78e58cf1635a5fa13ef85f6b1aa917d7f986b8fc826dd96917526e267c492bc36f9f494f6b5ab5d3d7a622f82951f59b7f75b07ce58a40aac20c98050fdaf982e3a928e02fff79960162a57e783d9ee9c98c52666dab3d16531af818d027f608af51b3f81cc63069d66660d514131e8df3658c9b5b33c76e764b57a7b476223c38a7db5431a1c6895c0a1209aac2e9a02191e0d50e78658b1079c940d2f5cd29c3508c99bb2ceb68406606147213411c184f8558140a30b57d489083e3921aba5b22f49b00170279b5ffafca348a39dd5b130a237af7ac380bd0f7d1ff438ee8d01b2e81f31f0c7424a2062615ca6c436e2e52d9474d8b096bee3c54c62cd5fb50c0a89748e733b0ca97cfdd115a4aa36edcdcf996b5fd8e10f0299d8360710bd9b843d4803d7ad7067039feeb44d11efadc5c9b2a8f481fc2ee768154cad8d2bee9e8c678090db9f13bb53ebdd9ca8fabd62d81c77e7348338153d5f66f5ce5fdf2ced681fbdad1bd34a180a8e7b952958a31255fd574f58ab890ffa902aaf24f05e853c6fd9c3090ac8232b3ac1ce37a95c849ff4bcdca79d4f0fd9ef0ba6c30ad1ab8a6d33c1e32c94e47759840ea8c3394ebc31326e62f312787e095be2c9b5bddc4f94e2898921b7886f7fbf53de2a4d05287188e6425aff4047ec9e7c1239666e3c25f7021f0e472111e91c94198063b1bf06db9298e54831e3a6025fb541f197e4134a50069c225c1b5c6c77d61ee1c2431baa67b93531c11143e2350c33d9145bc4737c7708d00af03191b9923b0f80dd5bacaf47992ccda84f6a372f4dc0e624ea2f9dede5cadbea531ae93e949d2e6dd9fcbf8269b72d7c29523ed8d7d7ddb3da9692552fdfb50616ab2db64abb641edde0fc7cd116ea07aafc563bb1d306ee9588dd096e8249d01609fe731fe360e561a22d2a37e0d104172c64845c7bb556a8ead5ad5071e96b4ec70b00670946e4862f51e2450e4d978dad4ff6c8aa662e3dd16c137623320e8f6214245890ae003f08c83ddb145bc85e708c2bf7bfe94344e601723fb288b477d181e318ca4e983e7c1f9c2046b148eb75d651146d51598ea3da912fd727154fd6b2c5e7f451db6d7386e195a55aace9f480e10d57950ad7e5ec9c9d9ae4658e67d0f86be8eac76c7f02112c6a13da658ab6efbf517a345a333dae2502b8eb350618f2dbfbc3d3cd787fe976d7bef68d94c598231592d084dcf1e579342a9914be63f07103f997f5d1c0e33f8da9332169c593156bc6e1a97dc0e68673e2cb6c26ae71b4d2b1cef4a7c28b1d9ff1c783d4f69a5fc5a53378e78538e0a2571137d15b8d3a0b3cff734ec146b38919e9f2d6e94f07a984a6f9f31392f777976195b57bc73ed89b70409b5010926049602cf5451e6eb5448c84506e8e0286899ad95576de69c603c82e1f374fa3960eef1b03be5dfe3d1cbf8741abb22f6697e9de16076fea1ebfee3115e886dca76d0b70e3b22f20bcc4676b4974c38564c01ab0ba349c08d081e2240e7a93704006f5ef59846f4750d3c0ec56c7c8f66a6a1075853c79231551feabb30ab521dea23356af5ddf49db000387969f3da5b9efd09e0758389af5bb38b46fbb5bc00de956128b1a784e56a18180f3fc43e6420559401cabad89bfacc4e9f70f6d7c018299ac7bc5093d4f61a9a313befb1f7d2a241952333daa9c03b55b50bbc7e35fd102f3a4b45a869ee46c1dd7a4c09be12dd42c288d31df1869930a8228e6e90c8d87d9d9cad8123bed37a6531df609e4b6d2ad593bea454632c3e3a13755964faf0a84a87ceb4c39e74ae64aeb2b7c7c4547223273c94d461d3d2dd5514f190e5b73c916e78fb5b869f98ceed03118d4c3329e29b2ca5cdc3d340cd0e0a470225a33292868c0e71312a5f1b903cf5b5b03e7e9523e6cec9663e68a40a6a71ebd5c0929f0cc01ed06aa4fb88b20fecdbc3e72fe2260bd2dc2f42a8362337b619ba83a1eda8afa2e57d89c5ee5e1d2cc8afc0ba0ee7dc7432e9e31e21dd02338fd8af49f17d4d16c036c63680925115fa3b11a2ffbce3f2bf97da3fa3b280bb74e211057617eeb89b727049fe538f6aa5f4c6e94d81bd80cd286d3afc92fab1b51779428ca6d807ba51f46d6ab4f42d7a537903ed422b3f662df2575544cd99c762deae62329dd948fc4b0757820d4daca07564dd0af13abba7dcd88702ace8395dba4c0aef7bc6a867cbca96365acad2be8800b7728569f10b17d37ff42205dee4f25135bcfd5e26d32964ebfce0b6a3cc195f39e3e7d6a25ee83d31e15095f17ae030b557863358e0d11a6b40bfd9e1f2ebd1c4949ae8406d0153f90497950fb5894c991e491e6da113439c815a5a954142b8ec87b9a3a852d64365534935d644f461cf75e245089bb5d793b057410796c07fb99a2f6486cdc2e0a81f3523724b51d6cc15da015f4f50817e14480febf2fb0b0a3de54d447a7ce994e8719a1015537848c7adca9675bbdf0f317f21aa669117b22a522d0418658ec242863cac90d4eb08ec6db7dca711f0a2a25b3454df383e0697f85f91ef767783f884f0583bad405714cadb3811667281a0ccb6c3055205b87b8f5d9b0f261882851d78c85fa22632bf7e1600a7043107fe08a787df0e692b526ff472de6ff2325a57d069bb65858fafefec88c38b64aa31fb447add51e9cd9562750c0f8d9b1f123bf18697fe23c1e8197cf9446629d453c41a4f2541399c8e3494ff6e78205bd8c1438ca1ce962fbc7e0a0c0f8ad1db73101bc03083222898e3b49efefdda67f016571684a809d5ee9173a2501d5982117434a7231f3ed6285ec79a03c3391649d73c5294d88d10e88809524ff435a5197d965e31db66ae2c0ea1395d1cc4ba02182b9af9fe4260c2fe1d53f32e28931d1ed11fdee5fd2c7e1a6015c6ab22886807894c3fd4958cf899cbb81bb77ec9ffef1db5e0386507cc29cb0ee0938c1e0bc9fed0fcd67d274935dc89fd9d663886c90206073b6d5e8168f566f259b419ad34f8252e496c8735c9e144d3ce6d89cbfb65570ae95deeefc2c94cd1e21037cd6773d217d292d0b7fd3790fc92d938afa0ec6678185ec2d619fd28bbec8d8bded94a86a8c3bea04bcb811613f27f041470c2708cf02aca9c384111682cdded9b720193d6a3afd0d379e49999b66d449f3443bd4b9bd82f6d9cc9279d4f0bb2349dd0a7c3a8a9cdfe5d51d411c77bb073d95e0b9ecd1cee7e986997b3706b8413e6efa7037a93a194e135343dc42050e0cb6a6624506a61d3d3ebe3ff58dc1d4255cbe4555c21574a96499189a9ffb3c588f0cf5b1e32416a3b9066a16c2dc280b09d42fa070f7b4a8905f6129cfbd5c88f63f323b1c09d408074021a1fd93849805711d4b18033fecf5e921307059b2305c84469fff49f454050ea3427491f7b3dd9b59d84d9df2b1c05a35177273dbd232dbb2bba5c334236ba7b4575f0667662b870a3eb3ba4fa52193eeee0ca7ab0065addd028bc994a0dc891eed4869a4a03b0700771fb54b505e58b126b7833572b5379502795361deb6500d176e4da05a564d0986a3cd7c2d4f0e28a2996c0bbb315bacfaa61e2dddcddf4cba85325bd70b0d0b5bb94684b2ede075c3b04aa1f4a107d93e006b9b547a101e3240118d73e72312b48e3928247c274678caacb7c50ffa416c73164af6850459bb3e32f50ef46a49a6f1c07d929bb97a0fecaf23e82c3881e1e21cf1f13c8daf61579ed65d248a3bb8033a5a60ed8863c615a1569a6b86067441b536abed4b1ad789c7ba37254c1ea20bb10a57b2864ef1005921b297e76360d92ec953d6fad04edbe5d33507b68dd07bd7c9d31c96c3c95fb66895e791999b19411d4f2b0dc4ddab39ea8dc671fa91af1c84d1b7db037956f7e3e51eafe47f4201516b44175dd019870687ccd0a31958f53ffdbd2cd77d9175ee497414698376f5858b9af37b41f33eb46227c96c5698048c3c1148862c163e88a07c7d56870193063a2f3f311a709f2d1dc568b634b2bc43722004b6410a4036513be1268d1daaa871aaffc2fe5eb2b0118d4d402aa7a06d859a5f229733d9785f50cc9dfc402c3584f98a0928d5ee5e924e0c7d39ebded4223a7add6cad2dff86d1d78c61eb465ddb11d55c9ba0e0097d231e1f9805963b120255898ebf87f3361a57e2da21930dd741204ef53666e96397d58b37f7bfee9cfc5f35512c611c7f8b39ffed1ed1d4939b4b49e5739a2b8930557a7c3dd7d7197c418a66954a53bf8079c16d44c396add720358ee9de682fd4254ddaca1abc8fa4062eb8d1536a1137d27a205a4f777eb684bcfc4fa8e59e3208e5054115ec4d7e3c15221dd7ca21a15a19ebd57a93d1a4d2eb098d38914c94483fb51466426d9bd84b055af2ff37ef7cfc50c1fd88e47b58b4587a5b058b02bc88659c6fa49cf90c1a65bbcef62e3019b6d48323693ab7139e63050b98aa935f63accdf45a4a0b62b37f223c16335be748132a2b8b963d37a23beb6877eea26147543ba955b7251b81c62a23cae9d45fe6f2928087cea63614fed732cab5e4bfa243f3c5409efc9f2406646d29947b7d9ed32f897821cd669952c5e897ee3e53c912f4615143f0e4dcaa82b71fadbd5181e77d894bc4f3179dcc67d127438c99851610161d55333994718825454ab447937a53db89898547baa226064a0a207963813f6a5a4f110d08a76d57efc0e54181f18e2fab496ea0b74254c95be0c711aaa9045f852942e7e3c94c44b8bb3d689f00d984554c75b87a2462a961e54cfc50aef8e4a1bb26f69c5fa2b91f68fb4bbc38deeb37d6c613be235ca9ab67304937a9cadf65236e61d0069c23705f2febb914fe6ec707cf820e6700c61cdfcb3d2dd36251b78bb81261c8c0918f05505df9bb8e0ea7f009a83959bf5ec634532a2937d74148275f3fcf7b8934c94d1101d8ea546da176ca9ac4ed1484488e2afe133164b295521b67ddff9cf9390952639642174e023bf96135d5a2eddc33ebef657885db47384038f23d590d0a7eb2831b7485aa3263216c0f4526d896b705829b3d9e38814b6d7c7a521cffe169895d59f6cca6ef9c75df38df03376d24acb29106d2231c379c98c537a838bd1e8be4fe910e8c1ff997f5cc56617ff454cdf4af357db8199a357cad1c89a8b7f0eaa071064338e99cfbacb49a753c24003bf23ceb16220d083304b099b7938a25cec91ce92ec1195485a3447b6d6ef5a58d738fa8d46affec0b3175c15ca486ac94602a91c6f9fced1aec15ca9c93facb608a59375490798d270bb51ace947a975267e48912c051daeeb6439ad673da4dcd32c0a4ec06c2810563b97bd3d0bff272a936e25f222fc9bf36dd010efd0db29cbe016edd18d287180963499a197b3021bf3f3dafbd56c2a3a337a39f2126fd65b1f828c0e8c82303817d6e71f277516cc1026d5f56494a4d04cc1b8ca63938626cc61fe98c7ea2687102b8c80ad261093eed6119b522167550758f619891e92a0b71d916b083180e520ba6eaf13d89d25d854dca308a561f02309170b6736da25edd47e9aed775bc4ba61a68b3ce35a11d91a7b3d1cbdbe67154b4db8fbd3251b22ae83a35e33fd7938824479dd32045daa459252d066f9fadf9a1033d9a4b6845dc628c5ea4994662fd7cb9e70c8ecf670f9a134d72fd7020e6f547ba0d05e754d22c28c2f55e6aadb02bbb459b0efe32faa173c61eb8ffa8d52b59c84883da2ec757acbf4431e349723f15e00c369b63357cbe5842ea6a6c32160eaeea0fd3470cd0cbab06be85840bacbeb9ff5e497657c15babfa97ffb4927718f474474a5cf3d36228f680c941335222b707453fea52d619614d2229fa5e286be5babdc5d86f8dc4354051f1692e9f70b745faa7cc77f079649a954da53d91fc8294e31961f63fb77e830bafd16a13fdde577d6db77c5057cc59ba5a908464d360518c939661d554aaa57e62cdb0d163f84edd40cd1143a1f8f9ad5cc08493eb3581ccb6026882a9630f4d6c5533817490abdf09144d3f18506fa0b7b0ec7e8f79bf0d2971a304391962e3c05364d584d0d0c640a08f0514cff7cf72251a50cf1253ead34a58c1d73bb2cd593eb5135778aca14ec95fe2e3b6942adfe2c7992a56fe75bd780e789ab07022a9533e7918091a91ec3601efb0e103bf947481cc53fd1ca764939456a647e55e03266a962ea3e3043c372c2d55141ad5a55a1e71df816f1bc41f4bfb87c03a97aa477e1f3b91c39049333bbdc6204898f35af37acf3f680debf9617cc86bc9fa83ca694f698df672e528e974e836df75f92831705a1b4f46e94ecaf59e382d2e2bd1d6c90101c8ad27c2a37440ef4dd18b914156b34de900682b6db00d5d3a06909147ac7a6b256006c17259762249098b34bf4d00fd423f1b7a3990eff3974296df32e93579872afe59ad63b1eb2f86e6cb6322e6e0f9195fc878a1f0a48d09a1b0369dbf2b9077d3de2ee8a5e29f5ad067c037f1fdf64dfc1204243dd671afd4171b302a3bdeee8403c82c0bb05fdaefe1850af9156fafe89475145970fdc577d997820ce39f3018b2ee309c7dbb740a5ed21e1470557a2242c8004329381bda36d3e94a93f2f1d686f1c9a4de006408c027dbec38bfffcc6bb61079271f4fe1dae369d2be2e1ae7c2936d7b444ec77ce8eeb2d44033cded31ac83fa62d6d022ce289f8c358b4b7cf5b48cc3d1273f7d2162d86f659a144417a1d47eaa7728ce0bab397a096cca6ced5558ae94d4dfa44dbaae0c9ca53da491e7560da66112150bb75ef0e8df2cbd8913569eee040c11adcd1591f4c17a36803bcfc2ff7ba2631458e639aeb685f2ac206135ee0ae595431e23a897627727edbce0096379a94b2f78e24e41608755444064a67b9b01e3f695fff94859cc9d8aaab71a6fae060323be4080714fd2e502c76ae6462a28e1d966eb143269ff6ae64007782ed173ed06c648e0f02b574ea51ea4dda06a454fd4de068dd09544f11399bb27d636745b22ec1723f7506423930fada67efabf67e2c91f57a928c7c99fd8648e6e421f777caa46628594370efaf36ff9f4bf8f8b66b7db6f430558cc687045d8fb34a7fe45075dce6b4e8840e87adefe0c1d85e202287cc4195cd6ce7e71f0aab58b922173bf04f1a5e77f29fbe4c5e958886166b90dd0610e64a4a76281bd56c465a6eee0c47d3f3505ea52a59d153dc22db991642f6721bbaeb964efbabfd25c4ab7edbb2f3973de29ac2593a57368616b75f26d454f15a14382ee36d06adf4493e5773bb2f83122cb4bc2c9fa1c2aef9bdf048b7c3de0a29505f7cd5aa02910b1edb4704d4cd64139ecd73e9fca7b7e7bbc2664f963f7fdd471a3bb13164df0faf4379e98f187681b65914df2fd23c874a5f44c4e2d9e8e50c97a3876a76de09f224b13cbc9909cad1dbfd6fb8bec052d281fe1742e1c78dd0dc9a9d93ca65eb999b041a3d98ee89e9665c929ba912edbab0c9df522a60d5e89bed6f6d0c21fd63b13cd95dd8281fea8bfd346d96d7728bf745e872477f7303a34914bc80f0e4d2823e03e0d0cb5304233641e073c5904e33f78c20efc6227faf9e49fabb1486dcfe88022a59657ec3cc24f77cf19ce4986b849b9adb27e7eecb6c32980973132c1d7c3234644fae81fe385150f0a42c28dcc2cacf19301318e0b64a05591a1cf1dfe2e7acae98b6e64f38f4cf1c7b362b6187d721bf3077af416535b0d8791e2fb325e05f8b3b956448ea16cea78f5e862d15c6f024bfade8e436207fca58926beb4c6b33459dee0471757891cbdd93396c99db2cdf5681ba9bc939d9f2ce7612f6f751169eaee9016e2f64297784363914045d49c614aa54592c6f944d3d62afc21dc57b0b313b7b4e7609d1253b9daa6889eddfa67a87005f29aab6c073cc3377b340b3dd5c30099c8ed01c5b957b974ab16bcdf9de730bdd19f94496f147df4d4922d3acba7ef8a7824756e4db9eabf1f310e7e967de6027736f92551141d3c898ca7916846cfe9491f2a28071786104eda7bddb1bc5eaa5cf29b45c37de189d4f6e27f533715087c4a4a09a8b926b3cfeeee38a92d134928d4b0998088e8c7fc8bcd5ef3aa0199446da0c1b6d7967b5da196b49df0a6cea9fe61886b25e1d5713194ac425788ddd2a938062b8aa231681c2ba30d3fa6bcd8bb5489df02389410a8463fa71a0f2fc44ee99b4aac6cd0e9fb2c26e6b4c601366b366545c1aafaf6ab810b281256ea250213e498f307974f0b038cb283b44ccfa1b185d00cdd03c9b371920095706307ede78fbe17460a39af76efeb5b5ef3d2663461de7288ecc336ac5c18f718b2c3c5a44b79cef1731c3f8e7f1f7424a6c7a554980d22be1638e5b82dddd010e394c68e8d35ddaa9d137526fa6350f7c052dd67f49cc83e0c0a2f09d45646d2a9bc100d2b499f5f75b31187530ba2156a0ab4411cb30c0a78d7aabb8075a9c876cc0efddfd9e2646cf989369ddbd58c4f5ced5c818b3de828046e98924a385ffda089141920fc1df4240386162aed382fb927b461981dfc62bbdb57fc7877fc4dc44bd867ab2a1f7450a328266fb41a19aa9c26d4d8350894db1282113f92d433486cb3f2d05ce288ee149d6b4e6eba20e4b67f6887376b60c65edeac47e0131752d5140aeacf6eba9e9dcc02953809fe8d3e9acf289fdb1aca25dfcdccbecfeda56d456027ad9225982df793927df4572b04b004a15fc220c29585606ade0c46fc1a2b457e07e0859acf2846995997c16a412e5d2b90c7b62607c81684b71fbc1655e4879e4e95df5e40dc93de4bbf94f0197c3ca7ab34be666a469e68551e1ab59e2ce0d575a5fde9de9b73b31102854109b11f6660f08dd0a72d729778cc56ed5743888e677f4379d3a3af87c39f7b1cad7fbff94cf42f0ad01b2000727b28645a8ba35acfdc1f6ad7719e0e895e59a5782b42357b8bfc5cba89dfe1d680d33970c17f09f1a6a497457fa5e01b8be14d150738329be4ed47f201be55676bddcf73f91001ee260d3e126652b8afaa609d867b900288c729dcf68e20f38b6d39d7eeeb9848654f822f648a70c84f95b948e7a631a7adec8e64881aa7ec095cfd3b5c595c8a2980b5a7ee63510de07cf2fd79e5dcf016ea467cf2fa4124fb1e60d3849310394fee7fb4d3b5d7e44b901c7cc267698257e219d52614da91ba005245c5673a952929fae06080cdec32ee78cf029f94786e35d3d02a443572fb7f666c741243d8c3dd551d473ca0d066eab3f97cf2026bdda7a921b984b632dfc23d2932fa63e0d0afcab51fe59359b630d96a17add2b56bf3a8eb63eaaea6c94ba17d75c7b0e5ae1d9a317bbce8781b737b62c4e9bcdaa4dc2471287afb276465fe5f8d96c3a6dc8a47ff46963103bb9bf2da5e54560e4650e9fab6ea70a695ff179930eac41c2cf80e30f1088f83308251a59aa8212277146e6990f098739d27da754da21fdcae98d5079afb04217d0e7800aa5c29ee91add1e3f911afac6ddf20d505c73c8b23f9910114c6c82012eef6256965665e755a54e0e524ccfd2dde585f276650e27a29be03a572aa54c1c592563a21198676d0dadc985d106f7f15e49919e7dc2462bf015e08c46323d89487e9312c9f8c292ec7ede1072e06b2c82ea2e53ee654528b30b31ad657eb6f4e587d6dffa4e58bcc805405241446feeda7915d9ec1f49bfec5f94ffbb80214005975bc3dc1800c4b13c6a7b49abb473c09a2eba18a2b385512081eb3347aad16f270a78fa1015a42d57273931e2826a70990c1445ca7ee7e2b2a5a153e1f3ed981c38ac2e90abf8f31d01af8a3be2f7bf3411a74952c17b3b6309a3ff4098a07dea43523f85c0fd6f8979bcce99b6cb2c302c8c59f58a8db56724b92269f7b51b6e55661db211418191e3fff2812951b002821064e027b3ed92bd6a156993c6c9172844e54578414b9cf48d023466ae2e6d4b358666463c21bd0444f54024866528ee54b6a0ff2f35eaa1f8ba7a7d8c68e3b171f1f0e7a41e86632b611f93abb9e9c29e808e20d9c585c5472eb4c72b2bfffc194542e07d45b6675ff6459b0ed46e150117978559bb19cc8b71b6c2bfae63398bb43e455ec531e4511d1554b0cc4cd61c89f3deb326a8b52e6e2d9fe778c20e018c499c3b196853ecf39646967c3cca7243441b5be82b28fb8e192cc8470e4d2f17e98aa0246dca5119e8dea85eb226735d81b2790206f6e825286ae8d233d4b52ef55c1d520929921d1bf13d7a1fc8ff24202c24e4b8aecd72718395ccf5d4d6c8aeb52d006b7f212835ba302453e63f59d0a676b69640ee7c0d82a057741273cca912a616f4c362473b58be2f0b17646baac92e9e760b258348e9d2b62e03130ae4a487d0db69643dfe67efb13f5e3f41ebe30b476080839da939b8836722ddc7b6d3ee393900fe22f650712794b38d24d136c6cfd4a66886b86516c5d632e5578462307b806db7a7faf7ceb42d906508bfdff2dbf0b6a4a57b5512069d28a8e47f2e60dd05f113f457a5da4bfc32ea76caee01ef1c15e6f53e8e07324710d962f2259832c87b863f2186a22c3df01d55130e8b263ecb07017ee4f9fcb7c7f5856b1ad0b483976d29ba240e6435c6ad1b858c20a3f0b5dbc0f9897794653d6a1f33a385533f9947792ff16b84d3664a55974262f27b9f207be9cd772ea65c0f921198697a17f9d39b2f34be1d0298b74cdfe692b137c6b743ed505594639ab083fafa62d619f1a3dc1837e101e95d2aa094ea27c4d7b47434d3f86235ec8d85b2de59098e8eaa9dea047fe9202d3606ef677bd5868cbf503f6396cedcdf23720c29ab77cdd066a6336362adfe5bac4282ae89ffdd46b76f0074e0a1fd97ec3afab4666df0f79c66772bb665d7dd70da16d2b668ccf22b7e2c31590721429e9798515a3c64e9d74a18bbe09834cabffba8f4c51e1c1bcba3b9f8bbed489916f202332f5d70c4d382bbd83b34a67d671056d4bdc602ebaa208e2dc8c71da902ff6e6eec096820a6a289ef75b079ea1c98f3f8a9eb4269df4184a4b54ed4029af4647b6608db44c7b294fa4fcee62aacd8d6f8af65814cc17b3c50545afdb74875dae75111882cba7e8875e45f515f050eb78b2edb3c89042da6ebdec48367880362ffd5476685b75a4036ab84bfb727cd98a33f92e23aac900a649d09d6c4db96d22209481069c733489aaa1b9ca8be10595aef84015319f913f2ab6baccae82bdf3046d339078c233dfa23f8d30977f00565ed6cce1e2ce5333b0c021656c21a585d3499aff466ec28da100504d30f973c6ed590a0b01b6af8d6ec3eedb1c397c31573e79d45b482bd119a52a804534daf50ab9782e1eb135f0aee177a0b650224d3f5384bd6f5c7a2187b6ba8b887f781578e6cda65197b38d6de3bc27ed87a36955fbc60d82204e75d06625345e9711d43c82d4c926c3e8572294a13691b944c3d1936141caac9597dd45889c5692c25b46ed8242084dcaf623e0f7203b2fe6a03651a768790ad75ab674f00f96014a2af7f1c2db2f21ed0eeabf9addd05866a7810a7bd28daebe566764772c2d62c0d2b8ae9936eb844268e914275f53d4ffd58912c2bc8c83a5bf416741cca0d0d3336baf3206678a3c263e34feeb1ce02e8bbfeb54976c365c5857d3e5b82f1c0974c96b00607b7e26d742c61bd42139e0b2e39942de21d2bfb919fee8ad7ff3cd467da6ff9d1c8acf534215b822c766b151be6ec2035de4094c0894cf84c259cdddd781c1470e78af8847189dcd4a5ddf7dc3e8a2dea214d16e281913f5465bcdb67f3e0089d7f4bd8a3a390b96df26d52524f2a2095af7a620fb0c508df2668ddaddfeb0e45f8c26de8c7a50b3bc7e557011a5a998b24c76e77fb4ae1f7eaf8a33e09323f1d2c3911304db72ef2118b2720d447742e455bc229799d7fec404035c35d4761e352af6989092cd6130969dad59297d2b5ea65a3bacf5fde6d22691561a78581b31a1a85de98761780215de02270e9939223c5031cc1c57d05d5f25722101e9258816bbf6fee9959b1fc3a4246ad60fea570333a29508efdd081c0ce9edca42a6f3b8125f824047ec255529cebb4490f33b9595c2acf8c90603cdeb18533be0305e1520e2a91e97366e4bc700e3fa5c075b5a5c17d08e8298eb320a7809522cfcda4957565ec423c4edc53f225896e499ed32565c65f8840c70e3baf25ea53ead59d736cbabf8dc528d15f868f0ab985089230d7546e8e000b42297beec03af0e0fc2671d6a1c753a5425e305fa5ad39ba7ff780d8421d641db9e9d972a3e0d083ca7eaa00dfbe2b7da85b765cd94cf4cdaa4509e824b8344466caa5e26e4e8edc16983d40e82524aa0d84ec7caf2ec84867f3be16c42663c330075e6c854238fce4dd1675b7f405dfba313a64497fb391691d6b09521c4b8e9132322b023d4a298fdd936fb053dc71209269c3348d9aa9aee49ce488d6658081488c8d2513feb6e76abf22179a0fa32feb453a12ead87cb7f9e299a85edeef41d4500e7b60c09da2ac763299e0a1abebb10308ce1546ed9ea37c7994fbc6cd8635b34c01c303acda35b3705545bee11052d59e2bbf28418a629c636284efe6ca4c29a3ff53f5538173756e5382d1823495c913f142491b773b9663cf29f4a1bc0d5b722bbcb8ef45e51b65305f5fdbbe3b7094422e22035bcd39a574ee03ff68e176be66f1896e446cf9e2624cb0fd9e7afb3b3b404c5cb7752f4375a111fd29747f969edc92daf166c9d1d3c98fa400b871d17ecc9257ae0ed14a486b93e3a3e45aa572e9c58e0f1e628f38a7e967b051c4948900fa42e7c5e2c3c0ff3aa1823f3b2945fadd1c608fbd21cf722e06eaf6982ba46abf22f5b3d60fc6b1b810f8fe25a168175fc59eeaf4c5423747c464f4756a875f658da609255a584923c34eb5bab1c5b02e9d50386f42876dbdaa87e8e4de9459f7825fbd58a5a5320edf1c2617e9b2747949daede7e721c5c0e78d3a8f8abf6d4eabe8ac8edc0512492e6162bcffd944624dc200ff415415e1cb8864a2f90d5ded37f38f74dca48593198365626ea4222c701779beba2641c71b0025d9b0f711167452759661d0205c22e7a6df93dd0a09801eb6e052258071208710ff14761b0babdaf9f210c72d3c9c964e9a533551a916a9a900ae14b855a20675771936a8e3062a13e64f5007d8d91856053ce7c535d5aa56bc2f11cd6f5582363c1d7b9f3a9a88d770ee3e7569832701ef2c538c3c26c63f23c52f3b9dc3edfffe0f88c0e83cc10fac97fafda5d27f303aa02bb2df6dc6e71d8161039eda22d4a185c03e4515b93087abbf5baf7774ba0e4d76df1b332c942c2cff6c725747f722af885a19ae042eb1ac25737b5dcb9eb414f5912126ea5801a0bccf56525d675a8f149ebd32111bfde876becfb869f6429655c3e9e60182533a3fede3d51f4d8cd711a0e277db13c6e6fcfb93ddb32739ba6ef1f018d66fbf353e3f32f6618c3e8fe125dd2fe289b0a18ea0fd6759205eaea0f32132b602638a33f138d4626a171efec8391190d2d19fb2637566244bde0c7f1f863ce3798210bc9132b38df9d3bed26e68148bfac7cec5073cd2cfcacbf4c51f22a964664d5486099ed4dabaf3f359ab7b38be840d83c6c5ac718e7a9bc6d943dcc5b6c1c2d12861fb207bbd3039e4c692e7ea5960f83509f38bb55cab9642b3042ba99c51c6de79a102ee405ff09a6dff2c5d1407144d715ef8845c3014c14949b8545112c43b774e750152ecb4b481c553256f439a34469e6323a3fbc6fa4476da6b00844b701d82d8e8bde6918b29105e25c37508895dfb2e742965ba085b92d51ae655275647a459e236ad6eca49413f0cb882dd4f5bae29647a63e58ae721ef7f05718a338fe2cf0d6c33e47c11313f6634f22e6e9bd25b9bbd558502a2765b8379599f044c58815371721341ad7119a042870314542111b50bf9f41ee5a5c6761bffa914695141250b3341ea6f8fb9340d9125f221ba77e228f9a126e4a39b1ceb282292cf28d7ec691134806eb4ca331b1c4863d1516f4ee1bf158ddad30a44578dca252aadf8db899e7feef7e70f5bfc7dc198f6aaa420db1c404f6a9bf0123c26f481086957a7a2af43e35ca9dcdaf4bd5e26e86a222780321f94ae09eda93c693e0b6e8fae70be2ff118f6bd2c2a23e45c8a8e6e9c39de6ebed5256fde6c2a4ca25b50441349535256100abc4dfaeddae8cf8a33825a001f26cb7bbba0cecf1d6eebe840bfae2f3e21cd963d0c064ff8f9147a68adab2ca00ea303c5ac1d515121d9c5acde570d2292fde276fdeaf985d952bc393c10b1e768b044651865de4c4385a9687d0a33d48d90f6b40cd2e7944abe5ce570c39499e38e8c3f4c211c37f4d522bd368615b58a4f32a29c35c3b67eece3600dc63df478b41e72521d2487da34f4ed50607a4cedc881bf0d04060fffb78d9bb5211d251923b3083b95c0bb7a009d16f35d77d0f3efbedc6d7993c2359820fa1dce9f86256f02b8508e3db9340c9c51fd1b74a9e9c010433ce24e20291cc8474955a52745e6f5bd24d87b4ccd0e4b8cbb203304bebbc42cdad9676b22178cbc7bb32f29b661c88eb172e43f14714bb2fe0b12b9b65aecdb74f6169851cab33b65d0883419cc409cf82023e68f1964bcdd3b1bcb623c640cde056cfc71c8f8cd7140213b3d8dea7584f24db5ed32d5f20971d3279ba036da434ce3de58633bc4308a59b7d59de857cb209b80e2fa7db2b210a3d5696d77b0214e34731e8028ccb1cb58ef8582648afa035fbe7a44f9a71a3fc66901a6622baebfea23c29900d9cbb8efa51884a3fd37e639157eb7841abe53c9c489b94abed00d93746ad2dab7b5128382d6043cca5091dc5b42140b382272ffc6250e4c01e9f3ee33451494a3aa351095d828c5f54f80f38bb073000974fdacc2f593083fda930e0483199d72a4edd042c32234d4fc4ef943ef72588df408dfc71ebde006a2d3bf312d9d09b372b7768d17cf55099802fffba3bdf93f96012efafedf5c17b5f857c4b6497344ca5bfbee69dffe3ec321855539b532a4fc878e0aee298ddae4635e4a7e0d682efff2b1e0ef31a11fc882efb8643a449c54a4429d381837beaa2e2d979fb4adef5b63e0f1e55d10ab60b3ac09fd800223d2d00707a9ebd86a6cea8b9baf93de0a6b851496f533bec56985cd7682741101095c4d937090bdc48059dd56c2c75a5c33d7f60ae2ddcbfa25df30a99f549851bef57334e7309f5a3efdc5108f68cfa85bdbafc50e8227082f0a31039eb0d90981ea327280e599c76667996b5745c4d7aafd734c7e4c0985647144bad71a194e5c4f7522ba38eb4f0ab70566de55b5175a08681b1e3c69eb8b78c8533dc5ca0dc99f48ac17bc1d2c8520a26b7c286ece6ed829d2762f092b7c167f6d71d5743bdee76cd255b163ae97abc323720c0ed4b87b05a4be7ac1f8d7c3484cd7c3f752aec355dc9c123b5069d2024c5b7e2e306114bde1d9222ea0ff6e6868f78288fb6942e571b7499664dc937d467b70e047a68c9bae97bdb226b2ab9afeff25ab41b5303a1de494904010ff1bb839b683aa7c3dd1f88df43f1325a28c9e46091d5452d072c570747d20e321728b04f699808050e305d42d8cf2ab51e290d015ad15a2d19d2e43f54932c9c83cf4bbe5918535d4169cc07f0eb5bbb9f114dcde8c96e438749022741e80ea7ecba5619d7f6cc14dafbad29ceeb9c6280336a2cc79fa0866d3f3336122216a1bdc349a57ef514f13eb9b9d6562e1050e41c10683be0fdffd8bc1b3e7219152cc0235b913a1de35f91ef4d66ba835d91136ab8d5140954244ad8163af88b65e3ebd6f0fbbb7a8bbc54e2f3a41528ff0bb0a1f89858596316a542407d6db66be843935b041d9a551398ab09f9476c7475541f4642a15544c00bdea5a064bfba62998ee7d7eb3498d602f51e776b18a387945392626fb5f184fbfcec6447109dbb88d0c2e42a429cb230171de6a046f95a7ddf7320e9e1851755784f790cdf4533ca0c0f09f3c2fe09dd18e480658e7fbe7e5f26f6f6c6ffd955460af18145ff18c699b6c93c204f4b866f7f369b5454cabf558c824398f65f9cd159e0762964b2d89176baa6fda869167b02d9a960fd77357e0dc6476c945b55e534a42394970e904b3273abf8f13c30bd266bf167fbce400bbf5f72cc73b3ad76ef645cc708563d9bb79c48bfd8d5f0675c14b0d97cac30f6cec509ef22be0b3e8b7314414ba82b699e2076b5ce5ca2082be4d78cd300eeb68e6d963e1f89e8b787b90a83d09d2067706205e26b8dc909f8965cd22761d5818b6828851169ac29f8b98c9d003da779774acdc0fb3bc6f8d9c55835b293027e232fb1295ff5382ef7d1632462354cd0714728b4aa709f6e9ed208cfec7a673afefd55bb639cae38d6b58887055a6cf791d59dc074b9288d16a64046c314aa9ae2a44618a2b26e04feebb59d5afc9d427185d1b477323d30b103e1b4527ecfb4795d7a4a5fd6b262ff2e77afa9389c0ed7142d4067187b4b08b7a8eed78b6978283d96de529191e6fc4aabb199613ffc83ca6c0b7d09f796e54ae8c89bf87aba367e9ca92e973936aac791f385d95899029a1b55e5000aadd6c0133cc7921ff7662291e2281460f26d6c387f658657991da6b860e81bc923356936bac6acc82c6a2fb2ad5f4ee5fbe63ce16c4cca67f06d58f0252fdae860c00bd12e2ac933f7e1f9763340d309cdb79e59071e8826b86927e49123437a774b511eb9ddbb12cbea81fd97f8b48206c0594644e40e9cc1e9c53784b12387d71b30196f5bfccf27b1f0b1ee856fa7b6c42de60d8e52efcc95f234a0451e50eb73e70a69f0e8b8ef4d6874c33c95e4e5822980298fe27973f50556395b61c238d9b829a4f2f47f5aa8556781116f7c4fdffd815e93a2bc119ef0c436fed97ec38e0f6cdcf12ea04ef57dee745c27478326309bcbe9297088080324bfff8b5918a25301c82a52691524f8f937fac67684c87ba6ba1e1402a6598299604faab8b72364fd620f82a880ef2b24d9f992bd25761d0869fd79a8c4361fb433ef847d7760d321f6622b72e0a6abe89f5c80e7c580dc3a468d405ff79c17e3176bb7ad3e785f6236e59d9455342dac479373764223e81f5926a2a151ecb0b9287b3740d6946ee09f4c5ace6c929f3bd387943ba13a72e8504d0dc2439ee6f7084deb5432717ac476112dbc4cc5a6a2c668f10b68be115043618ac1b33076ae026220a5e7b7dc3497fca40fd23e4f03d4ca0b559138cc99be0a611878eb48c14da1adfc1b297a55e73d27bf123435909c744e3fc975fecb0580d8b1be2a5f6883b68da54c31614bb65a95adbd0d61df449a7e7327bbee7d88a308e2707f936c311ef894e1bd85bb79cebf5855362bba7c097f6b58d884fc8c6a0d995ff06da1a3f0ceb769f80765ab905f4210258461b7354f3e7907343fa9eb0e22fbb1eb55963c63a87c226b87991c2e85e05abfa81b3f0596c162f51d45c31810f9576f7fa0fcfaef0fa8a674923954453d6429b9e2981ecd6fa901f4caefedb298bba470640cf90f44d74524eb01adb88990349b6d722bdba27d2f933e72a4bcf1cefdb2523c5d5c6d6f8ac2c97de9cc04d6ddb12be9f22dd412953822ed4898acd117d543ae2a85f921a5f59c45b6d25fef66bdf8b0187b6682cdf549db82320a010975fd0ad5dc8c082fd5b151e4da0e7feccd03b395f3f91fb06af2855f2ed3317835ec411a3952f97a12f3bb76b7db51ce699d12fa54314a29dc5c4c9bff58d6b79e4525b2cb32fab7a91f0a8b2da206fada8a7aabd94f65c1498eed7dfa29ad63bbc37bfd900c06b25cca705f2f48d972bb4e5bafa7692179f8af88654120add30de549a8b3b35a74f26d41a880ed22d0bca296a870ebbea4117b2957b378ebe404ce20d4c55beaa44fde91b82dfba7fcb68cd45c0dc41eab4962686e0f33139bd4df47d19bc9a39cd7de14f92f671d0fe24fe3d8270393dac7af153826196a1fc3dc3e38e3fddd6a28ec8bc904f074e6b7c0b6eb26401b9b013fab7932e08e0748ef444730fe6cdc3ef6ce82cf0b240d634ecdd3368fb0bfecf9df6115ed13dafa20c75c433309bd0a9852cac1bf54c44c982f4e7d37da7d7fa2c1ff276ed306de3e8008670bda495010bcfdf7e64ac97b31d41f7e0bd650fcd0921070273c768569f07a29eaabdc8ffc8f03de42c4cba16bbf17c5f83542f533b1ae23cd59362269bf29b608803646f278add77f5ba10432d20d616587d621b1d7def9ed39e8a5026306bdcb796582c423067b8862791b06263b299c60d2e7ebaabffd0731ffbbe5314a2f2c480c87652195e1f7bdef43bf0c178d3a7aae6d5540fed3f49c6a4dfb853c230d79f5a2f3430fefdbc15199e14f8957348ac4914043abe6cbd8db434d1e13bea0d58d534f091c392270385d571906f346ceaecd7610532da0099f93c654a452c661b3d44598f51c42e11e5f130cd523669b43315fd9214a550a8618a82b16ad7a12023c189f85adce21f5a7b587d52fb243ec26e9d31ee6f73b0bc0a1a2cc288e6839469cb4c023dda2497c64dc820bfcd28c0850ad13f79f202561910b0ade4c1c59c75376598ea64fc13fa16fd69bb716efbaaaf70e39335f99e732202e76f400ceb76cabf386b4357839157dae535e6d5b3eada76261252adc35fa459770716d524448d36c501e6226b5ef96d2539e450be7bda74d08d44f1f3690edca990da974bd08852ad94a51eba2db637e1ac9af6879a01ea118a8145d436a7c02e720e42c074172b68b1adfac536dd6f6b42cf8099be5ddcbb6d782e3e7f0fc1e2c1ecfb887c3529bee139779357aee0628f7446c67c061c543b00cf886baf4d41d8ee1e62e50e4ba44de7358d6654f84134aefc4fe1f4d1c4f4552f7a6969d545a9dd0da951de69cb75703bbe676d4fbfe3009981cae0ec8381cc79051c68f5fa184400df0c1881400b26f2cd104720ede98a4a67e0df0ab71442be237ed96394dc34fa97e41f83b0482285129a44ca58484b84aa757cef77d118398d05e59435a124dd692925229df3326888ce3f9bec1f95b309a54e1cf8f3590342cd659a4e6cf5260d88aca2b2770aeeb9ef1fd942e17421d654e514e90c4c6c003ee5de65017f98b9c4ca28261bc8ba078260ae975bc50c122ebcd9dc92bb4badce13ba27ccdd9f73ee6e54bc7ec59609db0e3c6a536101d99f5e7816c0e51be407ab15bae304c5950d60f9ab0206cf109ab5d15a998f76e42cee56360a2428cb3b0d7d7f13c1960b48d18af795ab72f2de85d7050f7c18731d04fa129419</script>\n  <div class=\"hbe hbe-content\">\n    <div class=\"hbe hbe-input hbe-input-default\">\n      <input class=\"hbe hbe-input-field hbe-input-field-default\" type=\"password\" id=\"hbePass\">\n      <label class=\"hbe hbe-input-label hbe-input-label-default\" for=\"hbePass\">\n        <span class=\"hbe hbe-input-label-content hbe-input-label-content-default\">Hey, password is required here.</span>\n      </label>\n    </div>\n  </div>\n</div>\n<script data-pjax src=\"/lib/hbe.js\"></script><link href=\"/css/hbe.style.css\" rel=\"stylesheet\" type=\"text/css\">","tags":["汇编"]},{"title":"对二十个数进行排序","url":"/2022/12/12/10/","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">data segment</span><br><span class=\"line\">array \tdw 40 dup(0)</span><br><span class=\"line\">ten \tdb 10 </span><br><span class=\"line\">fuyi \tdw -1\t</span><br><span class=\"line\">flag\tdb 0</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">stack segment </span><br><span class=\"line\">\tdw 40 dup(0)</span><br><span class=\"line\">stack ends</span><br><span class=\"line\"></span><br><span class=\"line\">assume cs:code, ds:data, ss:stack</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">\tstart:\t\t</span><br><span class=\"line\">\t\tmov ax,data</span><br><span class=\"line\">        mov ds,ax</span><br><span class=\"line\">        mov ax,stack</span><br><span class=\"line\">        mov ss,ax</span><br><span class=\"line\">        mov sp,80</span><br><span class=\"line\">        mov si,0 </span><br><span class=\"line\">        mov cx,20\t</span><br><span class=\"line\">        call scan\t</span><br><span class=\"line\">        mov cx,20</span><br><span class=\"line\">        call sort</span><br><span class=\"line\">        mov si,0</span><br><span class=\"line\">        mov cx,20</span><br><span class=\"line\">        call to_char</span><br><span class=\"line\">        mov ax,4c00h</span><br><span class=\"line\">        int 21h</span><br><span class=\"line\">\tscan:\t\t</span><br><span class=\"line\">\t\tpush ax</span><br><span class=\"line\">        push bx</span><br><span class=\"line\">        push dx</span><br><span class=\"line\">\tl1:\t\t</span><br><span class=\"line\">\t\tmov dx,0\t\t\t</span><br><span class=\"line\">\tll2:\t</span><br><span class=\"line\">\t\tmov ah,1</span><br><span class=\"line\">        int 21h\t\t\t\t</span><br><span class=\"line\">        cmp al,&#x27; &#x27;</span><br><span class=\"line\">        je continue\t\t\t</span><br><span class=\"line\">        cmp al,&#x27;-&#x27;</span><br><span class=\"line\">        je negtive\t\t\t</span><br><span class=\"line\">        sub al,30h</span><br><span class=\"line\">        mov bl,al </span><br><span class=\"line\">        mov ax,array[si]</span><br><span class=\"line\">        mul ten</span><br><span class=\"line\">        mov bh,0</span><br><span class=\"line\">        add ax,bx</span><br><span class=\"line\">        mov array[si],ax</span><br><span class=\"line\">        jmp ll2\t\t</span><br><span class=\"line\">negtive:</span><br><span class=\"line\">        inc dx\t</span><br><span class=\"line\">        jmp ll2\t\t\t</span><br><span class=\"line\">continue:\t\t\t\t\t\t\t</span><br><span class=\"line\">        cmp dx,0\t\t\t</span><br><span class=\"line\">        je l\t</span><br><span class=\"line\">        mov ax,array[si]</span><br><span class=\"line\">        imul fuyi</span><br><span class=\"line\">        mov array[si],ax</span><br><span class=\"line\">\t\tl:\t</span><br><span class=\"line\">        add si,2</span><br><span class=\"line\">        loop l1</span><br><span class=\"line\">        pop dx</span><br><span class=\"line\">        pop bx</span><br><span class=\"line\">        pop ax</span><br><span class=\"line\">        ret</span><br><span class=\"line\">\tsort:\t\t</span><br><span class=\"line\">\t\tpush di</span><br><span class=\"line\">        push bx</span><br><span class=\"line\">        push ax\t\t\t</span><br><span class=\"line\">\t\tdec cx</span><br><span class=\"line\">\ts1:\t\t</span><br><span class=\"line\">\t\tmov di,cx</span><br><span class=\"line\">\t\tmov bx,0</span><br><span class=\"line\">    s2:\t\t</span><br><span class=\"line\">    \tmov ax,array[bx]</span><br><span class=\"line\">        cmp ax,array[bx+2]</span><br><span class=\"line\">        jle s3</span><br><span class=\"line\">        xchg ax,array[bx+2]</span><br><span class=\"line\">        mov array[bx],ax</span><br><span class=\"line\">\ts3:\t\t</span><br><span class=\"line\">\t\tadd bx,2</span><br><span class=\"line\">        loop s2\t\t\t</span><br><span class=\"line\">        mov cx,di</span><br><span class=\"line\">        loop s1\t\t\t</span><br><span class=\"line\">        pop ax</span><br><span class=\"line\">        pop bx</span><br><span class=\"line\">        pop di</span><br><span class=\"line\">        ret\t\t\t</span><br><span class=\"line\">to_char:</span><br><span class=\"line\">    \tpush ax</span><br><span class=\"line\">    \tpush bx</span><br><span class=\"line\">    \tpush dx</span><br><span class=\"line\">    \tpush di   \t</span><br><span class=\"line\">    \tmov dl,0ah\t</span><br><span class=\"line\">    \tmov ah,2</span><br><span class=\"line\">    \tint 21h    \t</span><br><span class=\"line\">\tl2:\t\t</span><br><span class=\"line\">\t\tpush cx</span><br><span class=\"line\">\t\tmov bx,0</span><br><span class=\"line\">\t\tmov flag,0</span><br><span class=\"line\">\tl3:\t\t\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\tmov ax,[si]</span><br><span class=\"line\">\t\tand ah,10000000b</span><br><span class=\"line\">\t\tcmp ah,0</span><br><span class=\"line\">\t\tje b\t\t\t\t</span><br><span class=\"line\">\t\tmov ax,[si]\t\t\t</span><br><span class=\"line\">\t\timul fuyi</span><br><span class=\"line\">\t\tmov [si],ax</span><br><span class=\"line\">\t\tmov flag,1\t\t\t\t\t</span><br><span class=\"line\">\tb:\t</span><br><span class=\"line\">\t\tinc bx\t</span><br><span class=\"line\">\t\tmov cx,10</span><br><span class=\"line\">\t\tcall divtw</span><br><span class=\"line\">    \tmov dh,7</span><br><span class=\"line\">    \tadd dl,30h</span><br><span class=\"line\">    \tpush dx\t</span><br><span class=\"line\">    \tcmp word ptr [si],0</span><br><span class=\"line\">    \tje j</span><br><span class=\"line\">    \tloop l3    \t</span><br><span class=\"line\">    j:\t</span><br><span class=\"line\">    \tcmp flag,1</span><br><span class=\"line\">    \tjne q</span><br><span class=\"line\">    \tinc bx</span><br><span class=\"line\">\t\tmov dh,7</span><br><span class=\"line\">\t\tmov dl,&#x27;-&#x27;</span><br><span class=\"line\">\t\tpush dx    \t</span><br><span class=\"line\">    q:\t</span><br><span class=\"line\">    \tmov cx,bx</span><br><span class=\"line\">    k:\t</span><br><span class=\"line\">    \tpop dx</span><br><span class=\"line\">    \tmov ah,2</span><br><span class=\"line\">    \tint 21h</span><br><span class=\"line\">    \tloop k</span><br><span class=\"line\">    \tmov dl,&#x27; &#x27;</span><br><span class=\"line\">    \tmov ah,2</span><br><span class=\"line\">    \tint 21h    \t</span><br><span class=\"line\">    \tpop cx</span><br><span class=\"line\">   \t\tadd si,2</span><br><span class=\"line\">    \tloop l2    \t</span><br><span class=\"line\">    \tpop di</span><br><span class=\"line\">    \tpop dx</span><br><span class=\"line\">    \tpop bx</span><br><span class=\"line\">    \tpop ax</span><br><span class=\"line\">    \tret    \t</span><br><span class=\"line\"> divtw:</span><br><span class=\"line\"> \t\tpush ax\t\t</span><br><span class=\"line\">\t\tmov dx,0</span><br><span class=\"line\">\t\tmov ax,[si]</span><br><span class=\"line\">\t\tdiv cx</span><br><span class=\"line\">\t\tmov [si],ax\t\t</span><br><span class=\"line\">\t\tpop ax</span><br><span class=\"line\">\t\tret\t\t\t\t\t\t\t\t</span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\r\n","tags":["汇编"]},{"title":"货币的最终答案","url":"/2023/10/19/15/","content":"<h1 id=\"说在正文前\">说在正文前</h1>\r\n<p>本文首发的时候恰逢新冠疫情爆发，当时黄金约1400左右。然后是资本市场段时间内去杠杆，黄金也迎来了一波下跌。然后评论区质疑的有之，阴阳怪气的嘲讽的有之。后来我了解了一下，最多持有黄金的也只持有了40天左右。所以其实为了造成不必要的误会，先申明下，本文不构成投资建议，如若据此操作后果自负。</p>\r\n<p>比如这次美元最差也是失去东亚锚，最严重的结果是失去算货币地位。不管什么情况，美股都会暴跌，然后黄金也会经历一波去杠杆下跌。这个时候一些杠精肯定会阴阳怪气说黄金跌了赶紧买啊之类。但是市场上肯定有意志坚定的长期投资者买入。不过我很清楚，这种投资者比例太小。所以还是这个申明，本文不做投资建议，据此操作后果自负。</p>\r\n<p>互联网现在的算法非常符合“奶头乐”的定义，明显是一个短期刺激而缺乏长期考量。热点过后，流量已经变现失去了价值，那么之后就很少有人再去回顾。</p>\r\n<h1 id=\"正文\">正文</h1>\r\n<p>黄金的价格其实是两个因素决定的。第一个就是工业因素，比如黄金能补牙啊，黄金能做5g芯片的原料啊。这个由供求关系决定。还有一个因素，就是货币因素。也就是说，当信用货币失去信任的时候，黄金会显示出作为最终货币的价格。但是在美元大行其道的太平年间，这个因素被掩盖了，那么黄金基本上也就只表现出工业因素的价格。</p>\r\n<p>大家都是生活在信用货币年代的，没有经历过货币信任危机的事件，其实上一次货币面临信任危机的时候是第二次世界大战。</p>\r\n<p>逻辑也好解释，货币面临信任危机，那么当时的统治阶级基本上就要到头了。这时候不搏一把，就要被民众吊在广场上了，至于能不能赢都是第二位的。</p>\r\n<p>现在美国的统治阶级面临的是同样的问题，美元的两个锚，石油锚和东亚锚。其中东亚锚中国已经有退出的意思了。现在东亚锚的结算量基本上是石油锚结算量的五六倍。如果彻底失去了东亚锚，那么美元就黄了。</p>\r\n<p>如果美元黄了，世界就事实上失去了结算货币。这时候只有黄金出来，给各国货币作背书，世界贸易才能继续下去。这个其实是阳谋，看一下这几年各国已经在偷偷的往自己央行里面存黄金了。</p>\r\n<p>大家都在为，美元失去结算货币地位的情况做准备。</p>\r\n<p>其实从贸易战开始，中国就开始有步骤的退出东亚锚了。现在美国为什么不敢大规模量化宽松美元？因为以前有中国的东亚锚作为背书，量化宽松出来的美元有购买力。但是现在中国要退出东亚锚了，这时候美元的量化宽松却不会相应的增加购买力，只能敲响美元的丧钟。美国本土势力的诉求只有一个，就是让我们加强东亚锚。但是我们中国的态度很坚决，绝对不给美国背锅。那么很明显了，失去了东亚锚的情况下，美元丧失结算货币地位只是时间问题。期间美国肯定会有战术性动作，那就是收割一把欧洲或者日本等等。但只要中国坚决退出东亚锚，美元的结局就已经注定。那么到时候世界结算秩序，就只能由黄金来维持。各国的货币通过不同的途径挂钩黄金，由黄金给货币背书，然后用类似货币互换的方法保持贸易。</p>\r\n<p>黄金还有一个孪生兄弟，白银。黄金实在是各方争夺的焦点，太引人注目了。但是白银分布太广泛，美洲+澳大利亚，银矿储备占了世界的60%以上。</p>\r\n<p>当世界重构结算制度的时候，美元很可能挂钩白银，形成银本位稳定市场。</p>\r\n<p>以上，就是世界各国本土势力，应对危机很可能的保全之道。</p>\r\n<p>最后讲一下一个奇葩，那就是犹太势力力推的数字货币（比特币等）。</p>\r\n<p>大家看一下，比特币这样的货币其实就是用数字模拟了黄金的所有特性，包括总量一定，不可更改等等。黄金是天然稀缺性保证了信用，比特币是利用数字规则保证了稀缺性，从而保证了信用。犹太势力人为的把比特币“制作”为黄金最大的对手，因为数字化结算成本远远低于黄金。但是目前来看，我国央行是不支持比特币的。没有了中国的支持，比特币只能在西方结算体系中自娱自乐了。</p>\r\n<h1 id=\"补充\">补充</h1>\r\n<p>这里增加一下我对比特币等数字货币的理解。其实作为这些数字货币的底层技术区块链等，是非常的有前景的技术，我国已经将数字人民币法币化了。但是犹太势力发明这种技术的初衷是让比特币匿名洗钱转移资产的作用。就单纯的比较而言，比特币等数字货币的规则也能保证比特币的稀缺性和不可篡改，基本就是完美模拟了黄金的天然属性。因为央行黄金储备啊包括金矿什么的都在本土势力那边，在这种世纪大变局下，犹太势力可不想让黄金这种不在自己控制范围内的东西抢了风头。而且从实际交易来看，比特币这些数字货币已经表现出了优于黄金的一些特点，比如银行结算体系（现在很多欧美银行都支持比特币结算）等。马斯克等大佬也支持特斯拉用比特币结算。黄金么，你弄块金砖去做交易，不说路上被抢的风险，光检测真假就能烦死你。</p>\r\n<p>最关键的，我国央行已经反复表态了对比特币的态度，那就是反对。那这就明确了，在实物黄金和数字黄金的站队中，只要我国（东亚锚）站队了实物黄金，基本上就代表了本土势力这边会胜出了。</p>\r\n<p>就现在的情况来看，目力所能及，所有的因素都在支持黄金王者归来。</p>\r\n<p>想起了那句朴素的话，是金子，总会发光的。</p>\r\n<h1 id=\"section\">20220320</h1>\r\n<p>中国鼠年后，俄罗斯对乌克兰开始军事行动，实际上这就是挑战美国霸权了。</p>\r\n<p>美国也用了非军事手段外最严厉的措施，关闭俄罗斯几大银行的swift系统。</p>\r\n<p>现在乌克兰战争基本到了尾声，<strong>基本可以确定俄罗斯获胜了</strong>。俄罗斯胜利就等于动摇了美国军事霸权，动摇了美国军事霸权就等于动摇了美元的结算地位。而我们中国，则开始了内循环，不在以外贸赚取美元为目标。那么在东亚和欧洲两个方向，美元的地位都被动摇了。这次美元的加息，是美国本土势力最后的自救动作，极力想挽回美元的信用。但可以肯定的是，巨额的国债决定了这次加息只能以失败告终。从国债利率倒挂已经可以看出，加息对资本并没有产生多少作用，<strong>那么2022年美联储只能停止加息，然后降息加扩表。这个时候国际资本将抛弃美元，疯狂的买入可以保存价值的产品。</strong>中国和俄罗斯资产肯定是选择之一，但是在这个新老交替的时候，国际资本还不敢过于重仓中国和俄罗斯（沙俄时期曾经有没收犹太资本的动作，所以名声一直臭到了现在。）那么现在最值得信任的，仍然是古老的黄金。</p>\r\n<p>现在各国本土势力基本上通过央行在购买黄金，国际资本则想办法在交易中心交割黄金。但黄金现存开采出的总量一共有多少？有个传说，国际标准的游泳池，世界上的现存黄金加起来只能填满五十个这样的游泳池。黄金一共就这么多，加上央行放在金库里面的，世界上流通的可以交易的黄金有多少？现在能买到的就是赚到。</p>\r\n<p>再说一下比特币。犹太势力曾经也做过美元失去结算地位后的预案，那就是大肆宣传的数字黄金比特币。说实话，技术上比特币已经完全具备了黄金的所有特点，然后还得到了犹太势力的银行的认可。但最麻烦的是中国没有接受这样的预案，反而宣布比特币非法。我是建议我的读者不要碰比特币的，后面虽然肯能还会涨，但说不定什么时候泡沫就破了。</p>\r\n<p>最后说一下，本文不指导投资问题。</p>\r\n<h1 id=\"section-1\">20220624</h1>\r\n<p>现在局势的发展，大体上都是按照这个脉络在走。俄罗斯在冲击世界结算秩序的欧洲部分（连带中东），中国的外汇储备也在持续降低，美元在慢慢退出世界结算货币的地位，而黄金在1830的位置等待着王者归来的时刻。</p>\r\n<p>回顾一下，俄罗斯突袭乌克兰，实际上就是一个目的，<strong>冲击现有的世界结算秩序之欧洲部分。包括突然宣布天然气用卢布结算，这无疑是动摇了美元全球体系下的欧洲结算秩序。</strong>卢布吃下美元的份额后，一部分美元开始回流美国本土，这直接导致了美国通胀失控，美联储别无他法只能狠心的加息。而这些，我在2020年美国疫情大放水的时候，就预测到了。。。</p>\r\n<p>而现在美国严厉加息的时候，<strong>我很确定，今年年底左右，美联储就会结束加息，转而重新大放水。</strong></p>\r\n<p><strong>说到根本，加息保的是美元，而宽松是保美国现有贵族的指正地位。</strong>当然，美国肯定是两个都想保。但明显了，俄罗斯在乌克兰那边已经动手了，而且美国还不敢用军事手段，所以再怎么加息，美元的欧洲体系是肯定保不住了。很简单么，你不能用金融手段解决军事问题。加息已经把美国国债收益率加到了3%以上了，但俄罗斯还是能让石油价格继续上涨（控制了供给端，所以你怎么加息都没用。）再这么下去就要国债违约了。而且现在中国还没正式冲击亚洲结算体系呢，还不如乘美元现在还值点钱的时候，疯狂宽松降息，保住国债和美股不崩盘，而美元的地盘，在中俄的军事冲击下，只能放弃了。。。。。</p>\r\n<p>那么，降息和扩表需要一个理由，<strong>那就是原油价格下调。而要调整原油价格，就只能跟俄罗斯妥协</strong>，喜剧同志估计这次要杯具了。跟俄罗斯妥协后，俄罗斯事实上把乌克兰纳入势力范围，然后基本上就是慢慢登顶欧洲之王的位置了（标志性事件，欧洲全部用卢布结算天然气）。</p>\r\n<p>中国这次选择余地更大，很可能不用军事手段冲击美元结算地位，而是等待世界失去结算秩序以后虹吸资本。。。。</p>\r\n","tags":["禁评"]},{"title":"ATM机","url":"/2022/12/11/1/","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;vector&gt;</span><br><span class=\"line\">#include &lt;Windows.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\">#include &lt;fstream&gt;</span><br><span class=\"line\">#include &lt;ctime&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">class Account</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    string name;//姓名</span><br><span class=\"line\">    int accountNumber = 0;//账号</span><br><span class=\"line\">    int pinNumber = 0;//密码</span><br><span class=\"line\">    int balance = 0;//余额</span><br><span class=\"line\">public:</span><br><span class=\"line\">    bool welcome();//初始界面</span><br><span class=\"line\">    void show();//打印菜单</span><br><span class=\"line\">    void deposit();//存款</span><br><span class=\"line\">    void withdrawal();//取款</span><br><span class=\"line\">    void tran();//转账</span><br><span class=\"line\">    void change();//修改密码</span><br><span class=\"line\">    void getbalance();//查询余额</span><br><span class=\"line\">    void print();//打印账号信息</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;Account&gt; account;</span><br><span class=\"line\">Account ATM;</span><br><span class=\"line\">vector&lt;Account&gt;::iterator atm;</span><br><span class=\"line\"></span><br><span class=\"line\">void wait() &#123;</span><br><span class=\"line\">    int a = getchar();</span><br><span class=\"line\">    a = getchar();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void keep() &#123;</span><br><span class=\"line\">    ofstream ofs(&quot;ATM.txt&quot;);</span><br><span class=\"line\">    if (ofs.is_open()) &#123;</span><br><span class=\"line\">        vector&lt;Account&gt;::iterator it;</span><br><span class=\"line\">        for (it = account.begin(); it != account.end(); it++) &#123;</span><br><span class=\"line\">            ofs &lt;&lt; it-&gt;name &lt;&lt; &quot;\\t&quot; &lt;&lt; it-&gt;accountNumber &lt;&lt; &quot;\\t&quot; &lt;&lt; it-&gt;pinNumber &lt;&lt; &quot;\\t&quot; &lt;&lt; it-&gt;balance &lt;&lt; &quot;\\t&quot; &lt;&lt; endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ofs.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void open() &#123;</span><br><span class=\"line\">    ifstream ifs(&quot;ATM.txt&quot;);</span><br><span class=\"line\">    if (ifs.is_open()) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;文件打开成功！&quot; &lt;&lt; endl;</span><br><span class=\"line\">        system(&quot;cls&quot;);</span><br><span class=\"line\">        Account a;</span><br><span class=\"line\">        while (ifs &gt;&gt; a.name &gt;&gt; a.accountNumber &gt;&gt; a.pinNumber &gt;&gt; a.balance) &#123;</span><br><span class=\"line\">            account.push_back(a);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ifs.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;文件不存在！&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool Account::welcome() &#123;</span><br><span class=\"line\">    Account temp;</span><br><span class=\"line\">    cout &lt;&lt; &quot;欢迎使用！\\n请选择操作：\\n 1、登录\\n 2、开户\\n 3、退出&quot; &lt;&lt; endl;</span><br><span class=\"line\">    int a;</span><br><span class=\"line\">    cin &gt;&gt; a;</span><br><span class=\"line\">    system(&quot;cls&quot;);</span><br><span class=\"line\">    switch (a)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    case 1: &#123;</span><br><span class=\"line\">        if (account.begin() == account.end()) &#123;</span><br><span class=\"line\">            cout &lt;&lt; &quot;没有账号，无法登录！&quot; &lt;&lt; endl;</span><br><span class=\"line\">            wait();</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            cout &lt;&lt; &quot;请输入账号：&quot; &lt;&lt; endl;</span><br><span class=\"line\">            cin &gt;&gt; temp.accountNumber;</span><br><span class=\"line\">            for (vector&lt;Account&gt;::iterator it = account.begin(); it != account.end(); it++) &#123;</span><br><span class=\"line\">                if (it-&gt;accountNumber == temp.accountNumber) &#123;</span><br><span class=\"line\">                    cout &lt;&lt; &quot;请输入密码：&quot; &lt;&lt; endl;</span><br><span class=\"line\">                    cin &gt;&gt; temp.pinNumber;</span><br><span class=\"line\">                    if (it-&gt;pinNumber == temp.pinNumber) &#123;</span><br><span class=\"line\">                        atm = it;</span><br><span class=\"line\">                        cout &lt;&lt; &quot;登陆成功！&quot; &lt;&lt; endl;</span><br><span class=\"line\">                        wait();</span><br><span class=\"line\">                        return true;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    else &#123;</span><br><span class=\"line\">                        cout &lt;&lt; &quot;密码错误，无法登录！&quot; &lt;&lt; endl;</span><br><span class=\"line\">                        wait();</span><br><span class=\"line\">                        return false;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cout &lt;&lt; &quot;账号不存在！&quot; &lt;&lt; endl;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    case 2: &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;请输入姓名：&quot; &lt;&lt; endl;</span><br><span class=\"line\">        cin &gt;&gt; temp.name;</span><br><span class=\"line\">        cout &lt;&lt; &quot;请输入密码：&quot; &lt;&lt; endl;</span><br><span class=\"line\">        cin &gt;&gt; temp.pinNumber;</span><br><span class=\"line\">        srand(unsigned int(time(0)));</span><br><span class=\"line\">        srand(temp.pinNumber + rand());</span><br><span class=\"line\">        temp.accountNumber = rand() * 10000000 % 10000000 + 60000000;</span><br><span class=\"line\">        cout &lt;&lt; &quot;开户成功，您的账号为：&quot; &lt;&lt; temp.accountNumber &lt;&lt; endl;</span><br><span class=\"line\">        account.push_back(temp);</span><br><span class=\"line\">        wait();</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    case 3: &#123;</span><br><span class=\"line\">        keep();</span><br><span class=\"line\">        cout &lt;&lt; &quot;感谢使用，再见！&quot; &lt;&lt; endl;</span><br><span class=\"line\">        exit(0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    default:return false; break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Account::show() &#123;</span><br><span class=\"line\">    system(&quot;cls&quot;);</span><br><span class=\"line\">    cout &lt;&lt; &quot;请选择你需要的服务&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;1、存款&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;2、取款&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;3、转账&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;4、查询余额&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;5、修改密码&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;6、显示账号信息&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;7、退出&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Account::deposit() &#123;</span><br><span class=\"line\">    int temp;</span><br><span class=\"line\">    cout &lt;&lt; &quot;请输入存款金额：&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cin &gt;&gt; temp;</span><br><span class=\"line\">    atm-&gt;balance += temp;</span><br><span class=\"line\">    cout &lt;&lt; &quot;存款成功！&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Account::withdrawal() &#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;请输入取款金额：&quot; &lt;&lt; endl;</span><br><span class=\"line\">    int temp;</span><br><span class=\"line\">    cin &gt;&gt; temp;</span><br><span class=\"line\">    if (temp &gt; atm-&gt;balance)</span><br><span class=\"line\">        cout &lt;&lt; &quot;余额不足！&quot; &lt;&lt; endl;</span><br><span class=\"line\">    else</span><br><span class=\"line\">        atm-&gt;balance -= temp;</span><br><span class=\"line\">    cout &lt;&lt; &quot;成功！&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Account::tran() &#123;</span><br><span class=\"line\">    Account temp;</span><br><span class=\"line\">    cout &lt;&lt; &quot;请输入对方账户：&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cin &gt;&gt; temp.accountNumber;</span><br><span class=\"line\">    for (vector&lt;Account&gt;::iterator it = account.begin(); it != account.end(); it++) &#123;</span><br><span class=\"line\">        if (temp.accountNumber == it-&gt;accountNumber)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            int a;</span><br><span class=\"line\">            cout &lt;&lt; &quot;请输入转账金额：&quot; &lt;&lt; endl;</span><br><span class=\"line\">            cin &gt;&gt; a;</span><br><span class=\"line\">            if (a &lt; atm-&gt;balance &amp;&amp; a &gt; 0) &#123;</span><br><span class=\"line\">                atm-&gt;balance -= a;</span><br><span class=\"line\">                it-&gt;balance += a;</span><br><span class=\"line\">                cout &lt;&lt; &quot;转账成功！&quot; &lt;&lt; endl;</span><br><span class=\"line\">                return;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else if (a &gt; atm-&gt;balance) &#123;</span><br><span class=\"line\">                cout &lt;&lt; &quot;余额不足！&quot; &lt;&lt; endl;</span><br><span class=\"line\">                return;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else &#123;</span><br><span class=\"line\">                cout &lt;&lt; &quot;输入错误！&quot; &lt;&lt; endl;</span><br><span class=\"line\">                return;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; &quot;账户不存在！&quot; &lt;&lt; endl;</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Account::change() &#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;请输入新密码&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cin &gt;&gt; atm-&gt;pinNumber;</span><br><span class=\"line\">    cout &lt;&lt; &quot;修改成功！&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Account::getbalance() &#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;余额为：&quot; &lt;&lt; atm-&gt;balance &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Account::print() &#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; atm-&gt;name &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;账户名：&quot; &lt;&lt; atm-&gt;accountNumber &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;余额：&quot; &lt;&lt; atm-&gt;balance &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    open();</span><br><span class=\"line\">aaa:</span><br><span class=\"line\">    system(&quot;cls&quot;);</span><br><span class=\"line\">    bool b = ATM.welcome();</span><br><span class=\"line\">    while (b) &#123;</span><br><span class=\"line\">        int a;</span><br><span class=\"line\">        ATM.show();</span><br><span class=\"line\">        cin &gt;&gt; a;</span><br><span class=\"line\">        switch (a) &#123;</span><br><span class=\"line\">        case 1:system(&quot;cls&quot;); (*atm).deposit(); wait(); break;</span><br><span class=\"line\">        case 2:system(&quot;cls&quot;); (*atm).withdrawal(); wait(); break;</span><br><span class=\"line\">        case 3:system(&quot;cls&quot;); (*atm).tran(); wait(); break;</span><br><span class=\"line\">        case 4:system(&quot;cls&quot;); (*atm).getbalance(); wait(); break;</span><br><span class=\"line\">        case 5:system(&quot;cls&quot;); (*atm).change(); wait(); break;</span><br><span class=\"line\">        case 6:system(&quot;cls&quot;); (*atm).print(); wait(); break;</span><br><span class=\"line\">        case 7:system(&quot;cls&quot;); keep(); cout &lt;&lt; &quot;感谢使用，再见！&quot; &lt;&lt; endl; b = false; break;</span><br><span class=\"line\">        default:break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    goto aaa;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","tags":["C++"]},{"title":"拉萨尔幽灵的再现","url":"/2023/10/12/13/","content":"<p>苏修集团近年来翻来复去地要求苏联人民为“提高福利”而“不懈劳动”。勃列日涅夫喊得尤为起劲，今年六月他在莫斯科说，劳动是“获得福利的唯一源泉”\r\n;去年七月在基辅讲,“只有劳动才能为我们保障生活福利”;去年九月又到乌兹别克鼓吹“提高苏联人的福利”的“可靠途径是劳动、劳动、劳动”。</p>\r\n<p>苏修其他领导人和报刊的这类言论也到处可见，什么“福利的来源只有一个”，“这就是劳动”，“提高人民福利的途径除了劳动再没有别的办法”，等等。</p>\r\n<p>苏修领导集团这一套谬论是早在苏修二十四大上就定下的。翻开苏修二十四大的文件，在《关于一九七一～一九七五年苏联发展国民经济五年计划的指示》中，就有“劳动是财富的源泉”，只有劳动越多，福利才越多的十分荒谬的说法。提起“劳动是财富的源泉”和“劳动是福利的唯一源泉”，不能不使人想起机会主义的祖师爷拉萨尔。他早在一百多年前就提出了“劳动分工是一切财富的源泉”的谬论。\r\n之后《哥达纲领》这一机会主义文件又一次贩卖了这一黑货,胡说什么“劳动是一切财富和一切文化的源泉”。当时就受到伟大的无产阶级的革命导师马克思和恩格斯的痛斥。</p>\r\n<p><strong>马克思明确指出,“劳动不是一切财富的源泉”,劳动者只有“事先就以所有者的身分来对待自然界这个一切劳动资料和劳动对象的第一源泉，\r\n把自然界当作隶属于他的东西来处置，他的劳动才成为使用价值的源泉，因而也成为财富的源泉”。马克思在《哥达纲领批判》中一针见血地指出，拉萨尔谬论的要害，正在于对谁占有劳动的物质条件，即生产资料归谁所有这一根本条件避而不谈。</strong>在当年德国无产阶级同资产阶级的矛盾日益尖锐的情况下，号称“马克思的学生”的拉萨尔竭力在工人中宣扬劳资合作，竭力欺骗和蒙蔽工人阶级，要他们不去注意生产资料归资本家占有这一事实，而埋头为资产阶级卖命劳动。</p>\r\n<p>事隔一百多年，拉萨尔的幽灵在克里姆林宫再现了。在资本主义已经复辟了的苏联，这原是不足为怪的。<strong>同样号称“马克思的学生”的勃列日涅夫之流如今大吹大擂地贩卖拉萨尔的破烂货，是和拉萨尔一样，妄图用劳动的空谈来掩盖苏联日益尖锐的阶级矛盾，强迫人民卖命为苏修叛徒集团劳动，以维持他们的反动统治。在苏修叛徒集团的统治下，苏联的广大劳动人民早已失去了生产资料，失去了作为国家主人所拥有的最根本的权利，重又成为雇佣劳动者，遭受一小撮官僚垄断资产阶级的残酷剥削和压榨。</strong>近年来，苏联劳动人民采取各种形式反抗苏修的统治，旷工、罢工和消极怠工，以及大量的工人流动，已给苏修经济造成巨大损失。</p>\r\n<p>据苏联《劳动报》报道，由于青年工人大量流动，一九七一年仅俄罗斯联邦工业系统就损失三十四亿卢布。苏联一九七二年出版的《科学技术进步，和劳动生产率》一书说，工人怠工、停工使企业损失的工时占总工时的百分之十五到二十。苏联一经济学家对美国记者说，由于旷工、怠工和事故，苏联一年的损失达一百八十亿美元。</p>\r\n<p>面对着广大人民日益强烈的反抗和苏修国内严重的经济困境，苏修集团深感不安。<strong>他们在加强法西斯镇压的同时，不得不大肆进行欺骗宣传，要人们相信，苏联劳动人民今天所遭受的生活困苦，是劳动得不够，只有加强劳动，才得以改善。其实，人们已越来越清楚，在今日之苏联，为所谓“福利”而劳动，不过是为一小撮官僚垄断资产阶级的“特权”而卖命。这一小撮人通过利润和税金等形式无偿地占有工人创造的大量财富，并通过高工资、高奖金和其他额外收入，贪婪地榨取劳动人民的血汗。</strong>一些工人气愤地说:“领导人、厂长，汽车别墅....应有尽有，而我们工人只有两只手。”这就是苏修叛徒集团口口声声讲的所谓为“福利”而劳动!</p>\r\n<p>“提高人民福利”是假，强迫人民劳动是真。苏修集团让广大苏联人民为他们“劳动、劳动、再劳动”，就是想使他们这一小撮人获得“福利、福利、又福利”。这就是为什么他们不惜重新拾起拉萨尔的破旗来招摇过市。</p>\r\n<p><strong>但是，拉萨尔显然帮不了勃列日涅夫的忙，相反只能暴露新老机会主义者是一丘之貉，只能使苏联人民更加认清勃列日涅夫之流从理论到行动，彻头彻尾都是马列主义的叛徒。</strong></p>\r\n","tags":["禁评"]},{"title":"以史为鉴，复盘解读2020年3月的各大类市场动荡（短线视角）","url":"/2024/03/09/17/","content":"<p>文章主要包括，背景知识，实际发生的时间线，对金融市场的影响，相关启示。</p>\r\n<h2 id=\"篇头\">篇头</h2>\r\n<p>以下的内容大部分都是我当年用英文写的复盘的一小部分，你们目前看到的版本是我直接用的GPT翻译的，我读了一下，翻译腔严重，但是都能懂，所以我就不重新用中文完全重写了。</p>\r\n<p>主要包括，背景知识，实际发生的时间线，对金融市场的影响，相关启示。由于2020确实已经离现在挺远了，有些当时理解后续发现并不适用于2022，为避免歧义于是我独自保留。一方面是实盘复盘日记其实没什么看的，你们也就是看个感叹/笑话，而且那几周我身处的位置不佳，所以没怎么赶上。所以只挑出来知识的部分。</p>\r\n<p>发出来主要是因为有人之前问了我一些当年的相关情况，但他们根本不熟悉当年的时间线，对很多基础情况凭简中的不完整信息乱说一通，我也没看到在简中网上有人整理过，我就发点吧，也算是知识性的补充。</p>\r\n<h2 id=\"背景知识\">背景知识</h2>\r\n<p>XX-19事件的开始的触发点是意大利3月8日在伦巴第地区实施“风乘”并取消威尼斯狂欢节。这一事件为其他国家设定了一个“样板”。因为在此之前，西方国家的人们普遍认为“风乘”是在他们国家是不可能的。这个触发事件类似于雷曼兄弟的破产。</p>\r\n<p>但是价格暴跌（争夺美元）的真正触发契机却是在一天后的2020年3月9日，当天俄罗斯（又是你！）强行退出欧佩克+，因为他们不想削减石油产量。（注：当时油价价格仅为40美元时，俄罗斯强退使油价继续下跌了9美元，隔夜时段下跌了30%，然后在下一个交易日又下跌了20%）。大量的原油仓位被追加保证金通知（注：margin\r\ncall）带崩了本来就岌岌可危的权益类股票市场，而这触发了整个XX-19期间的首次跌停。</p>\r\n<p>随后在XX-19的恐慌期间，市场首先将高风险资产汇回到各国本国货币。因此，伴随着全球股市崩盘，英镑和欧元因为流动性紧张，他们的内币首先上涨。然后，随着情况恶化，他们的内币开始暴跌，因为所有人都开始涌入唯一安全的美元。随着XX-19变得更加严重，美元因流动性需求而走强，成为唯一强势的货币，直到美联储启动货币无限量互换解决了这一问题。美联储进行流动性互换之后，致美元走势出现大逆转。因为所有央行都可以从美联储借到无限量的美元，再没有了对美元的挤兑，美元开始走低。</p>\r\n<p>而当情况变得非常糟糕时，人们甚至会抛售黄金，唯一会上涨的是美国两年期国债，因为其在银行之间等同于现金，也是各大银行/投行向FED请求紧急注资的必要衍生品（国债价格不会上涨太多，更多的只是不会下跌）。但情况特别糟糕时，甚至十年期国债也会被卖掉以购买两年期，直到量化宽松来临。</p>\r\n<p>XX-19\r\n期间金价下跌原因很多，包括但不限于“美元强势+通货紧缩风险+多头失望因为金价没有上涨+黄金的供需+3月之前已经有不少涨幅所以多头了结+多头头寸受到挤压+机构们为了满足其他更重要市场的保证金所以放弃外围边缘市场”。虽然事后可以解释得通，但是乱世中做空黄金，需要不小的胆量。</p>\r\n<p>准确的说，央行发布意外刺激措施通常不是完全出乎意料，当中央银行可能采取某些行动的日子里，你会听到人们谈论意外刺激的可能性。要知道有学者就以研究中央银行的行动为生，加上需要刺激前通常有领先指标的担忧迹象。无论如何，你会听到人们谈论意外刺激的可能性。</p>\r\n<p>比如信贷利差突然扩大（人们不愿意相互借贷），这可能会导致中央银行召开临时会议。在临时会议期间，你不会事先知道会议发生（举行）。他们通常会公布他们的决定，然后回溯解释他们为什么这么做，通常是意外的降息，但极端情况下也有QE。</p>\r\n<h2 id=\"时间线\">时间线</h2>\r\n<p>美联储首次正式采取行动是在3月3日，但是杯水车薪，但此次行动并未阻止全球所有资产的恐慌抛售。</p>\r\n<p>于是FED取消并提前了原定于18日的FOMC会议，改为在15日周末直接宣布意外的降息决定\r\n+\r\n小QE（注：虽然我们现在管他叫小QE，但是实际上规模依然是很大的。只是说比起后来的无限量QE比起来，当时是小QE），但人们显然已经被吓傻了，当天美股依然跌停，全球对美元的需求只增不减。</p>\r\n<p>好巧不巧，其实当时欧洲央行这个猪队友在15日早些时候特意“隆重”地宣布他们将在今年一共进行1200亿欧元的QE（注：你可以大致理解为人行在危机时宣布临时降息0.05%那种感觉），这大大失望了市场，反而促成了当天的狂跌。迫不得已，美联储只能紧急召开临时会议（为欧央行擦屁股），宣布他们将每月进行1.5万亿美元的回购操作，来试图稳定全球市场，但即便如此，显然也不够，美元依然在暴涨。</p>\r\n<p>然后，美联储在19日开启了对所有央行的无限量货币互换和借贷，以保护全球所有其他国家经济体，避免经济影响继续扩散（注：美联储在19日以前就已经加大了货币互换量，但19日开始彻底宣布，如果有任何国家的央行想从美联储做货币互换或借贷，美联储都会不限量提供。美联储非但并没有趁火打劫要求惩罚性互换条件，借贷也没有要求借贷抵押物，完全是有求必应。整个2020美国事实上主动出手帮助稳定了全球其他国家的经济（注尤其是新兴发展中国家的经济体，避免了危机进一步发酵。美联储完全没有像是有些人恶意说的趁着危机“故意吸血”，事实上要不是美国主动出手阻止全球的系统性风险向新兴国家扩散，而真的选择了“从新兴国家吸血”，很多新兴国家到今天可能依然没处理完2020年的影响。当然美联储出手防止金融风险无序扩散当然也对美国有显著正面影响，也不只是利他主义）。（注：货币互换和借贷大部分是外汇sawp，之后是要还的。借的是SOFR\r\nbasis\r\nswap，只不过当时美联储利率是0，所以swap也是无息的。由于还款时间也很宽松，所以可以理解为中长期的美元无息借贷。）</p>\r\n<p>此时（注：19日），美国十年期国债价格开始反转，因为国债市场开始预期后面还会有更大规模QE（注：就是我们常说的，“做国债的比做股指的要聪明”），但其他市场包括ES和欧元仍在狂跌。</p>\r\n<p>最终，美联储在23日推出了无限量QE，从那时起市场开始转变。在3月23日，美联储表示，他们将每天购买750亿美元的国债和500亿美元的MBS，时长无约束，金额无上限（注：也就是无限量QE）。</p>\r\n<h2 id=\"市场影响主要关于美股\">市场影响（主要关于美股）</h2>\r\n<p>好了，现在很多人可能说当时那么大好的机会，肯定都赚疯了吧。事实上有些同僚定是赚疯了，但也有不少同僚破产的。</p>\r\n<p>在俄罗斯之后，美股随着黄金下跌，但由于很多人还是抱着“逢跌就买”的心里，所以美股随后几天又上涨回来（注：现在看起来像是做了最后的挣扎），然后接下来继续下跌。</p>\r\n<p>在15日，仅在宣布小规模QE后15分钟，ES就跌停，并在接下来的几天继续跌停（注：抄底就是这样的，一般不是真的底，具体可以看我写的“论散户接飞刀”的文章，另外再次强调：虽然我们现在管他叫小QE，但是实际上规模依然是很大的。而在当时我们并不知道未来会不会还有QE，我们只知道这是一个超大规模刺激。谁也不能预测到未来还有无限量QE。）</p>\r\n<p>在15日宣布小QE的事后，美股出现了三次100点（400跳）级别的奇怪波动。当时美股还是隔夜时段，在开始时就是平开（注：现在回顾，在宣布QE后美股应该在15日跳高，但没有跳高的时候就应该小心。）隔夜时段开盘后，价格迅速上涨10秒，急速冲高100多点（但我们都期待价格远远不只会走100点）。可是冲高10秒后很快就陷入困境，然后在75秒内反向冲刺接近跌停价。而正当空头快乐时，价格突然又暴涨一分钟，几乎回到了第一波10秒中冲高的最高价格（而在过程中，许多多头甚至购买了更多以平均降低成本）。</p>\r\n<p>然后接下来的2分10秒内，美股下探跌停价并建立双底，然后突然又暴涨了一分钟（大概回到到最初10秒移动距离的一半那么多）。最后再次下跌，出现三重底，然后横盘了大概了1分钟。之后直线瞬间冲向跌停，而接下来的几天更是一直暴跌不回头。</p>\r\n<p>由于15日的行情如此复杂，不管是做多还是做空，都是过山车一样的盈亏，考虑到宣布QE——大幅震荡——跌停，整个过程一共也就10多分钟，而且三重底后之后马上就跌停了，再无逃跑机会。随后RTH时段开盘接着跌停，除非你在RTH竞价的时候就选择巨亏出场，但凡犹豫了，许多人就再也没有机会了，因为价格再次打开的一瞬间就会被强平，许多人其实就在这一波破产了。</p>\r\n<p>而且此时国债也非常不好做，在15日由于宣布了QE，因此美债价格是高开的（注：符合一般的预期），但是在开盘后的几分钟就被美股带崩，迅速调转趋势，急速冲低。股和债的走势在那几天成了完全正相关（注：一般人们普遍认为股债价格应该是逆相关运动的，但由于人们过于恐慌，所以国债不再是债，而是成了另一种“特殊”的大宗商品。）</p>\r\n<p>随后，在3月23日无限制QE公布时，美股15分钟内飙升了800跳，之后在高部横盘两个小时，然后依旧向下走向跌停。（注：是的，在无限制QE公布当天，美股依旧跌停了。这两次宣布QE的当天都是跌停，而且国债也依旧被带崩，模仿了美股的走势，先升、后降、再升，直到当天尾盘的时候才走出了“合理的走势”——因QE而收盘高于开盘价）</p>\r\n<p>美股真正的反转发生在第二天的24日，但在上涨途中仍然困难重重。在接下来的几天里，美股只回到了18日至20日的价格水平，在全球其他大类资产快速收复失地的时候，美股几乎横盘了一周。</p>\r\n<p>“在全球其他大类资产快速收复失地的时候”，是的，在23日无限量QE之后，其他的市场基本都涨了，只有一直普遍被认为是“冲高先锋”的美股一直在横盘，而在所有冲高的市场中，其中最佳的市场是黄金。</p>\r\n<p>最初在3月9日，俄罗斯退出欧佩克+后，黄金开始下跌。黄金在15日小QE时稍微反弹，但之后仍然下跌（注：对黄金而言是暴跌，和美股走势一致，这有违乱世买黄金的一般理念）。但从19日到20日的时候（注：美元不再稀缺），黄金就已经开始稳定并保持。</p>\r\n<p>在23日无限量QE后，黄金开盘直线上涨，两天内上涨超过2000跳。在三天内就恢复到俄罗斯退出之前的水平，形成了强大的多重趋势性动能。</p>\r\n<p>搞笑的是，恐慌性抛售了黄金那么多天，爆了那么多仓，但它在两天半就收回了整个XX-19期间所有跌幅，第三天就开始创新高。事实上在23日的QE之后，黄金保持了以周为单位的单边直线上升，全程几乎没有出现过大回调。</p>\r\n<p>剩下外汇、国债、大宗商品的情况都差不多，本质也都是“做了符合美元走跌的情况下该有的走势”，其中国债的上升也较为坎坷，但比起美股来讲还是清晰的多。</p>\r\n<p>但当时我被迫遵循家里长辈的强烈要求，所以那两周都在PEK“蛤蜊”，我就带个笔电回来，就两块屏幕，然后“蛤蜊”还不是单间，网还差的要命，因此要不然也不会在电脑前，一样会错过这一波。而且我的自有资金账户已经被限制交易了（没爆仓，但是被risk\r\ndesk\r\nflagged，我最大仓位只有之前的四分之一），而另一个做套期保值账户的资金很大部分不是我自己的，只能委托看管，不能乱动。如果在电脑前，感觉ES的日内第一波，黄金和外汇的第二波我应该会抢进去，应该还是有大幅盈利的。但之后连“pf!zer”那一波也因为我的negligence，直到用手机在WX的新闻上看到，再打开电脑就实在是太迟了，就，就有点难受，虽然当天晚些时候和后续两天还是吃到了点……所以晴天雨天，哪怕不出海，最好也别筛网……话又说回来，YOLO的30不打游戏，难道等60打吗？老年电竞队打得过谁？</p>\r\n<p>还有额外两点想说的</p>\r\n<ul>\r\n<li>在极度波动的时期，很难解释市场为什么没有做”明显正确的事“。所以，在极度波动的时期，不要试图理解为什么，也不要基于逻辑交易。只需接受市场行为极其古怪。顺应市场流动而非逻辑，因为在恐慌期间逻辑是无效的。</li>\r\n<li>在危急时刻，国债的第一波反映总是难以预测。比如2022年3月，在鹰派美联储的背景下，国债应该下跌。但如果市场认为美联储变得过于鹰派（这会损害经济，同时面对欧洲潜在xx扩大的可能性），那么国债价格实际上会上升，作为避险操作。这是一个非常微妙的平衡，你必须谨慎行事，很难准确判断“如果说了什么，市场就会认为美联储变得过于鹰派”。虽然股市的走势更明确（无论美联储多么鹰派，只要不鸽派，总会下跌），但争夺成交的竞争更激烈。</li>\r\n</ul>\r\n<h2 id=\"题外话\">题外话</h2>\r\n<p>无限量QE光国债就是是每天买750亿美元，而当FED当年在2010年为应对2008的第一次QE时，每月QE的量还没有2020年一天QE的多。</p>\r\n<p>俄罗斯实际上引发了2020年和2022年恐慌的抛售。</p>\r\n<p>意大利你好的不学，净学些罪大恶极的，之前欧债危机你也是头一号（注：欧债危机主要也是意大利，希腊经济总量非常小，所以风险非常可控。但意大利要是暴雷，欧元区肯定是保不住的，意大利是欧元区第四大（现在是第三大）经济体，而希腊gdp规模在欧盟只是第16）。</p>\r\n","tags":["Undefined"]},{"title":"交易员的脑回路——在趋势面前判断市场究竟是否“合理”","url":"/2024/03/09/19/","content":"<p>一般哪怕是做超短线，你最好还是有一个比较清晰的思路，至少大概率的认为市场回向某一个方向运动，你要说就坐在电脑前，跟着盘面随便走，这个事情以前也许可以，现在你做的不如量化程序。而且哪怕判断好了大方向，市场如何达到那个位置依然是个问题。他是直接向上一口气冲上去。还是充一半找一个平台歇一歇再接着冲，或者就是三步一回头都有气不同的策略和入场方式，很大程度上要通过动能和量来判断。</p>\r\n<p>冲的又快又猛，动能特别足的，大多都是消息面，一个天大的利好，大家都抢着进去，根本都没有什么对手盘挡你路，你就要激进，冲不进去就直接错过了，但如果市场一旦开始明显回头（消息刚出现十几秒内有可能会因为一些量化程序跑套利之类的程序没意识到有消息或者行情因此价格有短暂反复，那个不算）否则一般冲错了，赶紧出来保命。如果市场是三步一回头，磨磨蹭蹭，慢慢飘的。就不需要激进，等一个更好的价格再入场也不迟。如何判断动能又是一项独立的技能，无论你是通过量化程序拟合出潜在的类型，还是通过主观经验直接猜，很多时候都不是说你上来就能够判断对的。</p>\r\n<p>事实上你也不需要全才，我之前的文章里写的很清楚，你只需要在某一类市场能够保证赚钱，在其他类型的市场别大亏，你就能做的很好。想做成全才，一方面也是比较困难，另一方面经常会有三个手表，哪个时间最准的问题？到底是在同一个标的上同时做突破，又做箱体震荡，还是说你直接找很多个不同的标的一起看但只做突破（没突破就等）这个看个人。但我个人认为前一种比较难，前一种前期对盘面的理解也许并不需要投入太多，只需要专注一个或一两个标的，但是之后非常注重判断，而后一种你需要充分理解不同品种的盘面特征，但是判断起来相对来讲要简单。</p>\r\n<p>再比如说成交量也是如此。并不是说成交量高就一定好，这是一个适度的问题。一鼓作气，再而衰，三而竭。在市场上也很常见，因为市场背后对应的决策是一个个主体。哪怕是量化程序，他所学习的盘面，进行的回测，也大多是根据前人的主观判断特征而决定的。</p>\r\n<p>没怎么投入，就取得了很好的结果，就容易轻敌（很可能是大资金还没有相互角力），容易之后被反扑。如果已经投入了很多，成交最后哪怕是突破了这个关卡，你的军队也需要休整。不能说是围城了三个月，攻破之后马上就可以快马加鞭赶上下一个战场。反之，你要是投入了很多的成交量，又没见到结果，那是努力又没有结果，这非常容易让人打退堂鼓的。损失了很多兵力，又攻不下来。先不说有没有逃兵？有没有投敌的？无论如何大部队得退下来歇歇。这东西就和手机游戏上瘾是一样的，时常给你一点小的正向回馈大家的才会持续士气高涨。反映在市场上就是反复的“短期积累动能向上突破”，这种动能一般是确实强。</p>\r\n<p>我的意思是市场是走出来的，是买卖双方的实力变化决定的。而实力变化要符合自然界的一般规律，至少中短期（微观和长期另算）并不是纯粹的价格随机游走。但是我并不是说市面上没有例外，有可能市场可以不断投入，好似不知疲惫一路遇到很大的阻力都能冲高，但这并不常见。就好似战争，前线部队疲惫的时候需要大部队（长期资本，大资本）的扶持，而（市价单）攻城略地的同时也需要（限价单）来防止敌人偷袭。双方的限价单不够，就会出现chopping的状况，也就是虽然最后某一方也可能会胜出，但过程有可能就是双方你追我赶。你的动能，成交量，价格变化等一系列的因素最好要在一个恰当的区间，过多过少都会出现问题，而市场很可能不给你那么多恰当的机会，因此像视频当中那么清晰的机会，市面上其实是不多见的。</p>\r\n<p>如何判断是否恰当是一个动态调整的过程，很难去讲，需要根据当时的市场周期而定。你无论是主观也好，量化也好，你都需要不断的根据最近的情况而调整，而并非是一个长期绝对数。如果你要问判断恰当有什么意义，我认为假设市场长期来讲也是符合一个事务运行的基本规律。那某种意义上你需要对市场的涨跌做一个评分标准。假设价格是涨了，但涨得不恰当。那么这个例子可能是一个独立事件，当然也有可能是最近有很多这样的独立事件，但是以后你再重复这样不恰当的交易时候，就要保持警惕。但如果市场长期都在不恰当的基础上取得优秀的结果，那么可能你需要更新恰当所意味的指标。你要问判断出市场涨跌的评分有什么意义，我想他最差也能给你信心，在犹豫不决时的信心，如果你做量化它也可以是一个入场仓位设定因子。</p>\r\n<p>而另一方面，也有一些特殊的判断技巧。即使价格没有突破，但价格是否有粘性？即使市场三步一回头，但回头的步伐是不是比较固定？都是一些可取的参考目标。但市场那么大，机会那么多，尤其如果你做期货/期权还自带杠杆，并不涉及到股票那种总持仓时长，毕竟你也不是基本面交易。而基本面交易，尤其是价值分析，你要找的是别人埋没的黄金，那别人埋他肯定是有埋他的理由，你要等到他认错了，你才能给他挖出来说，哦，这是块黄金。巴菲特有体量和资金成本的优势，如果长时间没有人挖，巴菲特自己找人带着铲子和矿工下矿井挖给大家看，而你连个巴菲特的铲子都没有，怎么去重复他的辉煌呢，尤其价值投资，成长投资已经是一个非常拥挤的赛道了。唔，跑题了，我的意思就是说我认为做长期投资其实比做短期交易还要难，虽然股市风险要小。</p>\r\n<p>最后当然运气也是其中重要的一部分，市场也会出现兵不厌诈，或者你长期判断正确了，只可惜止损线放的太严，被震荡出场，或者说你恰巧就只有一次没有放止损，就那次恰巧就发生了黑天鹅。不过至少令人欣慰的是，这种黑天鹅你没料到，市场上其他一半的和你同样的人估计也没有料到，因此你不是唯一被埋的那一个，但反过来来讲，如果你知道你同样的队友也没有料到，你已知他们可能其中有一部分人要想出口跑，那你最好跟他们一块儿往出口跑，不要犹豫，不要再等待有没有转机。除非这价格已经迅速跌到一个非常低的位置，那么你可以说算了，我套牢了，但不要就闭眼不看了，选择增持来降低平均持仓成本仍有几率，虽然也要看你背后的标的类型，究竟能不能长期持有？有没有交割日/行权日？未来有没有翻盘的可能？毕竟人在每一步都只能做当下看起来最正确的决定，虽然长期来讲并不一定是最明智的。但谁也预测不了明年对不对。这是一个你有可能会后悔，也有可能会不后悔的决策。但假设你不后悔，也要牢记这次的教训。下次就不一定会照单重演。</p>\r\n","tags":["Undefined"]},{"title":"只有敢加仓才有几率维持风险收益比，否则长期会死路一条（带我个人的入场和加仓的相关建议）","url":"/2024/03/09/21/","content":"<p>本章主要想讲我个人入场加仓理念，以及怎样避免入场时过度紧张，而导致出现一些blind\r\nspot进而对未来走势的误判。一般来讲，最让人紧张的时刻就是刚开始入场的时刻，有许多不成熟的交易者，即使在入场前能保证较为清晰的视角但在入场后因为持有效应而变得比较固执，进而忽略了市场转向可能，从而误判了未来的走势。市面上有很多入场的方法，比如金字塔型，倒三角形，长方形等，但我认为这种入场方式不够灵活，而且不太好面对一些突发情况。我在这里说一下我个人比较推荐的入场和加仓方式。</p>\r\n<p>首先加仓作为交易的一部分是非常非常重要的，就我在prop和券商的朋友和其他人交流而言，即使是非常资深的交易员，大部分的人胜率是低于50%的，以前曾有一些套利/做市类策略，有着极高的胜率，但是在当下的环境这部分的钱大概是被hft拿走了。如果你的胜率低于50%，那么你的赔率就必须大于1:1，而在很多情况下这是比较困难的，而且高赔率策略止损范围一般比较大，在逆势时心里会承受较大压力。所以确定的趋势下加仓，是一个比较折中的交易方式，也是任何一个成熟的交易者都应该掌握的基本技能。加仓这一点对于主观交易而言可能是基础中的基础，但是鉴于我的读者当中有一些是做量化的，而许多量化策略的进场部分近乎二极管，我希望你在量化程序里也考虑到加仓的概念。</p>\r\n<p>如果你的交易标的是保证金类交易，那么我建议以clip作为单位，而不是以实际的金额或者实际的数量，以便适应你仓位数值的变化，而不要局限自己在一个舒适的账户金额内止步不前。假设你把你的本金分成五份，那么你每一份就是一个clip，如果你同时交易n个标的，那么建议先把总金额一分为n（可以不等分）然后每个标的再分为五个clip，这样每个标的你都只有五个clip可以选择，增强了你的决策的确定性。同时为以后由于市场风格切换，某些标的不再吃香，你可以快速切换你的主要标的实际份额而不更改以clip入场的交易习惯。【因为我交易的品种比较多，而且多是超短线】一般只用三个clip，如果需要托底可以使用四个clip，最后一个clip除非确实是非常好的机遇同时已经有不小的盈利资金垫否则不会使用。根据当时的波动性和对趋势的确定性而言，如果是反转类策略，可以在有反转迹象的地方做一个clip，如果趋势确定，可以再加两个clip，这样如果判断正确，你的第一个clip会拉低你的平均持仓成本。当价格回到你另外两个clip入场点的附近时，由于你第一个clip是盈利的，有着更多的心理承压空间，不至于过于紧张。而局限了思考能力。你可以趁这个机会好好看一下当前市场是否和你入场时有所变化，是否需要变更自己的策略，甚至是否需要反向。即使你在这里选择了反向，由于你第一个clip是盈利的，所以你并不是纯粹浪费了这段交易时间。而如果趋势判断失败，由于你只投入了一个clip，你可以选择止损也可以选择在下方重新放两个clip，同样拉低你的平均持仓成本帮助你快速回本，这种策略一般在由新闻驱动的趋势时会比较有意义，有的时候有些策略不设定明确的止损线可能会有比较好的结果，但不排除有可能你运气极差，偶尔一次没有想好出场点放止损单的时候，突然来了一个突发利空结果流动性紧缺同时你的网还因为瞬间的流动性卡了几下因此瞬间暴跌，那就真傻眼了。不过一般而言如果价格是splash\r\ndown那种exhaustion，那么多半价格会在一个较短的区间内部分反转，那么你可以通过这个机会快速做2个clip来挽回一些你的实际损失，但记住如果利空是真实的那么大概率价格在一段时间后还会下行，你相当于是用另外两个clip去救急，这种例子在闪崩下非常常见。而如果你的入场不是一条线，而是一个区间，那么建议在区间外沿做一个clip，以防止出现v型快速反转进而被迫追高，总之由于你只有1/5的仓位进场，你无论怎样做都有很大的回旋余地。</p>\r\n<p>但如果市场当下波动性确实很低低，是一种低成交量价格慢速grind\r\nforward，你可以一次使用两个clip，在趋势确认后再加一个clip。因为如果趋势慢速向前，你很有可能不知道在哪里加仓，或者在哪里都可以加仓，鉴于波动性较低风险较小，你可以一次放两个仓位，形成金字塔型加仓。你用相对较多的底仓和相对较少的加仓，可以快速帮你确立价格优势，避免在价格慢速向前的过程当中，由于波动率实在较低，长时间不赚钱而怀疑自己的判断，就如同你在考试时，也许你的第一个答案就是正确的，当你反复在考虑这个题的时候，你可能多想因此把这个答案改错了。如果底仓是2个clip，我不建议加仓时直接加2个clip，因为万一价格从缓慢向前变成高位区间运动，那么你后续加的仓位不仅把平均持仓成本拉的比较高，同时后续加仓的仓位处于长时间不赔不赚的区间，但仓位较重，又不敢置之于脑后，导致过度关注某一标的，从而失去了分析其他标的潜在交易机会的时间。一般而言，作为保证金交易，你使用三个clip就已经承受了不低的风险了。如果你想在市场上长期活下去，没有必要非得梭哈四个clip或者五个clip。事实上你每天能稳定的做6个ticks就足以超过80%的职业交易者了，虽然我建议你在可以做多资本金的情况下尽量跑步向前。而不是每天挣一点酒钱就快乐的回家。但不代表你需要时常梭哈。</p>\r\n<p>就我个人而言，我喜欢保持着中低水平的心理压力。这样能让我肾上腺激素分泌的同时又能保持清醒的大脑。如果我的仓位过重，又面临较大的潜在亏损，那么我可能会忍不住直接清仓退场，今天就不看了，明后天再说，而实际上闭眼不看当缩头乌龟虽然心里上稳定了，却放走了潜在的回本机会，如果当天收盘后因为心痛就没有复盘，不仅丧失了自我检讨并发觉改善未来的可能，还会由于两眼放空导致几天后重回市场时可能因为风格切换而继续犯错，因此保持市场敏感性是很重要的，就如同电竞游戏中的“手感”。因此这种快速建立底仓，快速见到浮盈的方式就比较适合我这种心态的人，这也能保持我头脑的清醒。但有些人可能天生就比较抗压，他可能适合其他的加仓方式。这仅仅是我的一点点交易习惯，希望能对小白有借鉴意义。</p>\r\n<hr />\r\n<p>更新：所谓以clips进场（没看过我之前文章的可以大致理解为进出场和具体单子数量无关，而是按固定的“次”来计算。你就假设你手里永远拿的是六发的左轮，不要去考虑到底是什么caliber（不考虑有多大的单量），因为左轮你就记住你一共能打六枪，打老鼠还是打麋鹿都是同样的决策。但是根据猎物的不同，你可以选择.22lr或者.50AE。如果明确行情来了，比如狮子来了，再切换具体手法。还不明白的可以先去看看链接里的原文）<strong>用clips进场为的是增加交易之间一定的可比性</strong>，不要让每次交易不要变得太过特殊，这样才好总结和改进。比如加仓不要太纠结具体是要加几手，不要纠结之前加仓加多了还是加少了，你做了加仓的决策，就是一次决策，比如以”加一个clip”的形式就行，太细致的没有意义。Clip一般以总共5~10档为合适。如果你的入场方式喜欢scaling\r\nout，比如拿3~4 clip在区间内建底仓，那你总共就可以设定为 10\r\nclips。如果你进场一般以一至两个clips作为底仓，那么你就直接五档clips就可以了。如果觉得少也可以分为七档，八档，总之这个东西是你自己决定的，也不是说有什么金规玉律，每个人有每个人的习惯。请记住，以这种仓位管理方式主要还是达到一定的可比性，无论是从复盘的角度还是从账户扩张的角度，尽量维持一个相对比较固定的出入场方式，仅此而已。如果这种仓位管理方式限制你的发挥，那你也不一定非得要采取这种方式。一般如果你专注一两个市场，那么你就可以分为十档。如果同时做多个市场，尤其是经常做不同市场之间的互动关系（比如不一定是两腿价差套利，做同类市场的关联性交易也一样），那么你每个市场保留五档就足够了。</p>\r\n<p>总之尽可能交易与交易间还是要有一定可比性的，不用像量化那样恪守规律。但也不代表你每次做交易都是一个完全不同的节奏。</p>\r\n<p>我要强调，你在实际做交易的时候，每一clips所对应的实际单数是可以改的，遇到大机遇，你的仓位可以重点。遇到自己不太有把握但是值得一试的，你的仓位可以轻点。做交易的其实有各种各样的极端。有的人是极端的见好就收，有的人是极端的越赌越大。以clips的形式加减仓，可以总体上有一个度，不要太保守，当然也不能无限加仓。【当然，行情来了的另算，行情来了就别死规矩，这里说的都是日常的交易】</p>\r\n","tags":["Undefined"]},{"title":"机构是怎么培训交易员或操盘手的？","url":"/2024/03/11/25/","content":"<p>最近又有几位读者跟我说，他们做交易/投资不赚钱，比较迷茫，怎么办？我不想说“这本来就是九死一生”之类的，因为那也不是全部的事实，但一开始有正确的心理预期很重要，更重要的是，你要怎么做？</p>\r\n<p>本来想发关于“实盘的经验究竟就能做什么，对盘面走势取舍进出场”的那篇文章的。但可能也是年终了吧，被问的不赚钱的问题比较多，我也不想一个一个的开导了。有些人对能赚到什么钱，多长时间赚到多少钱没有什么概念，我这里先发这篇给大家疏导一下。</p>\r\n<p>之前我写了一篇文章，是关于交易员大概多长时间才开始赚钱的，有人就问我，为什么即使有人教学，到可以稳定盈利还要花一年那么久？老师教你的set\r\nup，你不是几周就能学会并熟练使用了吗？我说是的，那些set\r\nup并不难学，<strong>关键是你要知道什么时候该做，什么时候不该做。而这需要靠经验来取舍。</strong></p>\r\n<p>你自己闭门造车也是可以的，有些策略，比如那些盯盘口的（尤其是削头皮），或者类似我们的短线，哪怕不参考任何网上的资料，你自己根据基础的技术分析，完全从0开始摸索闭门造车，每天看盘口看个一两年大概率都能得出类似相同的结论的，因为其核心并不难发觉，你只要细心观察，而且确保每天都在看（仅限短线/超短线）。虽然一开始看不出所以然，但是每天录像，反复看那些突破前，失速前，震荡时的走势（最好加上dom和盘口微的观数据，学习微形态。虽然但是只看Lv2数据+裸K+成交量也行，我也见过不需要dom的。甚至还有只读tape/读1秒级k线就能盈利的）</p>\r\n<p>自己摸索的话，需要按照当时的市场波动整理成录像集（比如高波动率突破，低波动率突破，消息面突破）每天反复看差找规律。但无论如何，短线和超短线必须和盘口的表现对应，要考虑流动性的因素，不能只看技术分析。</p>\r\n<p>很大程度上做短线有点像“指纹匹配”的同时“找不同”，你拿当前的市场走势对比你记忆中的“标准走势”的同时注意当前走势的特点，并对机遇进行合理的取舍，完全符合“标准”的你该怎么做（建立好预期，一定程度上预判），不太符合“标准”的直接放弃，也就行了。而机构的训练其实很大程度就只是给你多看例子，多讲解例子罢了。他们会帮你快速掌握盘感不假，但无论如何盘感和经验还是要你自己练。（虽然机构里会为你整理好例子，直接告诉你如果是像案例里这种走势，哪里重要哪里可以略过。而闭门造车需要从头自己搜集整理例子，自己慢慢归类“保准走势”罢了。）</p>\r\n<p>所谓机构教学或者某些实盘网课“加速训练”的本质，其实也就只是他们收集好的案例更多，所以你在短时间内就看了海量的案例而已（比如每天给你看20个突破的实盘视频回放案例，你看一周就是100个不同时段/不同波动率/不同背景的案例，你要是还总结不出关于“标准盘面”的经验，我只能说你真的还是转行吧）。</p>\r\n<p>自己摸索出稳定的赚钱的不算罕见，失败的源于大部分人一上来选择做更靠运气的中长线，如果一年一共交易不足数十次，单纯是buy\r\nand\r\nhold，那单纯就是beta（准确来讲是特定行业beta），你有什么经验可言？话又说回来，很多人，哪怕是做短线也很少有自律去每天看上去并没有太多逻辑的东西盯一两年（也没有资金去这么做）。过于急着实盘，过于急着放大仓位（尤其是某些些经验建立在错误的认知上，但他们并不知道那些认知是错误的。由于不在一家firm或者大户室里，所以也不会收到到指点。反而是你参加trial的时候他们会看你的历史记录，反而有可能指导出你的错误）。亏钱时赌市场能回来肯定是不行的，更有甚者去追求各种玄学，就比如国内目前盛行的XXXX……</p>\r\n<p>但也不得不说，主观实在是太靠“经验，和对决策的取舍”，parameter实在太多太杂，很难充分量化。而且为了赚钱很多时候是夜以继日日夜兼程。就如我之前文章写到的，交易员其实就是“外卖小哥”，只不过挣得比外卖小哥要高很多。但如果想赚大钱，（在模拟盘或者小资金训练达到稳定性后）就像高等级的“外卖小哥”，一样是要在“雷电暴雨，冰雪大风”的时候接单快速提升美团等级（攒下资本金）。想着天气好的时候送上四五单就能挣钱是不可能的。只不过当资本金多了的时候，你就不用每天强行接单，如果大概率今天只有不赚钱的单子，你就可以直接回家休养一下（在市场上没有机遇的时候管住手，别强行做交易，有的日子提前关电脑反而是最佳决策）。但是“雷电暴雨，冰雪大风”的日子你还是一样要主动出门派送那些“高价单”（在波动率上来走势也清晰的日子，你就要熬到撑不住了再躺下睡一下之后起来再接着干。因为“你要考虑到一年大概总共有100个左右交易日有明显的趋势/清晰的震荡（属于较为简单就能转到钱的日子），而剩下的交易日想赚钱要困难不少。”）</p>\r\n<p>因此我确实觉得如果你没有太多资本金，参加funding\r\ntrial也是挺好的，一般小资金在前两年你split之后依然赚的比你单干要多。就像我说的，如果家庭实力一般，参加trial兴许可以帮你省下两年从小资金建立账户的时间。</p>\r\n","tags":["Undefined"]},{"title":"技术分析究竟有没有用?感觉那么多方法，比如波浪理论，各种指标，太过主观化，运用技术分析是不是不可能成功?","url":"/2024/03/09/18/","content":"<h2 id=\"第一次更新\">第一次更新</h2>\r\n<p>支撑位（区间）/阻力位（区间）/整数关卡等一些列技术名词，以下统称为“技术点位”</p>\r\n<p>总结：其实，与其说是价格会在技术点位遇到反应，不如说是人们相信价格会在技术点位遇到反应，因此在技术点位附近提供了流动性。</p>\r\n<p>今天来谈技术分析到底有没有用，技术分析是一个比较尴尬的东西，大部分最初进入交易的人，一开始基本上都会去学，无论是主观交易的，还是量化交易的。在课上，尤其是那种面向初学者的短期集训，讲师会展示出许多通过技术点位精确地预测价格顶和底，准确的找到反弹的一些例图，然后大家都十分兴奋“啊，这个有用，啊，交易好简单，啊，我们迅速就能学以致用”，然后一上实盘亏得一塌糊涂。很多人这时迅速就开始骂爹骂娘，说“之前的例子都是讲师特意找出来的，技术分析有用的时候，那是千里挑一的情况，都是curve\r\nfitting”，然后就把技术分析扔到了垃圾桶。</p>\r\n<p>那问题来了，为什么一般上来都教技术分析呢？因为技术分析相对客观，对于初学者，你总得交给他们最基础的，比如怎么看蜡烛图（k线），怎么理解均线。那既然都讲到这了，为什么不同时讲讲k线组合，k线图形，macd，布林线？这些技术分析，相对来讲是最容易理解的，是最客观的，你总不能说“我做交易纯粹靠盘感，我觉得在这就该买/卖”吧。尤其是量化交易，更要有数理原则，根据大数定律跑回测来证实策略可行性，即使最开始的模型总是会cherry\r\npick/curve fitting，但总需要个起点开始学习不是？</p>\r\n<p>稍微学学技术分析，然后去实盘看看的就会知道，有时候（30%）好像挺管用，但大多时候（70%）不管用。就算赔率是1比1，照这个胜率来看，赔到底裤都丢了只是个时间问题。那你说技术分析没用吗？不，其实是很有用，几乎所有的大顶和大底，都可以同时精确地匹配到数个技术分析都认同的交汇处，趋势的翻转可以说是“必然发生在技术分析所预测的点位上”。如果你是做量化的，很多人会认同价格是一个有一定规律的随机游走，并不会去考虑价格背后的“人”的因素，做量化就需要把价格模型化/数理化。很多人因此会去优化一些量化指标的参数，争取更好的找到顶和底。很多人会去考虑不同指标的confluence（交汇点），认为一个指标不管用，但如果很多指标都在这里交汇，那么管用的可能性会大一些。很多人可能会去对指标产生的信号做一些filter（筛选），不是指标提供的每一个买/卖都进行实际操作，而是筛选一些准确率高的。这基本上是通过绝对量化的，绝对客观的思路来看待价格，看待市场。毕竟主观是那么的不靠谱，历史回测数据看上去又是那么的真实，而且，无论如何，上实盘前你都得回测不是？但价格的本质究竟是什么呢？是科学的一种吗？</p>\r\n<p>事实上，决定价格波动的本质是“流动性与市价单的比值”，而相比于随机提供流动性，大家更倾向于在技术点位提供流动性。因此，与其说是价格会在技术点位遇到反应，不如说是人们相信价格会在技术点位遇到反应，因此在技术点位附近提供了流动性。这里的流动性，指的是挂限价单（花时间挂限价单在交易所，以期在未来一个更好的价格进行交易）。价格想要上涨，需要许多人用市价单（当下就买，不论价格）吃掉挂在交易所的限价单，在当下价格中找不到限价单的时候，价格就会上涨，去吃下一个价格的限价单。举个例子，我现在想用市价单买1000股茅台，假设茅台最后一次交易的价格是50元，有800股挂卖单在50元，有600股挂卖单在60元，50元到60元之间没人挂单。那么我会先吃掉800股挂在50元的卖单，之后吃200股60元的卖单，那么现在最后一次成交价就在60元，于是茅台就从50元上涨到了60元。</p>\r\n<p>现在，我们明白了价格波动的本质是“流动性与市价单的比值”，但什么决定了到底有多少人在这里挂单呢？不出意外，技术分析算出来的价格，会吸引人们向这个位置挂单。假如你是开小卖铺的，一个东西进价47.2，你想赚几块做利润，你会给这个东西标价到多少？是不是49.8？你本来已经想要在50块出售了，而技术分析告诉你，标价49.8会更容易出售，所以你就标价49.8，对不对？之前说到，几乎所有的大顶和大底，都可以同时精确地匹配到数个技术分析都认同的交汇处，这是因为技术分析让价格在这里转向吗？还是许多人本来就觉得这个价格附近可以买/卖了，只是在找一个更容易/更方便交易的价格？至于人们为什么会认为价格附近可以交易，其实我们并不容易得知。哪怕你认为股市是被操纵的，主力们和庄家们决定了价格涨跌，但是就对单一某个主力而言，他们实际也在试探其他主力的意图。</p>\r\n<p>技术分析，有时候（30%）好像挺管用，但大多时候（70%）不管用，这背后的本质，不是模型的精确性，也不是价格随机游走，而是人们/机器，对当前价格看法通过合力竞价进行的体现。价格几乎会在每一个重要的技术点位获得一定的阻力/支撑，但就价格是否会在这里转向，事实上比想象的更玄学。尤其是遇到突发（定期）新闻的时候，价格好像更容易在技术点位附近发生反应，与其说是数学和科学，不如说是在关键点位以外的流动性都撤单了，那些不重要的价格上的单子，几乎都在慌张和惊恐中，为了防止被市场踩踏而撤回了。只有那些重要技术点位上的单子，一部分出于对技术分析信念，一部分出于在更高时间尺度上对这个新闻的漠视，还会留在交易所等待执行（有很多长期资管，比如养老金或者巴菲特那样的长期投资人，并不会因为几周的价格波动而更改他们原先以年为单位的投资计划）。</p>\r\n<h2 id=\"第二次更新\">第二次更新</h2>\r\n<p>提供几方面思考</p>\r\n<p>1.假设价格是有“庄家”（事实上就算是个股一般也是数个庄家共通使力，一个庄家一般hold不住）操纵的，那么请问你在什么位置操纵可以借力打力？是不是在流动性充足的地方做一个反弹成本会比较低？因为本来就有很多人准备在这里购入，你在这里做反弹，会不会有很多人跟单？如果你是一个挂单者，你看到价格明明已经马上就到你的目标区间了，但是价格突然有反弹的迹象，你是继续等还是追一波？假如你追高，不是不是帮助庄家借力打力？</p>\r\n<p>这至于流动性为什么会在技术分析区间比较充裕。上面已经提到，不再赘述。</p>\r\n<p>2.为什么在数个技术分析交汇的地方，反弹/反转的几率会比较大？想一想你用什么技术分析？你相信什么技术分析？别人是不是都跟你相信同样的技术分析？就哪怕是最简单的macd/rsi你至少还有参数可以输入不是？你所相信的技术分析并不代表其他人跟你一样相信。但是有许多技术分析交汇的地方，就代表有许多不同观点，用不同技术分析视角的人，有可能都得出了类似的结论，那么相对于普通的支撑阻力点，这里可能获得的支撑或阻力就以其他地方更多，相当于获得了更多的流动性。</p>\r\n<p>3.很多人认为技术分析也许是一个magic\r\nbullet是一个魔法一样的神奇金手指。事实上技术分析基本上都是利用了大数回归定律和统计学的sample分析。那么任何学过统计学的人都知道。你统计出来的结果，只能有一定的趋向性，不代表任何预测的结果。即使是数个技术分析交汇的地方，他也只是增大了在这个位置上反转的可能性。假设在一个随机的地方反转的可能性是50%，在这里也许只是65%，并不像你们可能想象的像电影中的那样。像个预言家一样，那么大的确定性。假如你的胜率和赔率是1:1，那么你不断地在胜率65%的位置交易。就会不断的积累小盈利。但问题是，绝大部分人做不到，胜率赔率1:1。而且如果你不断的赚10%，亏10%，再赚10%，亏10%，你的钱是会不断减少的，有没有听说过震荡损耗这个东西？一个东西先涨20%，再跌20%，它价格不是回到了原点，你是亏了的。</p>\r\n<p>4.为什么在危机时刻提供流动性是那么的重要？为什么你看现在国际成熟市场一般在危机时刻，央行直接出手干预，提供流动性？因为没有流动性，价格有可能跌到负数。但要在短暂的时间里面提供流动性。就有可能把长期的价格稳住。上面提到了，在危机时刻或大涨大跌的时刻，许多人也许在观望观望的结果就是，你可能会把你挂的单撤单。那么依然在某一个价位挂单子的人。肯定是有某种意图，或者某种思考，虽然这种意图或思考可能是错误的，可能是螳臂挡车。事实上，绝大多数大型订单基本都是冰山订单。但是即使有复数过冰山订单在这里堆积，看起来也是非常多的。哪怕有投行放一个，每一个切片200单的冰山订单。假设有五个投行都在这个位置附近挂了冰山订单，那么这个附近明示的挂单量依旧是可观的，即使隐藏的挂单量并不对外人显现。</p>\r\n<h2 id=\"第三次更新\">第三次更新</h2>\r\n<p><strong>一些经典的策略到现在依然有用的本质。</strong></p>\r\n<p>很多人其实一直也没有搞明白，为什么很多最基础的东西到现在依然有用。就默认“以前有用的，现在也有用”，仿佛是祖宗之法不可变，甚至还有一些人认为具有数字浑然一体的精妙性，是自然界中伟大的数学传奇。<strong>我想说，咱拿数学当科学没问题，但你拿数学当宗教就是另一码事了。</strong></p>\r\n<p>我这里给大家举一个我经常说的例子，为什么直到现在，在均线和VWAP之类的地方，会有精确到跳的支撑和阻力。有些人可能会发现，如果价格长期偏离均线或者VWAP，当价格久违的碰触到均线的时候，价格往往会有精确到跳级别的阻力与支撑。网上绝大多数文章将其解释为“交易员收到指令，需要将订单以优于均线/VWAP的价格成交”而导致的反抽。当然，这部分的内容说的也不算错误，但是在这里的订单实际由交易员执行的单量比你想象的比例要小很多。反而是量化执行的订单比例更大，大量的量化程序终于是在这里才达到了执行的要求。于是一开始本来不会有精确到跳的阻力与支撑，加入了大量的量化程序后，反而数值比以前更精确了。陷入了一种自我加强的循环，Self\r\nfulfilling prophecy。</p>\r\n<p>不是说什么之前有用的，现在依然有用，而是一部分程序员认为交易员在这里会介入而写出了一些量化程序+一部分程序本来就需要降低交易次数，因此只有当价格碰触到均线才会执行+一部分专注于数据挖掘的量化程序，发现了（由于前两种策略都会在这里执行）所以在这里执行成功率较高的特点而加入其中。与其说是交易员的行为导致了精确到跳的均线策略依然有用，反而是大量的量化程序自我锻炼反复加强使得这个策略变得更有用了。这个道理很简单，一想就明白，但很多人从来没有考虑过这些事情。这个例子当中，虽然结果是相同的，但过程是不同的。我只是想强调大家不要简单的就说某个东西失效了，某个东西还有效，更不要归结于什么天意和数字的精妙性，争取想一想背后失效和有效的道理，不要人云亦云。但显然很多人处于一知半解的“这个东西它有用所以用”的死循环。</p>\r\n<p>因此我一直都在建议主观和量化应该结合，并且推荐新手以量化的视角做主观。</p>\r\n<blockquote>\r\n<p>咱们先理解一个大前提。就是什么样的策略才是一个好的主观策略？你在什么样的情况才应该选择量化？你的主观到底在什么情况下才算是优势？下面是我的一家之言，你要是不认同也没问题。\r\n在你的系统和策略已经高度量化的基础上，你利用你对盘面的整体了解，对市场大环境的整体熟悉度，以及大量的情景训练，总结出的主观经验。利用你的主观经验为你高度量化的策略系统去伪存真，并利用一些市场微形态寻求更好的出入场时机的时候，你的主观交易才是一个优势。\r\n什么意思？意思是说你在做主观的时候，你的交易思路应该是已经基于一个相当量化的多因子决策系统，而你主观就主观主要在对于根据经验对不同因子比重的动态分配。既不是根据盘感的拍脑门，也不是根据一些技术分析的红灯停，绿灯行一样的机械操作，在这种基础上，你的主观才是优势。\r\n很多人喜欢在主观上找经验，然后把这些东西尽可能的量化，去跑量化程序来回测，或者直接就跑量化来挣钱了。但假设你的量化思路真的是基于你的主观经验，往往意味着你的量化程序跑的不如你用人脑判断那么仔细，相当于你的量化程序是你主观经验的弱化版。除非是你的主观经验并不存在，只是单纯的基于技术分析的红灯停，绿灯行。然后你希望让人脑的红灯停，绿灯行变成机器识别的红灯停，绿灯行。如果你的主观思路有很大程度上是基于对于大盘整体环境理解，对于市场当前状态的理解，对于突发新闻的理解，和对于市场反常态的理解，哪怕是出于“既视感”的盘感。这样的主观哪怕搞出来量化，这个量化也是他们主观思路的弱化。\r\n因此我认为用主观思路去做量化是不那么靠谱的。熟悉我的人知道，这是我从量化私募走向Prop交易并准备一路主观到底的主要原因。\r\n我认为反倒是你应该尽可能的从量化上找思路，然后把这些量化思路运用在主观经验上，以量化算出来的因子，尤其是那些你主观可能并不会意识到的有关联性的因子，用量化求得的样本集，让程序算出的高胜率或高赔率的交易区间，然后你在这个区间根据你对市场的大时代背景，根据盘面当时的运行情况。在量化系统出的信号之中，去伪存真，利用人脑在使用订单流分析，微结构等复杂决策方面的主观优势来增强你的进出场位置以及加减仓时机。这样我认为你作为人的主观灵活性才能被充分发挥出来。主观和量化的结合才能够相互提升，而不是相互干扰。正如我之前所说的，你把主观拿去做量化，量化是你主观的弱化。你拿量化做主观。主观是你量化的强化。\r\n上述内容的前提是你要有一套以多因子为基础的，本身已经高度量化思路在其中作为铺垫。你用量化的可回测性，作为你主观判断的基石。这样才能结合量化的稳定性，和主观的灵活性。单凭经验是不靠谱的，尤其是你在其中很难分清实力和运气的关系的时候，人们普遍的会认为量化会更靠谱。但是如果你有以量化的思路做主观，你会发现这个问题就迎刃而解了。\r\n我随便举一个最最简单的例子，方便大家理解。假如说你的量化系统主要是基于macd，那么就会涉及到敏感度越低，你出入场时机就越晚。敏感度越高，假信号就越多，这样一个无解死循环。有人可能会说，那我多加一些其他的判断因素。比如说根据atr调整macd的敏感度。通过ema来过滤一些macd的假反转。甚至根据成交量和rsi背离来进一步过率信号。以至于在其之上发展出动态多因子择时，因子权重动态平衡，波动率调节加减仓，watermark形式跟踪出场。但其实都不如你直接在macd出信号的时候看一眼，在macd和背离同时出现的时候看两眼，在动能和均线都符合预期的时候看三眼，然后你手动利用订单流分子挑一个合适的出入场时机，在明显遇到下一个阻力时直接放在最近的支撑位来的更稳定。当然你也可以不信我说的，或者认为我讲的不对。因为这只是我一个人一家之言。但如果你觉得我讲的有道理，不如听我一言，换一个角度看量化和主观之间的关系。\r\n而且我强调一点，上面提到的你量化的视角做主观最优的解法并不是你用眼睛去看背离，用脑子去想atr和rsi，而是量化系统已经出了信号，你看一眼线，你的量化系统就直接告诉你条件abd已经满足，但c不满足，你再主观判断一下有没有必要等c也满足，或者哪怕是abcd都满足，但是盘面走势不符合你的“预期”因此依旧按兵不动。并不是说你用脑子去跑量化运算。尽可能的还是要科技改变生活，而不是钻木取火，否则你累了一天也就只能关注一两个市场，不是吗？利用量化解放双手，释放脑力的优势并不需阉割不是吗。\r\n当然，事实上是我说的这些东西大多数人可能并不适用，因为大多数人可能就想要一个红灯停，绿灯行的系统。也不想费脑子，不想费精力学习，更不想就光区间突破，看上几百个例子，花上几百个小时高压练习。如果你不知道我在说什么，我有一篇文章叫做机构是怎样训练交易员和操盘手的文章，感兴趣的可以看一下。不过事实也是如此，人都是趋向于懒惰的。没有在机构中那样一个高压的环境，那样一个人人比拼宛如高考的激烈竞争，你可能真的也坐不下来，看几百个小时的实盘录像。但如果你想知道你究竟还差了点什么？或者哪方面可以更加精进？不如参考一下我提供的这条思路，你可能从未想过，但它其实存在。</p>\r\n</blockquote>\r\n<p>上述我还提到了，你要有一个大概的盘感，能够判断出市场走势和预期走势之间的差别是不是符合要求的。不是在任何盘面达到要求之后都做相同的操作，你应该对于实际情况有一定的主观取舍，这样你才是利用了主观对于处理复杂信息的优势增强了你量化的精准度。我在文章<a\r\nhref=\"https://skytravelar.github.io/2024/03/09/19/\">交易员的脑回路——在趋势面前判断市场究竟是否“合理”</a>里有详细展开讲过，感兴趣的可以看一眼。</p>\r\n","tags":["Undefined"]},{"title":"打印玫瑰花","url":"/2022/12/11/2/","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;math.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">const int max_iterations = 128;</span><br><span class=\"line\">const float stop_threshold = 0.01f;</span><br><span class=\"line\">const float grad_step = 0.01f;</span><br><span class=\"line\">const float clip_far = 10.0f;</span><br><span class=\"line\"></span><br><span class=\"line\">const float PI = 3.14159265359f;</span><br><span class=\"line\">const float PI2 = 6.28318530718f;</span><br><span class=\"line\">const float DEG_TO_RAD = PI / 180.0f;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct &#123; float x, y; &#125; vec2;</span><br><span class=\"line\">typedef struct &#123; float x, y, z; &#125; vec3;</span><br><span class=\"line\">typedef struct &#123; float m[9]; &#125; mat3;</span><br><span class=\"line\"></span><br><span class=\"line\">const vec3 light_pos = &#123; 20.0f, 50.0f, 20.0f &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">float min(float a, float b) &#123; return a &lt; b ? a : b; &#125;</span><br><span class=\"line\">float max(float a, float b) &#123; return a &gt; b ? a : b; &#125;</span><br><span class=\"line\">float clamp(float f, float a, float b) &#123; return max(min(f, b), a); &#125;</span><br><span class=\"line\">vec2 make2(float x, float y) &#123; vec2 r = &#123; x, y &#125;; return r; &#125;</span><br><span class=\"line\">vec2 add2(vec2 a, vec2 b) &#123; vec2 r = &#123; a.x + b.x, a.y + b.y &#125;; return r; &#125;</span><br><span class=\"line\">vec2 sub2(vec2 a, vec2 b) &#123; vec2 r = &#123; a.x - b.x, a.y - b.y &#125;; return r; &#125;</span><br><span class=\"line\">float dot2(vec2 a, vec2 b) &#123; return a.x * b.x + a.y * b.y; &#125;</span><br><span class=\"line\">float length2(vec2 v) &#123; return sqrt(dot2(v, v)); &#125;</span><br><span class=\"line\">vec3 make3(float x, float y, float z) &#123; vec3 r = &#123; x, y, z &#125;; return r; &#125;</span><br><span class=\"line\">vec3 add3(vec3 a, vec3 b) &#123; vec3 r = &#123; a.x + b.x, a.y + b.y, a.z + b.z &#125;; return r; &#125;</span><br><span class=\"line\">vec3 sub3(vec3 a, vec3 b) &#123; vec3 r = &#123; a.x - b.x, a.y - b.y, a.z - b.z &#125;; return r; &#125;</span><br><span class=\"line\">vec3 mul3(vec3 a, vec3 b) &#123; vec3 r = &#123; a.x * b.x, a.y * b.y, a.z * b.z &#125;; return r; &#125;</span><br><span class=\"line\">vec3 scale3(vec3 v, float s) &#123; vec3 r = &#123; v.x * s, v.y * s, v.z * s &#125;; return r; &#125;</span><br><span class=\"line\">float dot3(vec3 a, vec3 b) &#123; return a.x * b.x + a.y * b.y + a.z * b.z; &#125;</span><br><span class=\"line\">float length3(vec3 v) &#123; return sqrt(dot3(v, v)); &#125;</span><br><span class=\"line\">vec3 normalize3(vec3 v) &#123; return scale3(v, 1.0f / length3(v)); &#125;</span><br><span class=\"line\">vec3 mul(mat3 m, vec3 v) &#123;</span><br><span class=\"line\">    return make3(</span><br><span class=\"line\">        m.m[0] * v.x + m.m[3] * v.y + m.m[6] * v.z,</span><br><span class=\"line\">        m.m[1] * v.x + m.m[4] * v.y + m.m[7] * v.z,</span><br><span class=\"line\">        m.m[2] * v.x + m.m[5] * v.y + m.m[8] * v.z);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">mat3 rotationXY(float x, float y) &#123;</span><br><span class=\"line\">    vec2 c = &#123; cos(x), cos(y) &#125;, s = &#123; sin(x), sin(y) &#125;;</span><br><span class=\"line\">    mat3 m = &#123;</span><br><span class=\"line\">        c.y      , 0.0f, -s.y,</span><br><span class=\"line\">        s.y * s.x,  c.x,  c.y * s.x,</span><br><span class=\"line\">        s.y * c.x, -s.x,  c.y * c.x</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    return m;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">float opI(float d1, float d2) &#123; return max(d1, d2); &#125;</span><br><span class=\"line\">float opU(float d1, float d2) &#123; return min(d1, d2); &#125;</span><br><span class=\"line\">float opS(float d1, float d2) &#123; return max(-d1, d2); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">float sdPetal(vec3 p, float s) &#123;</span><br><span class=\"line\">    p = add3(mul3(p, make3(0.8f, 1.5f, 0.8f)), make3(0.1f, 0.0f, 0.0f));</span><br><span class=\"line\">    vec2 q = make2(length2(make2(p.x, p.z)), p.y);</span><br><span class=\"line\"></span><br><span class=\"line\">    float lower = length2(q) - 1.0f;</span><br><span class=\"line\">    lower = opS(length2(q) - 0.97f, lower);</span><br><span class=\"line\">    lower = opI(lower, q.y);</span><br><span class=\"line\"></span><br><span class=\"line\">    float upper = length2(sub2(q, make2(s, 0.0f))) + 1.0f - s;</span><br><span class=\"line\">    upper = opS(upper, length2(sub2(q, make2(s, 0.0f))) + 0.97f - s);</span><br><span class=\"line\">    upper = opI(upper, -q.y);</span><br><span class=\"line\">    upper = opI(upper, q.x - 2.0f);</span><br><span class=\"line\"></span><br><span class=\"line\">    float region = length3(sub3(p, make3(1.0f, 0.0f, 0.0f))) - 1.0f;</span><br><span class=\"line\">    return opI(opU(upper, lower), region);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">float map(vec3 p) &#123;</span><br><span class=\"line\">    float d = 1000.0f, s = 2.0f;</span><br><span class=\"line\">    mat3 r = rotationXY(0.1f, PI2 * 0.618034f);</span><br><span class=\"line\">    r.m[0] *= 1.08f;  r.m[1] *= 1.08f;  r.m[2] *= 1.08f;</span><br><span class=\"line\">    r.m[3] *= 0.995f; r.m[4] *= 0.995f; r.m[5] *= 0.995f;</span><br><span class=\"line\">    r.m[6] *= 1.08f;  r.m[7] *= 1.08f;  r.m[8] *= 1.08f;</span><br><span class=\"line\">    for (int i = 0; i &lt; 21; i++) &#123;</span><br><span class=\"line\">        d = opU(d, sdPetal(p, s));</span><br><span class=\"line\">        p = mul(r, p);</span><br><span class=\"line\">        p = add3(p, make3(0.0, -0.02, 0.0));</span><br><span class=\"line\">        s *= 1.05f;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return d;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">vec3 gradient(vec3 pos) &#123;</span><br><span class=\"line\">    const vec3 dx = &#123; grad_step, 0.0, 0.0 &#125;;</span><br><span class=\"line\">    const vec3 dy = &#123; 0.0, grad_step, 0.0 &#125;;</span><br><span class=\"line\">    const vec3 dz = &#123; 0.0, 0.0, grad_step &#125;;</span><br><span class=\"line\">    return normalize3(make3(</span><br><span class=\"line\">        map(add3(pos, dx)) - map(sub3(pos, dx)),</span><br><span class=\"line\">        map(add3(pos, dy)) - map(sub3(pos, dy)),</span><br><span class=\"line\">        map(add3(pos, dz)) - map(sub3(pos, dz))));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">float ray_marching(vec3 origin, vec3 dir, float start, float end) &#123;</span><br><span class=\"line\">    float depth = start;</span><br><span class=\"line\">    for (int i = 0; i &lt; max_iterations; i++) &#123;</span><br><span class=\"line\">        float dist = map(add3(origin, scale3(dir, depth)));</span><br><span class=\"line\">        if (dist &lt; stop_threshold)</span><br><span class=\"line\">            return depth;</span><br><span class=\"line\">        depth += dist * 0.3;</span><br><span class=\"line\">        if (depth &gt;= end)</span><br><span class=\"line\">            return end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return end;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">float shading(vec3 v, vec3 n, vec3 eye) &#123;</span><br><span class=\"line\">    vec3 ev = normalize3(sub3(v, eye));</span><br><span class=\"line\">    vec3 vl = normalize3(sub3(light_pos, v));</span><br><span class=\"line\">    float diffuse = dot3(vl, n) * 0.5f + 0.5f;</span><br><span class=\"line\">    vec3 h = normalize3(sub3(vl, ev));</span><br><span class=\"line\">    float rim = pow(1.0f - max(-dot3(n, ev), 0.0f), 2.0f) * 0.15f;</span><br><span class=\"line\">    float ao = clamp(v.y * 0.5f + 0.5f, 0.0f, 1.0f);</span><br><span class=\"line\">    return (diffuse + rim) * ao;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">vec3 ray_dir(float fov, vec2 pos) &#123;</span><br><span class=\"line\">    vec3 r = &#123; pos.x, pos.y, -tan((90.0f - fov * 0.5f) * DEG_TO_RAD) &#125;;</span><br><span class=\"line\">    return normalize3(r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">float f(vec2 fragCoord) &#123;</span><br><span class=\"line\">    vec3 dir = ray_dir(45.0f, fragCoord);</span><br><span class=\"line\">    vec3 eye = &#123; 0.0f, 0.0f, 4.5f &#125;;</span><br><span class=\"line\">    mat3 rot = rotationXY(-1.0f, 1.0f);</span><br><span class=\"line\"></span><br><span class=\"line\">    dir = mul(rot, dir);</span><br><span class=\"line\">    eye = mul(rot, eye);</span><br><span class=\"line\"></span><br><span class=\"line\">    float depth = ray_marching(eye, dir, 0.0f, clip_far);</span><br><span class=\"line\">    vec3 pos = add3(eye, scale3(dir, depth));</span><br><span class=\"line\">    if (depth &gt;= clip_far)</span><br><span class=\"line\">        return 0.0f;</span><br><span class=\"line\">    else</span><br><span class=\"line\">        return shading(pos, gradient(pos), eye);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    puts(&quot;\\033[91m&quot;);</span><br><span class=\"line\">    for (int y = 0; y &lt; 80; y++) &#123;</span><br><span class=\"line\">        for (int x = 0; x &lt; 160; x++)</span><br><span class=\"line\">            putchar(&quot;  .,-:;+=*#@&quot;[(int)(f(make2((x / 160.0f - 0.5f) * 2.0f, (y / 80.0f - 0.5f) * -2.0f)) * 12.0f)]);</span><br><span class=\"line\">        putchar(&#x27;\\n&#x27;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","tags":["C++"]},{"title":"论交易与赌博的区别","url":"/2024/03/11/22/","content":"<p>“论交易与gambling的区别”</p>\r\n<p>我都写完“关于常见casino的游戏类型研究”这么长时间过去了，偶尔还是有人会问我，研究gambling究竟有什么用。其中一部分理由“利用casino游戏的大数定律判断你当下的运气”我在part\r\n8\r\n已经阐述的非常明确了。但如果我告诉你“交易与gambling”本质上是一致的呢？</p>\r\n<p>当然，并不是我说交易的结果和gamble一样随机，虽然如果遇到特殊行情和极端事件可能确实是这样。但首先我们要分清“一个傻子什么都不懂，就喜欢放手一搏，去casino里找乐子（以下简称傻子）”和“职业gambler（以下简称职人）”的区别。职业gambler是可以稳定的从casino或者对手方那里赢钱的人。【本文仅限讨论合法手段，出千赢得胜利的不在文中讨论范围内。毕竟在任何行业，成功的方法都是三元论“要么动作最快，要么最聪明，要么直接作弊”（faster，smarter，cheater）】</p>\r\n<p>至于为什么存在可以稳定从casino那里赢钱的游戏类型，casino为什么允许这样的游戏，以及具体原理举例，可以看之前“关于常见casino的游戏类型研究”的part\r\n9 和 9.2</p>\r\n<p>首先，“标准差是傻子的朋友，是职人的梦魇”，喜欢放手一搏的人，大部分还是会追求极限反杀的刺激（这也是部分PVP游戏和抽卡手游吸引傻子的精髓），而放大的标准差则意味着“运气”与“结局如何”是直接挂钩的，技术的占比在其中很低（也就是risk\r\nof ruin\r\n很高）。而职人则会去玩标准差非常低的游戏，这样游戏的“结局”和运气是脱钩的，可以让“技术”稳定发挥。</p>\r\n<p>假设有两个游戏，第一个是“你每次必须用全部本金去玩，80%的概率翻3倍，20%的概率赔光”和“99.9%的概率不赔不赚，0.1%的概率赚1块钱”，那么赌徒（傻子）会选择第一种，而职人会选择第二种。虽然第一种的期望收益高到离谱，但是只要输了一次之后，0乘以任何数都是0，也就是risk\r\nof\r\nruin非常高。第二种虽然看上去是蚊子肉，胜率非常低而且赢了也只能赚一块钱，但是risk\r\nof\r\nruin是0，也就意味着决定你收益上限的是你的游戏速度。傻子会去玩第一种游戏，而职人会去玩第二种游戏，外行会想象做交易是第一种的游戏那样，事实上做交易是第二种游戏那样（当然不排除有一些赌徒交易员会去做第一种游戏那样的决策“death\r\nor glory”）</p>\r\n<p>事实上限制了你作为职人的收益上限的只有三点\r\n1.游戏速度，2.是否能scaling up，3. （标准差之外的）运气。\r\n假设上面提到的游戏我每次只能玩一场，但是每场之间没有时间间隔，那么限制了收益上限的，就是我一天能玩多少场，也就是“游戏速度”。假设上面提到的游戏是在游戏机上玩，我每玩一次都有1个小时的冷却时间，但我身边有无数台可以玩这个游戏的机器，那么限制了我收益上限的，是我能够同时操作多少台机器，也就是“scaling\r\nup”。而标准差之外的运气，则在part 8里面有讲，建议翻回去看一下。</p>\r\n<p>那么这样对比下来，会发现职业gambler和交易员（尤其是中短期高频交易员）的本质是完全完全相同的，你把游戏速度变成“你精神上还能跟得上的每日最多round\r\nturn”（买一次再卖一次算是一个round turn代表交易一次），你把scaleing\r\nup变成“每一次交易的最大手数”（上限取决于你的杠杆率和资金上限），标准差之外的运气就是你遇到的“重大事件，黑天鹅的几率”（这里我详细在part\r\n8里面讲过如何用casino游戏去模拟）。作为交易员，你赚取的其实仅仅只是价差而已，你用“一千块钱买，一千零一块卖”和你用\r\n“十万块钱买，十万零一块卖”没有任何区别。但是影响的是你的scaling\r\nup能力，也就是资金效率。假设你有一万，前一种你可以做10手一次赚10块钱，后一种你只能做一手一次赚一块（上述例子颇为极端，且没有利用杠杆，仅做例子便于理解）。</p>\r\n<p>事实上我在part 9 里面介绍了duces wild，\r\n期望收益在100.76%左右，也就是你每次放100块钱进去，假设完美操作，你应该平均能拿回100.76块钱。“那么casino不亏吗？答案是确实会亏，所以一般期望收益超过100%的游戏，大多都不会有high\r\ndenomination，也就是大部分地方，你只能玩一次1.25$的游戏，假设你每小时能玩1000次（这是非常极限的速度了，大部分职人每小时大概只能玩800多次，有些机器可能还有限速，比如每秒发一张牌，这样你玩一次最少要7秒），那么1,000\r\nx 1.25 x 0.0074 =\r\n$9.50。相当于是你每小时假设全神贯注去玩，而且保证0失误，最终可能每小时只收获9-11刀，这和美国许多州的最低工资也差不多。从理性的角度，这样的话对于职业玩家来说可能还不如打份零工来的更有趣。”【上边内容节选自part\r\n9】</p>\r\n<p>事实上，video\r\npoker的标准差几乎是0，所以赔率基本上是确定的。但游戏限制了游戏速度，而且完全阻止了scaling\r\nup。low denomimation使得每次最多玩1.25刀（bet\r\nmax），这是游戏本身的瓶颈。假设你每次可以玩125刀的局呢？你的每小时收益瞬间就变成了950刀。事实上量化金融的优势就是利用高频的快进快出直接忽视中长期风险，降低策略标准差（减少运气在策略中的成分）。用超算去做高速交易决策，并且把机房部署在交易所附近，缩短操作延时（提升游戏速度）。利用资金优势提高抢单几率并降低杠杆减少降低trending\r\noffset风险（scaling up）也就仅此而已。</p>\r\n<p>因此如果你理解了职业gambler的本质，那么做交易与gambling没有太大区别。不过，当你的水平不是限制你自身的瓶颈时，做交易可以合法的scaling\r\nup（你的本金决定了你可以一次做多少手，前提是不考虑冲击成本），而gambling则受到游戏规则的限制。结合我在part\r\n8 当中尤其讲述了“运气”的元素，你就会理解两者其实环境是很相似的。</p>\r\n<p>但是！如果不考虑出千，提升gambling的水平是有上限的，只要游戏规则不改，你也玩不出花样。但是金融环境和市场的交易风格是时刻都在变化，所以“你的水平不是限制你自身的瓶颈”在金融中根本就是伪命题。因此两者最大的区别在于天花板的上限，一个有天花板但也有地板，一个既没有天花板下边又有n+1层地狱。</p>\r\n<p>【这里要着重强调投资和交易的不同：投资要看大方向，尽可能忽视小的价格波动。如果某向标的有长期大方向，那么最好的策略就是买入并持有。交易则相反，要忽略长期的大方向，尽可能抓小的价格变动，尽可能赚个价差就走。如果标的没有长期大方向（比如大宗商品，永远只有周期而没有十年不变的长期趋势），那么你最好的策略就是做交易赚价差。交易可以高频，可以低频，具体看你的策略。如果你的策略有回测，经得起科学的推敲和时间的考验，那么你就再玩第二种游戏。如果没有，就是凭猜测或感觉，甚至是不合法的内部消息，那么你就是在玩上面傻子回去玩的第一种游戏，只要你有复数次博弈，最终凭运气赚的钱都会凭本事亏回去。如果你能同时做交易和投资，那么你可以拥有the\r\nbest of both world，但是一般人只会陷入“戴维斯双杀”】</p>\r\n<p>【以下是拔高的部分】但是无论交易还是gambling，两者追求的本质却是相同的“追求边际的提升”。假设你偶发的失误会使你的期望收益从100.76%降低到100.71%，也就是你每1869次犯一次错误（注1，数字经Michael\r\nShackleford科学计算）。就会陷入“一个很小的问题.乘以13亿.都会变成一个大问题,一个很大的总量”，尤其是在量化高频的领域。</p>\r\n","tags":["Undefined"]},{"title":"胜率和盈亏比，你更看重哪一个？","url":"/2024/03/09/20/","content":"<p>我们之所以认为交易的赔率比胜率重要，是因为如果做主观，几乎一共就两种不同的胜率。要么你认为某个机遇有40%-50%的概率能成，要么你认为某个机遇有70%-80%的概率能成，也就这样了【注意，这里说的都是入场时的初始概率，随着你入场后得到越来越多的信息，你对概率的判断是要有更新的】。特别精确的胜率在主观交易里对决策的意义不大。因为你要做的是市场自然展现给你的机遇，而不是你强行从盘面中找出来的机遇。市场展现给你什么样的胜率和赔率，你就做什么样的胜率和赔率。如果你说你算出来有一个30%胜率的机遇（先知道胜率），但是可能有10倍赔率的机遇（然后你再算出了一个赔率），以为值得一做。但我认为你这个10倍很可能是硬生生找（编）出来的赔率，你是因为知道这个策略胜率低，强行要求高胜率，你很可能是希望市场能走到哪里（或者市场有较低几率走到哪里），而不是市场展现给你的有较高概率会到达的实际赔率。</p>\r\n<p>如果某个策略胜率低也能挣钱，那可能是最后统计的结果，但是你在做每一次交易的时候，<strong>要争取的依旧是高胜率+高赔率</strong>（而不是争取只能低胜率高赔率，或者高胜率低赔率）。因此至少有大概一半概率能成，才有必要去考虑，这才可以说是市场展现给你的机遇。不管结果最终是可以是低胜率高赔率，或者高胜率低赔率，但那都是结果，而不是你要争取的目标。因此做主观胜率几乎就只有两种，要么你认为某个机遇有40%-50%成的概率能成，要么你认为某个机遇有70%-80%成的概率能成。</p>\r\n<p>如果你想做高胜率策略，这当然是可以的（我也建议新手采取高胜率策略），但是在当下的市场环境里，不成熟的交易员运用高胜率策略大多意味着赢一次赚不了多少，但亏一次有可能会亏很多（比如你错一次可能会亏赢四次才赚出来的钱）。如果你看某位交易员（HFT和量化不算）做高胜率策略，胜率确实很高赚的也不少，那概率是他对盘面的认知和把控比较好，而不是他采取了一个多么神奇的高胜率策略。他能看出来这是一个机会，而我可能看不出来这有什么机会。他可能认为这里有风险，而我不认为这里有风险。做高胜率策略绝对是看水平的，反而是做高赔率策略，相对来讲对市场理解不用那么充分（尤其是价格变动的细节的把控），仅分析“价格走到哪里前都不应该遇到特别巨大的阻力”也经常能够吃到饱。</p>\r\n<p>言归正传，既然“要么你认为某个机遇有40%-50%的概率能成，要么你认为某个机遇有70%-80%的概率能成”【这里说的都是入场时的初始概率】，那我们怎么知道某个机遇好与不好，某个机遇是否要重仓？因此需要提前预估赔率。同样都是四五成概率能行的机遇但是赔率高，你就可以稍微加一点仓位。如果出现七八成概率能成，同时还有高赔率，那你就应该重仓。但需要得强调这个预估是建立在市场展现给你的走势和你深刻的分析的基础上。但如果你是“提前已知这个机遇胜率不高，所以我要强行找一个更高的赔率”，那几乎没有意义。</p>\r\n<p><strong>如何正确计算赔率？</strong>我之前有写过文章，大致你可以理解为当价格走到哪里，你就能够被深刻的证实你判断错了的位置来放你的止损，这是你盈亏比中的“亏”。而你通过市场走势，动能，形态等一系列因素分析到“假设价格发生运动，价格可能一直运动到x处，都不会遇到太多的阻力”那么这个位置x就是你的潜在盈利点（这是你盈亏比中的“赢”），你最好通过这种方式来计算你的盈亏比。当然，如果你的入场点不是单一的某个或某两个点，而是区间分布来scaling\r\nout，那确实会麻烦一些，但这也是个熟能生巧的过程。如果你出场也大量分布在不同的点（且点与点之间距离相差较远），那么我建议你将不同的出场点视为不同的交易。你大概可以理解为入场是一起入的，但是出场每一个都是单独的交易。（所谓单独的交易就是假设你没有其他同向持仓，这就是你当下唯一的交易。）当然，你不需要精准的算出你的盈亏比，你大概应该能知道“这个机遇比今天早些时候的几个类似胜率的其他机遇看上去盈亏比要更好，所以没准仓位可以重一点”就够了。</p>\r\n<p>但假如赔率类似，那必然是胜率高的重仓，胜率低的轻仓。两者并不冲突，只是判断胜率相对来讲比判断赔率更难一些，所以我这里强调的是如果你水平一般，那么注重赔率比较简单一点，所以“赔率比胜率重要”。</p>\r\n<hr />\r\n<p>这篇文章我不想写的太长，因为每月都会有四五位读者跟我说我的文章太长了，那我就短点写。</p>\r\n<p>因为经常有人会向我咨询一些跟交易相关的比较基础的问题。久而久之，我就发现很多散户（尤其是没有经过机构系统训练的野生散户）都会出现同样的倾向性。他们的思维方式和进机构里系统训练出来的有很大不同。【这里我想强调的是，并不是说散户的思路是有问题的，如果你能赚到钱，什么思路都是好的。只是说自己钻研的散户与经过机构训练的人的思路确实有很大不同】。</p>\r\n<p>大多数散户实际上是在“找一个精确的‘优势价格’入场，然后跟着盘面随波逐流。”我举个例子，很多散户可能利用一大套各种技术分析手段算出一个入场价格，等入场后，就以移动止损的方式让市场带着自己走。很多的散户策略真的就是这样的，他们将大量的时间和精力，不断的去尝试各种不同的技术分析手段，去找那个“高胜率的优势价格”，希望找到那个像金手指一样的入场点。</p>\r\n<p>但如果是经过系统性训练的人，他们的思路大概不是这样的。至少在我一开始做交易的时候，我的教官就非常明确的告诉我，最重要的其实是盈亏比。并不是我们不追求胜率，而是胜率这个东西它不太稳定。你说一个65%胜率的策略，也有可能连续四五次都失败。但如果你有一个好的盈亏比，胜率不到50%又何妨？（这里额外说一个很有意思的现象，很多人认为胜率在70%才是一个高胜率策略，胜率65%就不是一个高胜率的策略。事实上胜率65%就已经是2/3的胜率了，但人们潜意识的认为70%就接近90%乃至100%，65%就接近于50%，这可能是因为考试中60分才及格，给人留下了60分是刚刚超过一半的感觉。但事实上是很多即使在做高胜率策略的交易员，胜率也就是在65%左右。当然70%以上的也有，具体就看你的资金量和具体的盘面。一般通用性比较强的策略，即使是高胜率的，也就是65%胜率。要有一个交易员说他的胜率高达80%，那大概率是因为他对盘面的把控比较好，而不是说这个策略有多么神奇。）</p>\r\n<p>当然并不是说自己在家研究的野生小散就不考虑盈亏比，但他们对于盈亏比的概念一般是在“我愿意亏多少钱来止损”为主要目的。而我们考虑盈亏比，一般是在考虑在当前盘面能赚到多少钱。</p>\r\n<p>先说赢亏比中赢的部分，我们ideally希望入场之后价格可以自由的奔跑一段时间，有点像是“让子弹飞一会”，不要马上就让子弹碰到墙。我们在做规划的时候，尽量避开那种刚入场马上就会碰到一些坎坷，马上就碰到较大的阻力点，或者即使能发展成趋势，但一路上都会遇到阻力点的走势。然后我们大概的去预估，价格有可能会在哪里转向？因为就算是趋势，价格也不可能无限的向前推进。哪怕是遇到一个天大的利好，到一定程度它也是该回调的。但具体价格在哪里转向我们并不知道，但是在碰触重大的支撑或者阻力点的时候，你就可以适当减仓。（当然第一次碰触重要点位的时候，你可以让价格跑一跑看他有没有突破的迹象。但是如果短时间没有突破的迹象，你就可以减仓，注意这里是减仓，至于要不要出来还两说。）这是我们说的，赢的部分。</p>\r\n<p>毕竟市场的走势是高度不确定的，在市场真正走出头肩底之前，你永远也不知道他会是一个头肩底。在市场正经出现底部之前，你也不会知道他就是今天的底，你看订单流，看各种分析方式都没有办法确定价格会走到哪里，只能说推测出哪里的阻力可能会比较大一些，于是你用订单流等一些手段帮你更好的去辨识支撑与阻力的强度。至于如何判断价格有可能会在哪里遇到支撑与主力，请看我之前写的文章：<a\r\nhref=\"https://skytravelar.github.io/2024/03/09/18/\">技术分析究竟有没有用?感觉那么多方法，比如波浪理论，各种指标，太过主观化，运用技术分析是不是不可能成功?</a>。你可以先接着往下读，等读完这篇文章之后回来翻翻这篇文章。本质是说流动性决定了价格会遇到多少支撑与阻力，流动性决定了价格在一段趋势中会出现多少小的震荡区间。</p>\r\n<p>盈亏比中亏的部分主要是在说不能够单纯的担心自己会在上面损失多少钱，不能说“我就愿意在上面risk\r\n300元。那我就把止损放在这里。”反而，你应该考虑的是如果价格走到哪里，我就能够被非常清晰的证实我的判断是错的。因为你并不一定总能抓到好的入场点，比如你想做一个突破的策略，你在关键点位之前入场，准备做突破关键点位的交易。但你可能刚入场，价格就往回打，导致你刚一进去就是浮亏。这时候很多人可能就迅速出来吃个小亏损，（注意，我并不是说这样做不行。但如果你在这里选择了小亏出场，等价格再有突破迹象的时候，你就一定要把仓位加回去。但事实上大部分人就直接观望了，新手很难有加回去的，尤其是当价格反复在关键点位之前震荡。有些人说给自己三次试错机会，如果都是小亏就不看了。）</p>\r\n<p>一个更好的做法是你把你的止损放在一个“如果价格到这里，我就肯定是错了”的地方。毕竟你三次小亏和一次中亏哪个亏的更多，其实真的不好说。有些人问这有什么意义，其实能帮你拿住单子就是意义。有很多交易，其实事后看来他依然是能够成功的。但你可能当时出于各种原因一拿不住出来了，就导致你不仅拿了个小亏，之后大的你也没吃到。你三次小亏失败之后就可能彻底放弃，但你一次中亏之后还有可能进行再战，这就是心态的区别。而你再战的这一次没准就是开张吃三年的机会。另外，一些微小的波动有的时候可能也不需要太多的细读。事实上你不需要看的那么仔细，人的精力注意力都是有限的，也不可能一直死死盯着。</p>\r\n<p>按照我上述提的止盈和止损的位置，你再算盈亏比。如果盈亏比3-4或者更高，那就完全值得做。有些人可能觉得把止损的位置放到证明自己错了的地方，那风险太大了，不愿意承担那么大的价格波动。那我劝你就在仓位上想想办法。一般我们认为正确的仓位设计是，“你对这个交易的信心取决了你该放多大的仓位”。你觉得这个交易可行性高，你就应该重仓，你觉得这个交易可能性不好说，那你就应该轻仓。你在价格演绎的过程中越发觉得这个交易顺眼，你就应该加仓。但如果你觉得判断可行性这个事太主观了，你也可以根据“止损距离大的交易轻仓，止损距离小的重仓”，这样你每次交易你risk的金额应该是差不多的。（事实上我们也不是不采用这种办法，只是在采用这种办法的时候，一般都是市场波动性比较高的时候。因为在市场高波动性的情况下，最差的结果就是被反复止损出场，但是如果这样按照可行性来确定交易仓位，可能每次止损都要放到50-60ticks开外，那确实风险还是很高的。因此不如低仓位，但宽止损区间。）</p>\r\n<p><strong>之所以强调盈亏比，是因为你对的时候不一定能确保入场，入场了也不一定能完全吃到想要的区间，但错的时候一定会100%入场。如果你对的时候不一定能按3倍赔率出场而总是见好就收，那错的时候就直接亏，久而久之就和市场说byebye了。</strong></p>\r\n<p>那这样算出的盈亏比有什么意义？其实正经做交易，你的入场位置很难完美。比如你知道某一个交易的盈亏比是5，这是一个大好的机遇。我想来这里做突破或者反转。但是价格到那附近的时候，突然一个大单砸下来，价格嗖的一下就过去了，你根本没反应过来。现在问题来了，要不要追高？如果你再重新计算盈亏比之后发现盈亏比依然在3以上，那为什么不追高？这依然是一个好机会，对不对？价格嗖的一下就过去了，代表了其强劲的动能，然后你依然有一个不错的盈亏比，反而证实了这是一个不可多得的好机会。很多人说追高火葬场，但这种情况你就应该勇于追高。</p>\r\n<p>有些人用一大套的技术分析方法算的一溜八开，算了一个特别精确的价格。然后止损就是10\r\nticks的固定止损，止盈就是ema移动止盈。<strong>其实不如一个不那么精确的入场点，但是你能够根据盘面大致推算出这个价格有可能走到哪里都不会遇到太多的反击。把止损放到一个会证实自己的思路错了的地方。然后争取在你的止损附近找一个机会入场或者加仓（这种比较适合比如在突破之前，价格在你想要做突破点位附近形成了小的震荡区间，并在这里积蓄动能，这样你就可以尽可能在这个小区间中以更加优势的价格入场。并不是总能有这样的机会，有时你必须得在接近突破/翻转的时候hit进去。但是争取在更好的位置入场，无论如何是一个好的优化。）</strong>之后就一直拿着（除非从订单流或者微形态上读出明显不妙的迹象。这个东西是需要变通的，不是一成不变的。子弹打过来也不是说你就在那站着，该找掩体还是要躲的。）前一种交易方式属于要找到好的价格，而后一种是要做一个好的交易。</p>\r\n<p><strong>事实就是价格可能反复碰触好几次关键点位，也没能成功突破/反转（相当于短时间内没有证实你的判断是正确的，但也没有证明你是错误的。）如果你知道这是一个较高的盈亏比的好机会，你就能够比较心安的拿住订单。拿住订单就可以在价格没看出要突破迹象，却实实在在的突破了的时候，确保你不会错过一个好的交易。尤其是那种尾盘异动，盯了一天都没能突破，一直在看不到头脑的区间震荡，但最后20分钟你一不留神的时候就创了新高，你心里也不甘。又或者价格在长期来看是趋势，但在发展的过程中是一波接一波的，第一波和第二波可能相隔差40分钟。在这40分钟当中，你可以出来，你也可以拿住。如果你是小仓位好掉头，那么一般也不用考虑这么多。但是如果你一旦发大财了，成为千万级的资金，你就基本上只能做swing类的了，否则你出来就是砸盘。提前学习一下这类交易是怎么做的，也不是什么坏事。</strong></p>\r\n<p>我还得强调我上面提到的这种“以盈亏比作为是否值得一做的判断，以流动性作为规划依据”的做法并不适合所有人。如果你以其他的方式进行出入场并且赚到了钱，那当然是好事。但是我希望在这里点拨一下，小散自己钻研和一个接受过机构训练的交易员，在处理上是有哪些思路的不同之处。因为你的资金量一旦放大到一定程度，你很大程度上就只能以我提到的这类思考方式来做了，虽然当你能够影响市场后，你的手段是不一样的，但是思路是没变的。</p>\r\n<p>最后还得反复说“不亏就是赚，亏钱的概率是很大的。大部分人就是没坚持下来的，千万不要光看网上一些大牛人都日赚斗金，行情没赶上也没关系，不亏就行”，别总想些“一鸣惊人”的。</p>\r\n<p>所以希望咨询我的人不要拿一个我大概率会“推荐你不要那么做的策略”再来问我了，谢谢，我解释的也挺累的了。</p>\r\n","tags":["Undefined"]},{"title":"【实战干货】交易员如何（用散户的方式）交易关联市场，如何利用关联市场来提升当前交易","url":"/2024/03/11/26/","content":"<h2 id=\"前言\">前言</h2>\r\n<p>上次我写了一篇叫<strong>《大道至简，职业交易员处理/交易震荡走势的脑回路》</strong>的文章。有读者给我反馈那个文章的长度就正好，但是希望能再深度一点。那么这次就针对读者想看\"短小精悍\"需求讲一讲，这次讲职业交易员如何交易关联市场。【注意：正如以往的文章一样，本文主要适合可以T+0的市场品种或类型。T+1的市场不是不能做，但会比较困难。】</p>\r\n<p>这次也尽可能写的精简一点，直奔主题，少一些假大空的东西。如果你在任何一个时刻觉得我写的还不错，请给我点个赞，谢谢。你点一个赞可能对你不是很大的负担，但对于我来说是极大的鼓励。</p>\r\n<h2 id=\"背景知识很基础可以略过\">背景知识（很基础，可以略过）</h2>\r\n<p>首先，关联市场我们大致分为三种，弱关联市场，普通关联市场，和强关联市场。</p>\r\n<p>其中强关联市场在国内就是螺纹钢和热卷板，他们两个是完全强相关，价差也十分固定。两个产品都是铁矿石加工而成的，唯独就是制造的工艺略有差别。</p>\r\n<p>普通关联市场就像是铁矿石和螺纹钢的区别，相关性很强但是你不能保证价差一定维持在某个数值，即使长期来看价差大致维持在某一个区间，但日内日价间差有可能扩大情况。</p>\r\n<p>弱关联市场是价格有相同方向运动的倾向性，但价差的大小不太稳定。</p>\r\n<p>主要想讲的是普通关联和弱关联市场，强关联的我就只提一嘴。</p>\r\n<h2 id=\"实际操作\">实际操作</h2>\r\n<h3 id=\"一强关联市场略过\">一、强关联市场（略过）</h3>\r\n<p>强关联市场就是直接做价差，<strong>“价差大了就做空涨的多的，买入涨的少的”</strong>。常见的例子比如国内的上述提到的螺纹钢和热卷板，或者你做跨期套利。但由于这个东西太稳定了，导致大量的量化程序在做。哪怕你已经是在做量化的了，只要不是高频，你的抢单率很可能很难看。而当你能够轻易的入场的时候，反而可能是你不想要的时候，比如政策发生了变化，导致两者的价差有了较长期的变化。</p>\r\n<p>在交易这个行业，当你能轻易地抢进去做“套利”的时候，天上掉馅饼的机会大概是真陷阱。好似当你在淘金热时能低价买到优质的铲子时，淘金热往往已经结束了。做价差的另外一个特质就是你要能扛，也就是要你有deep\r\npocket。具体不展开了，如何做套利的文章满大街都是，建议随便搜搜，这里我就不多花篇幅了。</p>\r\n<h3 id=\"二弱关联市场重要\">二、弱关联市场（重要）</h3>\r\n<p>比如“股票和债券的逆相关”关系就是弱关联市场。不仅价差无法保证，甚至是否是逆相关都不好说。如果市场上没有其他的“主线剧情”，整个市场都比较看重经济的整体增长的时候，股债价格就是逆相关。如果有货币政策的变化，他们就是正相关——降息时同涨，加息时同跌（至少加息的那几个小时是这样的，所以传统的“40股60债”策略，除非你持有到债券到期，否则有可能被双杀）。或者股债各走各的，比如降息之后到QE启动之前这段时间，通胀走高但没有加息预期这段时间。因此一定要根据事态的变化及时调整你的策略。</p>\r\n<p>为简便理解，下面的内容都是“正相关”的市场（比如美国股市S&amp;P和德国股市DAX）。</p>\r\n<p>弱关联中最重要的内容是<strong>“做多强的，做空弱的”，记住这句话，这就是最核心的两个理念之一。</strong>我说“做多强的，做空弱的”并不是同时做多和做空，而是如果你想做多股票这个类别，你选择一个最强势的品种去做。如果你想做空股票这个类别，你选一个最弱的品种去做（类似有意的追涨杀跌）。比如，美国股市本来就想涨，但被德国股市下跌而拖了后腿导致高位震荡，那么一旦德国股市开始回弹，那美国股市就可能创新高（做多强势的）。如果德国股市没有跌的唯一原因是被美国股市拖着，一旦美国股市大盘休盘了，德国股市就可以继续跌（做空弱势的）。</p>\r\n<p>第二个核心理念是<strong>“不要因为关联市场的走势而促使你进入一个交易，你只能用关联市场去增强一个你本来就想做的交易”。</strong>继续上面的例子，不要因为美国股票跌了就促使你想做空德国股票，而是你本来就通过技术分析想在当下做空德国股票，而这时美国股票跌了，给了一个更好的理由去做空德国股票。反过来讲，如果你做空德国股票的唯一原因是因为美国股票跌了，如果你做空德股后美股开始震荡并小幅反弹，你是不是就没有做空德国股票的理由了？</p>\r\n<p>具体细节不再展开了，大致看明白就行，我要再一展开讲究又要七八千字了。做弱关联市场最重要的是大量看范例，概念其实并不难理解。</p>\r\n<h3 id=\"三普通关联市场\">三、普通关联市场</h3>\r\n<p>“普通”自然是介于“强关联市场”和“弱关联市场”中间，而究竟是做“价差回归”还是“做多强的，做空弱的”，完全取决于实际情况。</p>\r\n<p>简单的可以理解为，如果价差大体在公允范围（历史波动范围）之内，那就“做多强的，做空弱的”，但实际上你还要考虑近期市场之间的关联系数。如果市场最近这几天关联性总体一般（比如美股在高位震荡时，德股走出了头肩底。）要记住第二个核心理念“不要因为关联市场的走势而促使你进入一个交易，你只能用关联市场去增强一个你本来就想做的交易”。</p>\r\n<p>如果这几天的市场关联性非常好（比如美国股市和德国股市基本上“在相同时间段”走出“幅度几乎相同”的头肩底，并且在短期分不清到底谁强谁弱。ps：这种情况往往是由于市场上没有“主线剧情”）那么你就可以做某个市场的“超跌回弹”，因为市场大概率没有主线剧情才有这种走势，所以当一个市场超跌的时候，你就可以找一个合适的位置做回弹。但依旧记住第二条理念，你是本来就想在德股市场上做回弹的时候，正好美股有上涨的迹象，所以你做德股的超跌回弹（由于市场没有主线剧情，所以波动率也比较低，你做超跌回弹的价值可能比你做美股突破的价值要高一些。但如果回弹的价值算来算去也不如直接做美股突破，那该干啥还干啥）。</p>\r\n<p>在上述例子中，你可以做两腿的价差回归，也可以只做单边（只做回弹的部分）。虽然我建议直接做单边，因为价差不一定会回归，毕竟上述例子中的美国和德国是两个不同的国家，基本面也不一样。你做价差回归不一定会挣，而你做单边反而不一定会亏，但具体怎么做随你。</p>\r\n<h2 id=\"特殊行情数据事件\">特殊行情（数据/事件）</h2>\r\n<p>一般肯定是交易最相关/预计价格会变化最大的市场，但如果那个市场抢不进去而关联市场还没怎么动，也可以抢关联市场，但你要知道这个市场不是主要变化的对象，趋势可能不会持续，所以别太贪。如果能抢进预计价格会变化最大的市场，但是其他关联市场都无动于衷，或者跟了一段时间后开始走反向（你当前交易的市场是最后一个独立走势市场），那短期该干啥就不用我说了吧。虽然长期或数个小时后趋势依然有可能持续，但你短期需要准备吃下回调了。</p>\r\n<h2 id=\"注意\">注意</h2>\r\n<p>最重要的还是多看范例，我只是提纯之后讲一讲中心思想，具体还要看你对于盘面的认知。这次讲了入场，你还要结合处理持仓和出场方面的内容（我都写过，没事翻翻）。这些东西都不是独立的战法，而是一套关于“尝试理解市场”的系统的一部分。</p>\r\n<p>事实上，绝大部分专业交易员即使不是同时交易多个关联市场，一般也会关注关联市场的状态，尤其是你当前交易的这个市场太厚或者太薄的时候，有一个波动幅度适中的关联市场能够帮助你理解当前趋势的运行状态。比如说纳斯达克由于的每一跳的价值太小，价格震动区间非常大，再平日的交易中，可能上下能有八跳都是“价格自然震动区间”，一旦波动率上来了，很难保证每一个价位都有订单（也就是买卖价格之间有了点差，以市价单交易就会出现滑点）。在这种情况下盘口的最后成交价可能会在一个区间内到处上下乱跳，非常容易看着看着就迷失了对市场动能和速度的认知。在这个时候看一眼价格价格运动稳定的多的S&amp;P能更好的告诉你当下市场的运行状态。当市场太厚的时候也是一样，由于市场运行速度太慢，你可能都不确定动能是否还在的时候。看一眼波动速度相对较快的关联市场找找感觉（比如5yr和30yr），无论如何都是有益的。</p>\r\n<p>有两点要强调的，</p>\r\n<ul>\r\n<li>正如我上面简要举的股和债相关的例子，绝大多数市场的关联性其实是不稳定的，你一定要及时调整。某些市场之间的关联性变强、变弱也要及时做好记录，正如我<strong>《职业交易员如何做盘前准备，盘中纪录和复盘》</strong>写到的一样。</li>\r\n<li>当关联性变差（尤其是无端的开始变弱），你需要接受this is the way it\r\nis，不要尝试去解释，有的时候市场无端就走出独立走势，这个你是避免不了的，一定要记住核心理念的第二条。另外比较薄的市场比较容易“冲动”，比如Nasdaq在没有新闻或者没有主要成分股的重大利好而冲高，而S&amp;P几乎不怎么动或者只是震荡，我比较倾向于S&amp;P是“对的”，但具体情况具体分析，别当成策略，所以我只把这条写在最后面。</li>\r\n</ul>\r\n<h2 id=\"后记\">后记</h2>\r\n<p>本文偏短，但如果未来想到想更的内容，或者读者有疑问可以再更。虽然感觉里面挺多内容都可以再展开的，比如日金跳涨直接空等高阶操作，但可能也没必要？我觉得国内的好多大师和所谓的“大师”都是点到为止，剩下的看你们自己修行。那我也点到为止吧，少写一点，我也轻松。</p>\r\n<p>如果这类盘面实战文不吃香，我也在考虑弄点回忆录啥的，比如“回顾2020/2022，如何把握类似的市场机遇”，其实回顾2020的文章当年有现成的，本来准备火了之后作为粉丝福利翻新一下拿出来，但可惜这些年来我从没写出过爆款。</p>\r\n","tags":["Undefined"]},{"title":"为什么你不应该轻易移动止损线，即使你已经有所盈利","url":"/2024/03/11/30/","content":"<p>不知道大家有没有听过“三门问题”，不清楚的可以上网查一查。我这里提供一个简单的版本，假设你参加一个游戏节目，在游戏当中你面前有三道门，其中有一个门里装着100万美金，另外两个门里什么也没有。你可以在现在选择一扇门（假设选门1），等你选完了之后，主持人会在另外两个门（门2，门3）里打开一个错误的门（假设门3里面是空的），那么现在主持人问你，你是否要更换你所选的门（可以从门1换成门2）？</p>\r\n<p>很有意思的是大部分人都选择不换。这些人可能是这么想的，原先我这1/3的概率会赢，当主持人打开了一个错误的门，我现在是1/2的概率会赢。那么不管我换不换，我的胜率都是1/2那我不如坚持原来的选项，万一要是原先的对了我换错了，那么我心里会受到极大的打击。如果我一开始选择的门就是错的，我坚持不换，那么另一扇门里的钱就是没有赶上的火车（每天有那么多辆从站台出发到火车但是我并不会为没赶上这些车而惋惜，因为我一开始也没有想搭上这些车）因此，出于损失厌恶的原理，很多人选择不换</p>\r\n<p>然而从概率上来讲，如果你坚持不换，你的胜率是1/3，如果你坚持每次都换，你的胜率是2/3。然而，很多人对此不理解，我这里简单讲一个关于“集合”的问题。</p>\r\n<p>一开始的时候，你不管选哪扇门，你的胜率都是1/3。也就是说你没选的那两个扇门的胜率的合集是2/3。主持人会在你选完之后会在那个2/3的集合里面排除一个选项，所以排除了三分之一的错误项。因此如果你坚持不换，那么你是在1/3的胜率的集合里面，如果你坚持换，那么你就跳到了2/3胜率的集合里面。如果你从概率的集合的角度来考虑，你应该每次都坚持更换另一扇门而跳到胜率更大的合集。</p>\r\n<p>那么你可能会问，我讲这些东西有什么意义呢？这种集合概率不同导致认知误区的例子在生活中很常见，在交易中就更常见了。如果不知道我说的什么意思，可以参考我之前写的一篇关于“赌博和交易有什么区别的文章”，里面大量提到概率问题，尤其是在量化领域，基本就是纯概率。</p>\r\n<p><strong><a\r\nhref=\"https://skytravelar.github.io/2024/03/11/22/\">论交易与赌博的区别</a></strong></p>\r\n<p>有很多人在做量化和主观时候，会有一种落袋为安的心理，于是有一种策略叫做free\r\ntrade的策略。本质上是假设你已经有了一定的盈利（假设做多），那么你应该把你的止损线上移放到盈亏平衡的地方（假设你之前止损线在更下方的地方），这样假设未来价格下跌，那么你最多不亏不赚平着出来。但如果价格上涨，你则可以跟着吃肉，这样相当于你获得了一次“免费”的交易。</p>\r\n<p>但如果你理解上面关于集合的问题（三门问题），你会发现这样的交易思路是完全错误的。假设你已知你的胜率是50%（50%为了简便计算，如果你是主观交易，你的胜率可能不清楚，这里假设你已经知道你的长期胜率。但如果你是量化交易，你的胜率应该在回测当中有相当多的体现，这里不赘述。）那么假设你当前已经有浮盈，大概率是你在正确的那50%的概率上。假设这时候你由于损失厌恶的原理，把你的止损线上移到你入场点的地方，由于价格可能会区间波动，你相当于是增大了你平仓出局的几率。于是你本来有50%的胜率，你在移动止损线之后，你的胜率反而不足50%了。这就像上面的三门问题，如果你不移动止损线你还在原来的胜率的集合里面，如果你移动了止损线，你总体的胜率不是变高了，而是变低了。你看上去将止损线上移入场点附近的位置，好像是降低了风险，但由于你同时降低了总体胜率（从一个集合切换到另一个集合）因此你实际有多大风险，反而变成了未知。</p>\r\n<p>如果你以前的策略一直以来就是在应用Free\r\ntrade的基础上获得了50%的胜率，那么依照原策略执行即可。但如果你获得的50%的胜率是在不依靠free\r\ntrade策略的基础上获得的，那么你则不应该仅仅因为损失厌恶的原理而移动你的止损线。应该与以往的策略保持一贯性才能获得你在回测当中的基础胜率，否则你每次在没有回测的情况下变更一个参数都会陷入到新的概率集合的问题。</p>\r\n<p>那么问题来了，你在什么时候应该移动你的止损线呢？答案是“在认为当下走势应该做反向交易但又不确定的时候”。当你根据新的价格走势判断当下应该做反向交易（做空），但又不具备确定条件的时候你应该适当更改你的止损线（当然这里更改你的止损线不是指的你把止损放到不赔不赚的地方，而是放到一个适当的盈利的地方，这里牵扯到一个入场的频率与至于你是否在相同时间区间下是否get\r\npaid的问题）</p>\r\n<p>我不建议当你稍微有盈利的时候，就将你的止损拉平到入场的位置来获得一个Free\r\ntrade（免费的交易）。既然你的上面已经大概算过这个交易的潜在赔率，你迅速将止损拉到Free\r\ntrade的位置只是增大了出场的概率而已。如果你没有较低的交易成本，那么我建议你与其选择三次小亏，不如选择一次中亏。当然，如果你觉得还是反复小亏在心理上比较舒服，你怎么舒服怎么来就行。只是许多机构是像我说的这样来教育交易员的，毕竟如果你的仓位很小，那么你小亏就小亏，但等你的仓位大到一定程度的时候，我提到的这种入场思路是必须学的。</p>\r\n<p>但有一位读者就以为我的意思是一直不挪动止损线（或移动止盈线），以为我的意思是“要么亏损出场，要么赢钱之后做反向”。这当然不是我想讲的意思，只是因为价格经常是呈阶段性发展的，当价格向下一个阶段发展时，你就可以把你的止损放在上一个阶段中的合理位置。你当然是要移动你的止盈止损线的，只是不是进场之后马上就移动罢了。一般移动止盈止损线往往是你确实不知道当下是不是应该出来，但是你已经有不少浮盈所以你想保护你的盈利。毕竟如果你非常明确的知道当下应该出来了，直接出来就得了。</p>\r\n<p><strong>价格发展很有可能一开始比较清晰，后来越来越不清晰。直到你能在当下找到同样多的理由来做多和做空，你把你的止盈止损拉到一个可以保护你盈利的位置上（一般是上一个价格发展阶段中，买方/卖方占显然据主动或者有技术分析求得的具有保护作用的位置）【最好是放在如果价格突破x，那么市场的风格/劲头/动能明显的切换了的位置，这代表了如果价格走到这里，你入场的理由就已经完全不存在了。如果你找不到合适的维持你仓位的理由，那这个时候你就可以止盈出来。这和我上面一直说“你应该把止损放在一个，‘如果价格走到这里，你就能够被证实你是错误的位置’”是异曲同工的。】</strong></p>\r\n<p>如果你入场之后，价格马上就实打实的进入下一个发展阶段，那么你移动你的止损线也没有问题。但不要说你开始有一定盈利了，就移动你的止损线<strong>（你不应该单纯因为盈利的数字而移动了止损线，你应该判断价格是否已经发展到下一个阶段了）</strong>。当然，如果你要是做量化，那么量化程序可能没有办法准确识别所谓“价格的发展阶段”，所以使用了条件移动止盈或者更简单的指标止盈，但那是没办法的办法。</p>\r\n","tags":["Undefined"]},{"title":"如何正确使用订单流，如何结合不同技术分析方法——通过正确预期和盘中分析寻找最佳交易区间","url":"/2024/03/11/27/","content":"<p>因为我最近做的几个比较火的文章都是讲订单流的，所以大家可能就认为我就是做订单流的。这并不是事实，在现在这个金融大环境里，如果你只是根据市场微形态/动能动量/k线形态，做一些没有（成体系的）提前规划的交易。那么这实际上是属于scalping的范围，而这个部分现在手工已经很少有人做了，因为AI/bot已经就“量/价”这两大基本元素分析了无数年了。我之前也写过一篇文章，感兴趣的翻看一下，总之就是在金融和交易领域早就已经是后ai时代了。cta+高频搞了这么多年，你再手工的去找那些没有提前准备的行情已经比较困难了。虽然不是不能做，但是会比较不稳定，考虑到世面上绝对有“无数”多的人在给ai喂历史数据那么我们作为主观交易员尽量发挥好主观的优势，也就是处理复杂情况下的取舍。</p>\r\n<p>也就是说不要在市场上，没头没脑的找一些机会，就比如说不要多看什么布林轨/macd之类的。正确的思路是“在对市场有提前规划的情况下，对市场未来发展有正确预期的情况下”从点a做到点b（这几点我都写过单独的文章）。如果仔细观看过我之前的文章的人应该会知道，这个观点已经强调过很多次了。</p>\r\n<p>订单流只是微观层面具体判断的工具，最主要的还是对市场要有正确的分析方式。首先大家要理解价格到底为什么在某个地方会获得阻力与支撑，其本质取决于某一个价位的流动性，如果没看到这篇文章的请去读一下，讲了流动性与价格变化之间的关系。</p>\r\n<p><strong><a\r\nhref=\"https://skytravelar.github.io/2024/03/09/18/\">技术分析究竟有没有用?感觉那么多方法，比如波浪理论，各种指标，太过主观化，运用技术分析是不是不可能成功?</a></strong></p>\r\n<p>最近的这十档报价的挂单量，我们是能够看见的，但我们永远不知道在一个价格的背后还会隐藏多少“未来会进入的订单”，其中有一部分是冰山订单，但还有一部分订单是潜在的市价单。我们永远也无法得知某一个价格背后到底有多少流动性。但是我们可以通过是前盘前规划和。对当前盘面进行一些主观分析。知道哪里的流动性可能会多一些，哪里的流动性可能会少一些。假如我们做趋势策略，那在流动性低的且价格已经在此附近充分询价的地方，就应该持有而不去多读那些小波动（除非有明显的不妙的迹象），而在流动性明显高的地方，我们应该多加警惕，如果是高胜率策略，见好就收也不丢人。</p>\r\n<p>你可能会拍桌子，说这东西不就是最简单的阻力与支撑吗？是的，这就是阻力与支撑，但成功与否背后的成因是动能和流动性。而我们尽可能主观要做的就是去分析哪里的流动性比较厚，哪里流动性比较薄，然后根据当时盘面的实际情况利用订单流帮自己找一个更好的入场时机（或者避开潜在的假动作）。</p>\r\n<p>哪里流动性会比较足？大家都认为这里比较重要的时候流动性就比较足。显然是有多重分析（尤其是技术分析）都汇聚在的某一个点/区间，那么这里的流动性就会比较足。（消息面另算，消息面是一种“低流动性策略”，需要单独学）当许多种不同思路的人发现他们分析出来的结果都汇聚在一个点，或者在一个相对较近的区间内，那么这里流动性就会比较足。也就是说，我们依然要掌握多种不同的分析方式，那些技术分析/指标我们都不能落下，只是我们并不是信这些东西，而是因为有别的人在信这个东西，因为别人信，所以这里流动性比较足（比如“你可以不信中医，但不妨碍你买中药概念股”），那么我们对于在流动性比较足的地方做好更加细致的准备，而对于流动性比较差的地方我们可以相对放轻松，别把价格暂时的波动看的太细，让价格自己跑也不是不行。在此之上，我们要对价格发展有一个潜在预期，价格有可能在当前的盘面怎样发展你心目中应该多少有数，这也是我们主观经验在交易当中的作用。</p>\r\n<p><strong>这我其实早就写过，并不是什么新内容，但总有人反复问。因此我经常很沮丧，绝大部分问我问题的，其实根本就不翻看我写的文章，我链接甩给他们，他们都不去看。（下面继续）</strong></p>\r\n<p><strong><a\r\nhref=\"https://skytravelar.github.io/2024/03/09/19/\">交易员的脑回路——在趋势面前判断市场究竟是否“合理”</a></strong></p>\r\n<blockquote>\r\n<p>一般哪怕是做超短线，你最好还是有一个比较清晰的思路，至少大概率的认为市场回向某一个方向运动，你要说就坐在电脑前，跟着盘面随便走，这个事情以前也许可以，现在你做的不如量化程序。而且哪怕判断好了大方向，市场如何达到那个位置依然是个问题。他是直接向上一口气冲上去。还是充一半找一个平台歇一歇再接着冲，或者就是三步一回头都有气不同的策略和入场方式，很大程度上要通过动能和量来判断。</p>\r\n<p>冲的又快又猛，动能特别足的，大多都是消息面，一个天大的利好，大家都抢着进去，根本都没有什么对手盘挡你路，你就要激进，冲不进去就直接错过了，但如果市场一旦开始明显回头（消息刚出现十几秒内有可能会因为一些量化程序跑套利之类的程序没意识到有消息或者行情因此价格有短暂反复，那个不算）否则一般冲错了，赶紧出来保命。如果市场是三步一回头，磨磨蹭蹭，慢慢飘的。就不需要激进，等一个更好的价格再入场也不迟。如何判断动能又是一项独立的技能，无论你是通过量化程序拟合出潜在的类型，还是通过主观经验直接猜，很多时候都不是说你上来就能够判断对的。</p>\r\n<p>事实上你也不需要全才，我之前的文章里写的很清楚，你只需要在某一类市场能够保证赚钱，在其他类型的市场别大亏，你就能做的很好。想做成全才，一方面也是比较困难，另一方面经常会有三个手表，哪个时间最准的问题？到底是在同一个标的上同时做突破，又做箱体震荡，还是说你直接找很多个不同的标的一起看但只做突破（没突破就等）这个看个人。但我个人认为前一种比较难，前一种前期对盘面的理解也许并不需要投入太多，只需要专注一个或一两个标的，但是之后非常注重判断，而后一种你需要充分理解不同品种的盘面特征，但是判断起来相对来讲要简单。</p>\r\n<p>再比如说成交量也是如此。并不是说成交量高就一定好，这是一个适度的问题。一鼓作气，再而衰，三而竭。在市场上也很常见，因为市场背后对应的决策是一个个主体。哪怕是量化程序，他所学习的盘面，进行的回测，也大多是根据前人的主观判断特征而决定的。</p>\r\n<p>没怎么投入，就取得了很好的结果，就容易轻敌（很可能是大资金还没有相互角力），容易之后被反扑。如果已经投入了很多，成交最后哪怕是突破了这个关卡，你的军队也需要休整。不能说是围城了三个月，攻破之后马上就可以快马加鞭赶上下一个战场。反之，你要是投入了很多的成交量，又没见到结果，那是努力又没有结果，这非常容易让人打退堂鼓的。损失了很多兵力，又攻不下来。先不说有没有逃兵？有没有投敌的？无论如何大部队得退下来歇歇。这东西就和手机游戏上瘾是一样的，时常给你一点小的正向回馈大家的才会持续士气高涨。反映在市场上就是反复的“短期积累动能向上突破”，这种动能一般是确实强。</p>\r\n<p>我的意思是市场是走出来的，是买卖双方的实力变化决定的。而实力变化要符合自然界的一般规律，至少中短期（微观和长期另算）并不是纯粹的价格随机游走。但是我并不是说市面上没有例外，有可能市场可以不断投入，好似不知疲惫一路遇到很大的阻力都能冲高，但这并不常见。就好似战争，前线部队疲惫的时候需要大部队（长期资本，大资本）的扶持，而（市价单）攻城略地的同时也需要（限价单）来防止敌人偷袭。双方的限价单不够，就会出现chopping的状况，也就是虽然最后某一方也可能会胜出，但过程有可能就是双方你追我赶。你的动能，成交量，价格变化等一系列的因素最好要在一个恰当的区间，过多过少都会出现问题，而市场很可能不给你那么多恰当的机会，因此像视频当中那么清晰的机会，市面上其实是不多见的。</p>\r\n<p>如何判断是否恰当是一个动态调整的过程，很难去讲，需要根据当时的市场周期而定。你无论是主观也好，量化也好，你都需要不断的根据最近的情况而调整，而并非是一个长期绝对数。如果你要问判断恰当有什么意义，我认为假设市场长期来讲也是符合一个事务运行的基本规律。那某种意义上你需要对市场的涨跌做一个评分标准。假设价格是涨了，但涨得不恰当。那么这个例子可能是一个独立事件，当然也有可能是最近有很多这样的独立事件，但是以后你再重复这样不恰当的交易时候，就要保持警惕。但如果市场长期都在不恰当的基础上取得优秀的结果，那么可能你需要更新恰当所意味的指标。你要问判断出市场涨跌的评分有什么意义，我想他最差也能给你信心，在犹豫不决时的信心，如果你做量化它也可以是一个入场仓位设定因子。</p>\r\n<p>而另一方面，也有一些特殊的判断技巧。即使价格没有突破，但价格是否有粘性？即使市场三步一回头，但回头的步伐是不是比较固定？都是一些可取的参考目标。但市场那么大，机会那么多，尤其如果你做期货/期权还自带杠杆，并不涉及到股票那种总持仓时长，毕竟你也不是基本面交易。而基本面交易，尤其是价值分析，你要找的是别人埋没的黄金，那别人埋他肯定是有埋他的理由，你要等到他认错了，你才能给他挖出来说，哦，这是块黄金。巴菲特有体量和资金成本的优势，如果长时间没有人挖，巴菲特自己找人带着铲子和矿工下矿井挖给大家看，而你连个巴菲特的铲子都没有，怎么去重复他的辉煌呢，尤其价值投资，成长投资已经是一个非常拥挤的赛道了。唔，跑题了，我的意思就是说我认为做长期投资其实比做短期交易还要难，虽然股市风险要小。</p>\r\n<p>最后当然运气也是其中重要的一部分，市场也会出现兵不厌诈，或者你长期判断正确了，只可惜止损线放的太严，被震荡出场，或者说你恰巧就只有一次没有放止损，就那次恰巧就发生了黑天鹅。不过至少令人欣慰的是，这种黑天鹅你没料到，市场上其他一半的和你同样的人估计也没有料到，因此你不是唯一被埋的那一个，但反过来来讲，如果你知道你同样的队友也没有料到，你已知他们可能其中有一部分人要想出口跑，那你最好跟他们一块儿往出口跑，不要犹豫，不要再等待有没有转机。除非这价格已经迅速跌到一个非常低的位置，那么你可以说算了，我套牢了，但不要就闭眼不看了，选择增持来降低平均持仓成本仍有几率，虽然也要看你背后的标的类型，究竟能不能长期持有？有没有交割日/行权日？未来有没有翻盘的可能？毕竟人在每一步都只能做当下看起来最正确的决定，虽然长期来讲并不一定是最明智的。但谁也预测不了明年对不对。这是一个你有可能会后悔，也有可能会不后悔的决策。但假设你不后悔，也要牢记这次的教训。下次就不一定会照单重演。</p>\r\n</blockquote>\r\n<p><strong>因此，大家都在看的那些技术分析的部分，我们都不要落下。而且反过来也是一样的，要强调你要看那些大家都在看的东西，最好是大家都能一眼就看出这里很重要的东西，千万不要多搞什么你自己发明的神奇参数。比如大家都在看的默认的macd的参数，你就跟着用，不要多调。</strong></p>\r\n<p>你要是想去调整这些参数，你就去搞搞条件量化，搞搞step forward\r\noptimization，然后你就会发现不同风格，不同时期的最佳的参数变化可能很大，很有可能跑的最好策略的就是符合幸存者偏差的策略，而不是因为它真的有多好。而且，我们并不是拿这些技术分析直接做决策，我们只是拿这些技术分析找哪里的流动性可能会比较充足，具体的决策我们根据盘面走势，根据提前算好的几段a与b，最后利用订单流来拍板而已。</p>\r\n<p><strong>当对市场未来的走势有一个大概的认知，对于哪里流动性比较足也有一个充分的认识，那么就可以做出比如“跟着趋势从a到b的策略”，这个策略相对来讲，要么胜率较高，要么赔率可控是比较容易成功的方式（不一定非得跟着趋势，但你跟着趋势成功率还可能进一步提高，对于新手而言是比较推荐的方式）。</strong>当然价格转向除了遇到高流动性以外，还有可能是价格单纯的高/低到没人愿意接盘，也就是拍卖理论的last\r\nbuyer/seller，这种情况我们一般主要考虑市场是否被over\r\nstretch，是否存在panic\r\naction。而这是一个比较主观的判断（<strong>这里很重要很重要，但这里限于篇幅不展开了，有空我单独拿出来讲）</strong>，因此主观经验这里也不能丢，况且做交易也要考虑稍微天时地利人和。</p>\r\n<p>天时就是时间嘛，同样一个价格走势根据当时的市场环境，根据当时的交易时段不同，有可能会出现截然不同的结果。当天是否有预期发布的新闻，这几天市场整体上有没有动能都是其中要判断的因素之一。</p>\r\n<p>所谓地利，就是有没有各种大的小的事件。有的事件可能非常小，比如一个大家往往都不太关注的数据，可能正好在数据公布的时候，价格就差临门一脚。比如上下游关联市场有突发新闻发生。当价格可向上突破也可向下突破的时候，很多时候真的就差这么一下。这一下就有可能引起雪崩，有可能迫使一部分人以stop止损单方式出场。当然之后我们还要再看回踩是不是真的（尤其是有stop\r\nrun的情况下），而订单流在这个方面，就能起到非常大的作用。我们应该能从订单流中读出来一个在未来几十秒内比较大概率的走势（当然你要用订单流判断未来超过一分钟之后的走势可能并不准确）。因此我们要提前做好a在哪里，b在哪里的决策，提前心里做好盈亏比的预估。这样才不会无头苍蝇一样去读每一次价格的变化。尽可能简化到看微形态的就只做“是”与“不是”的判断。</p>\r\n<p>判断哪里流动性比较足，判断a和b究竟是哪里，并不需要订单流。这是对量价的基本分析的一部分。你只应该在这个基本分析的基础上利用订单流帮你查漏补缺而已。你可以进行充分回测，把k线图往前翻几天，然后假设你不知道未来的走势，你进行一个对未来a和b在哪里的判断，然后你可以看看你判断的是否有道理。如果你对最基础的盘面判断有着重大的问题，那么订单流可能不能帮到你太多。毕竟我先前已经说了，你无头苍蝇的做scalp成功率不高，而订单流最好只是在a点到来时判断“是”与“不是”。你还是要有一个对盘面走势的理解，对价格潜在有可能到达位置的判断。然后你再来看看订单流对你的分析是有帮助，如果没帮助就不要用了，我也认识那种不需要订单了就能做出很优秀的交易决策的交易员，他们单纯看裸k来交易，这一点问题都没有。但我们一般认为订单流是有辅助作用的就像你拿羽毛笔也是能写花体字的，但是自动下水的钢笔还是会方便一些。最后一点就是人和，人和这方面就是运气和概率了，我就不再细讲了，关于运气和概率，我也写过一些文章，感兴趣的翻一番。</p>\r\n<p>一般来说我们如何确定当天开盘或上午的走势很大程度上取决于我们的盘前准备（当然，盘中新发生的事情肯定重要性要优于一切的盘前准备）。有人的盘前准备就是看看昨天的profile，再画画趋势线，其实很多时候比那个还要再细致一些。当然这个东西准备了不一定有用，有些人不准备这个东西也依然能做好交易，有些人只做尾盘他们依然能赚大钱。感兴趣的可以等我未来某一篇文章看一看，但不看也行，本质上就是不同的画线方式嘛，毕竟k线图就是时间与价格。价格有价格的画法时间有时间的画法（时间主要从成交量那里着手）。先做加法，在做减法，先把尽可能多的线画出来，然后把那些没用的线删掉，最后把好多线（不同分析方式）都集中的位置作为重点观察区域来思考其是否是潜在的大量流动性堆积区域（因为这样的区域价格可能会焦灼，焦灼的过程当中也许风向就变了），就只是这样而已。</p>\r\n<hr />\r\n<p>怎么还有曲解我意思的读者哦，我都服气了，我觉得我写的已经挺通俗的了。</p>\r\n<p>这篇文章我本质的意义是在说你应该提前算好，哪里流动性会比较多，哪里流动性会比较少，流动性比较多的地方，那么可能价格就会反复拉锯，流动性比较低的地方，一般走势会比较清晰一点。我们提前对价格在哪里可能会有拉锯战，有一定心理准备，这样才不会在盘面混乱的时候摸不到头脑。而怎样去判断哪里流动性会比较充足，我之前也反复提到了，这不再赘述。我们做价差的就是赚一个价格的差距，那么价格能否走向下一个台阶，就是看动能能否突破阻力。这里的阻力说的就是对手方提供的流动性。而和你同向而行的友军实际上是在提供能量，而这个能量要能推动价格，才会产生动能（因此动能要既有能量又有价格的变化，而不是单纯就在那里拉锯），你应该根据当时盘面的能量根据你的经验和推断，一定程度上预估有多少动能，你在根据盘面实际表现看这个动能与你预估的动能相不相符，你应该尽可能地去做符合你预期的走势，排除那些你自己也看不懂的盘面。很多时候你做看得懂的盘面不仅会增强你的正确率，同时还能给你提供信心，有的时候你可能真的就差那么一点自信。然后你再去预估对面可能会提供多少阻力。这样你才能算出来这个价格还有可能走到多远，是不是应该见好就收？因此我建议你从a做到b，而不要随便抓一个趋势就开始做，随便抓一个小形态就开始做。你要对盘面有系统性规划，然后通过订单流帮你找一个更合适的入场时机，或者帮你排除一些明显错误的入场时机。</p>\r\n","tags":["Undefined"]},{"title":"糖果机","url":"/2022/12/11/3/","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include&lt;map&gt;</span><br><span class=\"line\">#include&lt;vector&gt;</span><br><span class=\"line\">#include&lt;cstdio&gt;</span><br><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;algorithm&gt;</span><br><span class=\"line\">#include&lt;string&gt;</span><br><span class=\"line\">#include&lt;windows.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">class Users &#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tmap&lt;string, string&gt; m;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tUsers()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tm[&quot;Administrator&quot;] = string(&quot;114514&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tbool check(string username, string password)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tauto it = m.find(username);</span><br><span class=\"line\">\t\tif (it == m.end())</span><br><span class=\"line\">\t\t\treturn false;</span><br><span class=\"line\">\t\tif (it-&gt;second != password)</span><br><span class=\"line\">\t\t\treturn false;</span><br><span class=\"line\">\t\treturn true;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tbool login()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tputs(&quot;输入用户名:&quot;);</span><br><span class=\"line\">\t\tstring uname;</span><br><span class=\"line\">\t\tcin &gt;&gt; uname;</span><br><span class=\"line\">\t\tputs(&quot;输入密码:&quot;);</span><br><span class=\"line\">\t\tstring passw;</span><br><span class=\"line\">\t\tcin &gt;&gt; passw;</span><br><span class=\"line\">\t\tif (!check(uname, passw))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tputs(&quot;用户名或密码错误&quot;);</span><br><span class=\"line\">\t\t\tSleep(600);</span><br><span class=\"line\">\t\t\treturn false;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tputs(&quot;登录成功&quot;);</span><br><span class=\"line\">\t\tSleep(600);</span><br><span class=\"line\">\t\tsystem(&quot;cls&quot;);</span><br><span class=\"line\">\t\treturn true;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;users;</span><br><span class=\"line\"></span><br><span class=\"line\">class CandyList &#123;</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tmap&lt;string, int&gt; list;//名字到id的映射</span><br><span class=\"line\">\tvector&lt;string&gt; nameList;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tCandyList()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tnameList.resize(1);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tint queryId(string name)//传入名字，返回id，不存在返回0</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tauto it = list.find(name);</span><br><span class=\"line\">\t\tif (it != list.end())</span><br><span class=\"line\">\t\t\treturn it-&gt;second;</span><br><span class=\"line\">\t\treturn 0;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tstring queryName(int id)//传入ID 返回名字</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif (id &gt; nameList.size())</span><br><span class=\"line\">\t\t\treturn string(&quot;&quot;);</span><br><span class=\"line\">\t\treturn nameList[id];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tint addCandyKind(string name)//无论有没有，都返回id</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tint id = queryId(name);</span><br><span class=\"line\">\t\tif (id)</span><br><span class=\"line\">\t\t\treturn id;</span><br><span class=\"line\">\t\tid = list.size() + 1;</span><br><span class=\"line\">\t\tlist[name] = id;</span><br><span class=\"line\">\t\tnameList.push_back(name);</span><br><span class=\"line\">\t\treturn id;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;candyList;</span><br><span class=\"line\"></span><br><span class=\"line\">class Store &#123;//仓库</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tvector&lt;pair&lt;int, int&gt; &gt; s; //数量、单价</span><br><span class=\"line\">\tint sum;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tStore()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ts.clear();</span><br><span class=\"line\">\t\ts.resize(100);</span><br><span class=\"line\">\t\tsum = 0;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tint getSum()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\treturn sum;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tint getPrice(int id)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\treturn s[id].second;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvoid displayCandy()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;编号\\t品名\\t剩余数量 单价&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\tfor (int i = 0; i &lt; s.size(); i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tif (s[i].first &gt; 0)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcout &lt;&lt; i &lt;&lt; &quot;\\t&quot; &lt;&lt; candyList.queryName(i) &lt;&lt; &quot;\\t&quot; &lt;&lt; s[i].first &lt;&lt; &quot;\\t &quot; &lt;&lt; s[i].second &lt;&lt; endl;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tvoid addCandy(string name, int num, int price = -1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tbool ok = 1;</span><br><span class=\"line\">\t\tif (num &lt; 1)</span><br><span class=\"line\">\t\t\tok = 0, puts(&quot;数量错误&quot;);</span><br><span class=\"line\">\t\tif (price &lt; -1 || price == 0)</span><br><span class=\"line\">\t\t\tok = 0, puts(&quot;价格错误&quot;);</span><br><span class=\"line\">\t\tif (!ok)</span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\tint id = candyList.addCandyKind(name);</span><br><span class=\"line\">\t\ts[id].first += num;</span><br><span class=\"line\">\t\tsum += num;</span><br><span class=\"line\">\t\tif (~price)</span><br><span class=\"line\">\t\t\ts[id].second = price;//更新价格</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tint rmCandy(int id, int num, int pay)//卖糖</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif (!id)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tputs(&quot;编号错误！&quot;);</span><br><span class=\"line\">\t\t\treturn 0;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif (s[id].first &lt; num)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tputs(&quot;数量不足&quot;);</span><br><span class=\"line\">\t\t\treturn 0;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tint totPrice = num * s[id].second;</span><br><span class=\"line\">\t\tif (pay &lt; totPrice)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tputs(&quot;钱不够&quot;);</span><br><span class=\"line\">\t\t\treturn -1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ts[id].first -= num;</span><br><span class=\"line\">\t\tsum -= num;</span><br><span class=\"line\">\t\treturn pay - totPrice;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;store;</span><br><span class=\"line\"></span><br><span class=\"line\">class Show &#123;//前端</span><br><span class=\"line\">private:</span><br><span class=\"line\">\tinline void read(int&amp; x)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tint s = 0, w = 1;</span><br><span class=\"line\">\t\tchar ch = getchar();</span><br><span class=\"line\">\t\twhile (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tif (ch == &#x27;-&#x27;)</span><br><span class=\"line\">\t\t\t\tw = -1;</span><br><span class=\"line\">\t\t\tch = getchar();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\twhile (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;)</span><br><span class=\"line\">\t\t\ts = s * 10 + ch - &#x27;0&#x27;, ch = getchar();</span><br><span class=\"line\">\t\tx = s * w;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">\tShow()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tstore.addCandy(string(&quot;白砂糖&quot;), 10, 10);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid run()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tprintf(&quot;启动中&quot;);</span><br><span class=\"line\">\t\tfor (int i = 0; i &lt; 5; i++)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tSleep(100);</span><br><span class=\"line\">\t\t\tprintf(&quot;.&quot;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\twhile (1)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\taa:</span><br><span class=\"line\">\t\t\tsystem(&quot;cls&quot;);</span><br><span class=\"line\">\t\t\tif (store.getSum())</span><br><span class=\"line\">\t\t\t\tprintf(&quot;营业中!\\n买糖请输入1\\n&quot;);</span><br><span class=\"line\">\t\t\telse</span><br><span class=\"line\">\t\t\t\tprintf(&quot;缺货 暂停营业！\\n&quot;);</span><br><span class=\"line\">\t\t\tputs(&quot;加糖请输入2\\n退出系统输入3&quot;);</span><br><span class=\"line\">\t\t\tint type = 0;</span><br><span class=\"line\">\t\t\t//read(type);//提高容错性</span><br><span class=\"line\">\t\t\tcin &gt;&gt; type;</span><br><span class=\"line\">\t\t\tswitch (type)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\tcase 1:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcout &lt;&lt; &quot;欢迎光临！&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\t\t\tstore.displayCandy();</span><br><span class=\"line\">\t\t\t\tputs(&quot;输入编号：&quot;);</span><br><span class=\"line\">\t\t\t\tint id;</span><br><span class=\"line\">\t\t\t\tread(id);</span><br><span class=\"line\">\t\t\t\tputs(&quot;输入数量：&quot;);</span><br><span class=\"line\">\t\t\t\tint num;</span><br><span class=\"line\">\t\t\t\tread(num);</span><br><span class=\"line\">\t\t\t\tputs(&quot;请付款：&quot;);</span><br><span class=\"line\">\t\t\t\tint pay;</span><br><span class=\"line\">\t\t\t\tread(pay);</span><br><span class=\"line\">\t\t\t\tint temp = store.rmCandy(id, num, pay);</span><br><span class=\"line\">\t\t\t\tif (temp &gt; 0)</span><br><span class=\"line\">\t\t\t\t\tcout &lt;&lt; &quot;给你找零:&quot; &lt;&lt; temp &lt;&lt; endl &lt;&lt; &quot;\\n欢迎下次光临！&quot;;</span><br><span class=\"line\">\t\t\t\telse if (temp == 0)</span><br><span class=\"line\">\t\t\t\t\tcout &lt;&lt; &quot;交易成功 欢迎下次光临！&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\t\t\tSleep(1000);</span><br><span class=\"line\">\t\t\t\tsystem(&quot;cls&quot;);</span><br><span class=\"line\">\t\t\t\tgoto aa;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcase 2:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tif (!users.login())</span><br><span class=\"line\">\t\t\t\t\tcontinue;</span><br><span class=\"line\">\t\t\t\tputs(&quot;请输入品名&quot;);</span><br><span class=\"line\">\t\t\t\tstring name;</span><br><span class=\"line\">\t\t\t\tcin &gt;&gt; name;</span><br><span class=\"line\">\t\t\t\tint id = candyList.queryId(name);//不存在这个糖 id==0</span><br><span class=\"line\">\t\t\t\tputs(&quot;请输入数量&quot;);</span><br><span class=\"line\">\t\t\t\tint num, price;</span><br><span class=\"line\">\t\t\t\tbool transPrice = 0;</span><br><span class=\"line\">\t\t\t\tread(num);</span><br><span class=\"line\">\t\t\t\tif (!id)</span><br><span class=\"line\">\t\t\t\t\tputs(&quot;输入定价(分/个)&quot;), read(price), transPrice = 1;</span><br><span class=\"line\">\t\t\t\tif (transPrice)</span><br><span class=\"line\">\t\t\t\t\tstore.addCandy(name, num, price);</span><br><span class=\"line\">\t\t\t\telse</span><br><span class=\"line\">\t\t\t\t\tstore.addCandy(name, num);</span><br><span class=\"line\">\t\t\t\tgoto aa;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcase 3:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tgoto flag;</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tdefault:</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tcout &lt;&lt; &quot;输入错误！请重新输入！&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\t\t\tSleep(1000);</span><br><span class=\"line\">\t\t\t\tgoto aa;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\tflag:</span><br><span class=\"line\">\t\t\tcout &lt;&lt; &quot;正在退出&quot;;</span><br><span class=\"line\">\t\t\tfor (int i = 0; i &lt; 5; i++)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tSleep(100);</span><br><span class=\"line\">\t\t\t\tprintf(&quot;.&quot;);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tcout &lt;&lt; &quot;\\n已退出！再见！&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tShow machine;</span><br><span class=\"line\">\tmachine.run();</span><br><span class=\"line\">\tsystem(&quot;pause&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","tags":["C++"]},{"title":"大道至简，职业交易员处理/交易震荡走势的脑回路","url":"/2024/03/11/31/","content":"<p>从来文章都是写的太长，这次简短点写。以往写过的内容（尤其是写过如何具体实操的部分）一笔带过，想看自己点开看。以下内容主要用于可以T+0的市场，A股较难操作。</p>\r\n<p>已知：</p>\r\n<p>1.交易员和操盘手也很难真正预测未来走势，只能粗略预测支撑和阻力在哪里（事实，不赘述，除非你控盘）。</p>\r\n<p><strong><a\r\nhref=\"https://skytravelar.github.io/2024/03/11/27/\">如何正确使用订单流，如何结合不同技术分析方法——通过正确预期和盘中分析寻找最佳交易区间</a></strong></p>\r\n<p>2.震荡走势肯定在趋势走势之后（无论日内还是日间），但当开始震荡时，我们并不知道未来会震荡多长时间。</p>\r\n<p>因此</p>\r\n<blockquote>\r\n<p>例如向下的趋势，第一次向下遇到阻力的时候，我们一般认为趋势要继续，不会急着就做反转。如果遇到阻力后建立一个小平台，我们认为反转的概率上升。但是仍需向上突破这个区间（尤其是回踩区间上沿成功后），我们才能说反转趋势的确立（因此较难吃到顶底，也反过来说如果吃到大顶大底，大概率是运气）。如果当日早些时候已经出现了趋势，随后长时间在底部建立平台，那么我们认为可能会在底部震荡到当日交易日结束（虽说是震荡到当日交易日结束，但有可能震荡的区间在当日晚些时候有所扩大）。我们会思考，当日的主要成交量否被转移到更下方？如果大部分成交量还是聚集在上方，那么我们认为第二天有较大可能会向上回测之前的阻力区间（虽然哪怕是成交量已经被转移到下方，仍有可能向上回测，还得看看over-night的走势）。</p>\r\n</blockquote>\r\n<p>3.如果是一个较大的震荡区间（或者震荡已经持续了几日），你可以做“保留一部分核心仓位的单边震荡”。</p>\r\n<blockquote>\r\n<p>在震荡中我们要找到向上的阻力和向下的阻力，看市场向哪边走会相对更简单。比如你认为市场向上的阻力更小，这是两方面的，一是向上突破的可能性，另外一方面是向上突破后你的潜在盈利空间。如果向上向下突破几率差不太多，那么就看向哪边突破你能获得的赔率是更高的，比如你认为向上突破，你的赔率要显著大于向下突破。那么即使向上/下突破的概率基本都是50/50。你应该尽可能的在区间下沿创建底仓，然后向上play。\r\n你在做区间单边震荡的时候，可以在区间上沿卖出一部分，做一个小的震荡play，但保留你的核心底仓。值得注意的是，如果区间震荡确实已经持续了几日，那么前几次的区间突破如果动能不是很大，很有可能是假突破。但只要你核心底仓在更下方的位置，只要是个突破就加点仓也无伤大雅，万一是真突破呢。\r\n如果价格无征兆向下突破区间，打穿你的核心底仓，参考第6条。</p>\r\n</blockquote>\r\n<p>4.日内分钟级小震荡要不要做？</p>\r\n<p>如果你先前的趋势走势已经有盈利的底仓，你把你的止损放在一个你可以证明自己错了地方就得了，幅度太小的震荡没必要太费心思，有功夫不如看看其他市场。移动止损的具体操作方式看这个。</p>\r\n<p><strong><a\r\nhref=\"https://skytravelar.github.io/2024/03/11/30/\">为什么你不应该轻易移动止损线，即使你已经有所盈利</a></strong></p>\r\n<p><strong><a\r\nhref=\"https://skytravelar.github.io/2024/03/09/20/\">胜率和盈亏比，你更看重哪一个？</a></strong></p>\r\n<p>如果你本身就是做震荡的，如果震荡区域不算特别小，我推荐从震荡的上下两沿往中间做，如果你是scalper（做更小区间的“价格抖动”）那么你要时刻注意市场的little\r\nrotation，在一个“价格抖动区间”里，找到到价格在抖动区间的上下两端失速的位置来回做高频（也就是MM做市类策略）。scalping是一项独立的技能，想做需要单独学，一定要注意使用限价单挂单入场，因为本来每次交易你也做不了几跳。小波动区间属于实在没别的机会，在市场风格合适的情况下做点也行，但不建议你彻底变成做MM的，MM真不好做，除非底仓雄厚。</p>\r\n<p>5.如何判断震荡是否会继续？</p>\r\n<p>事实上不好判断，但是也不是毫无征兆。比如</p>\r\n<ul>\r\n<li>当价格<strong>正常</strong>交易到震荡的上下两侧，成交量和动能都在贴近极点时明显下降，这是一个持续震荡的现象。</li>\r\n<li>价格<strong>缓慢</strong>交易到震荡上下两侧，且在向一侧靠近的小趋势中出现持续的明显小回调时，这是一个持续震荡的现象。</li>\r\n<li>在较为宽广的震荡区间内（前提是震荡区间比较宽），在震荡的中间位置向某方向<strong>快速突击</strong>一段距离后失速，这是一个持续震荡的现象。</li>\r\n<li>如果上一次价格到区间边缘时是因为遇到一个巨型订单（或者大量吸筹）无法突破，因此价格转向。那么如果下次价格回到这里，而巨型订单没有再次出现，这是一个突破的迹象。</li>\r\n<li>没有我曾写过的如何做突破的文章里出现的其他迹象，参考脑回路系列，Q&amp;A系列，笔记系列等。</li>\r\n<li>没有重大定期新闻/数据的公布（尤其定期数据公布前，价格已经顶到上下两端的某一边（就差临门一脚），不仅有可能同向突破，直接扫过震荡区间反向突破概率也不小，即使反向突破大概率会回踩）</li>\r\n</ul>\r\n<p>当然，这些东西都不保准。如果市场处于一个比较容易震荡状态，继续震荡的概率还是不低的。如果市场处于一个波动率很高（或已经持续震荡很久），本来就容易突破的状态中，你就不该玩震荡，除非你是做超短线震荡。</p>\r\n<p>6.\"以为是趋势，实际是震荡\" 和“假突破”怎么处理？</p>\r\n<p>没办法处理，资深的交易员可能会对盘面判断有更好的准确性，但是错的时候就是错了。资深的日内交易员长期胜率一般也就勉强达到60%（当然，如果遇到这位交易员擅长的市场走势和环境，胜率可以明显提高。不排除有世外高人，但是大多数职业交易员长期下来一般也就65%就不错了）。所以你对的时候要加仓，你认为胜率赔率都很高的盘面要重仓。必要时可以减仓，但一般建议别马上动止损。这更加是一个仓位管理的问题，而不是一个主观判断方面的问题。相关理念和具体操作方法在下面详细论述过，请自己点开看。</p>\r\n<p><strong><a\r\nhref=\"https://zhuanlan.zhihu.com/p/645308153\">Undefined：交易的仓位管理，你需要的（唯一且最后的）一篇文章</a></strong></p>\r\n<p><strong><a\r\nhref=\"https://skytravelar.github.io/2024/03/11/32/\">期货系统交易资金管理方面的心得分享</a></strong></p>\r\n","tags":["Undefined"]},{"title":"刘梦熊：问题在经济 根子在政治","url":"/2023/09/11/28/","content":"<p>来源：联合早报 2023年8月21日</p>\r\n<p>导语：在美国和西方发达国家，经济繁荣、衰退、复苏、繁荣周而复始，有其周期性和相应的经济对策。但中国是政治挂帅，政治凌驾经济，而且习惯只算政治账，不算经济账。当前中国经济盛极而衰，\r\n正是由于中共只搞局部经济体制改革，迟迟不启动政治体制改革带来的恶果。</p>\r\n<p>当前中国经济面临私企倒闭潮、外企撤离潮、投资大幅萎缩潮、出生人口下降潮、消费严重不足潮、债务连环爆煲潮，员工大规模失业潮，政府财税失血潮…………投资、出口、消费三大经济引擎全部动力不足乃至死火。中国国家统计局日前公布的7月份经济数据，不是疲弱下挫就是远逊预期，明显呈现通缩特征。第二季度外资投资额只有区区49亿美元，同比下跌87%！中国恒大、碧桂园两大房地产巨头“债可敌国”，象征整个行业崩溃累及相连产业陷入危机……以致美国总统拜登惊呼，中国经济下滑对世界犹如“定时炸弹”。</p>\r\n<p>中国坊间流传段子：“经济新三大引擎是国家统计局、中宣部、新华社”，“挽救经济的工具箱里只剩喇叭(意即“靠吹”)”\r\n。作为世界第二大经济体的中国，自改革开放以来一路高歌猛进，为何数年之间风云突变，急剧下滑？一句话：问题在经济，根子在政治。</p>\r\n<p>中国是当今世上经济被政治捆绑得最厉害的国家，没有之一！1966年至1976年文化大革命，国民经济到了崩溃边缘。\r\n1978年5月，胡耀邦推动”实践是检验真理的唯一标准”的思想解放运动，大力平反冤假错案，解放大批老干部；为所谓“地主，\r\n富农、反革命分子、坏分子、右派分子”摘帽，恢复公民权；在这基础上，1978年底，在邓小平等老一辈领导人推动下，中共十一届三中全会果断中止“阶级斗争为纲”，将工作重心转移到“经济建设为中心”，开启了改革开放新时期。这之后，\r\n农村改革，废除人民公社制，包产到户；开放沿海城市；允许私营企业进入市场，大量吸收劳动力；到海外招商引资，港澳台、美欧日企业不仅带进资金、先进科学技术、成套设备，而且引进市场经济、法治、知识产权，现代企业管理制度等观念；随着2001年中国加入世界贸易组织(WTO)，更加搭上经济全球化快车，在国际分工中成为世界工厂，积累了世界最丰厚的外汇储备，成为世界第二大经济体。</p>\r\n<p><strong>A. 中美友好是经济发展重要动力</strong></p>\r\n<p>必须指出，改革开放之初，邓小平等老一辈领导人努力达成如下党内共识：中国要实现现代化，\r\n一定要搞改革开放；而开放和引进的主要对像是美国。因此，改善和发展对美关系，是改革开放的内在要求，也是冷战格局下确保国家安全的根本要求。事实上，从美国给予中国最惠国贸易待遇到支持中国加入WTO，对中国开放市场，大量进口中国商品；美国企业大规模投资中国；向中国输出尖端科技；每年为中国培养大量留学人材，中美友好互利共赢，亦成为中国经济发展重要动力之一。</p>\r\n<p>改革开放30多年是稳步上升轨，近年来却陷入螺旋式下降轨，透过现像看本质，令经济逆转最根本原因在政治。</p>\r\n<p>第一，中国经济上升期主因是中共政治上中止阶级斗争为纲，坚持经济建设为中心，因而解放了生产力。近年经济恶化，主因是政治上强化意识形态，坚持”马克思是对的”，消灭私有制，强调斗争哲学，滥用国家安全、反间谍概念，对投资者和专业人士造成动辄误触法网的心理威胁，导致外商和游客对中国裹足不前。</p>\r\n<p>第二，经济上升期是在认识上坚持市场在资源配置方面的决定性作用，在政策上鼓励私营企业发展，保护”傻子瓜子”年广久一类民营企业家的合法权益和人身安全。</p>\r\n<p>但近年经济滑坡重要原因之一是“国进民退”\r\n的恶果：在认知上片面强调“党领导一切”，与中共十三大报告“党政分开，政企分开”改革方向背道而驰，在私企、外企设立党委、党支部，令国务院颁布的《公司法》《物权法》规定的企业自主权形同虚设，私企因此担心随时会发生”第二次公私合营”。此外，在舆论上“消灭私有制”、“私营经济退场论”、“私企职工共管共享论”此起彼伏，令投资者人心惶惶。</p>\r\n<p>在政策上，地方政府视私企为韭菜，由“乱收费、乱摊派、乱罚款”发展到“乱立案、乱抓人、\r\n乱没收”，将对私企的罚款没收作为政府创收手段\r\n之一。河北省著名农民企业家孙大午被罗织罪名入狱，大午集团巨额资产被价拍走，巧取豪夺令人心寒！所谓“行业整顿”充满随意性，一纸公文消灭一个行业，毁掉一批上市公司并非神话，而是现实!</p>\r\n<p><strong>B. 勒令移民公司交出移民档案</strong></p>\r\n<p>种种不公正待遇令私营企业家发出“利用我们是你们(中共)无奈的选择，消灭我们是你们(中共)崇高的理想”的哀鸣，投资信心尽失，因而”润(RUN)”意顿生。</p>\r\n<p>如今，当局又透过打击移民公司，勒令交出移\r\n民档案企图刹止“润潮”。中国私人企业和国际外资企业都是私有制的产物，目睹私企悲惨遭遇，外企自然兔死狐悲，心有余悸，感觉中国投资环境充\r\n满不确定性和不稳定性，从而避之则吉。私企、外企两大经济主力军信心大失，中国经济岂能不走下坡？</p>\r\n<p>第三，经济上升期重要原因，是中共在思想上强调“实践是检验真理的唯一标准”，提倡“实事求是，解放思想”，令整个社会形成允许独立思考、敢于探索，有利于激发原创动力的良好氛围。故此人才辈出，万众创业，明星企业大量涌现，促进生产力发展。但近年经济倒退的重要背景之一，\r\n正是有人违反中共中央第二份历史决议关于“禁止任何形式的个人崇拜”规定，鼓吹“忠诚不绝对，\r\n绝对不忠诚”，宣扬“定于一尊，一锤定音”，把个人崇拜推向新的高峰。</p>\r\n<p>后邓小平时代形成的集体领导格局无疾而终，\r\n干部队伍中吹牛拍马之辈当红得道，弹冠相庆。相反，正直敢言能干之士遭逆向淘汰；加上乱划敏感词汇，乱订封号标准的言论、网络监控，导致社会上万马齐喑，纠错机制缺位，以致违反经济规律、\r\n违反科学规律、违反自然规律乃至违反地缘政治规律的充满随意性拍板畅通无阻，给经济运行带来巨大冲击和惨重损失。</p>\r\n<p><strong>C. 泛政治化环境窒碍经济发展</strong></p>\r\n<p>例如冠病疫情三年，泛政治化成风，将明明是科学问题的公共卫生政策探讨，无限上纲为制度之争，提出不切实际的“坚持动态清零不动摇”口号，任意封城封路封关，停工停业停产，企业的生产、流通、营运惨遭腰斩，居民的人权、人身自由、人格尊严乃至居住权、财产权被恣意践踏，造成次生灾害远大于病毒本身，令世界工厂的产业链、供应链受到重创，是中国继大跃进、文革浩劫之后的第三次大折腾，经济损失惨重、公民权利受到破坏，政府公信力跌落且后患无穷!</p>\r\n<p>又如最近的河北省水灾，违反“水往低处流”\r\n自然法则，让海拔较高的涿州为“保护”海拔较低\r\n的雄安新区，无端成了泄洪区。涿州市民被拍脑袋工程祸害，人命财产损失惨重，是典型的三分天灾，七分人祸。</p>\r\n<p>如此投资环境，令人不寒而栗，自然窒碍了经济发展。</p>\r\n<p>第四，经济上升期重要动力之一，是中国在外交上将中美友好关系放到重中之重地位。正是2001\r\n年九一一事件发生后，中国第一时间表态支持美国反恐，美国遂投桃报李支持中国加入WTO，让中国获得最大红利。但近年中国经济下挫，却与战狼外交有直接关连：君不见前几年国内一片“厉害了，\r\n我的国”，自嗨，狂言“中国已在经济上、科技上、\r\n综合国力上全面超越美国”；扬言“双赢就是中国赢两次”；明明还是一个发展中国家，却动辄宣称中国在某某领域“为人类指明方向”云云。</p>\r\n<p>国际交往欠缺风度，将毛泽东、周恩来的“外交无小事” “有理 有利有节”\r\n遗训抛到九霄云外，撒野成惯性，四面树敌。尤其是去年2月俄罗斯侵略乌克兰以来，一不定性俄方行径为侵略，二对俄侵略罪行坚持不作谴责，三依然宣称“中俄友好无上限，合作无禁区”“会在各方面予以策应”;\r\n中国舆论场叫嚣“俄罗斯的特别军事行动是反对美国霸权主义的正义斗争”……并且在大多数国家对俄侵乌的谴责声中，坚持与俄罗斯频繁进行海陆空联合军演，以致俄罗斯国防部长绍伊古表白“俄中不仅仅是盟友关系”。</p>\r\n<p>连年推行战狼外交的结果，令中美关系跌到\r\n1972年尼克逊总统访华以来最低点，中欧、中英、\r\n中日、中韩、中澳、中加等关系全部跌至几十年来谷底。一带一路、大撒币的结果，只是糟蹋了中国老百姓的民脂民膏，并没有换来真正盟友。</p>\r\n<p>在中共强调“马克思主义行”根本价值观、与俄罗斯抱团取暖，单方面宣布“中英联合声明过时失效”、部署武统台湾等一系列事态演变面前，美国及西方发达国家盟友却意识到，基于国家安全和对以规则为基础国际秩序的维护，有必要“去风险化”，减少对中国产业链，供应链的依赖，并在高科技领域的对华投资、交易予以脱钩，避免养虎为患，反噬自己。</p>\r\n<p>古人云成也萧何败也萧何。外交上亲俄反美的实质表现，理所当然令中国逐渐失去美国和西方的资金、技术、市场，实际上终结了改革开放，重回闭关锁国，其必然趋势则是中国经济大幅萎缩、失业压力山大、广大民众重新返贫。</p>\r\n<p>常言道：经济是基础，政治是经济的集中表现，又曰“外交是内政的延续”。在美国和西方发\r\n达国家，经济繁荣、衰退、复苏、繁荣周而复始，\r\n有其周期性和相应的经济对策。但中国是政治挂帅，政治凌驾经济，而且习惯只算政治账，不算经济账。当前中国经济盛极而衰，正是由于中共只搞局部经济体制改革，迟迟不启动政治体制改革带来的恶果!</p>\r\n<p><strong>D. 不受制衡绝对权力才是最大腐败</strong></p>\r\n<p>企图回归改革开放前那套原教旨社会主义，甚至回到阶级斗争为纲、个人崇拜盛行的毛泽东文革时代，以此求得保住共产党的政权安全，只会让僵化的斯大林政治体制下产生的各种社会矛盾越积越多，越激越大。由此令私企痛感君子不立危墙之下，令外商惊悟危邦不入，则中国整个产业链、供应链，资金链将“火烧连营七百里”，这是目前中国经济结构性大坍方，反令共产党政权安全地动山摇的原因。中国前总理温家宝在任内最后一次记者招待会上，曾语重心长地警告：“如果不进行政治体制改革，经济体制改革的成果就会得而复失，类似文化大革命那样的历史悲剧，也有可能重演！”须知不受监督、制约、制衡的绝对权力，才是最大的绝对的腐败，且是各领域包括官场、军队、司法、外援撒币，医疗药业，教育、工程等等腐败的总根子!\r\n药方并不难开：政治体制改革，包括实行宪政、民主、普选制、官员财产申报公示、司法独立、保障言论新闻自由进行舆论监督………是保障经济高速优质发展必由之路。</p>\r\n<p>越南推行革新开放，政治上从党内民主扩展到社会民主，带动经济健康蓬勃发展，对外关系包括对美俄西方及亚细安友好融洽。样板就在眼前。政治造成的经济逆境，必须在政治上对症下药。问题是，从井岗山到延安到西柏坡到登上天安门城楼“一路风尘一路歌”的农民起义军领袖第二代，在“打江山，坐江山”的历史惯性思维下，有通过政治体制改革，实现经济市场化、社会法治化、政治民主化的历史使命感和远见魄力吗?</p>\r\n","tags":["禁评"]},{"title":"2024年的傻瓜式红包与开包基本技巧","url":"/2024/05/15/33/","content":"<p>很久没有认真正经的发一次傻瓜式红包了。</p>\r\n<p>一部分原因也是因为过去相当一段时间内暂时没有再发掘出类似船舶，招轮这种即使大A指数天崩地裂也不会有什么风险的适合标的。</p>\r\n<p>在过去这段时间的交易行为都需要很高级的技巧和丰富的经验，更要严格的仓位控制技巧。</p>\r\n<p>但这些东西注定为绝大多数人所缺失。</p>\r\n<p>那么2024年是不是还能再出现普通人也可以较为轻松应对的机会呢？</p>\r\n<p>有是有的，但你一定要认真看完我说的话，并且继续关注我后续发布的想法。</p>\r\n<p>因为你靠看互联网上别人的思路来做交易，本身就是一件很堕落的事情了，如果还看一段没一段的，那简直不能用堕落来形容了。</p>\r\n<p>好，我们言归正传。</p>\r\n<p>要想寻找到合适的，简单的交易机会。</p>\r\n<p>对市场当下主要趋势必须有一个清晰的认知。</p>\r\n<p>大A跌破2850影响我对超长期宏观走势的看法，与当下和中期预期是无关的。</p>\r\n<p>当下你首先要了解的是：</p>\r\n<p>————市场处于超强的空头趋势加速段。</p>\r\n<p>基于这一点展开下一步理解。</p>\r\n<p>首先，拿上证指数和创业板指数来举例。</p>\r\n<p>上证指数在2630+-2450区间都有可能见到本轮熊市极低值。极限情况在2200附近，但是概率不高。</p>\r\n<p>不过，见到极低值，不代表底部已经完成。</p>\r\n<p>因为看看月K这种大级别K线，可以很容易看出来，即使出了极低值，走出成规模的普涨，而不是超跌反弹，仍然需要最最最保守估计也不会低于一个月的时间。</p>\r\n<p>而正常估计，快也要一个季度以上。</p>\r\n<p>创业板道理和这差不多，极限低位可能在1150-1250之间，而当下的1450+其实也已经在可能出现极低位范围内了。</p>\r\n<p>月K本身已经在底背离区间了，但是你一看季度K在本轮的周期和实体大小。</p>\r\n<p>你就知道，要出现上规模的反弹，右边至少还需要一根季度K收敛，注意是至少！</p>\r\n<p>这意味着什么呢？</p>\r\n<p>意味着这轮抄底你没有任何理由着急忙慌的在疑似极低位上仓位。</p>\r\n<p>你不可能错过真正的反弹的。</p>\r\n<p>至少有3-4个月以上的低位建仓区间，而且还是乐观估计，保守一点看到半年以上的筑底时间也没什么不合理的。</p>\r\n<p>当可以再次做的创业板ETF那天来临，30M-1H的均线形态会告诉我们的。</p>\r\n<p>创业板1H的均线还在加速扩张中，这种时候光看指标底背离是不够用的。</p>\r\n<p>要看对均线的深缠绕次数，以及空头道琼斯结构是否被破坏。</p>\r\n<p>比如最近的一个是本月1号早上的1616能不能过掉？</p>\r\n<p>随着时间的前进，空头结构点的破坏标准可能会向下移动。</p>\r\n<p>激进些的交易者可能会参与到30分钟级别以内的价格收敛去寻找均线收敛和空头结构的破坏。</p>\r\n<p>以上这些，对傻瓜式交易基本都没什么帮助，如果你能理解上面那些，\r\n你也就不需要关注寻找傻瓜式交易机会了。</p>\r\n<p>在当下这种凶险的加速赶底的市场主体趋势下，还有没有比较稳妥的傻瓜式交易机会？</p>\r\n<p>事实上还是有的。</p>\r\n<p>这周末我复盘，还是找到了一些。</p>\r\n<p>之前一度想考虑将机场航运板块判定为傻瓜式机会，仔细盘算了之后还是认为不行，它最快也还要一个半月以上才能确定安全底部。</p>\r\n<p>现在必须是符合如下几个核心要求的，才是傻瓜也能做的。</p>\r\n<p>必须是资产有一定规模，行业有相当门槛或准入限制，自身和产业稳定性比较强的，最好是行业领导者的。</p>\r\n<p>更重要的是在图表上最好处于显著圆弧底的右侧，或已经是最小周K级别的K均深度缠绕收敛＋道琼斯空头结构破坏的。</p>\r\n<p>首先举个反例。</p>\r\n<p>比亚迪。</p>\r\n<p>比亚迪是行业领导者之一，而且资产规模，营收稳定性，技术力都能够达标。</p>\r\n<p>但是，比亚迪目前在图表上，维持一个强空头趋势，而且日周K均线还在加速扩张空头排列。</p>\r\n<p>这种结构虽然有一丢丢微弱可能能买到极低点，但是胜率超级低。不知道要尝试多少次才能命中，所以要pass掉。</p>\r\n<p>（不排除已经在极低点附近了，但若非超长线投资人，做投机的话，这种走法止损不好设置，所需尝试次数未知）</p>\r\n<p>那，有反例，有没有正面例子呢？</p>\r\n<p>有的。</p>\r\n<p>比如中国船舶，北京银行，上海银行，沪农商行，浙能电力，中国移动，中石化，双汇发展等等。</p>\r\n<p>举个例子如中石化，简单策略为5.80元，5.50元设置二级阶梯买入预案。</p>\r\n<p>止损为低于5.00元。</p>\r\n<p>突破6.70元之后再安排加仓。</p>\r\n<p>收益预期在最保守抵达8.10元，乐观的话抵达11元。</p>\r\n<p>这哥们不在空头趋势之中，整体保持着月。且非常完整。</p>\r\n<p>这种交易就不要指望着什么暴利不暴利的了。能完成这一段就超越市场里99%的人了。</p>\r\n<p>再举个例子，中国船舶。</p>\r\n<p>28-31区间逢低建仓，在2-3月之间完成底仓，34以上再考虑加仓。</p>\r\n<p>这个目标可以订的比中石化高一点，50以上是概率较大的。止损在27.50元即可。</p>\r\n<p>对于其它的类似标的，就按这个思路去做。</p>\r\n<p>如果不知道这些点位的含义，你就按照这两个例子去划线比划一下就知道为什么了。</p>\r\n<p>本座目前暂时就发现了这些，欢迎自行在评论区补充类似的标的。</p>\r\n<p>如果我还发现更好的，会告诉你们。</p>\r\n<p>机场和创业板之流，在小时级别层面K均收敛好了，空头结构破坏了，我自然会说的。</p>\r\n<p>记住了，现在还在超强空头趋势加速段，技术上仍然不能排除上证指数击穿2400，创业板指挑战1250的可能性。</p>\r\n<p>如果你看好的标的，多头趋势完整性和级别低于中国电信，那么看都不要看。</p>\r\n<p>中国电信这是120M级别的，也就是2H级别。</p>\r\n<p>你要是看上的比这级别还低，形态还弱的，直接把它删除出自选即可。</p>\r\n<p>这已经算是我上面提及的几个里最弱的一个了。</p>\r\n","tags":["永乐大帝明成祖"]},{"title":"市场逻辑在变化","url":"/2024/05/27/35/","content":"<p>对我而言每周写公众号最难的是怎么取标题，最好能言简意赅的概括内容，但是总是要想半天。</p>\r\n<p>先来讲A股，我不知道上周的意思大家有没有领会，因为我感觉有不少人有误解。上周说，这个地产政策，短期而言是利好出尽，但是中产期而言，大概率是实质性利好，因为标志着房地产政策彻底转向。短期是利好出尽是因为市场经过过去2年反复挨打以后，不再相信政策能救房地产（2022年中和2023年初市场选择相信政策，结果最后都被证伪），所以上周的盘面是房地产股涨，房地产产业链勉强跟一下，而宏观相关股票都是跌的，说明大家的反应不是政策会导致宏观复苏，而仅仅是找政策映射炒最直接的，而且房地产产业链第二天就跌了，说白了就是当天房地产涨停太多，追不上，于是有人追了产业链，结果大家都不信政策能拉动地产，于是第二天就都砸了。</p>\r\n<p>上周写了很大篇幅其实就是因为相信大多数人都会质疑政策是否还能拉动地产，但是因为写得太露骨，所以就404了。因为相信大多数人还会质疑，所以这里还是简单展开下。</p>\r\n<p>首先我们要明确一点，现在如果不是强力刺激，房地产市场是断然不可能复苏的，因为如果以前是大家相信房价永远涨，那么现在就是相信房价一定跌不是吗？最好的结果就是外贸很好，急跌结束后横盘，类似日本92年以后那样。</p>\r\n<p>接着第二点，如果不能重新拉动房地产，那么以后我们的经济主要就得靠外贸，那么我们的经济周期就会被迫跟随欧美，国内宏观调控的效果会越来越差（类似日韩，内部调控几乎没用），这点你觉得领导们能接受吗？</p>\r\n<p>第三点，如果这样下去，地方财政窟窿会越来越大，而且现在首付变成15%，房价基本上在17-18年的位置，也就是说如果这里房价继续跌15%，现在买房的人就会清零，大概率断供，如果跌20-30%，那么16年买房的人也大概率清零断供，这样银行真的不会出问题吗？</p>\r\n<p>因此现在不是你我愿意不愿意，也不是他们愿意不愿意，就如同2022年11月不是愿意不愿意的问题，而是要么选择一，不刺激，继续维稳，结果就是阴跌，最后海外经济出问题再来一波黑天鹅崩盘，然后银行暴雷，最后不得不印钞救银行。</p>\r\n<p>选择二，直接印钞发给地方政府，然后地方政府收储，类似猪肉收储一样，一边控制供给一边收储，等涨起来了再想办法出手或者做成reits什么的，本质上还是印钞加杠杆，类似4万亿，把问题留给后人智慧。</p>\r\n<p>就说怎么选吧？</p>\r\n<p>现在很多人喜欢说人口问题，杠杆率太高，库存太高等等，所以楼市起不来，但是这只是描述现象而已，说这话就如同2022年说经济数据依然很好，外贸高增，疫情死亡人数很少，所以这样封城百利而无一弊。描述现象对推演未来的变化没有什么意义，得看到现状的矛盾点才能推演未来的变化。2022年的矛盾点就是封城导致企业现金流断裂，会逐步破产倒闭，失业率上升，然后出问题，现在的矛盾点是房地产不刺激就起不来，长期看还会下去，但是继续下去银行会出大问题，经济会出大问题，最终还是得印钞，那与其到时候印钞救银行，不如现在印钞直接给地方政府，这样伤害更小也更符合他们的利益不是么？</p>\r\n<p>好了，这个就说到这里，也没意义争论，毕竟不管怎么论证，市场现在不会选择相信。市场现在需要的是数据验证。</p>\r\n<p>前几周写了，A股的估值其实已经不便宜了，继续上还是回调，完全就是看图了，然后从上周开始就显示出颓势。上周我提了一点，就是上周五早上拉地产砸其他，下午拉光伏砸地产，这说明2个问题，第一个，市场里没钱了，容不下同时涨2个板块了，第二个，市场风险偏好很差了，大家都不愿意追高，而更愿意抄底。当市场要开始卷手速，比微操的时候，就该休息了。所以本周的下跌基本上属于预期内。</p>\r\n<p>说实话，如果之后政府不能强力刺激拉动地产的话，A股现在这个估值没什么空间了，虽然短期也不见得跌下去（因为海外需求还旺盛），下半年又要和之前一样震荡，然后炒题材卷手速了，现在更夸张的是居然开始卷传销了……真不愧是空气币市场……</p>\r\n<p>看本周新闻，一线首付下调还是被拒绝了，那就说明他们可能还在既要又要，那就暂时还不会出全力拉地产，那就还需要时间，最近虽然都传闻说楼市带看人数大增，但是除非他们大力收储，否则大概率带看就是看，看完就算了，毕竟这么大的决策，大家都只会买涨不买跌。估计他们还在纠结，但是毕竟态度松动了，首付降低到15%其实等于是房价更不能跌了，否则就是给自己埋雷了。</p>\r\n<p>我们股市里决策就简单多了，就安心看M1,M1如果环比回升，市场就会转向复苏线，之后如果持续回升，那就是类似16-17,20年下半年到21年上半年的行情。</p>\r\n<p>所以A股现在就是M1回升之前当震荡市看，跌不多，涨不多，跌了可以买长逻辑好的，比如出海，比如电网投资，如果认定拉不起来，甚至可以跌下去买红利股。如果M1开始回升，则全面买入复苏线，复苏线有哪些那就看16-17,20年下半年到21年上半年涨哪些就够了。</p>\r\n<p>然后是港股，本周港股也不好，恒生指数不好的原因和A股类似，恒生科技指数不好的原因一方面可能因为游戏行业新规的传闻，一方面因为恒生指数带动。说白了，还是因为涨得多了，估值没那么便宜了，短期获利盘回吐加风险偏好下降导致回调。我们可以看到，现在海外风险偏好是在回升的，之前讲过，海外风险偏好回升对AH股是利空，因为当我全世界股市都能选的时候，我一定不会去选AH股，因为对于老外而言，纵使日本经济前景扑朔迷离，纵使印度发展前景难以预测，也好过预测这边的政策不是么？别说老外觉得不好预测，就算你我这样的中国人，难道觉得现在的政策容易预测？所以我说一旦海外风险偏好回升，老外就会面临灵魂拷问，港股是真便宜，还是估值低仅仅是对不确定性的风险补偿？20x的腾讯，我宁可选23x的META。</p>\r\n<p>当然，我不觉得港股就这么结束了，因为我是相信房地产政策是彻底转向了，只不过验证需要时间，在验证成功之前AH股很难很好，你看最近外资行的报告就可以发现分歧了，有的外资行说中国房地产政策转向，超配中国，有的外资行说房地产政策力度不够，利好出尽，低配中国。分歧就在这里了。</p>\r\n<p>然后美股，美股简单很多，上周写了，powell认为劳动力市场已经均衡，咬定通胀是暂时的，所以美股就类似2021年，虽然通胀在回升，但是无所谓，因为美联储说是暂时的，无非2021年是小票拥挤，大票低估，现在是大票拥挤，小票有一些刚拐点，另外不是说因为类似2021年就意味着之后要大跌，因为2021年之后大熊市是因为“通胀是暂时的”这个说法被证伪了。如果这次最终被证明通胀确实是暂时的，那么美股就没问题，如果最终证明通胀不是暂时的，那美股之后还会大熊市，短期无法证实无法证伪，那么市场就会相信美联储，继续炒人相对少，估值相对低，业绩好或者更拐点的东西。</p>\r\n<p>然后因为全球风险偏好回升，所以BTC也涨回来了，现在btc里机构越来越多，所以和股票市场风险偏好节奏很一致，但是BTC比股票市场好的一点是，股票市场后面还要担心一个衰退风险，但是这个东西对BTC反而是利好（但是刚开始跌的时候还是可能因为风险偏好下降而被砸下去，因为机构越来越多了）。</p>\r\n<p>本周四美股小型股大跌了一把，个人认为主要是因为上周美股有点发散，可能因为NICK发推说9月之前不会降息，于是大家开始定价9月降息，一堆降息逻辑的股被拉起来，然后本周美联储会议纪要出来以后，大家发现居然这么鹰派，然后这些东西暴跌，比如XBI之类的，但是还是得记得，会议纪要不如powell讲话重要，虽然上个月的FOMC会议纪要非常鹰派，但是POWELL讲话非常鸽派，你就可以知道他要的到底是什么了，无论他是因为政治压力也好，还是他真的相信通胀是暂时的也罢，一切以他的发言为准。</p>\r\n<p>那么美股现在的逻辑就很简单，就是通胀是暂时的，人多的，估值高的，业绩没催化剂的暂时就是落后的，人少的，估值便宜的，业绩有催化剂的，现在就是龙头。除非powell改口，否则没有系统性风险。</p>\r\n<p>整个美股市场最耀眼的肯定还是AI逻辑，无论是NVDA，还是DELL,MU，TSM或者电力股都是这个逻辑，然后是币股和GLP-1，所以接下去还是看这些能不能持续，另外就是看QQQ和NDX的的比值，现在NDX涨幅一直比QQQ大，说明M6还是拖后腿的，小盘股涨幅更大，如果什么时候开始逆转了，那就说明短期又涨不动要调整了，之后资金可能又回去M6了。</p>\r\n<p>当然，最最最核心关键的还是看美国经济数据，2个数据最重要，一，就业，离职率，工资增速，二，CPI，尤其房租通胀</p>\r\n<p>总结，AH股耐心等M1数据好转，M1数据不能起来，市场又是震荡市，操作难度会直线上升，又鸡肋了，如果M1回升，就全面拥抱复苏线，放弃TMT（最快也得6月的数据才能回升了估计，也就是要等7月数据出来）。美股继续换个地方炒alpha，盯紧宏观数据和powell讲话就可以了，本周的fomc纪要又打死一批炒降息beta的，但是如果之后数据好起来，不排除这些又杀回来。</p>\r\n","tags":["西湖醋鱼"]},{"title":"期货系统交易资金管理方面的心得分享","url":"/2024/03/11/32/","content":"<p>首先，以下内容主要针对于日内和日间交易。如果你是投资的话，那么以下方法不适用。仓位管理在投资方面的意义主要在于让账户在更长期的范围里抚平波动率，是你在几十年后能够获得足够大量的资本来稳定出金，而你账户的总价值理应将在你开始出金后不断缩小。做交易则是让你的账户能够快速扩张，争取达到你在一段时间以后就可以稳定的从账户里出金，而不会严重影响到账户净值。</p>\r\n<p>然后还是有读者跟我说每天止损上限是risk\r\n10%，实在是风险太大了。我想说你应该尽可能争取不要落到会触碰到每日止损上限的地步。有一个down\r\nday，或者连续几个down\r\nday都不是致命的，但你不需要每天都亏10%才收手。我们说你要设定一个每日止损的下限和上限，主要是防止你承担的风险太小使得你不能抓住合适的机遇，或承担的风险太大使得和赌徒行为类似。</p>\r\n<p>我在之前的文章中也反复强调了你要注意交易的盈亏比，你愿意risk你账户的10%，肯定是因为这是一个好的机遇，那我们认为什么样的机遇是好的机遇？有较高的几率同时能够获得较大的盈亏比的交易是一个好交易。比如我们看到一个交易有70%的胜率，同时带有六倍的盈亏比那我们认为这是一个好的交易。假如你勇敢的risk\r\n10%，那么你今天账户的净值就应该能够增长50%。或者某一个交易只有40%的胜率，但是有15倍的盈亏比，你用10%的本金去赌一个能让你今天账户翻1.5倍的机遇，为什么不勇于去尝试？</p>\r\n<p>如果你问怎么才能知道盈亏比是多少，怎么正确计算盈亏比？那看一下之前我写的这篇文章。里面写的都很清楚</p>\r\n<p><strong><a\r\nhref=\"https://skytravelar.github.io/2024/03/09/20/\">胜率和盈亏比，你更看重哪一个？</a></strong></p>\r\n<hr />\r\n<p>今天来讲两句仓位的事（不是加仓的事，加仓上一次文章已经提到了，没有详细展开，但致意思是讲的挺清楚了，我不想再重复了。）这个仓位我指的是总共的仓位。指的你应该拿多少钱去做某次交易，你应该怎样去规划你每日的盈利和亏损等等。</p>\r\n<p><strong><a\r\nhref=\"https://skytravelar.github.io/2024/03/09/20/\">胜率和盈亏比，你更看重哪一个？</a></strong></p>\r\n<p>上一次的文章指的是这个，你看完这篇文章感兴趣就可以再翻翻看这篇文章。</p>\r\n<p>仓位这件事其实是很重要的，虽然我一直在说应该先去找到做交易的稳定盈利方式，然后再考虑仓位。但有些内容，真的很多人自己琢磨很长时间估计都想不到。我这里直接提几句帮助新手避坑。</p>\r\n<p>少啰嗦两句，直接进入正题。</p>\r\n<p><strong>1.首先你交易仓位的放大应该源于你做交易稳定性的提升，而不是你前一阵子赚了多少钱。</strong>这个东西我一说大家都能明白，应该不需要再赘述，但显然很多人都在上面犯非常简单的错误。比如我昨天大赚一笔，今天就加仓位；比如我上周做的不错，这周开始加仓位。交易要考虑均值回复的，只有你技术的稳定性提升了，你才能确保你加了仓位之后获得的收益也是正的。</p>\r\n<p><strong>2.但是如果是行情驱动，导致你赚到钱了。那么你可以优先加仓位，但是当行情和市场风格切换的时候，你必须把仓位减回去。</strong>跟上面一条说的一样，你在某个行情下能赚到钱，不代表你在其他行情下也能赚到钱。之所以你可以在行情驱动下加仓位，是因为行情并不总存在。错过了可能就得等很久，也不一定会有下一个行情。但是如果行情明显有变化，或者市场风格有明显的切换，那么你一定要迅速的把仓位减回你原先的位置。否则你会快速的把凭运气赚的钱，凭本事亏回去。</p>\r\n<p><strong>3.你应该设定一个严格的每日亏损上线，但不要为每笔交易设定固定的单笔交易亏损上线。</strong>假设当你发现了一个非常好的机遇，你应该愿意将当日止损上限的50%都放在这一次交易上。如果你不愿意把50%的尺寸上限放在这一次交易上，那么这个机遇可能没你想的那么好。有一些简单的交易法则会说你在每次交易上risk\r\n2%，但这就像定投一样，是一个让大众都能够理解的简单计算方式。但显然你作为职业/半职业交易人员，不应该采取这样的行动。你应该按照价格走到哪里，你就会被充分的证实是错误的地方放你的止损，然后去看这个损失是否是你可以承受的？但如果这是一个非常好的交易，你需要愿意花费你当日止损上限的50%都投入到这一次交易当中。但是相反也是说得通的，除非这个机遇真的是好到离谱，否则你也不应该为这一次交易allocate超过50%的当日总止损额度。</p>\r\n<p><strong>4.你的止损上限不是你的预算，如果目前处于一个没有什么好行情的阶段，那么你应该考虑的是直接不做，而不是非得在这个市场上找点什么机会。千万不要想着今天的止损上线还没有用完，我再最后再玩几把大的。</strong>你要记住，你是在做交易，不是在DB。你能盈利的秘诀在于你的稳定性，而不是你的运气。<strong>如果你今天早些时候连亏，最后想着“算了，赌一把大的试试”，那么我建议直接关机，明天在说。</strong>当你有这个想法和倾向的时候，你下一把能不能一次赚回来就已经很大程度上不靠你的实力（稳定性），而是在靠运气了。</p>\r\n<p><strong><a\r\nhref=\"https://skytravelar.github.io/2024/03/11/22/\">论交易与赌博的区别</a></strong></p>\r\n<p>感兴趣的参考一下上面这篇文章，写的还是很清楚的，也提到了一些大家可能不会注意的东西，感兴趣的看一看。</p>\r\n<p><strong>5.对于小资金而言，你需要迅速的离开只要连续止损几次就会爆仓的地步，因此你的每日亏损上限应该设定为总资金的20%~30%。如果你认为连亏三四天就要爆仓的结果难以接受，那么你应该再多做几个月的模拟盘。但我必须强调，这个说法是正确的，但是却被很多不良交易公司所利用，他们会在你没有经过大量训练和回测的基础上就告诉你应该这样操作，导致你一上来连亏三天就爆仓，之后就要你追加入金，否则就将你扫地出门。</strong>这个说法是正确的，但是你需要有相应的实力来掌控这种玩法。这种有点像poker\r\ntournament，每个人拿2000美金入场，每一次游戏最少risk\r\n200美金。假设你可以玩100局后仍然活在市场上没出局，那么你可以拿10万美元的奖金回家。在这种情况下，你最好的策略是一开始玩大的。如果一开始成功的在最初的20局内站稳了脚跟，那么后面你就可以play\r\nsafe。就像如果你能非常幸运的在最初的几个交易日就利用新手运成功赚到了一定的资金，你就可以切换成下面对于大中资金的玩法。</p>\r\n<p><strong>6.对于大中资金而言，你的每日止损上限不应小于总账户的5%，但除非行情来了，也不建议你将你的每日止损上线超过你账户总资金的15%。</strong>本质是在说（如果没有行情）你每日承担的风险不应该太小，当然也不应该太大。由于金融资产的流动性实在太好，随时可以兑换回钱，导致大家可能对于数字变化过于敏感。你想象你是一家水果店，你既不能进货太少，导致大家都没得买，也不能进的太多，导致水果烂掉，你赚的就只是从批发到零售的一个价差。你在决定你承受多少风险的时候，就假设你不能随时出来，假设你就是这一家水果店，你是否会亏损在决定订货的这一瞬间就已经定下。如果你感觉每日10%亏损的风险不可理喻，那么请参考一下这个水果店的例子。上面这个说法是双向的，意味着当你有几百万美金的时候，你也应该愿意在每一交易日上risk\r\n10%，如果行情真的来了，你愿意一天risk\r\n20%。当然这也客观上的导致了大部分交易员的账户曲线是呈阶梯式的。</p>\r\n<p><strong>7.在第六条之上，如果不是行情来了，你的每日止损上限也不能超过7日平均日盈利的两倍。如果与第六条有冲突，以本条为主。</strong>如果你的盈利水平太低，你会陷入downward\r\nspiral。比如连亏三天，你要靠连赚六天来赚回来，但如果你在这六天当中再亏一次，你就需要更多的连赚。直到出现从事实上不可能连赚那么多天，导致你的账户有可能不能再回来。这时你需要思考是降低你的总仓位还是降低你的每日止损上限。有可能你的每日止损上限是没问题的，但由于你的仓位过大，导致普通级别的异动就能迫使你达到今日的止损目标。因此你的总止损上限也应该跟你的盈利水平相配合。</p>\r\n<p><strong>8.如果你想要放大你的总仓位（不是单次交易的加仓，是总仓位），那么你每次放大仓位最少不应小于已有仓位的30%。</strong>举例，如果原先你可以做10手，那么你放大仓位之后应该考虑可以做15手。你每次加仓后应该明显感觉到账户净值波动扩大，你需要趁这个机会assess扩大仓位是否可行？这分为几方面，一是你心理和实力上上是否接受，是否已经准备好接受全新的挑战，二是当前行和标的行情是否能容纳，比如你要做国际原油CL，单次交易超过15手你就必须得学会分仓了，一次直接打进去就要付出冲击成本了。你如果慢慢提升仓位，很多事情有可能温水煮青蛙，直到慢慢的开始发现，好像因为各种原因开始不赚钱了。</p>\r\n<p><strong>9.一般不建议设定每日盈利上限，建议赚钱的时候能赚多少赚多少。不赚钱的日子直接关电脑回家享受生活。</strong>在我们业界有一个说法叫做出租车司机思维。出租车司机经常是赚够了钱就提前回家，赚不够当日限额，熬夜也要开。一般建议是在能赚钱的时候使劲赚，因为你不知道什么时候可能突然市场波动率就下来了，当市场波动率降低的时候，你对于出入场的准确性就需要大幅提高。许多能够读市场走势赚到钱的，在这种环境下就很难熬。当然在这种环境下，擅长做波段的就能够活的很好。但一般人很难迅速的从做趋势变成做波段。因此我们建议如果你在做趋势能赚到钱的时候，赚最多的钱，你在做波段能赚到钱的时候赚最多的钱，这样当风格切换的时候，你有足够的资金垫，可以熬到下一次风格切换。或者趁这个机会学习一下如何做另外一种市场风格，但无论如何这都需要你有一定的既往盈利。一般我们建议，如果你累了，撑不住了或者感觉判断的准确率下降的厉害再下机。跟你游戏打排位是一样的建议。</p>\r\n<p>还有些其他的就比较因人而异了。有些人是你给他多少仓位，他就做多少手。有些人是给他很大的仓位，他也不会做几手。这个东西还是要分人的，因此上面的都是大众都可以使用的“一般规则”，至于你个人什么交易习惯，你自己可以再参考一下。你只要能赚到钱，怎么样的交易习惯都可以，但是负责的机构一般会教新交易员这些内容，因此你们可以参考一下。</p>\r\n<p>本来我还想讲一下盈利水印的（也就是watermark）但这个适合那些盈利非常稳定的人。你可以大致理解为每日profit\r\ncurve的training stop，感兴趣的自己了解一下。</p>\r\n","tags":["Undefined"]},{"title":"迎接180度","url":"/2024/05/21/34/","content":"<p>上周写了所谓的制造业很强大，意味着未来经济全靠外贸拉动，有2个弊端，第一，经济周期只能跟着欧美，宏观调控几乎没用，而欧美隔三差五经济危机很正常，再来一次我们地产再崩一次就很容易陷入资产负债表衰退；第二，外贸无法提供足够多的财政收入，解决财政危机。</p>\r\n<p>一直看我写的东西的人知道，我一直说上证=房地产，中国经济=房地产，财政≈房地产，只要房价不涨，需求就无法提振，接下来最多就是暂时跌不动，房地产对经济和上证没有负面拖累而已。然后今年我一直担心消费后面会增速快速下行，那样的话，今年GDP很难保5%，甚至4%都未必能保（除非外贸特别好，或者价格平减指数特别低）。所以我一直觉得迟早得刺激房地产，这就如同得了盲肠炎，无论如何最后得动手术一样，无非现在是曹操穿越来现代得了盲肠炎罢了，你不知道他什么时候会答应动手术罢了。</p>\r\n<p>这个操作就很有他的特色，和疫情一样，如果理性分析就知道，迟早得放，越早放越好，放得越晚，需要的刺激力度越大，但是他的特色就是除非头破血流，否则坚决不转向，妄图通过各种微操来扭转失败以后才会答应转向，但是一旦转向，又是不管不顾向前冲，退烧药有没有无所谓，防护知识有没有宣传到位也无所谓了，死亡人数也可以不公布了，反正别问，问就是昨天清零是忠诚问题，是路线问题，今天放开是忠诚问题，路线问题。</p>\r\n<p>这次我觉得不再是秀微操的那种政策而是彻底转向，几个原因，第一，之前的政策都很孤立，都是今天出一个，过阵子再出一个，而这次是密集出台，一个礼拜出一堆，第二，之前的政策主要出在融资端，当时我记得我还吐槽过，我说他们还不知道问题出在哪儿，房地产根本不是融资问题，而是需求问题，只要房价一直跌，不能扭转降价预期，需求就会越来越少，连问题出在哪儿都不知道，政策肯定没用。但是这次不一样，这次全是需求端政策。</p>\r\n<p>我们看下政策：库存太多的城市不再批住宅用地（供给侧改革），地方政府允许收储（国家队入市），降低首付比例，取消房贷利率下限（鼓励加杠杆），我聊了下，大多数人现在还是认为救不起来，我觉得都做到这份上，同时强调房地产具有人民性，政治性了，这你得承认是180度的转变吧？既然是180度的转变，与其直接否定，不如观察数据，大家质疑很正常，毕竟过去2年从房地产政策应出尽出，到保交楼，到化债，到稳楼市，无数次狼来了，大家伤透了，所以不信很正常。但是这次真的不太一样了，即使真的不信，也建议观察一下数据再否定。</p>\r\n<p>毕竟他的风格就是我定个目标，你们去完成，完不成就滚，至于打击教培会导致什么后果，怎么收场，我从来没想过，下面的人不敢想，更不敢问，至于清零最后如果清不掉，经济会怎么样，我也从来没想过，底下人一样不敢想，不敢问，非要问，那就是忠诚问题，路线问题。所以有人问，这次难道真的想把房价刺激起来吗？怎么收场？我的想法是，会不会他根本没想那么远，实际情况就是财政真的兜不住了，所以水电煤气，高铁等都要涨价，而且涨那么点就怨声载道，未来的窟窿怎么办，4月房地产数据加速恶化，社零数据也开始拐头，如果还不稳住，他开始担心会不会出系统性风险了，于是直接下一个命令，你们必须稳住地产，至于怎么稳，当然是有形的手，毕竟无论涨跌，他们只会这一招。</p>\r\n<p>于是下面的人就接到KPI了，去完成吧，必然是运动式保楼市，反正之前一天3次核酸，6个月封城的官员也没下马的，反而是漏掉几个人导致疫情扩散的全下马了。现在的考核体系就是KPI给你，随便你怎么完成，你只要完成KPI，引发其他问题都可以忽略，但是你完不成，就滚。</p>\r\n<p>那么现在的KPI可能就是稳定房地产市场，发到各级政府手里，这就是个决心问题，不用卷成技术问题，技术上有问题，之后都可以一张A4纸解决的。毕竟担心一夜下岗100W而不敢打教培的人最后发现100W算个P，担心没有药，有2000多种后遗症，人口密度太大会死很多人的，到现在都不知道死亡人数，算个P。</p>\r\n<p>相信他，相信这就是他的风格，所以我相信这次就是180度了。</p>\r\n<p>非要说问题，那么问题主要在长期，16年是定向放水给拆迁户，拆迁户买房，全国人民补贴拆迁户，现在的定向放水给地方政府，地方政府买房，全国人民补贴地方政府。另外一个问题就是这次下跌太久，刺激力度不够的话，房价没有起色的话，需求马上又会萎靡，而刺激力度如果足够，房价起来的话，会发现一线和强二线供给马上就没了（二手房都是弹性供给，就如同股票，一旦连续涨停，卖盘就没了）最后怎么收场。</p>\r\n<p>但是这种长期问题，他们大概率不考虑，所以我们也没必要操心，简言之，就看力度，力度够，相当于重回16年老路，说白了，这才是中国经济的龙脉。</p>\r\n<p>如果房地产销售真的恢复，M1开始回升，那么股市就真的会有牛市，然后风格就从出海完胜会切到复苏线，而且一旦房地产起来，利率就会起来，汇率也很有可能起来，那么出海和红利就成了受损的，资金会全面切向复苏这条线。当然，短期资金明显还在质疑，所以周五主要涨地产公司（还在破产估值，现在往不会破产的预期修复，但是并没有敢预期房地产行业复苏）。</p>\r\n<p>短期对场内资金而言，现在属于利好兑现，可能不少场内资金还要跑，但是对场外资金而言，现在是实质性利好出台，至于到底会不会复苏，核心的分歧就在于，这次刺激力度到底够不够，有非常乐观，觉得转向了，一定成功，也有跟我这样，比较乐观，但是觉得还需要数据验证的，也有比较悲观觉得短炒一把就可以了的，也有非常悲观，觉得利好出尽，该撤了的。</p>\r\n<p>所以短期估计市场还会分歧，但是必须重视M1和地产销售数据以及房价变化，一旦市场得到数据验证，那么分歧就消除了，复苏线的趋势性行情就开始了。</p>\r\n<p>接着讲港股，你可以看到，从上个月底开始我就逐步让港股的篇幅超过日股了，一方面博弈的因素越来越有利于港股，不利于日股，一方面基本面上港股也确实有变化。</p>\r\n<p>本周港股又有几个变化，第一，腾讯财报超预期，之前我们分析腾讯的时候特意提了腾讯大幅增加回购，很大概率就是赚钱不再是原罪了，不用防止资本无序扩张了，现在资本扩张是中国拥抱改革开放路线不动摇的证明，而腾讯赚钱可能就是中国资本市场的脊梁，只要定调变了，腾讯这样的企业放利润是很容易的。</p>\r\n<p>第二个，美国数据比预期好，全世界开始重新RISK\r\nON，如果没有房地产利好的话，港股不再稀缺。今年其实港股科技股有不少一直在涨，但是直到美股开始大跌，港股才被重视，因为之前全世界都在涨，港股并不出众，反而有各种不确定性，但是伴随美股下跌，全世界risk\r\noff，港股就特别耀眼了，而伴随全世界重新risk\r\non，本来港股应该就不稀缺了，反而大家要重新开始考虑，港股估值低到底是真的便宜，还是对政策的不确定性的补偿？</p>\r\n<p>但是，第三，房地产政策转向了，这就又不一样了，房地产政策转向了，就相当于港股里的和中国大陆宏观经济相关的行业都面临基本面拐点了，不但估值极其便宜，而且大概率现在是拐点，于是恒生科技不再稀缺，但是恒生指数可能就很有弹性了，A50就更有弹性了（A50主要权重是银行，保险，白酒，地产，说白了就是地产相关）。所以接下去估计港股还会上，但是未必是恒生科技领涨，很可能是A50和恒生指数更强。毕竟20x的腾讯真不一定比23x的meta香，要涨估计也要涨估值更低的那些，否则一比价，我就愿意卖腾讯买meta了（未来cagr会远高于腾讯）。</p>\r\n<p>然后日经，日元之前说过了，除非证明美国经济真的冷却下来了，否则日元大概率还是会贬值，而日经的权重，几乎都是出口为主的企业，所以现在日经基本上完全是跟着美国经济走，美国经济强，日元贬值，利好这些公司股价，美国经济弱，日元升值，这些公司股价就利空，至于日本内需，至少目前还没看到明显复苏。所以目前日经看起来并没有特别高的性价比，确定性也不如美股。</p>\r\n<p>最后美股，本周POWELL接受采访的时候强调，因为现在看到就业基本上恢复平衡，所以他坚持认为通胀会下来，这其实就类似2021年了，2021年通胀也是不断上升，但是powell一直强调通胀是暂时的。但是有2个区别，第一个就是2021年最终证明美联储是错的，所以最终美股跌了，第二个就是2021年初拥挤的是小盘股，而现在拥挤的是大盘股。所以这波小盘股涨得很好，而大盘股远远跑输，典型就是SPX跑赢fang指数，这还是苹果和谷歌大涨的情况下，如果去掉苹果和谷歌，fang指数的涨幅更小。我们可以看一下fang或者SOXX就明白了，fang里面涨最好的是之前基本面最差的特斯拉，苹果，谷歌，其他之前基本面好的大科技NFLX,UBER都是大跌，而之前财报不佳的SNAP,Pinterest都是大涨，即使是duol，PLTR之类财报小幅beat一样大跌。然后半导体里，需求最好的AI相关标的都还没新高，而之前基本面比较差的TXN和QCOM这波最猛。（因为没预期，所以超预期以后特别猛）说明这波市场就是资金从拥挤品种里流向新的不拥挤的有改善的品种。</p>\r\n<p>因为POWELL这么讲话，所以实际上就是类似2021年，通胀数据实际上无所谓了，即使略超预期也可以说没有证据证明现在是在再通胀，我们只是需要时间等通胀下来，何况本周的PPI和CPI都是4个月来第一次符合预期，PPI虽然表观超预期，但是主要是因为上个月大幅下修了，所以环比变高了，但是也并没有超预期。同时零售数据也比预期差，也说明经济在放缓，然后我看彭博说历史上加州失业率一直领先全美失业率，现在加州失业率又是上升比较快，所以预期之后失业率还会上升。看powell这个讲话，今年他更在意的应该是就业，而不是短期通胀，只要通胀没有大幅超预期，那么就业平衡是关键，一旦失衡，比如就业过热就会担心再通胀，或者就业过冷就会担心衰退。所以接下来美股最大的风险或许不是再通胀，而是万一失业率持续上升引发衰退。</p>\r\n<p>但是市场不会YY，我们复盘2021年就知道了，无论当时通胀多高，美联储说我不加息，市场就会信不加息，直到美联储改口，现在也是一样，除非有数据证明明显衰退，或者美联储改口说我可能加息，否则市场就会相信软着陆，然后按照软着陆的路线去选股，也就是利率见顶，但是不会大幅下降，沿着业绩改善路线去选不拥挤的品种。所以这次很多二线业绩改善股暴涨。这个趋势大概率还会延续，这个趋势改变有几个可能，第一，这些股大涨之后估值没空间了，和别的板块之间的股价强弱对比发生改变，第二，经济明显出问题了，或者美联储改口可能加息了。</p>\r\n<p>然后本周short\r\ncover的逼空非常疯狂，大概率告一段落了，几个中概能不能继续逼空我不知道，中概比GME更持续之前我们也预期过，只不过我没想到FF能这么疯狂……太牛逼了，又错过了几个亿，这种反正我也无法判断。</p>\r\n<p>所以接下来大概率是全世界RISK\r\nON,A股可能短期有分歧，但是一旦数据验证成功那么就是真正牛市起点，美股继续延续现在的风格一段时间再说，港股很大概率还有超额收益，但是大概率领涨的是宏观相关的板块，而不再是科技。</p>\r\n","tags":["西湖醋鱼"]},{"title":"三季度基本宏观图表分析和展望","url":"/2024/06/10/36/","content":"<p>眼下大宗商品的最核心相关宏观图表，必须首先研究美元和中长期美债。</p>\r\n<p>第一点就是≥年的超长级别来说，美元目前的超长期下降趋势并未改变，因为大结构上，164-78-121-70这个下降结构并没有被破坏掉，而且本轮美元指数反弹在离121还有明显距离时就遭遇了很明显强有力的回调。这可不是一般回调，是直接破坏了周K多头完美结构的回调，而且回调中五次击穿103关键位，可见美元上方121方向的压力位非常强大。</p>\r\n<p>这也是直接反映出外汇市场对于美国的货币紧缩周期预期并不持久和强大，虽然本轮美元多头趋势已经超过了90-02这一波，但肯定远远不如八十年代那一波。原因也不复杂，高企的联邦公共债务以及仍在扩大的经常账户逆差，一定是压制美元多头的。</p>\r\n<p>现在市场对此也很纠结，右侧又走出了一个日K小多头结构，但是公道的说，美元上攻难度远大于下破。</p>\r\n<p>跌破99就肯定开启一大波空头趋势。而上攻挑战114或121，难度都很大。跌破99的话，第一目标马上可以看低到92附近。但还有一种情况要考虑，就是美元指数确实没有实力上攻114-121，但空头也不足以在短期内将它真正砸到103以下。在99-106.7这个区间内持续相当一段时间再去抉择方向。</p>\r\n<p>这种推测可能具有现实参考意义。\r\n因为美债的走势是有指示的。拿十年期美债的主力合约来举例的话，今年初的美债收益率回撤根本就挑战不了去年四月份的位置。美债价格筑底，收益率见顶，看来不是见容易的事情，甚至在年K来看不能完全排除今年还有价格新低收益率新高的可能性。假设它们能摆脱底部这个下降区间之后再去酝酿，至少也还要2-3个月时间吧。\r\n所以，在图表上，我们对于与美元指数高度负相关市场的最好预期就是在三季度尾声会有很大的多头机会。</p>\r\n<p>对贵金属市场和铜来说是第二波机会。拿银子和黄金距离，多头趋势并没有走完，我个人判断后面还有更大的主升浪幅度，尤其白银相对明显。</p>\r\n<p>我们把这三个相关系数非常高的关键图表指标合起来评估。美刀→偏弱横盘，超大格局是空头，季度级别是多头，目前卡在99-107区间横盘。贵金属→超大多头趋势暂时修整。争议较小。美债→收益率高位收敛，季月周K美债价格空头趋势保持完整，目前日K出现一个微弱反弹（收益率下降）</p>\r\n<p>总结一下就是，二季度末和三季度前期肯定没有特别高潮，特别激烈的事情。大体上我们倾向于判断美刀最终选择方向是向下！但是需要时间。贵金属需要时间修整，美元需要时间向下确认越过99，美债需要时间至少破坏周K完美空头趋势。可见在1-2个月时间内，我们是很难马上见到全球美元流动性全面改善以及大宗商品通胀第二波降临的。（但我个人主观看好化工板块的大宗）。美元指数大概率往下走，全球美元流动性大概率改善，但不是立刻，而是需要两三个月或两个季度。</p>\r\n<p>确立了这一个基本格局观点之后，下一步是什么呢？我们继续补充可以确认的大格局基本观点。</p>\r\n<p>比如中国国债的走势，这个其实很一目了然，我都不用放图表了，因为它是个傻子都能看出来的超级多头。意味着中国的流动性是充裕的。即使美元的利率走到了目前这个水平，即使在新加坡和香港仔那边吸引了无数资金去搞美元存款，仍然无法阻止中国推进结构性宽松的决心。我们不搞什么美国收割中国收割不动，或者中国过段时间就顶不住了，人民币会大贬值这种愚蠢的阴谋论话语。大家要明白一个基本点，中国是目前全球最强大的全产业链，中低端制造业霸主，并且在少部分高端制造业已经挤进去了。而目前世界上的大规模热点冲突地区全都远离中国，并且中国不制裁，不明确站队哪一边。中国没有得罪任何主要资源输出国，目前在输入性通胀层面对欧美日等存在明显优势。远离全球热点冲突的中立强工业国，是绝不可能被美元加息这种简单到不能再简单的货币工具给搞到受不了的。</p>\r\n<p>至于很多公知喜闻乐见的脱钩，我就说一事情，俄国人在2014年开始全面谋划和美欧脱钩，并且开始抛售美元计价债券，购入大量黄金。到2022年，它们都还没有脱干净。面对经济规模与全球经济关联度远超俄罗斯的中国，这个脱钩需要的时间，同样会远远超过俄国。我之前说过的今天再重复一次，在很长一段时间内，人民币的贬值绝对是可控的，有序的。</p>\r\n<p>实际上宏观分析来说，绝大部分内容都指向于有利A股。A股的主要敌人其实很简单，一个是自身的改革不够快不够好，第二个就是各种无风险收益率。在以前，A股总是败给国内的各种隐性刚兑带来的超高无风险收益率。目前看呢，国内这方面开始全面退潮了，但很遗憾美元存款和美元理财产品的无风险收益率又崛起了，还捎带一个对冲贬值额外收益，这两年两边一加，实际无风险收益率几乎可以追到8个点，对A股形成了很沉重的压制。所以随着时间的推移，一旦美元中期多头趋势的预期被打破，那么就意味着美元理财产品和美元存款的无风险收益率中的汇率收益开始逆转。如果它再持续降息，那基础无风险收益率也会下降。到时候将会有大量资金回流人民币资产。A股自然就会水涨船高。</p>\r\n<p>那说到最后，形成对决的指数是什么呢？A股的拦路虎其实变成了全球能源和农产品走势。因为中国持续推进结构性宽松是确定的，但美国降息是不确定的。这里面原因无非是中国输入性通胀对美国来说有优势，但是一方宽松一方紧缩会造成无风险收益率差异性虹吸。美国降息的根本关键就是通胀，绝对不是什么狗屁美元潮汐收割（当然也能收割到一点印花税和手续费，服务费，但是并不是至关重要的），那不过是一些外行的意淫。</p>\r\n<p>原油板块并不算强。短期内也看不出走强趋势。农产品指数两年来非常疲软，是否筑底了目前还无法确认。</p>\r\n<p>我觉得农产品和能源的趋势对美帝的通胀短期内不构成很强的威胁，现在可能更多是它的薪资螺旋惯性在维持通胀粘性。至少在图表来说，美联储即便先降息一次，也绝对有1-2个季度的充足时间来围观大宗农副产品和能源的走势。只要中国不陷入周边热冲突的话，一旦美元指数走上空头预期，应该是会迎来一波热钱回流的。</p>\r\n<p>有的人可能会说，中国不动产债务不是有N多问题解决不了吗？话是这么说没错啦，但中国金融系统的防火墙和欧美那一套不一样。而且这不影响投机性热钱回流这种事，它们不看那么长期的问题，更关注汇率的稳定性和无风险收益率的变化，以及投机情绪的发展。</p>\r\n<p>所以最后我们要看看大A自身股指的走势。上证指数，空头压制过于标准，标准到让我怀疑。</p>\r\n<p>上证50，看好转势已经在酝酿中。沪深300，其实我也看好底部已经出来了，正在酝酿底部转势。\r\n创业板疑似也到底了，但形态远不如两个大蓝筹指数走得好，不过下个季度可是创业板这两年下跌的第十三个季度哦。不仅是创业板，科创板，深证，中证系列指数，走的都不如沪深三百和上证50\r\n。你会发现像科创板50的指数走势，它周K并没有走出好的多头结构。而上证50则是不仅走出了周K多头结构，而且走出了明确破坏下降通道，回踩不跌破回去的意思。所以A股这次还得老大哥带头冲，引动整个市场的势能，才会带动起自身热度，吸引外部投机者，尤其是新一代的，没怎么经历过过去几次泡沫的那种。指数期货这次50和300的日K笔画调整完，我是打算进入的。</p>\r\n<p>至于做什么板块，我个人比较倾向于电力，因为铜。铜的这轮价格暴走，是跟全球到处都在扩大规划中的数据中心深度相关的。而中国肯定不能够允许自己在这轮AI工业竞赛中落后，这事关生产秩序和效率的究极进步，需要海量的电源，海量的铜。所以我说电、机、证路线。先电（油运和集装箱货柜运输的海运行情结束后），一定是最稳妥的。机场还得看地缘矛盾是否缓解。至于证券，你们等春江水暖鸭先知的人带动了散户的初步投机热情之后才能去收割。</p>\r\n","tags":["永乐大帝明成祖"]},{"title":"输出斐波拉契数列前20项","url":"/2022/12/12/9/","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">DATAS SEGMENT</span><br><span class=\"line\"> VAL    DW 20 DUP(0)</span><br><span class=\"line\">DATAS ENDS</span><br><span class=\"line\">STACKS SEGMENT</span><br><span class=\"line\"> DW 30 DUP(0)</span><br><span class=\"line\">STACKS ENDS</span><br><span class=\"line\">CODES SEGMENT</span><br><span class=\"line\">    ASSUME CS:CODES,DS:DATAS,SS:DATAS</span><br><span class=\"line\">START:</span><br><span class=\"line\">    MOV AX,DATAS</span><br><span class=\"line\">    MOV DS,AX</span><br><span class=\"line\">    MOV AX,STACKS</span><br><span class=\"line\">    MOV SS,AX</span><br><span class=\"line\">    MOV DI,0</span><br><span class=\"line\">    MOV AX,1</span><br><span class=\"line\">    MOV DX,1</span><br><span class=\"line\">    JMP FIBO</span><br><span class=\"line\">    </span><br><span class=\"line\">FIBO:   MOV VAL[DI],AX</span><br><span class=\"line\">\t\tADD DI,2</span><br><span class=\"line\">\t\tMOV VAL[DI],DX</span><br><span class=\"line\">\t\tADD DI,2</span><br><span class=\"line\">\t\tADD AX,DX</span><br><span class=\"line\">\t\tADD DX,AX</span><br><span class=\"line\">\t\tCMP DI,40</span><br><span class=\"line\">\t\tJAE  BACK</span><br><span class=\"line\">\t\tCALL FIBO</span><br><span class=\"line\">\t\tRET</span><br><span class=\"line\">\t  </span><br><span class=\"line\">BACK:   </span><br><span class=\"line\">  MOV DI,0</span><br><span class=\"line\">   MOV CX,20</span><br><span class=\"line\">   MOV DX,0</span><br><span class=\"line\">   </span><br><span class=\"line\">L1:    </span><br><span class=\"line\">        MOV AX,VAL[DI]</span><br><span class=\"line\">  ADD DI,2</span><br><span class=\"line\">  CMP AX,1000</span><br><span class=\"line\">  JNB P1</span><br><span class=\"line\">  CMP AX,100</span><br><span class=\"line\">  JNB P2</span><br><span class=\"line\">  CMP AX,10</span><br><span class=\"line\">  JNB P3</span><br><span class=\"line\">  CMP AX,1</span><br><span class=\"line\">  JNB P4</span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">P1:  MOV BX,1000</span><br><span class=\"line\">  DIV BX</span><br><span class=\"line\">  PUSH DX</span><br><span class=\"line\">  MOV DX,AX</span><br><span class=\"line\">  ADD DL,30H</span><br><span class=\"line\">  MOV AH,2H</span><br><span class=\"line\">  INT 21H</span><br><span class=\"line\">  POP AX</span><br><span class=\"line\">  MOV DX,0</span><br><span class=\"line\">  </span><br><span class=\"line\">P2:  MOV BX,100</span><br><span class=\"line\">  DIV BX</span><br><span class=\"line\">  PUSH DX</span><br><span class=\"line\">  MOV DX,AX</span><br><span class=\"line\">  ADD DL,30H</span><br><span class=\"line\">  MOV AH,2H</span><br><span class=\"line\">  INT 21H</span><br><span class=\"line\">  POP AX</span><br><span class=\"line\">  MOV DX,0</span><br><span class=\"line\">  </span><br><span class=\"line\">P3:     MOV BX,10</span><br><span class=\"line\">  DIV BX</span><br><span class=\"line\">  PUSH DX</span><br><span class=\"line\">  MOV DX,AX</span><br><span class=\"line\">  ADD DL,30H</span><br><span class=\"line\">  MOV AH,2H</span><br><span class=\"line\">  INT 21H</span><br><span class=\"line\">  POP AX</span><br><span class=\"line\">  MOV DX,0</span><br><span class=\"line\">  </span><br><span class=\"line\">P4:    </span><br><span class=\"line\">        MOV BX,1</span><br><span class=\"line\">  DIV BX</span><br><span class=\"line\">  PUSH DX</span><br><span class=\"line\">  MOV DX,AX</span><br><span class=\"line\">  ADD DL,30H</span><br><span class=\"line\">  MOV AH,2H</span><br><span class=\"line\">  INT 21H</span><br><span class=\"line\">  POP AX</span><br><span class=\"line\">  </span><br><span class=\"line\">  MOV DL,32</span><br><span class=\"line\">  MOV AH,2H</span><br><span class=\"line\">  INT 21H</span><br><span class=\"line\">  MOV DX,0</span><br><span class=\"line\">  LOOP L1</span><br><span class=\"line\">  </span><br><span class=\"line\">  MOV AX,4C00H</span><br><span class=\"line\">  INT 21H</span><br><span class=\"line\">CODES ENDS</span><br><span class=\"line\">    END START</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n","tags":["汇编"]},{"title":"学生信息管理系统","url":"/2022/12/11/4/","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include&lt;iostream&gt;</span><br><span class=\"line\">#include&lt;string&gt;</span><br><span class=\"line\">#include&lt;vector&gt;</span><br><span class=\"line\">#include&lt;windows.h&gt;</span><br><span class=\"line\">#include&lt;algorithm&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">class student</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    string s_name;</span><br><span class=\"line\">    int s_id = 0;</span><br><span class=\"line\">    int y_score = 0;//语文成绩</span><br><span class=\"line\">    int s_score = 0;//数学成绩</span><br><span class=\"line\">    int e_score = 0;//英语成绩</span><br><span class=\"line\">    int s_total = 0;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;student&gt; v;</span><br><span class=\"line\">vector&lt;student&gt;z;</span><br><span class=\"line\"></span><br><span class=\"line\">void showmenu()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;*******************************&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;欢迎来到学生管理系统&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;请选择您的操作&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;1.添加学生&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;2.输出学生列表&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;3.对成绩进行排序&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;4.根据学号查找学生信息&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;输入其他字符退出程序&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;*******************************&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void showstudent(vector&lt;student&gt;&amp; a)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (vector&lt;student&gt;::iterator it = a.begin(); it != a.end(); it++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; (*it).s_name &lt;&lt; &quot;\\t学号：&quot; &lt;&lt; (*it).s_id &lt;&lt; &quot;\\t语文成绩：&quot; &lt;&lt; (*it).y_score &lt;&lt; &quot;\\t数学成绩：&quot; &lt;&lt; (*it).s_score &lt;&lt; &quot;\\t英语成绩：&quot; &lt;&lt; (*it).e_score &lt;&lt; &quot;\\t总成绩：&quot; &lt;&lt; (*it).s_total &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void showstudent1(vector&lt;student&gt;&amp; a)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i = 1;</span><br><span class=\"line\">    for (vector&lt;student&gt;::iterator it = a.begin(); it != a.end(); it++, i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;第&quot; &lt;&lt; i &lt;&lt; &quot;名： 姓名：&quot; &lt;&lt; (*it).s_name &lt;&lt; &quot;\\t学号：&quot; &lt;&lt; (*it).s_id &lt;&lt; &quot;\\t语文成绩：&quot; &lt;&lt; (*it).y_score &lt;&lt; &quot;\\t数学成绩：&quot; &lt;&lt; (*it).s_score &lt;&lt; &quot;\\t英语成绩：&quot; &lt;&lt; (*it).e_score &lt;&lt; &quot;\\t总成绩：&quot; &lt;&lt; (*it).s_total &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bool comp(const student&amp; a, const student&amp; b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return a.s_total &gt; b.s_total;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    while (true)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    aaa:</span><br><span class=\"line\">        showmenu();</span><br><span class=\"line\">        int a;</span><br><span class=\"line\">        cin &gt;&gt; a;</span><br><span class=\"line\">        system(&quot;cls&quot;);</span><br><span class=\"line\">        switch (a)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        case 1:</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            student stu;</span><br><span class=\"line\">            cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; endl;</span><br><span class=\"line\">            cin &gt;&gt; stu.s_name;</span><br><span class=\"line\">            cout &lt;&lt; &quot;学生号：&quot; &lt;&lt; endl;</span><br><span class=\"line\">            cin &gt;&gt; stu.s_id;</span><br><span class=\"line\">            cout &lt;&lt; &quot;语文成绩&quot; &lt;&lt; endl;</span><br><span class=\"line\">            cin &gt;&gt; stu.y_score;</span><br><span class=\"line\">            cout &lt;&lt; &quot;数学成绩&quot; &lt;&lt; endl;</span><br><span class=\"line\">            cin &gt;&gt; stu.s_score;</span><br><span class=\"line\">            cout &lt;&lt; &quot;英语成绩&quot; &lt;&lt; endl;</span><br><span class=\"line\">            cin &gt;&gt; stu.e_score;</span><br><span class=\"line\">            stu.s_total = stu.y_score + stu.s_score + stu.e_score;</span><br><span class=\"line\">            v.push_back(stu);</span><br><span class=\"line\">            cout &lt;&lt; &quot;添加成功！&quot; &lt;&lt; endl;</span><br><span class=\"line\">            Sleep(1000);</span><br><span class=\"line\">            system(&quot;cls&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        case 2:</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            showstudent(v);</span><br><span class=\"line\">            system(&quot;pause&quot;);</span><br><span class=\"line\">            system(&quot;cls&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        case 3:</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            z = v;</span><br><span class=\"line\">            sort(z.begin(), z.end(), comp);</span><br><span class=\"line\">            showstudent1(z);</span><br><span class=\"line\">            system(&quot;pause&quot;);</span><br><span class=\"line\">            system(&quot;cls&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        case 4:</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            int id;</span><br><span class=\"line\">            cout &lt;&lt; &quot;请输入学生id号：&quot; &lt;&lt; endl;</span><br><span class=\"line\">            cin &gt;&gt; id;</span><br><span class=\"line\">            for (vector&lt;student&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                if ((*it).s_id == id)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    cout &lt;&lt; &quot;查找成功 学生信息如下：&quot; &lt;&lt; endl;</span><br><span class=\"line\">                    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; (*it).s_name &lt;&lt; &quot;\\t学号：&quot; &lt;&lt; (*it).s_id &lt;&lt; &quot;\\t语文成绩：&quot; &lt;&lt; (*it).y_score &lt;&lt; &quot;\\t数学成绩：&quot; &lt;&lt; (*it).s_score &lt;&lt; &quot;\\t英语成绩：&quot; &lt;&lt; (*it).e_score &lt;&lt; &quot;\\t总成绩：&quot; &lt;&lt; (*it).s_total &lt;&lt; endl;</span><br><span class=\"line\">                    system(&quot;pause&quot;);</span><br><span class=\"line\">                    system(&quot;cls&quot;);</span><br><span class=\"line\">                    goto aaa;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cout &lt;&lt; &quot;查无此人！&quot; &lt;&lt; endl;</span><br><span class=\"line\">            system(&quot;pause&quot;);</span><br><span class=\"line\">            system(&quot;cls&quot;);</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            goto bbb;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">bbb:</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n","tags":["C++"]},{"title":"航班信息管理系统","url":"/2022/12/12/7/","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string&gt;   </span><br><span class=\"line\">#include &lt;iomanip&gt;   </span><br><span class=\"line\">#include &lt;fstream&gt; </span><br><span class=\"line\">#include &lt;random&gt; </span><br><span class=\"line\">#include &lt;ctime&gt;   </span><br><span class=\"line\">#include &lt;windows.h&gt; </span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct flightnode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstring flight_num;       //航班号</span><br><span class=\"line\">\tstring time;             //起飞时间</span><br><span class=\"line\">\tint date = 0;            //起飞日期</span><br><span class=\"line\">\tstring start_place;      //出发地</span><br><span class=\"line\">\tstring end_place;        //目的地</span><br><span class=\"line\">\tfloat discount = 0;      //折扣</span><br><span class=\"line\">\tint left = 0;            //余票</span><br><span class=\"line\">\tfloat price = 0;         //价格</span><br><span class=\"line\">\tflightnode* next = NULL;</span><br><span class=\"line\">&#125;*flightlist;</span><br><span class=\"line\"></span><br><span class=\"line\">struct ticket</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstring flight_num;\t  //航班号</span><br><span class=\"line\">\tstring time;\t\t  //起飞时间</span><br><span class=\"line\">\tstring start_place;\t  //出发地</span><br><span class=\"line\">\tstring end_place;     //目的地</span><br><span class=\"line\">\tfloat price = 0;      //价格</span><br><span class=\"line\">\tint date = 0;         //起飞日期</span><br><span class=\"line\">\tstring order_num;\t  //订单编号</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct passengernode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstring name;        //名字</span><br><span class=\"line\">\tstring ID_num;      //证件号</span><br><span class=\"line\">\tticket ticket;      //票</span><br><span class=\"line\">\tint full = 0;       //预约标志  1表示预约状态</span><br><span class=\"line\">\tpassengernode* next = NULL;</span><br><span class=\"line\">&#125;*passengerlist;</span><br><span class=\"line\"></span><br><span class=\"line\">//航班类信息</span><br><span class=\"line\">void Init_flight(flightlist&amp; h);\t\t//初始化航班</span><br><span class=\"line\">void Load_flight(flightlist&amp; h);\t\t//载入航班</span><br><span class=\"line\">void Add_flight(flightlist&amp; h);\t\t\t//添加航班</span><br><span class=\"line\">void Check_flight(flightlist&amp; h);\t\t//查找航班</span><br><span class=\"line\">void Check_flightnum(flightlist&amp; h);\t//航班号查找</span><br><span class=\"line\">void Check_seplace(flightlist&amp; h);\t\t//起始地查找</span><br><span class=\"line\">void Check_all(flightlist&amp; h);\t\t\t//浏览全部航班</span><br><span class=\"line\">void Revise_flight(flightlist&amp; h);\t\t//修改航班信息</span><br><span class=\"line\">void Delete_flight(flightlist&amp; h);\t\t//删除航班</span><br><span class=\"line\">void Revise_time(flightlist&amp; h);\t\t//修改起飞抵达时间</span><br><span class=\"line\">void Revise_price(flightlist&amp; h);\t\t//修改价格</span><br><span class=\"line\">void Save_flight(flightlist&amp; h);\t\t//保存航班信息</span><br><span class=\"line\">//用户信息</span><br><span class=\"line\">void Init_passenger(passengerlist&amp; c);\t\t\t//初始化用户</span><br><span class=\"line\">void Load_passenger(passengerlist&amp; c);\t\t\t//载入用户信息</span><br><span class=\"line\">void Book(flightlist&amp; h, passengerlist&amp; c);\t\t//定票</span><br><span class=\"line\">void Qbook(flightlist&amp; h, passengerlist&amp; c);\t//退票</span><br><span class=\"line\">void Check_book(passengerlist&amp; c);\t\t\t\t//查询订单</span><br><span class=\"line\">void Save_passenger(passengerlist&amp; c);\t\t\t//保存用户信息</span><br><span class=\"line\">//管理操作</span><br><span class=\"line\">void manage(flightlist&amp; flight, passengerlist&amp; passenger);</span><br><span class=\"line\">void password();//密码管理</span><br><span class=\"line\">//通用</span><br><span class=\"line\">void wait();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">void manage(flightlist&amp; flight, passengerlist&amp; passenger)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\twhile (1) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;航班信息管理系统&quot; &lt;&lt; endl &lt;&lt; endl;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;主菜单&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;1.录入航班信息&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;2.查询航班&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;3.订票&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;4.退票&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;5.查询订单&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;6.修改航班信息&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;0.退出系统 &quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;请输入您想要进行的功能：&quot;;</span><br><span class=\"line\">\t\tint i;</span><br><span class=\"line\">\t\tcin &gt;&gt; i;</span><br><span class=\"line\">\t\tsystem(&quot;cls&quot;);</span><br><span class=\"line\">\t\tswitch (i) &#123;</span><br><span class=\"line\">\t\tcase 1:Add_flight(flight); Save_flight(flight); wait(); break;</span><br><span class=\"line\">\t\tcase 2:Check_flight(flight); wait(); break;</span><br><span class=\"line\">\t\tcase 3:Book(flight, passenger); Save_flight(flight); Save_passenger(passenger); wait(); break;</span><br><span class=\"line\">\t\tcase 4:Qbook(flight, passenger); Save_flight(flight); Save_passenger(passenger); wait(); break;</span><br><span class=\"line\">\t\tcase 5:Check_book(passenger); wait(); break;</span><br><span class=\"line\">\t\tcase 6:Revise_flight(flight); Save_flight(flight); wait(); break;</span><br><span class=\"line\">\t\tcase 0:exit(0); break;</span><br><span class=\"line\">\t\tdefault:cout &lt;&lt; &quot;请检查你的输入！&quot; &lt;&lt; endl; break;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Sort_flight(flightlist&amp; h)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tflightlist p = h-&gt;next;  //指向第一个结点</span><br><span class=\"line\">\twhile (p != NULL) &#123;</span><br><span class=\"line\">\t\tflightlist q = h-&gt;next;   //指向p后一个结点</span><br><span class=\"line\">\t\twhile (q) &#123;</span><br><span class=\"line\">\t\t\tif (q-&gt;date &gt; p-&gt;date) &#123;</span><br><span class=\"line\">\t\t\t\tflightnode temp = *p;   //临时保存指针交换</span><br><span class=\"line\">\t\t\t\ttemp.next = q-&gt;next;</span><br><span class=\"line\">\t\t\t\tq-&gt;next = p-&gt;next;</span><br><span class=\"line\">\t\t\t\t*p = *q;</span><br><span class=\"line\">\t\t\t\t*q = temp;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tq = q-&gt;next;   //指针移动</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tp = p-&gt;next;    //指针移动</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Init_flight(flightlist&amp; h)//初始化航班</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\th = new flightnode;  //头指针</span><br><span class=\"line\">\th-&gt;next = NULL;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Load_flight(flightlist&amp; h)//载入航班</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tflightlist f = h;</span><br><span class=\"line\">\tflightlist newp = new flightnode;</span><br><span class=\"line\">\tifstream ifs(&quot;FlightList.txt&quot;);</span><br><span class=\"line\">\tif (!ifs.is_open()) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;文件未被打开！&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile (ifs &gt;&gt; newp-&gt;flight_num &gt;&gt; newp-&gt;date &gt;&gt; newp-&gt;time &gt;&gt; newp-&gt;start_place &gt;&gt; newp-&gt;end_place &gt;&gt; newp-&gt;price &gt;&gt; newp-&gt;discount &gt;&gt; newp-&gt;left) &#123;</span><br><span class=\"line\">\t\tf-&gt;next = newp;</span><br><span class=\"line\">\t\tf = f-&gt;next;</span><br><span class=\"line\">\t\tnewp = new flightnode;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tf-&gt;next = NULL;</span><br><span class=\"line\">\tdelete newp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Add_flight(flightlist&amp; h)//添加航班</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tchar mark = &#x27;y&#x27;;</span><br><span class=\"line\">\tflightlist s, rear;</span><br><span class=\"line\">\tfor (rear = h; rear-&gt;next != NULL; rear = rear-&gt;next) &#123;&#125;  // rear移动结点尾</span><br><span class=\"line\">\twhile (mark == &#x27;y&#x27; || mark == &#x27;Y&#x27;) &#123;</span><br><span class=\"line\">\t\ts = new flightnode;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;请输入航班号：&quot;;</span><br><span class=\"line\">\t\tcin &gt;&gt; s-&gt;flight_num;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;请输入起飞日期：&quot;;</span><br><span class=\"line\">\t\tcin &gt;&gt; s-&gt;date;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;请输入起飞时间：&quot;;</span><br><span class=\"line\">\t\tcin &gt;&gt; s-&gt;time;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;请输入出发地：&quot;;</span><br><span class=\"line\">\t\tcin &gt;&gt; s-&gt;start_place;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;请输入目的地：&quot;;</span><br><span class=\"line\">\t\tcin &gt;&gt; s-&gt;end_place;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;请输入价格：&quot;;</span><br><span class=\"line\">\t\tcin &gt;&gt; s-&gt;price;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;请输入折扣：&quot;;</span><br><span class=\"line\">\t\tcin &gt;&gt; s-&gt;discount;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;请输入余票：&quot;;</span><br><span class=\"line\">\t\tcin &gt;&gt; s-&gt;left;</span><br><span class=\"line\">\t\trear-&gt;next = s;</span><br><span class=\"line\">\t\trear = s;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;添加成功！&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;是否继续添加？（是“y”/否“n”）：&quot;;</span><br><span class=\"line\">\t\tcin &gt;&gt; mark;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\trear-&gt;next = NULL;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Check_flight(flightlist&amp; h)//查找航班</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;查找方式&quot; &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;1.航班查找&quot; &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;2.起始地查找&quot; &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;3.浏览全部航班&quot; &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;请输入查找方式：&quot;;</span><br><span class=\"line\">\tcin &gt;&gt; i;</span><br><span class=\"line\">\tswitch (i) &#123;</span><br><span class=\"line\">\tcase 1:Check_flightnum(h); break;</span><br><span class=\"line\">\tcase 2:Check_seplace(h); break;</span><br><span class=\"line\">\tcase 3:Check_all(h); break;</span><br><span class=\"line\">\tdefault:break;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Check_flightnum(flightlist&amp; h)//航班号查找</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstring flightnum;</span><br><span class=\"line\">\tflightlist p = h-&gt;next;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;请输入航班号：&quot;;</span><br><span class=\"line\">\tcin &gt;&gt; flightnum;</span><br><span class=\"line\">\tcout &lt;&lt; setw(6) &lt;&lt; &quot;航班号&quot; &lt;&lt; setw(17) &lt;&lt; &quot;起飞日期&quot; &lt;&lt; setw(15) &lt;&lt; &quot;起飞时间&quot; &lt;&lt; setw(15) &lt;&lt; &quot;出发地&quot; &lt;&lt; setw(15) &lt;&lt; &quot;目的地&quot; &lt;&lt; setw(15) &lt;&lt; &quot;价格&quot; &lt;&lt; setw(15) &lt;&lt; &quot;折扣&quot; &lt;&lt; setw(15) &lt;&lt; &quot;余票&quot; &lt;&lt; endl;</span><br><span class=\"line\">\twhile (p != NULL) &#123;</span><br><span class=\"line\">\t\tif (p-&gt;flight_num == flightnum) &#123;</span><br><span class=\"line\">\t\t\tcout &lt;&lt; setw(6) &lt;&lt; p-&gt;flight_num &lt;&lt; setw(15) &lt;&lt; p-&gt;date &lt;&lt; &quot;日&quot; &lt;&lt; setw(15) &lt;&lt; p-&gt;time &lt;&lt; setw(15) &lt;&lt; p-&gt;start_place &lt;&lt; setw(15) &lt;&lt; p-&gt;end_place &lt;&lt; setw(15) &lt;&lt; p-&gt;price &lt;&lt; setw(15) &lt;&lt; p-&gt;discount &lt;&lt; setw(15) &lt;&lt; p-&gt;left &lt;&lt; endl;</span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\tp = p-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt; setw(32) &lt;&lt; &quot;未查到任何信息。&quot;;</span><br><span class=\"line\">\twait();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Check_seplace(flightlist&amp; h)//起始地查找</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstring start_place, end_place;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;请输入出发地：&quot;;</span><br><span class=\"line\">\tcin &gt;&gt; start_place;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;请输入目的地：&quot;;</span><br><span class=\"line\">\tcin &gt;&gt; end_place;</span><br><span class=\"line\">\tflightlist p = h-&gt;next;</span><br><span class=\"line\">\tcout &lt;&lt; setw(6) &lt;&lt; &quot;航班号&quot; &lt;&lt; setw(17) &lt;&lt; &quot;起飞日期&quot; &lt;&lt; setw(15) &lt;&lt; &quot;起飞时间&quot; &lt;&lt; setw(15) &lt;&lt; &quot;出发地&quot; &lt;&lt; setw(15) &lt;&lt; &quot;目的地&quot; &lt;&lt; setw(15) &lt;&lt; &quot;价格&quot; &lt;&lt; setw(15) &lt;&lt; &quot;折扣&quot; &lt;&lt; setw(15) &lt;&lt; &quot;余票&quot; &lt;&lt; endl;</span><br><span class=\"line\">\twhile (p != NULL) &#123;</span><br><span class=\"line\">\t\tif (p-&gt;start_place == start_place &amp;&amp; p-&gt;end_place == end_place) &#123;</span><br><span class=\"line\">\t\t\tcout &lt;&lt; setw(6) &lt;&lt; p-&gt;flight_num &lt;&lt; setw(15) &lt;&lt; p-&gt;date &lt;&lt; &quot;号&quot; &lt;&lt; setw(15) &lt;&lt; p-&gt;time &lt;&lt; setw(15) &lt;&lt; p-&gt;start_place &lt;&lt; setw(15) &lt;&lt; p-&gt;end_place &lt;&lt; setw(15) &lt;&lt; p-&gt;price &lt;&lt; setw(15) &lt;&lt; p-&gt;discount &lt;&lt; setw(15) &lt;&lt; p-&gt;left &lt;&lt; endl;</span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tp = p-&gt;next;        //移动</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;未查到任何信息&quot; &lt;&lt; endl;</span><br><span class=\"line\">\twait();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Check_all(flightlist&amp; h)//浏览全部航班</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tSort_flight(h);  //日期排序</span><br><span class=\"line\">\tflightlist p = h-&gt;next;</span><br><span class=\"line\">\tcout &lt;&lt; setw(6) &lt;&lt; &quot;航班号&quot; &lt;&lt; setw(17) &lt;&lt; &quot;起飞日期&quot; &lt;&lt; setw(15) &lt;&lt; &quot;起飞时间&quot; &lt;&lt; setw(15) &lt;&lt; &quot;出发地&quot; &lt;&lt; setw(15) &lt;&lt; &quot;目的地&quot; &lt;&lt; setw(15) &lt;&lt; &quot;价格&quot; &lt;&lt; setw(15) &lt;&lt; &quot;折扣&quot; &lt;&lt; setw(15) &lt;&lt; &quot;余票&quot; &lt;&lt; endl;</span><br><span class=\"line\">\twhile (p != NULL)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; setw(6) &lt;&lt; p-&gt;flight_num &lt;&lt; setw(15) &lt;&lt; p-&gt;date &lt;&lt; &quot;号&quot; &lt;&lt; setw(15) &lt;&lt; p-&gt;time &lt;&lt; setw(15) &lt;&lt; p-&gt;start_place &lt;&lt; setw(15) &lt;&lt; p-&gt;end_place &lt;&lt; setw(15) &lt;&lt; p-&gt;price &lt;&lt; setw(15) &lt;&lt; p-&gt;discount &lt;&lt; setw(15) &lt;&lt; p-&gt;left &lt;&lt; endl;</span><br><span class=\"line\">\t\tp = p-&gt;next;   //移动</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Revise_flight(flightlist&amp; h)//修改航班信息</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tflightlist f = h-&gt;next;</span><br><span class=\"line\">\tint i;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;修改内容:&quot; &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;1.删除航班&quot; &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;2.修改起飞时间&quot; &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;3.修改航班价格&quot; &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;4.返回&quot; &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;请输入查找方式：&quot;;</span><br><span class=\"line\">\tcin &gt;&gt; i;</span><br><span class=\"line\">\tCheck_all(h);     //浏览全部</span><br><span class=\"line\">\tswitch (i) &#123;</span><br><span class=\"line\">\tcase 1:Delete_flight(h); break;</span><br><span class=\"line\">\tcase 2:Revise_time(h); break;</span><br><span class=\"line\">\tcase 3:Revise_price(h); break;</span><br><span class=\"line\">\tcase 4:return; break;</span><br><span class=\"line\">\tdefault:cout &lt;&lt; &quot;请检查你的输入！&quot; &lt;&lt; endl; break;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Delete_flight(flightlist&amp; h)//删除航班</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tflightlist p = h-&gt;next, q = h;  //q是p的前驱</span><br><span class=\"line\">\tstring flightnum;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;请输入您想要修改的航班号：&quot;;</span><br><span class=\"line\">\tcin &gt;&gt; flightnum;</span><br><span class=\"line\">\twhile (p != NULL) &#123;</span><br><span class=\"line\">\t\tif (p-&gt;flight_num == flightnum) &#123;</span><br><span class=\"line\">\t\t\tq-&gt;next = p-&gt;next;      //p是要删除的结点，q是前一个结点</span><br><span class=\"line\">\t\t\tdelete p;</span><br><span class=\"line\">\t\t\tcout &lt;&lt; &quot;删除成功！&quot;;</span><br><span class=\"line\">\t\t\twait();</span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tq = q-&gt;next;</span><br><span class=\"line\">\t\tp = q-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;未查找到相关航班！&quot;;</span><br><span class=\"line\">\twait();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Revise_time(flightlist&amp; h)//修改起飞抵达时间</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstring flightnum;</span><br><span class=\"line\">\tflightlist p = h-&gt;next;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;请输入您想要修改的航班号：&quot;;</span><br><span class=\"line\">\tcin &gt;&gt; flightnum;</span><br><span class=\"line\">\twhile (p != NULL) &#123;</span><br><span class=\"line\">\t\tif (p-&gt;flight_num == flightnum) &#123;</span><br><span class=\"line\">\t\t\tcout &lt;&lt; &quot;请输入新的起飞日期：&quot;;</span><br><span class=\"line\">\t\t\tcin &gt;&gt; p-&gt;date;</span><br><span class=\"line\">\t\t\tcout &lt;&lt; &quot;请输入新的起飞时间：&quot;;</span><br><span class=\"line\">\t\t\tcin &gt;&gt; p-&gt;time;</span><br><span class=\"line\">\t\t\tcout &lt;&lt; &quot;修改成功！&quot;;</span><br><span class=\"line\">\t\t\twait();</span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tp = p-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;没有您想要修改的航班号!&quot;;</span><br><span class=\"line\">\twait();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Revise_price(flightlist&amp; h)//修改价格</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstring flightnum;</span><br><span class=\"line\">\tflightlist p = h-&gt;next;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;请输入您想要修改的航班号：&quot;;</span><br><span class=\"line\">\tcin &gt;&gt; flightnum;</span><br><span class=\"line\">\twhile (p != NULL) &#123;</span><br><span class=\"line\">\t\tif (p-&gt;flight_num == flightnum) &#123;</span><br><span class=\"line\">\t\t\tcout &lt;&lt; &quot;请输入新的价格：&quot;;</span><br><span class=\"line\">\t\t\tcin &gt;&gt; p-&gt;price;</span><br><span class=\"line\">\t\t\tcout &lt;&lt; &quot;请输入新的折扣：&quot;;</span><br><span class=\"line\">\t\t\tcin &gt;&gt; p-&gt;discount;</span><br><span class=\"line\">\t\t\tcout &lt;&lt; &quot;修改成功！\t&quot;;</span><br><span class=\"line\">\t\t\twait();</span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tp = p-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;没有您想要修改的航班号!&quot;;</span><br><span class=\"line\">\twait();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Save_flight(flightlist&amp; h)//保存航班信息</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tflightlist f = h-&gt;next;</span><br><span class=\"line\">\tSort_flight(h);</span><br><span class=\"line\">\tofstream ofs(&quot;FlightList.txt&quot;);</span><br><span class=\"line\">\tif (!ofs)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;存储失败！&quot;;</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile (f != NULL)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tofs &lt;&lt; f-&gt;flight_num &lt;&lt; &quot; &quot; &lt;&lt; f-&gt;date &lt;&lt; &quot; &quot; &lt;&lt; f-&gt;time &lt;&lt; &quot; &quot; &lt;&lt; f-&gt;start_place &lt;&lt; &quot; &quot; &lt;&lt; f-&gt;end_place &lt;&lt; &quot; &quot; &lt;&lt; f-&gt;price &lt;&lt; &quot; &quot; &lt;&lt; f-&gt;discount &lt;&lt; &quot; &quot; &lt;&lt; f-&gt;left &lt;&lt; endl;</span><br><span class=\"line\">\t\tf = f-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tofs.close();   //关闭文件</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Init_passenger(passengerlist&amp; c)//初始化用户</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tc = new passengernode;   //头结点</span><br><span class=\"line\">\tc-&gt;next = NULL;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Load_passenger(passengerlist&amp; c)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tpassengerlist p = c;</span><br><span class=\"line\">\tpassengerlist newp = new passengernode;</span><br><span class=\"line\">\tifstream ifs(&quot;PassengerList.txt&quot;);</span><br><span class=\"line\">\tif (!ifs.is_open()) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;文件未被打开！&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;数据读取成功！&quot; &lt;&lt; endl;</span><br><span class=\"line\">\tsystem(&quot;cls&quot;);</span><br><span class=\"line\">\twhile (ifs &gt;&gt; newp-&gt;name &gt;&gt; newp-&gt;ID_num &gt;&gt; newp-&gt;ticket.flight_num &gt;&gt; newp-&gt;ticket.date &gt;&gt; newp-&gt;ticket.time &gt;&gt; newp-&gt;ticket.start_place &gt;&gt; newp-&gt;ticket.end_place &gt;&gt; newp-&gt;ticket.price &gt;&gt; newp-&gt;ticket.order_num)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tp-&gt;next = newp;</span><br><span class=\"line\">\t\tp = p-&gt;next;</span><br><span class=\"line\">\t\tnewp = new passengernode;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tp-&gt;next = NULL;</span><br><span class=\"line\">\tdelete newp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Book(flightlist&amp; h, passengerlist&amp; c)//订票</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstring start_place, end_place, flightnum;</span><br><span class=\"line\">\tint date;//航班信息</span><br><span class=\"line\">\tflightlist p = h-&gt;next, q = h-&gt;next;</span><br><span class=\"line\">\tpassengerlist s, r = c;</span><br><span class=\"line\">\tchar mark, check = &#x27;1&#x27;;</span><br><span class=\"line\">\tchar mark02 = &#x27;1&#x27;;         //标志</span><br><span class=\"line\">\tfor (; r-&gt;next != NULL; r = r-&gt;next) &#123;&#125;   //r移动到结点尾</span><br><span class=\"line\">\ts = new passengernode;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;请输入乘客的姓名：&quot;;</span><br><span class=\"line\">\tcin &gt;&gt; s-&gt;name;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;请输入乘客的证件号：&quot;;</span><br><span class=\"line\">\tcin &gt;&gt; s-&gt;ID_num;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;请输入出发地：&quot;;</span><br><span class=\"line\">\tcin &gt;&gt; start_place;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;请输入目的地：&quot;;</span><br><span class=\"line\">\tcin &gt;&gt; end_place;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;请选择出发日期：&quot;;</span><br><span class=\"line\">\tcin &gt;&gt; date;</span><br><span class=\"line\">\tcout &lt;&lt; setw(6) &lt;&lt; &quot;航班号&quot; &lt;&lt; setw(17) &lt;&lt; &quot;起飞日期&quot; &lt;&lt; setw(15) &lt;&lt; &quot;起飞时间&quot; &lt;&lt; setw(15) &lt;&lt; &quot;出发地&quot; &lt;&lt; setw(15) &lt;&lt; &quot;目的地&quot; &lt;&lt; setw(15) &lt;&lt; &quot;价格&quot; &lt;&lt; setw(15) &lt;&lt; &quot;折扣&quot; &lt;&lt; setw(15) &lt;&lt; &quot;余票&quot; &lt;&lt; endl;</span><br><span class=\"line\">\twhile (p != NULL)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif (p-&gt;start_place == start_place &amp;&amp; p-&gt;end_place == end_place &amp;&amp; p-&gt;date == date)//匹配日期相符的航班</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tcout &lt;&lt; setw(6) &lt;&lt; p-&gt;flight_num &lt;&lt; setw(15) &lt;&lt; p-&gt;date &lt;&lt; &quot;号&quot; &lt;&lt; setw(15) &lt;&lt; p-&gt;time &lt;&lt; setw(15) &lt;&lt; p-&gt;start_place &lt;&lt; setw(15) &lt;&lt; p-&gt;end_place &lt;&lt; setw(15) &lt;&lt; p-&gt;price &lt;&lt; setw(15) &lt;&lt; p-&gt;discount &lt;&lt; setw(15) &lt;&lt; p-&gt;left &lt;&lt; endl;</span><br><span class=\"line\">\t\t\tcheck = &#x27;0&#x27;;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tp = p-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif (check == &#x27;1&#x27;) &#123;</span><br><span class=\"line\">\t\tp = h-&gt;next;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;无&quot; &lt;&lt; setw(15) &lt;&lt; &quot;无&quot; &lt;&lt; setw(17) &lt;&lt; &quot;无&quot; &lt;&lt; setw(15) &lt;&lt; &quot;无&quot; &lt;&lt; setw(15) &lt;&lt; &quot;无&quot; &lt;&lt; setw(15) &lt;&lt; &quot;无&quot; &lt;&lt; setw(15) &lt;&lt; &quot;无&quot; &lt;&lt; setw(15) &lt;&lt; &quot;无&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;该天没相关的航班&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\tif (mark02 == &#x27;1&#x27;)</span><br><span class=\"line\">\t\t\treturn;//结束</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;是否进行购买？（Y/N）&quot;;</span><br><span class=\"line\">\tcin &gt;&gt; mark;</span><br><span class=\"line\">\tif (mark == &#x27;y&#x27; || mark == &#x27;Y&#x27;) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;请输入您想要购买的航班号：&quot;;</span><br><span class=\"line\">\t\tcin &gt;&gt; flightnum;</span><br><span class=\"line\">\t\twhile (q != NULL) &#123;</span><br><span class=\"line\">\t\t\tif (q-&gt;flight_num == flightnum &amp;&amp; q-&gt;start_place == start_place &amp;&amp; q-&gt;end_place == end_place) &#123;</span><br><span class=\"line\">\t\t\t\tif (q-&gt;left == 0) &#123;</span><br><span class=\"line\">\t\t\t\t\tcout &lt;&lt; &quot;余票不足，请选择是否预约（Y/N）&quot;;</span><br><span class=\"line\">\t\t\t\t\tcin &gt;&gt; mark;</span><br><span class=\"line\">\t\t\t\t\tif (mark == &#x27;y&#x27; || mark == &#x27;Y&#x27;) &#123;</span><br><span class=\"line\">\t\t\t\t\t\ts-&gt;full = 1;  //修改预约标志</span><br><span class=\"line\">\t\t\t\t\t\ts-&gt;ticket.flight_num = flightnum;</span><br><span class=\"line\">\t\t\t\t\t\ts-&gt;ticket.start_place = start_place;</span><br><span class=\"line\">\t\t\t\t\t\ts-&gt;ticket.end_place = end_place;</span><br><span class=\"line\">\t\t\t\t\t\ts-&gt;ticket.time = &quot;预约&quot;;</span><br><span class=\"line\">\t\t\t\t\t\ts-&gt;ticket.price = 000;</span><br><span class=\"line\">\t\t\t\t\t\ts-&gt;ticket.date = date;</span><br><span class=\"line\">\t\t\t\t\t\ts-&gt;ticket.order_num = &quot;预约&quot;;</span><br><span class=\"line\">\t\t\t\t\t\tcout &lt;&lt; &quot; 预约成功&quot;;</span><br><span class=\"line\">\t\t\t\t\t\tr-&gt;next = s;</span><br><span class=\"line\">\t\t\t\t\t\tr = s;</span><br><span class=\"line\">\t\t\t\t\t\tr-&gt;next = NULL;</span><br><span class=\"line\">\t\t\t\t\t\twait();</span><br><span class=\"line\">\t\t\t\t\t\treturn;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\telse</span><br><span class=\"line\">\t\t\t\t\t\treturn;  //不预约直接结束</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\ts-&gt;ticket.flight_num = flightnum;</span><br><span class=\"line\">\t\t\t\ts-&gt;ticket.start_place = start_place;</span><br><span class=\"line\">\t\t\t\ts-&gt;ticket.end_place = end_place;</span><br><span class=\"line\">\t\t\t\ts-&gt;ticket.time = q-&gt;time;</span><br><span class=\"line\">\t\t\t\ts-&gt;ticket.price = q-&gt;price;</span><br><span class=\"line\">\t\t\t\ts-&gt;ticket.date = q-&gt;date;</span><br><span class=\"line\">\t\t\t\tsrand((unsigned int)time(0));</span><br><span class=\"line\">\t\t\t\ts-&gt;ticket.order_num = q-&gt;flight_num + to_string(rand()) + to_string(rand());//订单编号</span><br><span class=\"line\">\t\t\t\tr-&gt;next = s;</span><br><span class=\"line\">\t\t\t\tr = s;</span><br><span class=\"line\">\t\t\t\tr-&gt;next = NULL;</span><br><span class=\"line\">\t\t\t\tcout &lt;&lt; &quot;购票成功！&quot; &lt;&lt; &quot;订单号为&quot; + s-&gt;ticket.order_num &lt;&lt; endl;</span><br><span class=\"line\">\t\t\t\tq-&gt;left--;</span><br><span class=\"line\">\t\t\t\treturn;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\telse</span><br><span class=\"line\">\t\t\t\tq = q-&gt;next;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;航班号填入错误！&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\twait();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\telse &#123;</span><br><span class=\"line\">\t\treturn;//不进行购买直接结束</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Qbook(flightlist&amp; h, passengerlist&amp; c)//退票</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstring name, ID_num;</span><br><span class=\"line\">\tbool mark = false;</span><br><span class=\"line\">\tflightlist f = h-&gt;next;</span><br><span class=\"line\">\tpassengerlist p = c-&gt;next, q = c, t = c-&gt;next;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;请输入乘客的姓名：&quot;;</span><br><span class=\"line\">\tcin &gt;&gt; name;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;请输入乘客的证件号：&quot;;</span><br><span class=\"line\">\tcin &gt;&gt; ID_num;</span><br><span class=\"line\">\twhile (p != NULL) &#123;</span><br><span class=\"line\">\t\tif (p-&gt;name == name &amp;&amp; p-&gt;ID_num == ID_num) &#123;</span><br><span class=\"line\">\t\t\tmark = true;   //找到乘客</span><br><span class=\"line\">\t\t\twhile (f != NULL) &#123;</span><br><span class=\"line\">\t\t\t\tif (p-&gt;ticket.flight_num == f-&gt;flight_num) &#123;</span><br><span class=\"line\">\t\t\t\t\tf-&gt;left++;  //票数更新</span><br><span class=\"line\">\t\t\t\t\twhile (t != NULL) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tif (t-&gt;ticket.flight_num == p-&gt;ticket.flight_num &amp;&amp; t-&gt;full == 1) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t\tt-&gt;ticket.start_place = p-&gt;ticket.start_place;</span><br><span class=\"line\">\t\t\t\t\t\t\tt-&gt;ticket.end_place = p-&gt;ticket.end_place;</span><br><span class=\"line\">\t\t\t\t\t\t\tt-&gt;ticket.time = p-&gt;ticket.time;</span><br><span class=\"line\">\t\t\t\t\t\t\tt-&gt;ticket.price = p-&gt;ticket.price;</span><br><span class=\"line\">\t\t\t\t\t\t\tt-&gt;ticket.date = p-&gt;ticket.date;</span><br><span class=\"line\">\t\t\t\t\t\t\tsrand((unsigned int)time(0));</span><br><span class=\"line\">\t\t\t\t\t\t\tt-&gt;ticket.order_num = p-&gt;ticket.flight_num.c_str() + to_string(rand()) + to_string(rand());</span><br><span class=\"line\">\t\t\t\t\t\t\tf-&gt;left--;</span><br><span class=\"line\">\t\t\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\tt = t-&gt;next;</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tf = f-&gt;next;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tq-&gt;next = p-&gt;next;</span><br><span class=\"line\">\t\t\tdelete p;</span><br><span class=\"line\">\t\t\tcout &lt;&lt; &quot;退票成功！&quot;;</span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tq = q-&gt;next;</span><br><span class=\"line\">\t\tp = q-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif (!mark) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;未找到相关乘客的订单&quot;;</span><br><span class=\"line\">\t\twait();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Check_book(passengerlist&amp; c)//查询订票</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tstring name, ID_num;</span><br><span class=\"line\">\tpassengerlist p = c-&gt;next;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;请输入乘客的姓名：&quot;;</span><br><span class=\"line\">\tcin &gt;&gt; name;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;请输入乘客的证件号：&quot;;</span><br><span class=\"line\">\tcin &gt;&gt; ID_num;</span><br><span class=\"line\">\tcout &lt;&lt; setw(8) &lt;&lt; &quot;姓名&quot; &lt;&lt; setw(15) &lt;&lt; &quot;航班号&quot; &lt;&lt; setw(17) &lt;&lt; &quot;起飞日期&quot; &lt;&lt; setw(15) &lt;&lt; &quot;起飞时间&quot; &lt;&lt; setw(15) &lt;&lt; &quot;出发地&quot; &lt;&lt; setw(15) &lt;&lt; &quot;目的地&quot; &lt;&lt; setw(15) &lt;&lt; &quot;价格&quot; &lt;&lt; setw(18) &lt;&lt; &quot;订单编号&quot; &lt;&lt; endl;</span><br><span class=\"line\">\twhile (p != NULL) &#123;</span><br><span class=\"line\">\t\tif (p-&gt;name == name &amp;&amp; p-&gt;ID_num == ID_num) &#123;</span><br><span class=\"line\">\t\t\tcout &lt;&lt; setw(8) &lt;&lt; p-&gt;name &lt;&lt; setw(15) &lt;&lt; p-&gt;ticket.flight_num &lt;&lt; setw(15) &lt;&lt; p-&gt;ticket.date &lt;&lt; &quot;号&quot; &lt;&lt; setw(15) &lt;&lt; p-&gt;ticket.time &lt;&lt; setw(15) &lt;&lt; p-&gt;ticket.start_place &lt;&lt; setw(15) &lt;&lt; p-&gt;ticket.end_place &lt;&lt; setw(15) &lt;&lt; p-&gt;ticket.price &lt;&lt; setw(18) &lt;&lt; p-&gt;ticket.order_num &lt;&lt; endl;</span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\tp = p-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcout &lt;&lt; setw(32) &lt;&lt; &quot;未查到任何信息。&quot;;</span><br><span class=\"line\">\twait();</span><br><span class=\"line\">\treturn;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Save_passenger(passengerlist&amp; c)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tpassengerlist p = c-&gt;next;</span><br><span class=\"line\">\tofstream ofs(&quot;PassengerList.txt&quot;);</span><br><span class=\"line\">\tif (!ofs) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;存储失败！&quot;;</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twhile (p != NULL) &#123;</span><br><span class=\"line\">\t\tofs &lt;&lt; p-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;ID_num &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;ticket.flight_num &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;ticket.date &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;ticket.time &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;ticket.start_place &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;ticket.end_place &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;ticket.price &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;ticket.order_num &lt;&lt; endl;</span><br><span class=\"line\">\t\tp = p-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tofs.close();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void wait() &#123;</span><br><span class=\"line\">\tint a = getchar();</span><br><span class=\"line\">\ta = getchar();</span><br><span class=\"line\">\tsystem(&quot;cls&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tflightlist flight;</span><br><span class=\"line\">\tpassengerlist passenger;</span><br><span class=\"line\">\tInit_passenger(passenger); //初始用户信息</span><br><span class=\"line\">\tLoad_passenger(passenger); //载入用户信息</span><br><span class=\"line\">\tInit_flight(flight);       //初始化航班</span><br><span class=\"line\">\tLoad_flight(flight);       //载入航班</span><br><span class=\"line\">\tmanage(flight, passenger); //封装管理函数</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n","tags":["C++"]},{"title":"输出斐波拉契数列前50项","url":"/2022/12/12/8/","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">DATAS SEGMENT</span><br><span class=\"line\">\tDW 200 DUP(0)</span><br><span class=\"line\">   </span><br><span class=\"line\">DATAS ENDS</span><br><span class=\"line\"></span><br><span class=\"line\">STACKS SEGMENT</span><br><span class=\"line\">    DW 30 DUP(0)</span><br><span class=\"line\">STACKS ENDS</span><br><span class=\"line\"></span><br><span class=\"line\">CODES SEGMENT</span><br><span class=\"line\">    ASSUME CS:CODES,DS:DATAS,SS:STACKS</span><br><span class=\"line\">START:</span><br><span class=\"line\">\t.386</span><br><span class=\"line\">\tMOV AX,DATAS</span><br><span class=\"line\">\tMOV DS,AX</span><br><span class=\"line\">\tMOV AX,STACKS</span><br><span class=\"line\">\tMOV SS,AX</span><br><span class=\"line\">\tMOV SI,0</span><br><span class=\"line\">\tMOV DI,0 </span><br><span class=\"line\">\tMOV EAX,1</span><br><span class=\"line\">\tMOV EDX,0</span><br><span class=\"line\">\tJMP PRINT11</span><br><span class=\"line\">A:</span><br><span class=\"line\">\tCALL FIBO</span><br><span class=\"line\"></span><br><span class=\"line\">FIBO:</span><br><span class=\"line\">\tCMP DI,392</span><br><span class=\"line\">\tJE BACK</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tCMP DI,0\t</span><br><span class=\"line\">\tJE SET1</span><br><span class=\"line\"></span><br><span class=\"line\">SET1BACK:</span><br><span class=\"line\">\tCMP DI,8</span><br><span class=\"line\">\tJE SET2</span><br><span class=\"line\"></span><br><span class=\"line\">SET2BACK:</span><br><span class=\"line\">\tADD DI,8</span><br><span class=\"line\">\tMOV EAX,DS:[DI-8]</span><br><span class=\"line\">\tMOV EDX,DS:[DI-4]</span><br><span class=\"line\">\tMOV ECX,DS:[DI-12]</span><br><span class=\"line\">\tMOV EBX,DS:[DI-16]</span><br><span class=\"line\">\tADD EAX,EBX</span><br><span class=\"line\">\tADC EDX,ECX</span><br><span class=\"line\">\tMOV DS:[DI],EAX</span><br><span class=\"line\">\tMOV DS:[DI+4],EDX</span><br><span class=\"line\">\tCALL PRINT</span><br><span class=\"line\"></span><br><span class=\"line\">PRINTBACK:\t</span><br><span class=\"line\">\tCALL FIBO</span><br><span class=\"line\">\t</span><br><span class=\"line\">;==================================================</span><br><span class=\"line\">SET1:</span><br><span class=\"line\">\tMOV DS:[0],EAX</span><br><span class=\"line\">\tMOV DS:[4],EDX</span><br><span class=\"line\">\tADD DI,8</span><br><span class=\"line\">\tJMP SET1BACK</span><br><span class=\"line\">;==================================================</span><br><span class=\"line\">SET2:</span><br><span class=\"line\">\tMOV DS:[8],EAX</span><br><span class=\"line\">\tMOV DS:[12],EDX</span><br><span class=\"line\">\tJMP SET2BACK</span><br><span class=\"line\">;==================================================\t</span><br><span class=\"line\"></span><br><span class=\"line\">;PRINT EDX EAX</span><br><span class=\"line\">PRINT:</span><br><span class=\"line\">\tPUSH EAX</span><br><span class=\"line\">\tPUSH EBX</span><br><span class=\"line\">\tPUSH ECX</span><br><span class=\"line\">\tPUSH EDX</span><br><span class=\"line\">\tCMP EDX,10B</span><br><span class=\"line\">\tJNB P1</span><br><span class=\"line\">\tCMP EDX,0</span><br><span class=\"line\">\tJA  P2</span><br><span class=\"line\">\tCMP EAX,1000000000</span><br><span class=\"line\">\tJNB P2</span><br><span class=\"line\">\tCMP EAX,100000000</span><br><span class=\"line\">\tJNB P3</span><br><span class=\"line\">\tCMP EAX,10000000</span><br><span class=\"line\">\tJNB P4</span><br><span class=\"line\">\tCMP EAX,1000000</span><br><span class=\"line\">\tJNB P5</span><br><span class=\"line\">\tCMP EAX,100000</span><br><span class=\"line\">\tJNB P6</span><br><span class=\"line\">\tCMP EAX,10000</span><br><span class=\"line\">\tJNB P7</span><br><span class=\"line\">\tCMP EAX,1000</span><br><span class=\"line\">\tJNB P8</span><br><span class=\"line\">\tCMP EAX,100</span><br><span class=\"line\">\tJNB P9</span><br><span class=\"line\">\tCMP EAX,10</span><br><span class=\"line\">\tJNB P10</span><br><span class=\"line\">\tCMP EAX,1</span><br><span class=\"line\">\tJNB P11</span><br><span class=\"line\"></span><br><span class=\"line\">P1:</span><br><span class=\"line\">\tMOV DL,1</span><br><span class=\"line\">\tADD DL,30H</span><br><span class=\"line\">\tMOV AH,2H</span><br><span class=\"line\">\tINT 21H</span><br><span class=\"line\">\tMOV EAX,10011010001001110101010101100001B</span><br><span class=\"line\">\tMOV EDX,0</span><br><span class=\"line\"></span><br><span class=\"line\">P2:</span><br><span class=\"line\">\tMOV EBX,1000000000</span><br><span class=\"line\">\tDIV EBX</span><br><span class=\"line\">\tPUSH EDX</span><br><span class=\"line\">\tMOV EDX,EAX</span><br><span class=\"line\">\tADD DL,30H</span><br><span class=\"line\">\tMOV AH,2H</span><br><span class=\"line\">\tINT 21H</span><br><span class=\"line\">\tPOP EAX</span><br><span class=\"line\">\tMOV EDX,0</span><br><span class=\"line\"></span><br><span class=\"line\">P3:</span><br><span class=\"line\">\tMOV EBX,100000000</span><br><span class=\"line\">\tDIV EBX</span><br><span class=\"line\">\tPUSH EDX</span><br><span class=\"line\">\tMOV EDX,EAX</span><br><span class=\"line\">\tADD DL,30H</span><br><span class=\"line\">\tMOV AH,2H</span><br><span class=\"line\">\tINT 21H</span><br><span class=\"line\">\tPOP EAX</span><br><span class=\"line\">\tMOV EDX,0</span><br><span class=\"line\"></span><br><span class=\"line\">P4:</span><br><span class=\"line\">\tMOV EBX,10000000</span><br><span class=\"line\">\tDIV EBX</span><br><span class=\"line\">\tPUSH EDX</span><br><span class=\"line\">\tMOV EDX,EAX</span><br><span class=\"line\">\tADD DL,30H</span><br><span class=\"line\">\tMOV AH,2H</span><br><span class=\"line\">\tINT 21H</span><br><span class=\"line\">\tPOP EAX</span><br><span class=\"line\">\tMOV EDX,0</span><br><span class=\"line\"></span><br><span class=\"line\">P5:</span><br><span class=\"line\">\tMOV EBX,1000000</span><br><span class=\"line\">\tDIV EBX</span><br><span class=\"line\">\tPUSH EDX</span><br><span class=\"line\">\tMOV EDX,EAX</span><br><span class=\"line\">\tADD DL,30H</span><br><span class=\"line\">\tMOV AH,2H</span><br><span class=\"line\">\tINT 21H</span><br><span class=\"line\">\tPOP EAX</span><br><span class=\"line\">\tMOV EDX,0</span><br><span class=\"line\"></span><br><span class=\"line\">P6:</span><br><span class=\"line\">\tMOV EBX,100000</span><br><span class=\"line\">\tDIV EBX</span><br><span class=\"line\">\tPUSH EDX</span><br><span class=\"line\">\tMOV EDX,EAX</span><br><span class=\"line\">\tADD DL,30H</span><br><span class=\"line\">\tMOV AH,2H</span><br><span class=\"line\">\tINT 21H</span><br><span class=\"line\">\tPOP EAX</span><br><span class=\"line\">\tMOV EDX,0</span><br><span class=\"line\"></span><br><span class=\"line\">P7:</span><br><span class=\"line\">\tMOV EBX,10000</span><br><span class=\"line\">\tDIV EBX</span><br><span class=\"line\">\tPUSH EDX</span><br><span class=\"line\">\tMOV EDX,EAX</span><br><span class=\"line\">\tADD DL,30H</span><br><span class=\"line\">\tMOV AH,2H</span><br><span class=\"line\">\tINT 21H</span><br><span class=\"line\">\tPOP EAX</span><br><span class=\"line\">\tMOV EDX,0</span><br><span class=\"line\"></span><br><span class=\"line\">P8:</span><br><span class=\"line\">\tMOV EBX,1000</span><br><span class=\"line\">\tDIV EBX</span><br><span class=\"line\">\tPUSH EDX</span><br><span class=\"line\">\tMOV EDX,EAX</span><br><span class=\"line\">\tADD DL,30H</span><br><span class=\"line\">\tMOV AH,2H</span><br><span class=\"line\">\tINT 21H</span><br><span class=\"line\">\tPOP EAX</span><br><span class=\"line\">\tMOV EDX,0</span><br><span class=\"line\"></span><br><span class=\"line\">P9:</span><br><span class=\"line\">\tMOV EBX,100</span><br><span class=\"line\">\tDIV EBX</span><br><span class=\"line\">\tPUSH EDX</span><br><span class=\"line\">\tMOV EDX,EAX</span><br><span class=\"line\">\tADD DL,30H</span><br><span class=\"line\">\tMOV AH,2H</span><br><span class=\"line\">\tINT 21H</span><br><span class=\"line\">\tPOP EAX</span><br><span class=\"line\">\tMOV EDX,0</span><br><span class=\"line\"></span><br><span class=\"line\">P10:</span><br><span class=\"line\">\tMOV EBX,10</span><br><span class=\"line\">\tDIV EBX</span><br><span class=\"line\">\tPUSH EDX</span><br><span class=\"line\">\tMOV EDX,EAX</span><br><span class=\"line\">\tADD DL,30H</span><br><span class=\"line\">\tMOV AH,2H</span><br><span class=\"line\">\tINT 21H</span><br><span class=\"line\">\tPOP EAX</span><br><span class=\"line\">\tMOV EDX,0\t</span><br><span class=\"line\"></span><br><span class=\"line\">P11:</span><br><span class=\"line\">\tMOV EBX,1</span><br><span class=\"line\">\tDIV EBX</span><br><span class=\"line\">\tPUSH EDX</span><br><span class=\"line\">\tMOV EDX,EAX</span><br><span class=\"line\">\tADD DL,30H</span><br><span class=\"line\">\tMOV AH,2H</span><br><span class=\"line\">\tINT 21H</span><br><span class=\"line\">\tPOP EAX</span><br><span class=\"line\">\tMOV EDX,0</span><br><span class=\"line\">\tMOV DL,32</span><br><span class=\"line\">\tMOV AH,2H</span><br><span class=\"line\">\tINT 21H</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPOP EDX</span><br><span class=\"line\">\tPOP ECX</span><br><span class=\"line\">\tPOP EBX</span><br><span class=\"line\">\tPOP EAX</span><br><span class=\"line\">\tJMP PRINTBACK</span><br><span class=\"line\">;PRINT END</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">;PRINT11</span><br><span class=\"line\">PRINT11:</span><br><span class=\"line\">\tPUSH EDX</span><br><span class=\"line\">\tPUSH EAX</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tMOV DL,1</span><br><span class=\"line\">\tADD DL,30H</span><br><span class=\"line\">\tMOV AH,2H</span><br><span class=\"line\">\tINT 21H</span><br><span class=\"line\">\tMOV DL,32</span><br><span class=\"line\">\tMOV AH,2H</span><br><span class=\"line\">\tINT 21H</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tMOV DL,1</span><br><span class=\"line\">\tADD DL,30H</span><br><span class=\"line\">\tMOV AH,2H</span><br><span class=\"line\">\tINT 21H</span><br><span class=\"line\">\tMOV DL,32</span><br><span class=\"line\">\tMOV AH,2H</span><br><span class=\"line\">\tINT 21H</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPOP EAX</span><br><span class=\"line\">\tPOP EDX</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tJMP A</span><br><span class=\"line\"></span><br><span class=\"line\">BACK:</span><br><span class=\"line\">\tMOV AX,4C00H</span><br><span class=\"line\">   \tINT 21H</span><br><span class=\"line\">CODES ENDS</span><br><span class=\"line\">    END START</span><br></pre></td></tr></table></figure>\r\n","tags":["汇编"]},{"title":"写于7月4日盘前","url":"/2024/07/04/5/","content":"<p>7月3日是下跌的，而且搞出个全年地量5802亿元。什么概念呢，年后股灾开始前的最低量是1月15号，6108亿，股灾最低点是9260亿。跟昨天相比直接缩量643.4亿。缩量意味着，持有的不想卖，套死了，能跑的全跑差不多了，剩下的都是不看的了，耐心资本了。场外的不想买，说出大天来，也没有哪个有规模的资金会像进。缩量代表着高度的一致性，多空资金没有分歧。</p>\r\n<p>但是今天不想聊这个，其他热点话题也不想聊。只想聊一个全新的话题：市场的定价权的问题。无论是戴维斯双击双杀，还是行业给几倍估值几倍PE。到最后，都得是有一个什么主体，给市场或者公司一个定价。低于这个定价，就会有一个主体，通过自身的影响力，带动资金，把价格钉到一个固定的位置。如果这个定价被市场认可，就会带来资金的跟随，冲击这个价格成功。定价不被认可，就会有其他资金把这个价格砸下来，砸的那个主体，就是实质上拥有了定价权。</p>\r\n<p>所谓多空博弈，就是不同的主体对价格的认识不同，不同价格的主体互相争夺定价权的一个过程。打个比方，猪肉价格暴涨，就是供货商在争夺定价权，把猪肉价格往上拉，是多头。消费者不买账，觉得猪肉贵了，我要吃牛羊肉，我不买猪肉。虽然猪肉价格高了，但没有接盘的，这个价格坐不住，没有成交量，回头还是会掉下来。消费者不买，就是空头，用不成交来做空。除非哪天猪肉跌到了一个价格，消费者觉得合理，比如3块钱一斤（极端一点）。那么消费者不会去考虑什么趋势不趋势的，只要肉比菜便宜，那肯定还是买肉吃。成交量就放大了，价格就又推高了。一直推高到又不会成交为止。</p>\r\n<p>猪肉的定价，从供应商的角度，会根据成本，产能，竞争对手各种方式定价从消费者的角度，就会从同类品种，比如牛羊肉价格，蔬菜价格，其他替代品的价格，去对比然后进行定价。无论哪一方，总归会有一个道理，一种估值方式，最后多空双方再博弈一下，形成一个平衡。</p>\r\n<p>我们的市场，公司，是靠什么去定价？靠谁去定价？你按照猪肉的角度去考虑问题，你会发现，这东西就没有一个能讲出来的逻辑。最后做出买卖决策的，不是价格，而是涨跌。越涨越买，只要大家看到K线总是红的，斜线向上。也别管这个价格是否合理，只要涨的时间够长，幅度够高，价格越离谱越合理。总会找到理由的。只要是跌的，也别管有没有跌穿成本价，PB，还是任何什么东西，只要下跌，就越跌越不值钱。影响大家决策的，是每天看的利好利空，是技术形态，是支撑压力，是趋势。什么都有，就是没有定价。</p>\r\n<p>以前很长一段时间，很多人讲价值投资，但是现在不讲了。因为谁也说不清什么是价值，真持仓跌下来了，那点价值投资的理论，覆盖不了自己的恐慌，趋势和价值，最后还要看趋势决策。之前讲中特估，中国特色估值，是什么？是定价。提出这个概念的人，也是想要用什么类似于算猪肉价的方式，去把这个价算出来。当然中特估现在走的也还不错。但是，谁能说清楚，中特估是怎么估的？为什么这么估？估出来最后价格到底应该是值多少？怎么判断是还没到？还是已经高估了？没人知道，大家聊中特估，做买卖决策的时候，还是把中特估当个板块看待。这个板块是强还是弱，有没有龙头，有没有资金流入。到最后，中特估没有估。</p>\r\n<p>现在市场上唯一剩下的，真正能估出来的，就是高股息。拿股息率去跟银行存款去对比。一眼就能看出来现在是高了低了。除此之外，这个市场就是一个无法估值的东西。科班出身的，会去用现金流贴现模型来估值。这个估值方式也是挺合理的。但，真的到买卖决策的时候，现金流贴现模型会给人大胆持有的勇气吗？算的结果很坚定，这种坚定能抵抗住下跌亏钱时的焦虑吗？3块钱买上10吨用不变质的猪肉，你永远会安心持有，不用担心猪肉价格回不去。就像苹果永远会落在地上一样。现金流贴现一算，算的很明白，但这公司股价万一真的回不去呢？造假了呢？不分红呢？破产了呢？除了股息率，没有任何估值方法能让你有，股价必然回去的安全感。</p>\r\n<p>现在除了高股息外，没有任何资金敢于再在哪个板块里抱团。除了散户以外，大的资金机构也都很迷茫，大家都不知道该怎么估值，这个市场已经没有一个合理的估值方法了。大机构买股票，说穿了，也不是在衡量企业价值的，也会因为各种各样估值以外的，乱七八糟的理由，去买去卖。到最后也是追涨杀跌嘛。这几天国债的价格变着法的往上涨，央行都在融券做空国债了，也挡不住大家买国债的热情。就是因为国债这个东西，是能算出来了，是可以估值的。最近半导体也哑火了，这个板块看多的逻辑也不是因为估值，是因为三期大基金嘛。还是资金博弈嘛，行情好的时候，讲个故事，给个虚头八脑的定价，大家都不懂，但是相信能涨，这个定价就定住了。行情不好，大家都抢跑，谁也拿不到这个定价权。谁的定价也没人认，所有人都是空头。</p>\r\n<p>又讲科特估，也立不住，科特估是怎么估的？按什么估的？如果这个估值真的有道理，就像3块钱一斤的猪肉一样必赚，那必然会有人不记盈亏的买入并持有呀。只是那些玄而又玄的估值方式，没人懂也没人信，大家还是只相信趋势而已。我们每天聊行情，关注的，看的都是利好利空，看GJD的动向。是拼命的想抓住点什么去解决持仓过程中的焦虑。如果真的有一种，像3块钱的猪肉一样的估值方式，那真的没必要每天关注那些海量的信息，或者说是噪音。但是，这个市场真的就没有一种合理的估值方式，永远焦虑。大家都在期盼GJD的动向，期待他去救市，想博弈他的资金。目前看，除了GJD以外，没有任何一个主体，有对公司定价的意愿了。谁也没有定价权，大家都在跟随别人，因为大家都迷茫。GJD也迷茫，他在用什么方式估值，去用什么方式定价？用市值吗？如果他不迷茫，那就拿出钱来，把认为合理的公司买上\r\n一遍，把价格钉死在他们认为合理的位置。他们会抱着一刻雀跃的心，去捡那些便宜。而不是像现在，总是被动的，不得不左拉一下右拉一下。</p>\r\n<p>为什么会这样？因为他们也不知道该如何定价，他们也不知道现在是高了还是低了，未来到底会不会大亏。连茅台这种最有价值的公司，估值的逻辑也破灭了，又有什么是价值呢？他们有那个权力去做掌握定价权的人，但是就连他们，也不知道除了银行外，还有哪些是值得的。可能在前年养老金入市时，他们也还是很坚定的，但现在，他们还能坚持那时的估值逻辑了吗？</p>\r\n<p>我记得当年学证券从业资格时，有一个知识点印象非常深刻。有效市场假说。这个知识点在我脑中转了快20年了。20年后我终于明白了，没法定价的市场，其实就是无效市场呀。</p>\r\n<p>4号还是会跌，以后也还是会跌，点位什么的都不重要。这个市场存在交易的圣杯，多因子alpha也好，趋势也好，都是可以赚钱的。</p>\r\n","tags":["无人喝彩"]},{"title":"“高（岗）饶（漱石）反党集团”是一大冤案","url":"/2024/09/08/14/","content":"<p>高岗，原名崇德，陕西横山人，生于1905年，比毛泽东小12岁。1926年加入中国共产党，在国民党西北地方部队中秘密开展兵运工作，发动武装起义，曾与刘志丹，谢干长等一起创建陕甘革命根据地和陕甘红军。1949年后任中共中央东北局书记、东北人民政府主席、东北军区司令员兼政治委员，中华人民共和国成立后任中央人民政府副主席。当时号称“东北王”。</p>\r\n<p>与刘志丹共创陕甘，参与辽沈平津战役，抗美援朝时坚持东北的物资支持，彭德怀曾说，抗美援朝胜利，有赖于两个麻子：前方是洪大麻子（洪学智），后方是高大麻子（高岗）。现代战争，打的就是后勤。朝鲜战场“不绝粮道”，高岗有大功焉。</p>\r\n<p>1952年11月高岗等各地领导被调到中央工作，时称“五马进京，一马当先”，这“一马”就是指高岗，他被任命为中央人民政府计划委员会主席并兼东北行政委员会主席，一时炙手可热。薄一波对此做了说明。《若干重大决策与事件的回顾》中介绍，毛泽东在文化大革命之前就多次表示对周恩来的不满，不仅出言相讥，甚至两度剥夺他的总理权力。薄一波1953年春组织财政部出台新税制后，因“事先没有报告中央”等原因而受到严厉批评。不久毛泽东又认为政务院犯了分散主义的错误，强调要加强中央对政府工作机关的领导。此后，经济计划工作和八个工业部由高岗负责，周恩来事实上只负责外交事务；新中国成立之后，周恩来除了总理一职，还兼任外交部长。到了1958年2月，外长一职由副总理陈毅接任。在高岗次年初受到整肃后，周恩来的总理权力才又有恢复。</p>\r\n<p>根据薄一波的回忆录可以知道，毛泽东对总理周恩来不满，计划用高岗取代周恩来。本来这场政治斗争，完全是棋逢对手的较量，甚至由于高岗有毛泽东的支持，高岗可能最终战胜周恩来，成为中华人民共和国历史上第二位总理。但毛泽东和高岗都被胜利的前景冲昏了头脑，把政治斗争扩大化，居然矛头指向了党和国家的二把手刘少奇。据公开史料记载，1953年夏秋，党中央召开全国财经工作会议期间及会后，高岗、饶漱石散布流言蜚语，破坏中央威信，攻击中央书记处刘少奇和周恩来等党和国家领导，硬说中央有宗派，到处挑拨离间。12月，高岗四处活动，要求由他担任党中央的总书记或副主席。他还要求改换政务院总理人选，由他担任总理。</p>\r\n<p>要知道刘少奇和邓小平个人关系很好，两人的政治路线也比较合拍，而周恩来面对自己即将失去的权力，自然也会向刘邓靠拢。这个时候，陈云在毛高和刘邓周之间，选择了刘邓周，笔者认为这很合乎情理，因为大势所趋，中共中央高层的力量对决中，毛泽东和高岗的计划已经失败，更何况毛泽东在暗处，真正在明处搞政治斗争的，只有高岗和饶漱石，而饶漱石在政坛作用不大，虽然毛泽东派林彪支持高岗，但在党内的力量对比，高岗已经完了。在这种情况下，陈云倒向刘邓周，高岗被彻底击垮。</p>\r\n<p>陈云这位政客，一生都在韬光养晦，最终在毛泽东去世后，逐渐在政坛掌握权力，并和李先念等左派元老联盟，加上执政初期的江泽民以及李鹏等左派政客，对邓小平、胡耀帮、赵紫阳等右派对政客进行了抵制，这才保证了中国的改革开放没有激进，没有在邓小平活着时，中国就因改革而崩溃，老年陈云的政治价值就是保证了改革的平稳进行，保障了国家和人民的太平。所以，陈云穷其一生，都在避开惊涛骇浪的政治斗争。对这一点，毛泽东看得很清楚，高岗夫人曾介绍，毛泽东警告过高岗：“陈云这个人是不可靠的，形势好了他就出来；形势不好他就有病了。”</p>\r\n<p>但高岗不相信，依然和陈云保持良好的个人关系，他哪知道，政治斗争失败时，谁也不愿意为他搭上一条命。</p>\r\n<p>当刘少奇、周恩来、邓小平、陈云等高层政客联合在一起，对高岗上纲上线进行批斗时，不仅高岗完了，而且躲在暗处的毛泽东也害怕了，不仅自己马上洗脱自己，而且叫林彪远走南方休养以避开风头，以至林彪公开警告“高可能自杀”。因为毛泽东怕被高岗连累，不仅拒绝和高岗见面，而且在批判高岗的文件中，加上了比较负面的评语，世人认为这是毛泽东落阱下石，其实只是毛泽东先洗清自己，然后再想办法帮助高岗。可高岗因绝望自杀过，导致周恩来要求软禁高岗，毛泽东不疑有诈，也认为这样可以避免让高岗再次自杀，所以同意软禁高岗。谁知这样一来，高岗受到严密监控，不仅失去了自由，消息也不灵通了，反倒是负面的批斗、谈话、交待材料等越来越重，让高岗越发绝望，终于承受不住压力自杀成功。读者们记住，这是中共建国后，周恩来第一次运用政治斗争，消灭掉一个高层政客。</p>\r\n<p>为什么笔者说是周恩来在里面起的重要作用呢？因为根据现在公开的史料记载，毛泽东根本没想过要严重处理高岗，还等待着风头一过，先让高岗到西北任省长，等待机会重新进中央。</p>\r\n<p>所以，高岗自杀的消息传到毛泽东耳中时，他仔细询问：“人死了吗？”</p>\r\n<p>当确知高岗已死时，毛泽东问：“怎么死的？”</p>\r\n<p>工作人员回答说，是吃安眠药死的，还在检查。毛泽东听后，沉默良久，说：“遗憾，终于留不住他。他这个人，斗争性太强，性格过于刚烈。”</p>\r\n<p>而据高岗夫人回忆，在北戴河，毛泽东从杭州回来，跟周恩来发脾气。后来他在政治局在十三陵开会时也说，有人想把高岗整死，灭他的口。后来在庐山会议，毛泽东说，对高岗的问题，我迟了一步，我要习仲勋（跟高岗）谈话，结果我迟了一步，结果他死了。过去叶子龙（注：毛泽东秘书）也说嘛，高岗死了以后，毛主席是一个多月显得心里沉重。</p>\r\n<p>那么习仲勋为什么没有接受毛泽东的命令，给被软禁的高岗传话呢？因为当时的高岗不仅被监控，而且每个找他谈话的人都有记录，加上当时党内中高层倒高岗之势汹涌，一直在查高岗联络的人都是谁，这足以吓倒习仲勋，因为习仲勋和高岗一样，都属于陕北根据地的创建人，一起欢迎来了党中央和中央红军；现在追查都是谁和高岗一起搞帮派活动，习仲勋要是见被监控的高岗传达毛泽东的悄悄话，那么最终结果必将是习仲勋成为“高饶反党集团”一分子。习仲勋的谨慎和政治头脑，帮助他躲过了一劫。本来这也没什么，可没想到高岗被整死了，导致毛泽东大怒，在心中给习仲勋记下了一笔，认为他在自己最困难的时候，站在了自己的对立面。</p>\r\n<p>既然毛泽东想保高岗，为什么在高岗自杀后，要给高岗扣上“反党集团”的大帽子呢？因为政治形势所迫。一位中共高层领导自杀了，人民都要问为什么，而且党和政府要给党的各级干部一个交待，要给世界一个明确的原因，总不能说高岗是被人整死的吧？！所以，面对苏联来人询问，毛泽东批评高岗变质了，因为“在革命中，他们跟着党走到一定程度，就离开了革命。高岗和饶漱石就是这样的人。”。毛泽东在1953年3月召开的中国共产党全国代表会议上发表讲话时，专门谈了高、饶的问题，其中特别提到骄傲情绪是危险的。他说：“不要逞英雄。事业是多数人做的，少数人的作用是有限的。”他告诫全党的高级干部，要“永远保持谦虚进取的精神。”</p>\r\n<p>笔者撰文写毛泽东是被迫批判高岗的，一些读者可能不相信。可是读者们只要想想，毛泽东不批判高岗，他能赞扬自杀的高岗吗？难道夸他“生得伟大，死得光荣”？更何况把高岗打成反党集团，又不是毛泽东个人的意思，面对政治压力，他只能违心地接受党中央的决议，并公开表态以和被搞臭的高岗拉开距离。史料记载，毛泽东不止一次说过“要是高岗不搞小动作我还是要重用他”、“其实我没想把高岗怎么样”。公开史料记载，在林彪摔死在温都尔汗后，成了孤家寡人的毛泽东曾当人面感叹：“要是高岗活着该多好！”</p>\r\n<p>说高岗和林彪是毛泽东的左膀右臂，有一个历史故事可以证明。当年苏联国家元首斯大林过生日时，毛泽东准备了一列车中国政府的礼物，并亲自去祝寿。可是林彪和高岗私自各准备了一列车礼物，挂在了火车尾部，算是自己给斯大林的祝寿；要知道，这是中共高层干部中谁也不敢做的事情，可林彪和高岗偏偏就做了，导致毛泽东大怒，命令“把这两节车皮的礼物卸下，一节送到林彪家，一节送到高岗家”。大家都以为毛泽东回国后，要敲打林彪和高岗两人，没想到毛泽东回国后没再提此事。可见两人在毛泽东心中的位置。实际上，高岗自杀后，被党和政府称为“反党集团”首领，但毛泽东却对高岗的家人照顾得很好，他的夫人介绍过。</p>\r\n<p>邓小平执政后，给饶漱石平反了，因为饶漱石本来就是属于起哄的角色，本以为可以趁着高岗当总理，自己也能在政坛更上一层楼，没想到错误估计了形势，一下子成了阶下囚，还把自己的家人和下属连累了。但邓小平不给高岗平反，胡耀邦做总书记时曾组织给高岗平反的小组，但被邓小平否决了，他虽然承认历史上的高岗没有反党，但强调这是党中央的决议，以这种借口拒绝给高岗平反。结果高岗的夫人到现在还在骂邓小平。为什么邓小平不给高岗平反呢？因为当年是刘邓周陈等政客给高岗下的定义，更何况回顾邓小平执政，我们就会发现，但凡毛泽东的亲信，很少有不被邓小平打倒搞臭的，邓小平知道高岗是毛泽东的亲信，也知道毛泽东怀念高岗，所以就铁了心不给高岗平反。</p>\r\n<p>在高岗夫人多年的上诉中，不仅得到了时任总书记的胡耀帮的同情，也得到了后来的总书记江泽民的同情，江泽民曾亲自指示，给高岗家人一个好的安置、一个好的待遇。实际上，曾任国务院总理的朱镕基，年轻时在东北工作，也得到过高岗的青睐和提拨。李扬不明白的是，既然在党和政府内部，早就确认了高岗没有反党问题，不给其平反的原因究竟是为了什么？当然，高岗这位政客也有阴暗的一面，就是公开史料大多记载他玩弄女性，甚至有强奸的嫌疑！</p>\r\n<p>笔者最后告诉读者一句，中国历史上，中共党史上，从来没有高岗反党集团、林彪反党集团、四人帮反党集团。这一切都是政治斗争太残酷的结果。</p>\r\n","tags":["历史回顾"]},{"title":"中南大学复试机试练手 Based on Acwing","url":"/2025/02/27/16/","content":"<h1 id=\"算法基础课\">算法基础课</h1>\r\n<h2 id=\"第一讲-基础算法\">第一讲 基础算法</h2>\r\n<p><strong>2025.2.27</strong></p>\r\n<h3 id=\"acwing-785.-快速排序\">AcWing 785. 快速排序</h3>\r\n<p>内置函数法</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;vector&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">#include &quot;iostream&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    int n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    vector&lt;int&gt; a(n);</span><br><span class=\"line\">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(a.begin(),a.end());</span><br><span class=\"line\">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;  // 引入输入输出流库</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">const int N = 100010; // 定义最大数组长度</span><br><span class=\"line\">int a[N];           // 全局数组用于存储原始数据</span><br><span class=\"line\"></span><br><span class=\"line\">// 函数功能：使用Hoare分区方案的快速排序算法对数组a[l..r]进行升序排序</span><br><span class=\"line\">void quick_sort(int a[], int l, int r) &#123;</span><br><span class=\"line\">    if (l &gt;= r) return; // 递归终止条件：区间长度为1时无需排序</span><br><span class=\"line\">    </span><br><span class=\"line\">    int x = a[l + r &gt;&gt; 1]; // 选取中间位置的元素作为基准值（位运算优化）</span><br><span class=\"line\">    int i = l - 1, j = r + 1; // 初始化双指针（i左移一位，j右移一位）</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Hoare分区核心逻辑：i向右找≥x的元素，j向左找≤x的元素，交换不符合条件的元素</span><br><span class=\"line\">    while (i &lt; j) &#123;</span><br><span class=\"line\">        // 找到第一个≥x的元素（跳过比x小的元素）</span><br><span class=\"line\">        while (a[++i] &lt; x);</span><br><span class=\"line\">        // 找到第一个≤x的元素（跳过比x大的元素）</span><br><span class=\"line\">        while (a[--j] &gt; x);</span><br><span class=\"line\">        if (i &lt; j)</span><br><span class=\"line\">            swap(a[i], a[j]); // 交换不满足顺序的元素</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 递归排序左右子区间（注意：Hoare分区后的基准值位置在j）</span><br><span class=\"line\">    quick_sort(a, l, j);</span><br><span class=\"line\">    quick_sort(a, j + 1, r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    int n;</span><br><span class=\"line\">    cin &gt;&gt; n; // 输入数组长度</span><br><span class=\"line\">    </span><br><span class=\"line\">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        cin &gt;&gt; a[i]; // 输入数组元素</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    quick_sort(a, 0, n - 1); // 调用快速排序函数对整个数组排序</span><br><span class=\"line\">    </span><br><span class=\"line\">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; // 输出排序后的数组</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-786.-第k个数\">AcWing 786. 第k个数</h3>\r\n<p>内置函数法</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;vector&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">#include &quot;iostream&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    int n,k;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">    vector&lt;int&gt; a(n);</span><br><span class=\"line\">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(a.begin(),a.end());</span><br><span class=\"line\">    cout&lt;&lt;a[k-1]&lt;&lt;endl;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;  // 引入输入输出流库</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">// 函数功能：使用快速选择算法在数组a[l..r]范围内查找第k小的元素（k从1开始计数）</span><br><span class=\"line\">// 参数：</span><br><span class=\"line\">//   a[]：待查找的数组</span><br><span class=\"line\">//   l：当前查找范围的左边界（包含）</span><br><span class=\"line\">//   r：当前查找范围的右边界（包含）</span><br><span class=\"line\">//   k：要查找的第k小的元素的序号（k &gt;= 1）</span><br><span class=\"line\">int quicksortfind(int a[], int l, int r, int k) &#123;</span><br><span class=\"line\">    if (l &gt;= r) return a[l]; // 当区间只有一个元素时，直接返回该元素</span><br><span class=\"line\">    </span><br><span class=\"line\">    int x = a[l + r &gt;&gt; 1]; // 选择中间位置的元素作为基准值（位运算优化）</span><br><span class=\"line\">    int i = l - 1, j = r + 1; // i初始指向l左侧，j初始指向r右侧</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Hoare分区核心逻辑：i向右找≥x的元素，j向左找≤x的元素，交换不符合条件的元素</span><br><span class=\"line\">    while (i &lt; j) &#123;</span><br><span class=\"line\">        // 找到第一个≥x的元素（跳过比x小的元素）</span><br><span class=\"line\">        while (a[++i] &lt; x);</span><br><span class=\"line\">        // 找到第一个≤x的元素（跳过比x大的元素）</span><br><span class=\"line\">        while (a[--j] &gt; x);</span><br><span class=\"line\">        if (i &lt; j)</span><br><span class=\"line\">            swap(a[i], a[j]); // 交换不满足顺序的元素</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int sl = j - l + 1; // 当前基准值所在位置分割后的左半部分长度（包含基准值）</span><br><span class=\"line\">    // 根据k的值决定递归方向</span><br><span class=\"line\">    if (k &lt;= sl) </span><br><span class=\"line\">        return quicksortfind(a, l, j, k); // 递归处理左半部分</span><br><span class=\"line\">    else </span><br><span class=\"line\">        return quicksortfind(a, j + 1, r, k - sl); // 递归处理右半部分</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    int n, k;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; k; // 输入数组长度和要查找的第k小的元素序号</span><br><span class=\"line\">    int a[n]; // 定义数组（注意：C++标准不支持VLA，此处为GCC扩展语法）</span><br><span class=\"line\">    </span><br><span class=\"line\">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        cin &gt;&gt; a[i]; // 输入数组元素</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; quicksortfind(a, 0, n - 1, k) &lt;&lt; endl; // 输出第k小的元素</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-787.-归并排序\">AcWing 787. 归并排序</h3>\r\n<p>内置函数法</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;vector&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">#include &quot;iostream&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    int n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    vector&lt;int&gt; a(n);</span><br><span class=\"line\">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(a.begin(),a.end());</span><br><span class=\"line\">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;  // 引入输入输出流库</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int temp[100010] = &#123;&#125;; // 全局临时数组，用于合并过程中的数据暂存</span><br><span class=\"line\"></span><br><span class=\"line\">// 归并排序函数声明：对数组a的[l, r]区间进行升序排序</span><br><span class=\"line\">void merge_sort(int a[], int l, int r) &#123;</span><br><span class=\"line\">    if (l &gt;= r) return; // 递归终止条件：单个元素已有序</span><br><span class=\"line\">    int mid = (l + r) &gt;&gt; 1; // 计算中间索引（等价于(l+r)/2，位运算更高效）</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 递归划分左右子数组</span><br><span class=\"line\">    merge_sort(a, l, mid);   // 对左半部分排序 [l, mid]</span><br><span class=\"line\">    merge_sort(a, mid+1, r); // 对右半部分排序 [mid+1, r]</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 合并两个有序子数组为整体有序数组</span><br><span class=\"line\">    int k = 0;            // temp数组的写入指针</span><br><span class=\"line\">    int i = l, j = mid + 1; // 左右子数组的遍历指针</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 比较左右子数组元素，按顺序存入temp数组</span><br><span class=\"line\">    while (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class=\"line\">        if (a[i] &lt; a[j]) &#123;</span><br><span class=\"line\">            temp[k++] = a[i++];</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            temp[k++] = a[j++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 处理左子数组剩余元素</span><br><span class=\"line\">    while (i &lt;= mid) &#123;</span><br><span class=\"line\">        temp[k++] = a[i++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 处理右子数组剩余元素</span><br><span class=\"line\">    while (j &lt;= r) &#123;</span><br><span class=\"line\">        temp[k++] = a[j++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 将temp数组中的数据复制回原数组a的[l, r]区间</span><br><span class=\"line\">    k = 0; // 重置temp数组的读取指针</span><br><span class=\"line\">    for (int m = l; m &lt;= r; ++m) &#123;</span><br><span class=\"line\">        a[m] = temp[k++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    int n;</span><br><span class=\"line\">    cin &gt;&gt; n; // 输入数组长度</span><br><span class=\"line\">    </span><br><span class=\"line\">    int a[n]; // 定义整型数组（注意：C++标准不支持VLA，此处为GCC扩展语法）</span><br><span class=\"line\">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        cin &gt;&gt; a[i]; // 输入数组元素</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    merge_sort(a, 0, n-1); // 调用归并排序函数，对整个数组排序</span><br><span class=\"line\">    </span><br><span class=\"line\">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; // 输出排序后的数组，元素间以空格分隔</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-788.-逆序对的数量\">AcWing 788. 逆序对的数量</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;  // 引入输入输出流库</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">const int N = 100010; // 定义最大数组长度</span><br><span class=\"line\">int a[N];           // 全局数组用于存储原始数据</span><br><span class=\"line\">int temp[N];        // 全局临时数组用于归并过程</span><br><span class=\"line\"></span><br><span class=\"line\">// 函数功能：使用归并排序计算数组a[l..r]范围内的逆序对总数</span><br><span class=\"line\">// 参数：a为数组，l/r为当前处理区间的左右边界</span><br><span class=\"line\">// 返回值：当前区间的逆序对数量</span><br><span class=\"line\">long long find(int a[], int l, int r) &#123;</span><br><span class=\"line\">    if (l &gt;= r) return 0; // 区间长度为1时无逆序对</span><br><span class=\"line\">    </span><br><span class=\"line\">    int mid = (l + r) &gt;&gt; 1; // 计算中间位置（位运算优化）</span><br><span class=\"line\">    long long res = 0;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 递归计算左右子区间的逆序对数</span><br><span class=\"line\">    res += find(a, l, mid);</span><br><span class=\"line\">    res += find(a, mid + 1, r);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 合并两个有序子区间并统计跨越两区的逆序对</span><br><span class=\"line\">    int i = l, j = mid + 1, k = 0;</span><br><span class=\"line\">    while (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class=\"line\">        if (a[i] &lt;= a[j]) &#123; // 左侧元素不大于右侧，无需统计逆序</span><br><span class=\"line\">            temp[k++] = a[i++];</span><br><span class=\"line\">        &#125; else &#123; // 右侧元素更小，左侧剩余元素全部构成逆序对</span><br><span class=\"line\">            temp[k++] = a[j++];</span><br><span class=\"line\">            res += mid - i + 1; // 统计逆序对数量</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 处理剩余元素</span><br><span class=\"line\">    while (i &lt;= mid) temp[k++] = a[i++];</span><br><span class=\"line\">    while (j &lt;= r) temp[k++] = a[j++];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 将合并结果复制回原数组a</span><br><span class=\"line\">    for (int m = l, k = 0; m &lt;= r; ++m) &#123;</span><br><span class=\"line\">        a[m] = temp[k++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return res; // 返回总逆序对数</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    int n;</span><br><span class=\"line\">    cin &gt;&gt; n; // 输入数组长度</span><br><span class=\"line\">    </span><br><span class=\"line\">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        cin &gt;&gt; a[i]; // 输入数组元素</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; find(a, 0, n - 1) &lt;&lt; endl; // 输出整个数组的逆序对总数</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-789.-数的范围\">AcWing 789. 数的范围</h3>\r\n<p>内置函数法</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;iostream&quot;</span><br><span class=\"line\">#include &quot;algorithm&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    int n,q,k;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class=\"line\">    int a[n];</span><br><span class=\"line\">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (int i = 0; i &lt; q; ++i) &#123;</span><br><span class=\"line\">        cin&gt;&gt;k;</span><br><span class=\"line\">        if(binary_search(a,a+n,k))&#123;</span><br><span class=\"line\">            cout&lt;&lt;lower_bound(a,a+n,k) -a &lt;&lt;&quot; &quot;&lt;&lt;upper_bound(a,a+n,k) -a - 1&lt;&lt;endl;</span><br><span class=\"line\">        &#125; else&#123;</span><br><span class=\"line\">            cout &lt;&lt; &quot;-1 -1&quot; &lt;&lt; endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-790.-数的三次方根\">AcWing 790. 数的三次方根</h3>\r\n<p>内置函数法</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include&lt;bits/stdc++.h&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    double n;</span><br><span class=\"line\">    scanf(&quot;%lf&quot;,&amp;n);</span><br><span class=\"line\">    printf(&quot;%lf&quot;,cbrt(n));</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;iostream&quot;</span><br><span class=\"line\">#include &quot;iomanip&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    double n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    double l=-100000,r=100000;</span><br><span class=\"line\">    while (r-l&gt;1e-8)&#123;</span><br><span class=\"line\">        double mid = (l+r)/2;</span><br><span class=\"line\">        if(mid*mid*mid&lt;n)</span><br><span class=\"line\">            l=mid;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            r=mid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;fixed&lt;&lt;setprecision(6)&lt;&lt;r&lt;&lt;endl;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-791.-高精度加法\">AcWing 791. 高精度加法</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">#include &quot;iostream&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">string a,b;</span><br><span class=\"line\"></span><br><span class=\"line\">string add(string s1,string s2)&#123;</span><br><span class=\"line\">    string c;</span><br><span class=\"line\">    int t=0;</span><br><span class=\"line\">    for (int i = s1.size()-1,j=s2.size()-1; i &gt;=0||j&gt;=0||t&gt;0 ; --i,--j) &#123;</span><br><span class=\"line\">        if (i&gt;=0) t+=(s1[i]-&#x27;0&#x27;);</span><br><span class=\"line\">        if (j&gt;=0) t+=(s2[j]-&#x27;0&#x27;);</span><br><span class=\"line\">        c+=((t%10)+&#x27;0&#x27;);</span><br><span class=\"line\">        t/=10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    reverse(c.begin(),c.end());</span><br><span class=\"line\">    return c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class=\"line\">    cout&lt;&lt;add(a,b)&lt;&lt;endl;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-792.-高精度减法\">AcWing 792. 高精度减法</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;   // 引入输入输出流库</span><br><span class=\"line\">#include &lt;algorithm&gt;  // 引入算法库，用于std::sort等函数</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;  // 使用标准命名空间</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @brief 比较两个字符串表示的数字的大小</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param s1 第一个字符串数字</span><br><span class=\"line\"> * @param s2 第二个字符串数字</span><br><span class=\"line\"> * @return bool 如果s1大于或等于s2，返回true；否则返回false</span><br><span class=\"line\"> */</span><br><span class=\"line\">bool cmp(string s1, string s2)&#123;</span><br><span class=\"line\">    if(s1.size() != s2.size()) </span><br><span class=\"line\">        return s1.size() &gt; s2.size();  // 如果长度不同，长度较长的数字更大</span><br><span class=\"line\">    for (int i = 0; i &lt; s1.size(); ++i) &#123;</span><br><span class=\"line\">        if(s1[i] != s2[i]) </span><br><span class=\"line\">            return s1[i] &gt; s2[i];  // 从高位到低位逐位比较，较大的数字更大</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true;  // 如果所有位都相同，返回true</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @brief 计算两个字符串表示的数字的差值，s1 - s2</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param s1 被减数，字符串形式的数字</span><br><span class=\"line\"> * @param s2 减数，字符串形式的数字</span><br><span class=\"line\"> * @return string 返回差值的字符串表示，保证没有前导零（除非结果为0）</span><br><span class=\"line\"> */</span><br><span class=\"line\">string sub(string s1, string s2)&#123;</span><br><span class=\"line\">    string c;  // 存储结果的字符串</span><br><span class=\"line\">    int t = 0; // 借位标志，初始为0</span><br><span class=\"line\"></span><br><span class=\"line\">    // 从字符串的末尾（即数字的最低位）开始逐位相减</span><br><span class=\"line\">    for (int i = s1.size() - 1, j = s2.size() - 1; </span><br><span class=\"line\">         i &gt;= 0 || j &gt;= 0 || t &gt; 0; --i, --j) &#123;</span><br><span class=\"line\">        // 如果被减数的当前位有效，减去借位</span><br><span class=\"line\">        if(i &gt;= 0) </span><br><span class=\"line\">            t = (s1[i] - &#x27;0&#x27;) - t;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 如果减数的当前位有效，继续减去该位的值</span><br><span class=\"line\">        if(j &gt;= 0) </span><br><span class=\"line\">            t -= (s2[j] - &#x27;0&#x27;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 将当前位的结果加上10后取模，确保结果为非负数，并转换为字符</span><br><span class=\"line\">        c += ((t + 10) % 10) + &#x27;0&#x27;;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 更新借位标志</span><br><span class=\"line\">        if(t &lt; 0) &#123;</span><br><span class=\"line\">            t = 1;  // 需要继续借位</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            t = 0;  // 不需要借位</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 移除结果中末尾多余的零（如果有的话），但保留至少一个零</span><br><span class=\"line\">    while (c.size() &gt; 1 &amp;&amp; c.back() == &#x27;0&#x27;)</span><br><span class=\"line\">        c.pop_back();</span><br><span class=\"line\">    </span><br><span class=\"line\">    reverse(c.begin(), c.end());  // 反转字符串，得到正确的顺序</span><br><span class=\"line\">    return c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    string a, b;  // 定义两个字符串变量，用于存储输入的数字</span><br><span class=\"line\">    cin &gt;&gt; a &gt;&gt; b;  // 从标准输入读取两个数字字符串</span><br><span class=\"line\"></span><br><span class=\"line\">    // 比较a和b的大小</span><br><span class=\"line\">    if (cmp(a, b)) </span><br><span class=\"line\">        cout &lt;&lt; sub(a, b) &lt;&lt; endl;  // 如果a &gt;= b，输出a - b的结果</span><br><span class=\"line\">    else </span><br><span class=\"line\">        cout &lt;&lt; &quot;-&quot; &lt;&lt; sub(b, a) &lt;&lt; endl;  // 如果a &lt; b，输出-(b - a)的结果</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;  // 程序结束</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-793.-高精度乘法\">AcWing 793. 高精度乘法</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;vector&gt;</span><br><span class=\"line\">#include &quot;iostream&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">// 函数mul：实现一个大整数（用vector&lt;int&gt;表示）与一个整数的乘法</span><br><span class=\"line\">// 参数v：大整数，每个元素表示一位数字，且低位在前，高位在后</span><br><span class=\"line\">// 参数i：要乘的整数</span><br><span class=\"line\">// 返回值：返回乘积，同样用vector&lt;int&gt;表示，低位在前，高位在后</span><br><span class=\"line\">vector&lt;int&gt; mul(vector&lt;int&gt; v, int i) &#123;</span><br><span class=\"line\">    vector&lt;int&gt; ve;  // 用于存储乘积的结果</span><br><span class=\"line\">    int t = 0;       // 进位初始化为0</span><br><span class=\"line\"></span><br><span class=\"line\">    // 遍历输入的大整数v的每一位</span><br><span class=\"line\">    for (int j = 0; j &lt; v.size(); ++j) &#123;</span><br><span class=\"line\">        t += v[j] * i;          // 当前位乘以i并加上进位</span><br><span class=\"line\">        ve.push_back(t % 10);   // 将当前位的结果（个位数）存入ve</span><br><span class=\"line\">        t /= 10;                // 更新进位</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 处理剩余的进位</span><br><span class=\"line\">    while (t) &#123;</span><br><span class=\"line\">        ve.push_back(t % 10);</span><br><span class=\"line\">        t /= 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 去除结果中高位的无效零（保证至少有一位有效数字）</span><br><span class=\"line\">    while (ve.size() &gt; 1 &amp;&amp; ve.back() == 0)</span><br><span class=\"line\">        ve.pop_back();</span><br><span class=\"line\"></span><br><span class=\"line\">    return ve;  // 返回乘积结果</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    string s;  // 用于存储输入的大整数（以字符串形式）</span><br><span class=\"line\">    int a;     // 用于存储要乘的整数</span><br><span class=\"line\"></span><br><span class=\"line\">    cin &gt;&gt; s &gt;&gt; a;  // 输入大整数和乘数</span><br><span class=\"line\"></span><br><span class=\"line\">    vector&lt;int&gt; aa;  // 用于存储转换后的大整数（低位在前）</span><br><span class=\"line\"></span><br><span class=\"line\">    // 将字符串形式的大整数s转换为vector&lt;int&gt;形式，低位在前</span><br><span class=\"line\">    for (int i = s.size() - 1; i &gt;= 0; --i) &#123;</span><br><span class=\"line\">        aa.push_back(s[i] - &#x27;0&#x27;);  // 将字符转换为数字并存入aa</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    auto au = mul(aa, a);  // 调用mul函数计算乘积</span><br><span class=\"line\"></span><br><span class=\"line\">    // 输出乘积结果，从高位到低位</span><br><span class=\"line\">    for (int i = au.size() - 1; i &gt;= 0; --i) &#123;</span><br><span class=\"line\">        cout &lt;&lt; au[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;  // 程序结束</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-794.-高精度除法\">AcWing 794. 高精度除法</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;vector&gt;       // 引入向量容器库</span><br><span class=\"line\">#include &lt;algorithm&gt;    // 引入算法库（用于反转容器）</span><br><span class=\"line\">#include &quot;iostream&quot;      // 引入输入输出流库</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">// 函数功能：对逆序存储的数字数组进行除法运算，返回商的各位数字（高位在前）</span><br><span class=\"line\">// 参数：v表示逆序存储的被除数数字数组，i表示除数，y通过引用返回余数</span><br><span class=\"line\">vector&lt;int&gt; div(vector&lt;int&gt; v, int i, int &amp;y) &#123;</span><br><span class=\"line\">    vector&lt;int&gt; result; // 存储商的各位数字</span><br><span class=\"line\">    y = 0;             // 初始化余数为0</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 从最高位到最低位处理每一位数字（v的索引0对应个位，索引末尾对应最高位）</span><br><span class=\"line\">    for (int j = v.size() - 1; j &gt;= 0; --j) &#123;</span><br><span class=\"line\">        y = y * 10 + v[j]; // 累加当前位到余数y（模拟手动除法的逐位操作）</span><br><span class=\"line\">        result.push_back(y / i); // 计算当前位的商并存储</span><br><span class=\"line\">        y %= i;               // 更新余数</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    reverse(result.begin(), result.end()); // 反转商的顺序（使高位在前）</span><br><span class=\"line\">    // 去除商末尾的零（例如：结果为[0, 2, 3]时，去除前导零变为[2, 3]）</span><br><span class=\"line\">    while (result.size() &gt; 1 &amp;&amp; result.back() == 0) &#123;</span><br><span class=\"line\">        result.pop_back();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    string s;           // 输入的整数字符串</span><br><span class=\"line\">    int b, r;           // 除数b和余数r</span><br><span class=\"line\">    </span><br><span class=\"line\">    cin &gt;&gt; s &gt;&gt; b;      // 读取输入的字符串和除数</span><br><span class=\"line\">    vector&lt;int&gt; a;       // 存储逆序的数字位（例如：&quot;123&quot; -&gt; [3,2,1]）</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 将字符串转换为逆序的数字数组</span><br><span class=\"line\">    for (int i = s.size() - 1; i &gt;= 0; --i) &#123;</span><br><span class=\"line\">        a.push_back(s[i] - &#x27;0&#x27;); // 字符转数字并逆序存储</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    auto result = div(a, b, r); // 调用div函数进行除法运算</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 输出商的结果（注意：result已经是高位到低位的顺序）</span><br><span class=\"line\">    for (int i = result.size() - 1; i &gt;= 0; --i) &#123;</span><br><span class=\"line\">        cout &lt;&lt; result[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; endl&lt;&lt; r &lt;&lt; endl; // 输出余数</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-795.-前缀和\">AcWing 795. 前缀和</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;iostream&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    int n,m,l,r;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    int a[n],b[n];</span><br><span class=\"line\">    for(int i = 1;i &lt;= n;i++)</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\">    b[0]=0;</span><br><span class=\"line\">    b[1]=a[1];</span><br><span class=\"line\">    for (int i = 2; i &lt;= n; ++i)</span><br><span class=\"line\">        b[i]=b[i-1]+a[i];</span><br><span class=\"line\">    for (int j = 0; j &lt; m; ++j) &#123;</span><br><span class=\"line\">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class=\"line\">        cout&lt;&lt; b[r]-b[l-1]&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-796.-子矩阵的和\">AcWing 796. 子矩阵的和</h3>\r\n<p>超时版本</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;iostream&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">const int N=1010;</span><br><span class=\"line\">int a[N][N],b[N][N];</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    int n,m,q,x1,x2,y1,y2,cnt;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class=\"line\">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        for (int j = 0; j &lt;= m; ++j) &#123;</span><br><span class=\"line\">            if (j==0)&#123;</span><br><span class=\"line\">                a[i][j]=0;</span><br><span class=\"line\">                b[i][j]=0;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else&#123;</span><br><span class=\"line\">                cin&gt;&gt;a[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        for (int j = 1; j &lt;= m; ++j) &#123;</span><br><span class=\"line\">            b[i][j]=a[i][j]+b[i][j-1];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (int i = 1; i &lt;= q ; ++i) &#123;</span><br><span class=\"line\">        cnt=0;</span><br><span class=\"line\">        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class=\"line\">        for (int j = x1; j &lt;= x2 ; ++j) &#123;</span><br><span class=\"line\">            cnt = cnt + b[j][y2]-b[j][y1-1];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>混元模型优化版</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cstring&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">const int N = 1010;</span><br><span class=\"line\">int a[N+1][N+1], b[N+1][N+1], s[N+1][N+1];</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    ios::sync_with_stdio(false);</span><br><span class=\"line\">    cin.tie(0);</span><br><span class=\"line\"></span><br><span class=\"line\">    int n, m, q;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 初始化数组并输入数据</span><br><span class=\"line\">    memset(a, 0, sizeof a);</span><br><span class=\"line\">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        for (int j = 1; j &lt;= m; ++j) &#123;</span><br><span class=\"line\">            cin &gt;&gt; a[i][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算每行的前缀和</span><br><span class=\"line\">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        for (int j = 1; j &lt;= m; ++j) &#123;</span><br><span class=\"line\">            b[i][j] = b[i][j-1] + a[i][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算二维前缀和</span><br><span class=\"line\">    memset(s, 0, sizeof s);</span><br><span class=\"line\">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        for (int j = 1; j &lt;= m; ++j) &#123;</span><br><span class=\"line\">            s[i][j] = s[i-1][j] + b[i][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 处理查询</span><br><span class=\"line\">    while (q--) &#123;</span><br><span class=\"line\">        int x1, y1, x2, y2;</span><br><span class=\"line\">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class=\"line\">        cout &lt;&lt; s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1] &lt;&lt; &#x27;\\n&#x27;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-797.-差分\">AcWing 797. 差分</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;iostream&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    int n,m,l,r,c;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    int a[n+1],b[n+1];</span><br><span class=\"line\">    a[0]=0;</span><br><span class=\"line\">    b[0]=0;</span><br><span class=\"line\">    for (int i = 1; i &lt;= n; ++i)</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        b[i]=a[i]-a[i-1];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class=\"line\">        cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class=\"line\">        b[l]+=c;</span><br><span class=\"line\">        b[r+1]-=c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        b[i]+=b[i-1];</span><br><span class=\"line\">        cout&lt;&lt;b[i]&lt;&lt;&quot; &quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-798.-差分矩阵\">AcWing 798. 差分矩阵</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;iostream&quot;  // 引入输入输出流库</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;  // 使用标准命名空间</span><br><span class=\"line\"></span><br><span class=\"line\">const int N = 1010;  // 定义一个常量N，表示数组的最大尺寸</span><br><span class=\"line\">int a[N][N] = &#123;&#125;, s[N][N] = &#123;&#125;;  // 定义两个二维数组a和s，并初始化为0</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    int n, m, q, x1, y1, x2, y2, c;  // 定义变量用于存储输入的数据</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;  // 输入矩阵的行数n、列数m，以及操作的次数q</span><br><span class=\"line\"></span><br><span class=\"line\">    // 输入初始矩阵的值，并存储在s数组中</span><br><span class=\"line\">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        for (int j = 1; j &lt;= m; ++j) &#123;</span><br><span class=\"line\">            cin &gt;&gt; s[i][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算初始矩阵的前缀和，并存储在a数组中</span><br><span class=\"line\">    // a[i][j]表示从(1,1)到(i,j)的子矩阵的和</span><br><span class=\"line\">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        for (int j = 1; j &lt;= m; ++j) &#123;</span><br><span class=\"line\">            a[i][j] = s[i][j] + s[i - 1][j - 1] - s[i - 1][j] - s[i][j - 1];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 处理q次操作，每次操作给出一个子矩阵的左上角(x1,y1)和右下角(x2,y2)，以及要增加的值c</span><br><span class=\"line\">    for (int i = 0; i &lt; q; ++i) &#123;</span><br><span class=\"line\">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class=\"line\">        // 使用差分数组的方法，对子矩阵进行加减操作</span><br><span class=\"line\">        // 这样可以在O(1)的时间内完成子矩阵的加减操作</span><br><span class=\"line\">        a[x1][y1] += c;</span><br><span class=\"line\">        a[x1][y2 + 1] -= c;</span><br><span class=\"line\">        a[x2 + 1][y1] -= c;</span><br><span class=\"line\">        a[x2 + 1][y2 + 1] += c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 根据差分数组a，重新计算矩阵s的值</span><br><span class=\"line\">    for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">        for (int j = 1; j &lt;= m; ++j) &#123;</span><br><span class=\"line\">            // 通过前缀和的方式，计算出每个位置的值</span><br><span class=\"line\">            s[i][j] = a[i][j] + s[i][j - 1] + s[i - 1][j] - s[i - 1][j - 1];</span><br><span class=\"line\">            cout &lt;&lt; s[i][j] &lt;&lt; &quot; &quot;;  // 输出计算后的矩阵值</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout &lt;&lt; endl;  // 换行，输出下一行的矩阵值</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;  // 程序结束</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-799.-最长连续不重复子序列\">AcWing 799.\r\n最长连续不重复子序列</h3>\r\n<p>超时版本</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;iostream&quot;</span><br><span class=\"line\">#include &quot;cstring&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    int n,cnt=0,x=0;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    int a[n],b[100001]=&#123;0&#125;;</span><br><span class=\"line\">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        if (b[a[i]]==0)&#123;</span><br><span class=\"line\">            b[a[i]]=1;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">            x= max(cnt,x);</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (b[a[i]]==1)&#123;</span><br><span class=\"line\">            x= max(cnt,x);</span><br><span class=\"line\">            i=i-cnt;</span><br><span class=\"line\">            cnt=0;</span><br><span class=\"line\">            memset(b, 0, sizeof(b));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;x&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>优化版本</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;vector&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">const int MAX_VALUE = 100001; // 根据题目数据范围设置最大值</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    ios::sync_with_stdio(false);</span><br><span class=\"line\">    cin.tie(nullptr);</span><br><span class=\"line\"></span><br><span class=\"line\">    int n;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\"></span><br><span class=\"line\">    vector&lt;int&gt; a(n);</span><br><span class=\"line\">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        cin &gt;&gt; a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    vector&lt;int&gt; last_pos(MAX_VALUE, -1); // 记录每个元素最后出现的索引</span><br><span class=\"line\">    int max_len = 0, left = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    for (int right = 0; right &lt; n; ++right) &#123;</span><br><span class=\"line\">        if (last_pos[a[right]] &gt;= left) &#123; // 如果该元素在当前窗口中出现过</span><br><span class=\"line\">            left = last_pos[a[right]] + 1; // 移动左边界到重复元素的下一个位置</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        last_pos[a[right]] = right; // 更新最后一次出现的位置</span><br><span class=\"line\">        max_len = max(max_len, right - left + 1); // 更新最大长度</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; max_len &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-800.-数组元素的目标和\">AcWing 800. 数组元素的目标和</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;iostream&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    int n,m,x;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x;</span><br><span class=\"line\">    int a[n],b[m];</span><br><span class=\"line\">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class=\"line\">        cin&gt;&gt;b[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for (int i = 0,j=m-1; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        while (a[i]+b[j]&gt;x&amp;&amp;j&gt;0) j--;</span><br><span class=\"line\">        if(a[i]+b[j]==x)</span><br><span class=\"line\">            cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-801.-二进制中1的个数\">AcWing 801. 二进制中1的个数</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int lowbit(int x)&#123;</span><br><span class=\"line\">    return x&amp;(-x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    int n,x;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        int res = 0;</span><br><span class=\"line\">        cin&gt;&gt;x;</span><br><span class=\"line\">        while (x)&#123;</span><br><span class=\"line\">            x-= lowbit(x);</span><br><span class=\"line\">            res++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;res&lt;&lt;&quot; &quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-802.-区间和\">AcWing 802. 区间和</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;vector&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义一个类型别名 p，用于表示键值对 (int, int)</span><br><span class=\"line\">typedef pair&lt;int, int&gt; p;</span><br><span class=\"line\"></span><br><span class=\"line\">// 存储添加操作的区间及其对应的值</span><br><span class=\"line\">vector&lt;p&gt; add;</span><br><span class=\"line\">// 存储查询操作的区间</span><br><span class=\"line\">vector&lt;p&gt; query;</span><br><span class=\"line\">// 存储所有出现过的坐标，用于离散化</span><br><span class=\"line\">vector&lt;int&gt; alls;</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义常量 N，设定数组的最大大小</span><br><span class=\"line\">const int N = 300010;</span><br><span class=\"line\">// 数组 a 用于存储每个离散化后的位置的累加值</span><br><span class=\"line\">int a[N];</span><br><span class=\"line\">// 数组 s 用于存储前缀和，便于快速查询区间和</span><br><span class=\"line\">int s[N];</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @brief 使用二分查找找到 x 在 alls 中的位置，并返回其在离散化后的索引（从1开始）</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * @param x 需要查找的坐标</span><br><span class=\"line\"> * @return int 离散化后的索引</span><br><span class=\"line\"> */</span><br><span class=\"line\">int find(int x) &#123;</span><br><span class=\"line\">    int l = 0, r = alls.size() - 1, mid;</span><br><span class=\"line\">    // 标准的二分查找，找到第一个 &gt;= x 的位置</span><br><span class=\"line\">    while (l &lt; r) &#123;</span><br><span class=\"line\">        mid = (l + r) / 2;</span><br><span class=\"line\">        if (alls[mid] &gt;= x)</span><br><span class=\"line\">            r = mid;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            l = mid + 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 返回离散化后的索引（假设 alls 已排序且唯一）</span><br><span class=\"line\">    return r + 1; // 索引从1开始，方便后续前缀和计算</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    int n, m; // n 是添加操作的次数，m 是查询操作的次数</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 处理所有的添加操作</span><br><span class=\"line\">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">        int x, c;</span><br><span class=\"line\">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class=\"line\">        add.emplace_back(x, c); // 存储添加操作的坐标和值</span><br><span class=\"line\">        alls.push_back(x);      // 将坐标记录下来，用于后续离散化</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 处理所有的查询操作</span><br><span class=\"line\">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class=\"line\">        int l, r;</span><br><span class=\"line\">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class=\"line\">        query.emplace_back(l, r); // 存储查询操作的区间</span><br><span class=\"line\">        alls.push_back(l);        // 记录查询区间的左右端点</span><br><span class=\"line\">        alls.push_back(r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 对所有记录的坐标进行排序</span><br><span class=\"line\">    sort(alls.begin(), alls.end());</span><br><span class=\"line\"></span><br><span class=\"line\">    // 去除重复的坐标，并调整 alls 的大小</span><br><span class=\"line\">    alls.erase(unique(alls.begin(), alls.end()), alls.end());</span><br><span class=\"line\"></span><br><span class=\"line\">    // 遍历所有的添加操作，将对应的值累加到离散化后的位置</span><br><span class=\"line\">    for (auto aa : add) &#123;</span><br><span class=\"line\">        // 找到坐标 aa.first 在离散化后的索引，并累加值 aa.second</span><br><span class=\"line\">        a[find(aa.first)] += aa.second;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 计算前缀和数组 s，s[i] 表示前 i 个位置的累加总和</span><br><span class=\"line\">    for (int i = 1; i &lt;= alls.size(); i++) &#123;</span><br><span class=\"line\">        s[i] = s[i - 1] + a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 处理每一个查询操作，输出对应区间的累加和</span><br><span class=\"line\">    for (auto q : query) &#123;</span><br><span class=\"line\">        // 计算区间 [q.first, q.second] 的累加和</span><br><span class=\"line\">        // find(q.second) 得到右端点的离散索引</span><br><span class=\"line\">        // find(q.first) - 1 得到左端点前一个位置的离散索引</span><br><span class=\"line\">        cout &lt;&lt; s[find(q.second)] - s[find(q.first) - 1] &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-803.-区间合并\">AcWing 803. 区间合并</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;vector&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef pair&lt;int, int&gt; p;    // 定义区间类型，方便后续使用</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;p&gt; nums, res;         // nums存储原始区间，res存储合并后的结果</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    int n, l, r;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 读取n个区间并存入nums容器</span><br><span class=\"line\">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class=\"line\">        nums.emplace_back(l, r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 按照区间的起始点进行升序排序</span><br><span class=\"line\">    sort(nums.begin(), nums.end());</span><br><span class=\"line\">    </span><br><span class=\"line\">    int start = -1, end = -1;</span><br><span class=\"line\">    // 遍历每个区间，进行合并处理</span><br><span class=\"line\">    for (auto num : nums) &#123;</span><br><span class=\"line\">        if (num.first &gt; end) &#123; // 当前区间与已合并区间无重叠</span><br><span class=\"line\">            if (end != -1) &#123; // 如果已有合并区间，则存入结果集</span><br><span class=\"line\">                res.emplace_back(start, end);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 更新当前合并区间的起始和结束位置</span><br><span class=\"line\">            start = num.first;</span><br><span class=\"line\">            end = num.second;</span><br><span class=\"line\">        &#125; else if (num.second &gt; end) &#123; // 当前区间与已合并区间有重叠，合并它们</span><br><span class=\"line\">            end = num.second; // 扩展合并区间的结束位置</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 处理最后一个区间</span><br><span class=\"line\">    res.emplace_back(start, end);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 输出合并后的不重叠区间数量</span><br><span class=\"line\">    cout &lt;&lt; res.size() &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-2816.-判断子序列\">AcWing 2816. 判断子序列</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt; // 引入输入输出流库</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std; // 使用标准命名空间</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    int n, m, x = 0; // 声明并初始化变量 n 和 m，x 用于跟踪数组 a 的匹配索引</span><br><span class=\"line\">    </span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; m; // 从标准输入读取两个整数 n 和 m</span><br><span class=\"line\">    // n 表示第一个数组的大小，m 表示第二个数组的大小</span><br><span class=\"line\">    </span><br><span class=\"line\">    int a[n], b[m]; // 声明两个整型数组 a 和 b，大小分别为 n 和 m</span><br><span class=\"line\">    // 注意：在 C++ 中，使用变量长度数组（VLA）是非标准的，建议使用 vector 替代</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 读取 n 个整数存入数组 a</span><br><span class=\"line\">    for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">        cin &gt;&gt; a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 读取 m 个整数存入数组 b</span><br><span class=\"line\">    for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class=\"line\">        cin &gt;&gt; b[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 遍历数组 b，检查数组 a 中的元素是否按顺序出现在数组 b 中</span><br><span class=\"line\">    for (int i = 0; i &lt; m; ++i) &#123; // 遍历数组 b 的每一个元素</span><br><span class=\"line\">        if(a[x] == b[i] &amp;&amp; x &lt; n) &#123; // 如果 a 的当前元素等于 b 的当前元素，并且 x 没有超出 a 的范围</span><br><span class=\"line\">            x++; // 匹配成功，移动到 a 的下一个元素</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 检查是否所有 a 的元素都按顺序在 b 中找到了匹配</span><br><span class=\"line\">    if(x != n) </span><br><span class=\"line\">        cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; // 如果有 a 的元素未匹配，输出 &quot;No&quot;</span><br><span class=\"line\">    else </span><br><span class=\"line\">        cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; // 如果所有 a 的元素都匹配，输出 &quot;Yes&quot;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return 0; // 程序结束</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<hr />\r\n<h2 id=\"第二讲-数据结构\">第二讲 数据结构</h2>\r\n<p><strong>2025.3.4</strong></p>\r\n<h3 id=\"acwing-826.-单链表\">AcWing 826. 单链表</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#include &quot;iostream&quot;  // 引入输入输出流库</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace std;  // 使用标准命名空间</span><br><span class=\"line\"></span><br><span class=\"line\">const int N = 100010;  // 定义一个常量N，表示链表的最大长度</span><br><span class=\"line\">int e[N], ne[N], idx = 1, hh = 0;  // 定义数组e存储链表节点的值，ne存储下一个节点的索引，idx为当前节点索引，hh为头节点索引</span><br><span class=\"line\"></span><br><span class=\"line\">// 在链表头部添加一个值为x的节点</span><br><span class=\"line\">void add_to_head(int x) &#123;</span><br><span class=\"line\">    e[idx] = x;          // 将x存入当前节点的值</span><br><span class=\"line\">    ne[idx] = hh;        // 将当前节点的下一个节点指向原来的头节点</span><br><span class=\"line\">    hh = idx++;          // 更新头节点为当前节点，并将索引值自增</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 删除链表中第k个节点的下一个节点</span><br><span class=\"line\">void Delete(int k) &#123;</span><br><span class=\"line\">    if (k == 0) &#123;        // 如果k为0，表示删除头节点</span><br><span class=\"line\">        hh = ne[hh];     // 更新头节点为下一个节点</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        ne[k] = ne[ne[k]];  // 将第k个节点的下一个节点指向其下下个节点，从而删除第k+1个节点</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 在链表中第k个节点后面添加一个值为x的节点</span><br><span class=\"line\">void add(int k, int x) &#123;</span><br><span class=\"line\">    e[idx] = x;          // 将x存入当前节点的值</span><br><span class=\"line\">    ne[idx] = ne[k];     // 将当前节点的下一个节点指向第k个节点的下一个节点</span><br><span class=\"line\">    ne[k] = idx++;       // 将第k个节点的下一个节点指向当前节点，并将索引值自增</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    int m;               // 定义一个变量m表示操作次数</span><br><span class=\"line\">    cin &gt;&gt; m;            // 输入操作次数</span><br><span class=\"line\">    while (m--) &#123;        // 循环m次，执行相应操作</span><br><span class=\"line\">        char c;          // 定义一个字符变量c表示操作类型</span><br><span class=\"line\">        int k, x;        // 定义变量k和x，k表示节点位置，x表示节点值</span><br><span class=\"line\">        cin &gt;&gt; c;        // 输入操作类型</span><br><span class=\"line\">        if (c == &#x27;H&#x27;) &#123;  // 如果操作类型为&#x27;H&#x27;，表示在头部添加节点</span><br><span class=\"line\">            cin &gt;&gt; x;    // 输入节点值</span><br><span class=\"line\">            add_to_head(x);  // 调用add_to_head函数添加节点</span><br><span class=\"line\">        &#125; else if (c == &#x27;D&#x27;) &#123;  // 如果操作类型为&#x27;D&#x27;，表示删除节点</span><br><span class=\"line\">            cin &gt;&gt; k;    // 输入要删除的节点位置</span><br><span class=\"line\">            Delete(k);   // 调用Delete函数删除节点</span><br><span class=\"line\">        &#125; else &#123;         // 如果操作类型为其他，表示在指定位置后添加节点</span><br><span class=\"line\">            cin &gt;&gt; k &gt;&gt; x;  // 输入节点位置和节点值</span><br><span class=\"line\">            add(k, x);      // 调用add函数添加节点</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 遍历链表并输出所有节点的值</span><br><span class=\"line\">    for (int i = hh; i != 0; i = ne[i]) &#123;  // 从头节点开始，依次遍历每个节点</span><br><span class=\"line\">        cout &lt;&lt; e[i] &lt;&lt; &quot; &quot;;  // 输出当前节点的值，并在后面加一个空格</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;  // 程序正常结束，返回0</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-827.-双链表\">AcWing 827. 双链表</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-828.-模拟栈\">AcWing 828. 模拟栈</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-3302.-表达式求值\">AcWing 3302. 表达式求值</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-829.-模拟队列\">AcWing 829. 模拟队列</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-830.-单调栈\">AcWing 830. 单调栈</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-154.-滑动窗口\">AcWing 154. 滑动窗口</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-831.-kmp字符串\">AcWing 831. KMP字符串</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-835.-trie字符串统计\">AcWing 835. Trie字符串统计</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-143.-最大异或对\">AcWing 143. 最大异或对</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-836.-合并集合\">AcWing 836. 合并集合</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-837.-连通块中点的数量\">AcWing 837. 连通块中点的数量</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-240.-食物链\">AcWing 240. 食物链</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-838.-堆排序\">AcWing 838. 堆排序</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-839.-模拟堆\">AcWing 839. 模拟堆</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-840.-模拟散列表\">AcWing 840. 模拟散列表</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"acwing-841.-字符串哈希\">AcWing 841. 字符串哈希</h3>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<hr />\r\n","tags":["C++"]}]