[{"title":"胜率和盈亏比，你更看重哪一个？","url":"/2024/03/09/20/","content":"\n我们之所以认为交易的赔率比胜率重要，是因为如果做主观，几乎一共就两种不同的胜率。要么你认为某个机遇有40%-50%的概率能成，要么你认为某个机遇有70%-80%的概率能成，也就这样了【注意，这里说的都是入场时的初始概率，随着你入场后得到越来越多的信息，你对概率的判断是要有更新的】。特别精确的胜率在主观交易里对决策的意义不大。因为你要做的是市场自然展现给你的机遇，而不是你强行从盘面中找出来的机遇。市场展现给你什么样的胜率和赔率，你就做什么样的胜率和赔率。如果你说你算出来有一个30%胜率的机遇（先知道胜率），但是可能有10倍赔率的机遇（然后你再算出了一个赔率），以为值得一做。但我认为你这个10倍很可能是硬生生找（编）出来的赔率，你是因为知道这个策略胜率低，强行要求高胜率，你很可能是希望市场能走到哪里（或者市场有较低几率走到哪里），而不是市场展现给你的有较高概率会到达的实际赔率。\n\n如果某个策略胜率低也能挣钱，那可能是最后统计的结果，但是你在做每一次交易的时候，**要争取的依旧是高胜率+高赔率**（而不是争取只能低胜率高赔率，或者高胜率低赔率）。因此至少有大概一半概率能成，才有必要去考虑，这才可以说是市场展现给你的机遇。不管结果最终是可以是低胜率高赔率，或者高胜率低赔率，但那都是结果，而不是你要争取的目标。因此做主观胜率几乎就只有两种，要么你认为某个机遇有40%-50%成的概率能成，要么你认为某个机遇有70%-80%成的概率能成。\n\n如果你想做高胜率策略，这当然是可以的（我也建议新手采取高胜率策略），但是在当下的市场环境里，不成熟的交易员运用高胜率策略大多意味着赢一次赚不了多少，但亏一次有可能会亏很多（比如你错一次可能会亏赢四次才赚出来的钱）。如果你看某位交易员（HFT和量化不算）做高胜率策略，胜率确实很高赚的也不少，那概率是他对盘面的认知和把控比较好，而不是他采取了一个多么神奇的高胜率策略。他能看出来这是一个机会，而我可能看不出来这有什么机会。他可能认为这里有风险，而我不认为这里有风险。做高胜率策略绝对是看水平的，反而是做高赔率策略，相对来讲对市场理解不用那么充分（尤其是价格变动的细节的把控），仅分析“价格走到哪里前都不应该遇到特别巨大的阻力”也经常能够吃到饱。\n\n言归正传，既然“要么你认为某个机遇有40%-50%的概率能成，要么你认为某个机遇有70%-80%的概率能成”【这里说的都是入场时的初始概率】，那我们怎么知道某个机遇好与不好，某个机遇是否要重仓？因此需要提前预估赔率。同样都是四五成概率能行的机遇但是赔率高，你就可以稍微加一点仓位。如果出现七八成概率能成，同时还有高赔率，那你就应该重仓。但需要得强调这个预估是建立在市场展现给你的走势和你深刻的分析的基础上。但如果你是“提前已知这个机遇胜率不高，所以我要强行找一个更高的赔率”，那几乎没有意义。\n\n**如何正确计算赔率？**我之前有写过文章，大致你可以理解为当价格走到哪里，你就能够被深刻的证实你判断错了的位置来放你的止损，这是你盈亏比中的“亏”。而你通过市场走势，动能，形态等一系列因素分析到“假设价格发生运动，价格可能一直运动到x处，都不会遇到太多的阻力”那么这个位置x就是你的潜在盈利点（这是你盈亏比中的“赢”），你最好通过这种方式来计算你的盈亏比。当然，如果你的入场点不是单一的某个或某两个点，而是区间分布来scaling out，那确实会麻烦一些，但这也是个熟能生巧的过程。如果你出场也大量分布在不同的点（且点与点之间距离相差较远），那么我建议你将不同的出场点视为不同的交易。你大概可以理解为入场是一起入的，但是出场每一个都是单独的交易。（所谓单独的交易就是假设你没有其他同向持仓，这就是你当下唯一的交易。）当然，你不需要精准的算出你的盈亏比，你大概应该能知道“这个机遇比今天早些时候的几个类似胜率的其他机遇看上去盈亏比要更好，所以没准仓位可以重一点”就够了。\n\n但假如赔率类似，那必然是胜率高的重仓，胜率低的轻仓。两者并不冲突，只是判断胜率相对来讲比判断赔率更难一些，所以我这里强调的是如果你水平一般，那么注重赔率比较简单一点，所以“赔率比胜率重要”。\n\n\n\n------\n\n\n\n这篇文章我不想写的太长，因为每月都会有四五位读者跟我说我的文章太长了，那我就短点写。\n\n因为经常有人会向我咨询一些跟交易相关的比较基础的问题。久而久之，我就发现很多散户（尤其是没有经过机构系统训练的野生散户）都会出现同样的倾向性。他们的思维方式和进机构里系统训练出来的有很大不同。【这里我想强调的是，并不是说散户的思路是有问题的，如果你能赚到钱，什么思路都是好的。只是说自己钻研的散户与经过机构训练的人的思路确实有很大不同】。\n\n大多数散户实际上是在“找一个精确的‘优势价格’入场，然后跟着盘面随波逐流。”我举个例子，很多散户可能利用一大套各种技术分析手段算出一个入场价格，等入场后，就以移动止损的方式让市场带着自己走。很多的散户策略真的就是这样的，他们将大量的时间和精力，不断的去尝试各种不同的技术分析手段，去找那个“高胜率的优势价格”，希望找到那个像金手指一样的入场点。\n\n但如果是经过系统性训练的人，他们的思路大概不是这样的。至少在我一开始做交易的时候，我的教官就非常明确的告诉我，最重要的其实是盈亏比。并不是我们不追求胜率，而是胜率这个东西它不太稳定。你说一个65%胜率的策略，也有可能连续四五次都失败。但如果你有一个好的盈亏比，胜率不到50%又何妨？（这里额外说一个很有意思的现象，很多人认为胜率在70%才是一个高胜率策略，胜率65%就不是一个高胜率的策略。事实上胜率65%就已经是2/3的胜率了，但人们潜意识的认为70%就接近90%乃至100%，65%就接近于50%，这可能是因为考试中60分才及格，给人留下了60分是刚刚超过一半的感觉。但事实上是很多即使在做高胜率策略的交易员，胜率也就是在65%左右。当然70%以上的也有，具体就看你的资金量和具体的盘面。一般通用性比较强的策略，即使是高胜率的，也就是65%胜率。要有一个交易员说他的胜率高达80%，那大概率是因为他对盘面的把控比较好，而不是说这个策略有多么神奇。）\n\n当然并不是说自己在家研究的野生小散就不考虑盈亏比，但他们对于盈亏比的概念一般是在“我愿意亏多少钱来止损”为主要目的。而我们考虑盈亏比，一般是在考虑在当前盘面能赚到多少钱。\n\n先说赢亏比中赢的部分，我们ideally希望入场之后价格可以自由的奔跑一段时间，有点像是“让子弹飞一会”，不要马上就让子弹碰到墙。我们在做规划的时候，尽量避开那种刚入场马上就会碰到一些坎坷，马上就碰到较大的阻力点，或者即使能发展成趋势，但一路上都会遇到阻力点的走势。然后我们大概的去预估，价格有可能会在哪里转向？因为就算是趋势，价格也不可能无限的向前推进。哪怕是遇到一个天大的利好，到一定程度它也是该回调的。但具体价格在哪里转向我们并不知道，但是在碰触重大的支撑或者阻力点的时候，你就可以适当减仓。（当然第一次碰触重要点位的时候，你可以让价格跑一跑看他有没有突破的迹象。但是如果短时间没有突破的迹象，你就可以减仓，注意这里是减仓，至于要不要出来还两说。）这是我们说的，赢的部分。\n\n毕竟市场的走势是高度不确定的，在市场真正走出头肩底之前，你永远也不知道他会是一个头肩底。在市场正经出现底部之前，你也不会知道他就是今天的底，你看订单流，看各种分析方式都没有办法确定价格会走到哪里，只能说推测出哪里的阻力可能会比较大一些，于是你用订单流等一些手段帮你更好的去辨识支撑与阻力的强度。至于如何判断价格有可能会在哪里遇到支撑与主力，请看我之前写的文章：[技术分析究竟有没有用?感觉那么多方法，比如波浪理论，各种指标，太过主观化，运用技术分析是不是不可能成功? ](https://skytravelar.github.io/2024/03/09/18/)。你可以先接着往下读，等读完这篇文章之后回来翻翻这篇文章。本质是说流动性决定了价格会遇到多少支撑与阻力，流动性决定了价格在一段趋势中会出现多少小的震荡区间。\n\n盈亏比中亏的部分主要是在说不能够单纯的担心自己会在上面损失多少钱，不能说“我就愿意在上面risk 300元。那我就把止损放在这里。”反而，你应该考虑的是如果价格走到哪里，我就能够被非常清晰的证实我的判断是错的。因为你并不一定总能抓到好的入场点，比如你想做一个突破的策略，你在关键点位之前入场，准备做突破关键点位的交易。但你可能刚入场，价格就往回打，导致你刚一进去就是浮亏。这时候很多人可能就迅速出来吃个小亏损，（注意，我并不是说这样做不行。但如果你在这里选择了小亏出场，等价格再有突破迹象的时候，你就一定要把仓位加回去。但事实上大部分人就直接观望了，新手很难有加回去的，尤其是当价格反复在关键点位之前震荡。有些人说给自己三次试错机会，如果都是小亏就不看了。）\n\n一个更好的做法是你把你的止损放在一个“如果价格到这里，我就肯定是错了”的地方。毕竟你三次小亏和一次中亏哪个亏的更多，其实真的不好说。有些人问这有什么意义，其实能帮你拿住单子就是意义。有很多交易，其实事后看来他依然是能够成功的。但你可能当时出于各种原因一拿不住出来了，就导致你不仅拿了个小亏，之后大的你也没吃到。你三次小亏失败之后就可能彻底放弃，但你一次中亏之后还有可能进行再战，这就是心态的区别。而你再战的这一次没准就是开张吃三年的机会。另外，一些微小的波动有的时候可能也不需要太多的细读。事实上你不需要看的那么仔细，人的精力注意力都是有限的，也不可能一直死死盯着。\n\n按照我上述提的止盈和止损的位置，你再算盈亏比。如果盈亏比3-4或者更高，那就完全值得做。有些人可能觉得把止损的位置放到证明自己错了的地方，那风险太大了，不愿意承担那么大的价格波动。那我劝你就在仓位上想想办法。一般我们认为正确的仓位设计是，“你对这个交易的信心取决了你该放多大的仓位”。你觉得这个交易可行性高，你就应该重仓，你觉得这个交易可能性不好说，那你就应该轻仓。你在价格演绎的过程中越发觉得这个交易顺眼，你就应该加仓。但如果你觉得判断可行性这个事太主观了，你也可以根据“止损距离大的交易轻仓，止损距离小的重仓”，这样你每次交易你risk的金额应该是差不多的。（事实上我们也不是不采用这种办法，只是在采用这种办法的时候，一般都是市场波动性比较高的时候。因为在市场高波动性的情况下，最差的结果就是被反复止损出场，但是如果这样按照可行性来确定交易仓位，可能每次止损都要放到50-60ticks开外，那确实风险还是很高的。因此不如低仓位，但宽止损区间。）\n\n**之所以强调盈亏比，是因为你对的时候不一定能确保入场，入场了也不一定能完全吃到想要的区间，但错的时候一定会100%入场。如果你对的时候不一定能按3倍赔率出场而总是见好就收，那错的时候就直接亏，久而久之就和市场说byebye了。**\n\n那这样算出的盈亏比有什么意义？其实正经做交易，你的入场位置很难完美。比如你知道某一个交易的盈亏比是5，这是一个大好的机遇。我想来这里做突破或者反转。但是价格到那附近的时候，突然一个大单砸下来，价格嗖的一下就过去了，你根本没反应过来。现在问题来了，要不要追高？如果你再重新计算盈亏比之后发现盈亏比依然在3以上，那为什么不追高？这依然是一个好机会，对不对？价格嗖的一下就过去了，代表了其强劲的动能，然后你依然有一个不错的盈亏比，反而证实了这是一个不可多得的好机会。很多人说追高火葬场，但这种情况你就应该勇于追高。\n\n有些人用一大套的技术分析方法算的一溜八开，算了一个特别精确的价格。然后止损就是10 ticks的固定止损，止盈就是ema移动止盈。**其实不如一个不那么精确的入场点，但是你能够根据盘面大致推算出这个价格有可能走到哪里都不会遇到太多的反击。把止损放到一个会证实自己的思路错了的地方。然后争取在你的止损附近找一个机会入场或者加仓（这种比较适合比如在突破之前，价格在你想要做突破点位附近形成了小的震荡区间，并在这里积蓄动能，这样你就可以尽可能在这个小区间中以更加优势的价格入场。并不是总能有这样的机会，有时你必须得在接近突破/翻转的时候hit进去。但是争取在更好的位置入场，无论如何是一个好的优化。）**之后就一直拿着（除非从订单流或者微形态上读出明显不妙的迹象。这个东西是需要变通的，不是一成不变的。子弹打过来也不是说你就在那站着，该找掩体还是要躲的。）前一种交易方式属于要找到好的价格，而后一种是要做一个好的交易。\n\n**事实就是价格可能反复碰触好几次关键点位，也没能成功突破/反转（相当于短时间内没有证实你的判断是正确的，但也没有证明你是错误的。）如果你知道这是一个较高的盈亏比的好机会，你就能够比较心安的拿住订单。拿住订单就可以在价格没看出要突破迹象，却实实在在的突破了的时候，确保你不会错过一个好的交易。尤其是那种尾盘异动，盯了一天都没能突破，一直在看不到头脑的区间震荡，但最后20分钟你一不留神的时候就创了新高，你心里也不甘。又或者价格在长期来看是趋势，但在发展的过程中是一波接一波的，第一波和第二波可能相隔差40分钟。在这40分钟当中，你可以出来，你也可以拿住。如果你是小仓位好掉头，那么一般也不用考虑这么多。但是如果你一旦发大财了，成为千万级的资金，你就基本上只能做swing类的了，否则你出来就是砸盘。提前学习一下这类交易是怎么做的，也不是什么坏事。**\n\n我还得强调我上面提到的这种“以盈亏比作为是否值得一做的判断，以流动性作为规划依据”的做法并不适合所有人。如果你以其他的方式进行出入场并且赚到了钱，那当然是好事。但是我希望在这里点拨一下，小散自己钻研和一个接受过机构训练的交易员，在处理上是有哪些思路的不同之处。因为你的资金量一旦放大到一定程度，你很大程度上就只能以我提到的这类思考方式来做了，虽然当你能够影响市场后，你的手段是不一样的，但是思路是没变的。\n\n最后还得反复说“不亏就是赚，亏钱的概率是很大的。大部分人就是没坚持下来的，千万不要光看网上一些大牛人都日赚斗金，行情没赶上也没关系，不亏就行”，别总想些“一鸣惊人”的。\n\n所以希望咨询我的人不要拿一个我大概率会“推荐你不要那么做的策略”再来问我了，谢谢，我解释的也挺累的了。\n","tags":["Undefined"]},{"title":"交易员的脑回路——在趋势面前判断市场究竟是否“合理”","url":"/2024/03/09/19/","content":"\n一般哪怕是做超短线，你最好还是有一个比较清晰的思路，至少大概率的认为市场回向某一个方向运动，你要说就坐在电脑前，跟着盘面随便走，这个事情以前也许可以，现在你做的不如量化程序。而且哪怕判断好了大方向，市场如何达到那个位置依然是个问题。他是直接向上一口气冲上去。还是充一半找一个平台歇一歇再接着冲，或者就是三步一回头都有气不同的策略和入场方式，很大程度上要通过动能和量来判断。\n\n冲的又快又猛，动能特别足的，大多都是消息面，一个天大的利好，大家都抢着进去，根本都没有什么对手盘挡你路，你就要激进，冲不进去就直接错过了，但如果市场一旦开始明显回头（消息刚出现十几秒内有可能会因为一些量化程序跑套利之类的程序没意识到有消息或者行情因此价格有短暂反复，那个不算）否则一般冲错了，赶紧出来保命。如果市场是三步一回头，磨磨蹭蹭，慢慢飘的。就不需要激进，等一个更好的价格再入场也不迟。如何判断动能又是一项独立的技能，无论你是通过量化程序拟合出潜在的类型，还是通过主观经验直接猜，很多时候都不是说你上来就能够判断对的。\n\n事实上你也不需要全才，我之前的文章里写的很清楚，你只需要在某一类市场能够保证赚钱，在其他类型的市场别大亏，你就能做的很好。想做成全才，一方面也是比较困难，另一方面经常会有三个手表，哪个时间最准的问题？到底是在同一个标的上同时做突破，又做箱体震荡，还是说你直接找很多个不同的标的一起看但只做突破（没突破就等）这个看个人。但我个人认为前一种比较难，前一种前期对盘面的理解也许并不需要投入太多，只需要专注一个或一两个标的，但是之后非常注重判断，而后一种你需要充分理解不同品种的盘面特征，但是判断起来相对来讲要简单。\n\n再比如说成交量也是如此。并不是说成交量高就一定好，这是一个适度的问题。一鼓作气，再而衰，三而竭。在市场上也很常见，因为市场背后对应的决策是一个个主体。哪怕是量化程序，他所学习的盘面，进行的回测，也大多是根据前人的主观判断特征而决定的。\n\n没怎么投入，就取得了很好的结果，就容易轻敌（很可能是大资金还没有相互角力），容易之后被反扑。如果已经投入了很多，成交最后哪怕是突破了这个关卡，你的军队也需要休整。不能说是围城了三个月，攻破之后马上就可以快马加鞭赶上下一个战场。反之，你要是投入了很多的成交量，又没见到结果，那是努力又没有结果，这非常容易让人打退堂鼓的。损失了很多兵力，又攻不下来。先不说有没有逃兵？有没有投敌的？无论如何大部队得退下来歇歇。这东西就和手机游戏上瘾是一样的，时常给你一点小的正向回馈大家的才会持续士气高涨。反映在市场上就是反复的“短期积累动能向上突破”，这种动能一般是确实强。\n\n我的意思是市场是走出来的，是买卖双方的实力变化决定的。而实力变化要符合自然界的一般规律，至少中短期（微观和长期另算）并不是纯粹的价格随机游走。但是我并不是说市面上没有例外，有可能市场可以不断投入，好似不知疲惫一路遇到很大的阻力都能冲高，但这并不常见。就好似战争，前线部队疲惫的时候需要大部队（长期资本，大资本）的扶持，而（市价单）攻城略地的同时也需要（限价单）来防止敌人偷袭。双方的限价单不够，就会出现chopping的状况，也就是虽然最后某一方也可能会胜出，但过程有可能就是双方你追我赶。你的动能，成交量，价格变化等一系列的因素最好要在一个恰当的区间，过多过少都会出现问题，而市场很可能不给你那么多恰当的机会，因此像视频当中那么清晰的机会，市面上其实是不多见的。\n\n如何判断是否恰当是一个动态调整的过程，很难去讲，需要根据当时的市场周期而定。你无论是主观也好，量化也好，你都需要不断的根据最近的情况而调整，而并非是一个长期绝对数。如果你要问判断恰当有什么意义，我认为假设市场长期来讲也是符合一个事务运行的基本规律。那某种意义上你需要对市场的涨跌做一个评分标准。假设价格是涨了，但涨得不恰当。那么这个例子可能是一个独立事件，当然也有可能是最近有很多这样的独立事件，但是以后你再重复这样不恰当的交易时候，就要保持警惕。但如果市场长期都在不恰当的基础上取得优秀的结果，那么可能你需要更新恰当所意味的指标。你要问判断出市场涨跌的评分有什么意义，我想他最差也能给你信心，在犹豫不决时的信心，如果你做量化它也可以是一个入场仓位设定因子。\n\n而另一方面，也有一些特殊的判断技巧。即使价格没有突破，但价格是否有粘性？即使市场三步一回头，但回头的步伐是不是比较固定？都是一些可取的参考目标。但市场那么大，机会那么多，尤其如果你做期货/期权还自带杠杆，并不涉及到股票那种总持仓时长，毕竟你也不是基本面交易。而基本面交易，尤其是价值分析，你要找的是别人埋没的黄金，那别人埋他肯定是有埋他的理由，你要等到他认错了，你才能给他挖出来说，哦，这是块黄金。巴菲特有体量和资金成本的优势，如果长时间没有人挖，巴菲特自己找人带着铲子和矿工下矿井挖给大家看，而你连个巴菲特的铲子都没有，怎么去重复他的辉煌呢，尤其价值投资，成长投资已经是一个非常拥挤的赛道了。唔，跑题了，我的意思就是说我认为做长期投资其实比做短期交易还要难，虽然股市风险要小。\n\n最后当然运气也是其中重要的一部分，市场也会出现兵不厌诈，或者你长期判断正确了，只可惜止损线放的太严，被震荡出场，或者说你恰巧就只有一次没有放止损，就那次恰巧就发生了黑天鹅。不过至少令人欣慰的是，这种黑天鹅你没料到，市场上其他一半的和你同样的人估计也没有料到，因此你不是唯一被埋的那一个，但反过来来讲，如果你知道你同样的队友也没有料到，你已知他们可能其中有一部分人要想出口跑，那你最好跟他们一块儿往出口跑，不要犹豫，不要再等待有没有转机。除非这价格已经迅速跌到一个非常低的位置，那么你可以说算了，我套牢了，但不要就闭眼不看了，选择增持来降低平均持仓成本仍有几率，虽然也要看你背后的标的类型，究竟能不能长期持有？有没有交割日/行权日？未来有没有翻盘的可能？毕竟人在每一步都只能做当下看起来最正确的决定，虽然长期来讲并不一定是最明智的。但谁也预测不了明年对不对。这是一个你有可能会后悔，也有可能会不后悔的决策。但假设你不后悔，也要牢记这次的教训。下次就不一定会照单重演。\n","tags":["Undefined"]},{"title":"技术分析究竟有没有用?感觉那么多方法，比如波浪理论，各种指标，太过主观化，运用技术分析是不是不可能成功?","url":"/2024/03/09/18/","content":"\n## 第一次更新\n\n支撑位（区间）/阻力位（区间）/整数关卡等一些列技术名词，以下统称为“技术点位”\n\n总结：其实，与其说是价格会在技术点位遇到反应，不如说是人们相信价格会在技术点位遇到反应，因此在技术点位附近提供了流动性。\n\n今天来谈技术分析到底有没有用，技术分析是一个比较尴尬的东西，大部分最初进入交易的人，一开始基本上都会去学，无论是主观交易的，还是量化交易的。在课上，尤其是那种面向初学者的短期集训，讲师会展示出许多通过技术点位精确地预测价格顶和底，准确的找到反弹的一些例图，然后大家都十分兴奋“啊，这个有用，啊，交易好简单，啊，我们迅速就能学以致用”，然后一上实盘亏得一塌糊涂。很多人这时迅速就开始骂爹骂娘，说“之前的例子都是讲师特意找出来的，技术分析有用的时候，那是千里挑一的情况，都是curve fitting”，然后就把技术分析扔到了垃圾桶。\n\n那问题来了，为什么一般上来都教技术分析呢？因为技术分析相对客观，对于初学者，你总得交给他们最基础的，比如怎么看蜡烛图（k线），怎么理解均线。那既然都讲到这了，为什么不同时讲讲k线组合，k线图形，macd，布林线？这些技术分析，相对来讲是最容易理解的，是最客观的，你总不能说“我做交易纯粹靠盘感，我觉得在这就该买/卖”吧。尤其是量化交易，更要有数理原则，根据大数定律跑回测来证实策略可行性，即使最开始的模型总是会cherry pick/curve fitting，但总需要个起点开始学习不是？\n\n稍微学学技术分析，然后去实盘看看的就会知道，有时候（30%）好像挺管用，但大多时候（70%）不管用。就算赔率是1比1，照这个胜率来看，赔到底裤都丢了只是个时间问题。那你说技术分析没用吗？不，其实是很有用，几乎所有的大顶和大底，都可以同时精确地匹配到数个技术分析都认同的交汇处，趋势的翻转可以说是“必然发生在技术分析所预测的点位上”。如果你是做量化的，很多人会认同价格是一个有一定规律的随机游走，并不会去考虑价格背后的“人”的因素，做量化就需要把价格模型化/数理化。很多人因此会去优化一些量化指标的参数，争取更好的找到顶和底。很多人会去考虑不同指标的confluence（交汇点），认为一个指标不管用，但如果很多指标都在这里交汇，那么管用的可能性会大一些。很多人可能会去对指标产生的信号做一些filter（筛选），不是指标提供的每一个买/卖都进行实际操作，而是筛选一些准确率高的。这基本上是通过绝对量化的，绝对客观的思路来看待价格，看待市场。毕竟主观是那么的不靠谱，历史回测数据看上去又是那么的真实，而且，无论如何，上实盘前你都得回测不是？但价格的本质究竟是什么呢？是科学的一种吗？\n\n事实上，决定价格波动的本质是“流动性与市价单的比值”，而相比于随机提供流动性，大家更倾向于在技术点位提供流动性。因此，与其说是价格会在技术点位遇到反应，不如说是人们相信价格会在技术点位遇到反应，因此在技术点位附近提供了流动性。这里的流动性，指的是挂限价单（花时间挂限价单在交易所，以期在未来一个更好的价格进行交易）。价格想要上涨，需要许多人用市价单（当下就买，不论价格）吃掉挂在交易所的限价单，在当下价格中找不到限价单的时候，价格就会上涨，去吃下一个价格的限价单。举个例子，我现在想用市价单买1000股茅台，假设茅台最后一次交易的价格是50元，有800股挂卖单在50元，有600股挂卖单在60元，50元到60元之间没人挂单。那么我会先吃掉800股挂在50元的卖单，之后吃200股60元的卖单，那么现在最后一次成交价就在60元，于是茅台就从50元上涨到了60元。\n\n现在，我们明白了价格波动的本质是“流动性与市价单的比值”，但什么决定了到底有多少人在这里挂单呢？不出意外，技术分析算出来的价格，会吸引人们向这个位置挂单。假如你是开小卖铺的，一个东西进价47.2，你想赚几块做利润，你会给这个东西标价到多少？是不是49.8？你本来已经想要在50块出售了，而技术分析告诉你，标价49.8会更容易出售，所以你就标价49.8，对不对？之前说到，几乎所有的大顶和大底，都可以同时精确地匹配到数个技术分析都认同的交汇处，这是因为技术分析让价格在这里转向吗？还是许多人本来就觉得这个价格附近可以买/卖了，只是在找一个更容易/更方便交易的价格？至于人们为什么会认为价格附近可以交易，其实我们并不容易得知。哪怕你认为股市是被操纵的，主力们和庄家们决定了价格涨跌，但是就对单一某个主力而言，他们实际也在试探其他主力的意图。\n\n技术分析，有时候（30%）好像挺管用，但大多时候（70%）不管用，这背后的本质，不是模型的精确性，也不是价格随机游走，而是人们/机器，对当前价格看法通过合力竞价进行的体现。价格几乎会在每一个重要的技术点位获得一定的阻力/支撑，但就价格是否会在这里转向，事实上比想象的更玄学。尤其是遇到突发（定期）新闻的时候，价格好像更容易在技术点位附近发生反应，与其说是数学和科学，不如说是在关键点位以外的流动性都撤单了，那些不重要的价格上的单子，几乎都在慌张和惊恐中，为了防止被市场踩踏而撤回了。只有那些重要技术点位上的单子，一部分出于对技术分析信念，一部分出于在更高时间尺度上对这个新闻的漠视，还会留在交易所等待执行（有很多长期资管，比如养老金或者巴菲特那样的长期投资人，并不会因为几周的价格波动而更改他们原先以年为单位的投资计划）。\n\n## 第二次更新\n\n提供几方面思考\n\n1.假设价格是有“庄家”（事实上就算是个股一般也是数个庄家共通使力，一个庄家一般hold不住）操纵的，那么请问你在什么位置操纵可以借力打力？是不是在流动性充足的地方做一个反弹成本会比较低？因为本来就有很多人准备在这里购入，你在这里做反弹，会不会有很多人跟单？如果你是一个挂单者，你看到价格明明已经马上就到你的目标区间了，但是价格突然有反弹的迹象，你是继续等还是追一波？假如你追高，不是不是帮助庄家借力打力？\n\n这至于流动性为什么会在技术分析区间比较充裕。上面已经提到，不再赘述。\n\n2.为什么在数个技术分析交汇的地方，反弹/反转的几率会比较大？想一想你用什么技术分析？你相信什么技术分析？别人是不是都跟你相信同样的技术分析？就哪怕是最简单的macd/rsi你至少还有参数可以输入不是？你所相信的技术分析并不代表其他人跟你一样相信。但是有许多技术分析交汇的地方，就代表有许多不同观点，用不同技术分析视角的人，有可能都得出了类似的结论，那么相对于普通的支撑阻力点，这里可能获得的支撑或阻力就以其他地方更多，相当于获得了更多的流动性。\n\n3.很多人认为技术分析也许是一个magic bullet是一个魔法一样的神奇金手指。事实上技术分析基本上都是利用了大数回归定律和统计学的sample分析。那么任何学过统计学的人都知道。你统计出来的结果，只能有一定的趋向性，不代表任何预测的结果。即使是数个技术分析交汇的地方，他也只是增大了在这个位置上反转的可能性。假设在一个随机的地方反转的可能性是50%，在这里也许只是65%，并不像你们可能想象的像电影中的那样。像个预言家一样，那么大的确定性。假如你的胜率和赔率是1:1，那么你不断地在胜率65%的位置交易。就会不断的积累小盈利。但问题是，绝大部分人做不到，胜率赔率1:1。而且如果你不断的赚10%，亏10%，再赚10%，亏10%，你的钱是会不断减少的，有没有听说过震荡损耗这个东西？一个东西先涨20%，再跌20%，它价格不是回到了原点，你是亏了的。\n\n4.为什么在危机时刻提供流动性是那么的重要？为什么你看现在国际成熟市场一般在危机时刻，央行直接出手干预，提供流动性？因为没有流动性，价格有可能跌到负数。但要在短暂的时间里面提供流动性。就有可能把长期的价格稳住。上面提到了，在危机时刻或大涨大跌的时刻，许多人也许在观望观望的结果就是，你可能会把你挂的单撤单。那么依然在某一个价位挂单子的人。肯定是有某种意图，或者某种思考，虽然这种意图或思考可能是错误的，可能是螳臂挡车。事实上，绝大多数大型订单基本都是冰山订单。但是即使有复数过冰山订单在这里堆积，看起来也是非常多的。哪怕有投行放一个，每一个切片200单的冰山订单。假设有五个投行都在这个位置附近挂了冰山订单，那么这个附近明示的挂单量依旧是可观的，即使隐藏的挂单量并不对外人显现。\n\n## 第三次更新\n\n**一些经典的策略到现在依然有用的本质。**\n\n很多人其实一直也没有搞明白，为什么很多最基础的东西到现在依然有用。就默认“以前有用的，现在也有用”，仿佛是祖宗之法不可变，甚至还有一些人认为具有数字浑然一体的精妙性，是自然界中伟大的数学传奇。**我想说，咱拿数学当科学没问题，但你拿数学当宗教就是另一码事了。**\n\n我这里给大家举一个我经常说的例子，为什么直到现在，在均线和VWAP之类的地方，会有精确到跳的支撑和阻力。有些人可能会发现，如果价格长期偏离均线或者VWAP，当价格久违的碰触到均线的时候，价格往往会有精确到跳级别的阻力与支撑。网上绝大多数文章将其解释为“交易员收到指令，需要将订单以优于均线/VWAP的价格成交”而导致的反抽。当然，这部分的内容说的也不算错误，但是在这里的订单实际由交易员执行的单量比你想象的比例要小很多。反而是量化执行的订单比例更大，大量的量化程序终于是在这里才达到了执行的要求。于是一开始本来不会有精确到跳的阻力与支撑，加入了大量的量化程序后，反而数值比以前更精确了。陷入了一种自我加强的循环，Self fulfilling prophecy。\n\n不是说什么之前有用的，现在依然有用，而是一部分程序员认为交易员在这里会介入而写出了一些量化程序+一部分程序本来就需要降低交易次数，因此只有当价格碰触到均线才会执行+一部分专注于数据挖掘的量化程序，发现了（由于前两种策略都会在这里执行）所以在这里执行成功率较高的特点而加入其中。与其说是交易员的行为导致了精确到跳的均线策略依然有用，反而是大量的量化程序自我锻炼反复加强使得这个策略变得更有用了。这个道理很简单，一想就明白，但很多人从来没有考虑过这些事情。这个例子当中，虽然结果是相同的，但过程是不同的。我只是想强调大家不要简单的就说某个东西失效了，某个东西还有效，更不要归结于什么天意和数字的精妙性，争取想一想背后失效和有效的道理，不要人云亦云。但显然很多人处于一知半解的“这个东西它有用所以用”的死循环。\n\n因此我一直都在建议主观和量化应该结合，并且推荐新手以量化的视角做主观。\n\n> 咱们先理解一个大前提。就是什么样的策略才是一个好的主观策略？你在什么样的情况才应该选择量化？你的主观到底在什么情况下才算是优势？下面是我的一家之言，你要是不认同也没问题。\n> 在你的系统和策略已经高度量化的基础上，你利用你对盘面的整体了解，对市场大环境的整体熟悉度，以及大量的情景训练，总结出的主观经验。利用你的主观经验为你高度量化的策略系统去伪存真，并利用一些市场微形态寻求更好的出入场时机的时候，你的主观交易才是一个优势。\n> 什么意思？意思是说你在做主观的时候，你的交易思路应该是已经基于一个相当量化的多因子决策系统，而你主观就主观主要在对于根据经验对不同因子比重的动态分配。既不是根据盘感的拍脑门，也不是根据一些技术分析的红灯停，绿灯行一样的机械操作，在这种基础上，你的主观才是优势。\n> 很多人喜欢在主观上找经验，然后把这些东西尽可能的量化，去跑量化程序来回测，或者直接就跑量化来挣钱了。但假设你的量化思路真的是基于你的主观经验，往往意味着你的量化程序跑的不如你用人脑判断那么仔细，相当于你的量化程序是你主观经验的弱化版。除非是你的主观经验并不存在，只是单纯的基于技术分析的红灯停，绿灯行。然后你希望让人脑的红灯停，绿灯行变成机器识别的红灯停，绿灯行。如果你的主观思路有很大程度上是基于对于大盘整体环境理解，对于市场当前状态的理解，对于突发新闻的理解，和对于市场反常态的理解，哪怕是出于“既视感”的盘感。这样的主观哪怕搞出来量化，这个量化也是他们主观思路的弱化。\n> 因此我认为用主观思路去做量化是不那么靠谱的。熟悉我的人知道，这是我从量化私募走向Prop交易并准备一路主观到底的主要原因。\n> 我认为反倒是你应该尽可能的从量化上找思路，然后把这些量化思路运用在主观经验上，以量化算出来的因子，尤其是那些你主观可能并不会意识到的有关联性的因子，用量化求得的样本集，让程序算出的高胜率或高赔率的交易区间，然后你在这个区间根据你对市场的大时代背景，根据盘面当时的运行情况。在量化系统出的信号之中，去伪存真，利用人脑在使用订单流分析，微结构等复杂决策方面的主观优势来增强你的进出场位置以及加减仓时机。这样我认为你作为人的主观灵活性才能被充分发挥出来。主观和量化的结合才能够相互提升，而不是相互干扰。正如我之前所说的，你把主观拿去做量化，量化是你主观的弱化。你拿量化做主观。主观是你量化的强化。\n> 上述内容的前提是你要有一套以多因子为基础的，本身已经高度量化思路在其中作为铺垫。你用量化的可回测性，作为你主观判断的基石。这样才能结合量化的稳定性，和主观的灵活性。单凭经验是不靠谱的，尤其是你在其中很难分清实力和运气的关系的时候，人们普遍的会认为量化会更靠谱。但是如果你有以量化的思路做主观，你会发现这个问题就迎刃而解了。\n> 我随便举一个最最简单的例子，方便大家理解。假如说你的量化系统主要是基于macd，那么就会涉及到敏感度越低，你出入场时机就越晚。敏感度越高，假信号就越多，这样一个无解死循环。有人可能会说，那我多加一些其他的判断因素。比如说根据atr调整macd的敏感度。通过ema来过滤一些macd的假反转。甚至根据成交量和rsi背离来进一步过率信号。以至于在其之上发展出动态多因子择时，因子权重动态平衡，波动率调节加减仓，watermark形式跟踪出场。但其实都不如你直接在macd出信号的时候看一眼，在macd和背离同时出现的时候看两眼，在动能和均线都符合预期的时候看三眼，然后你手动利用订单流分子挑一个合适的出入场时机，在明显遇到下一个阻力时直接放在最近的支撑位来的更稳定。当然你也可以不信我说的，或者认为我讲的不对。因为这只是我一个人一家之言。但如果你觉得我讲的有道理，不如听我一言，换一个角度看量化和主观之间的关系。\n> 而且我强调一点，上面提到的你量化的视角做主观最优的解法并不是你用眼睛去看背离，用脑子去想atr和rsi，而是量化系统已经出了信号，你看一眼线，你的量化系统就直接告诉你条件abd已经满足，但c不满足，你再主观判断一下有没有必要等c也满足，或者哪怕是abcd都满足，但是盘面走势不符合你的“预期”因此依旧按兵不动。并不是说你用脑子去跑量化运算。尽可能的还是要科技改变生活，而不是钻木取火，否则你累了一天也就只能关注一两个市场，不是吗？利用量化解放双手，释放脑力的优势并不需阉割不是吗。\n> 当然，事实上是我说的这些东西大多数人可能并不适用，因为大多数人可能就想要一个红灯停，绿灯行的系统。也不想费脑子，不想费精力学习，更不想就光区间突破，看上几百个例子，花上几百个小时高压练习。如果你不知道我在说什么，我有一篇文章叫做机构是怎样训练交易员和操盘手的文章，感兴趣的可以看一下。不过事实也是如此，人都是趋向于懒惰的。没有在机构中那样一个高压的环境，那样一个人人比拼宛如高考的激烈竞争，你可能真的也坐不下来，看几百个小时的实盘录像。但如果你想知道你究竟还差了点什么？或者哪方面可以更加精进？不如参考一下我提供的这条思路，你可能从未想过，但它其实存在。\n\n上述我还提到了，你要有一个大概的盘感，能够判断出市场走势和预期走势之间的差别是不是符合要求的。不是在任何盘面达到要求之后都做相同的操作，你应该对于实际情况有一定的主观取舍，这样你才是利用了主观对于处理复杂信息的优势增强了你量化的精准度。我在文章[交易员的脑回路——在趋势面前判断市场究竟是否“合理” ](https://skytravelar.github.io/2024/03/09/19/)里有详细展开讲过，感兴趣的可以看一眼。\n","tags":["Undefined"]},{"title":"以史为鉴，复盘解读2020年3月的各大类市场动荡（短线视角）","url":"/2024/03/09/17/","content":"\n文章主要包括，背景知识，实际发生的时间线，对金融市场的影响，相关启示。\n\n## 篇头\n\n以下的内容大部分都是我当年用英文写的复盘的一小部分，你们目前看到的版本是我直接用的GPT翻译的，我读了一下，翻译腔严重，但是都能懂，所以我就不重新用中文完全重写了。\n\n主要包括，背景知识，实际发生的时间线，对金融市场的影响，相关启示。由于2020确实已经离现在挺远了，有些当时理解后续发现并不适用于2022，为避免歧义于是我独自保留。一方面是实盘复盘日记其实没什么看的，你们也就是看个感叹/笑话，而且那几周我身处的位置不佳，所以没怎么赶上。所以只挑出来知识的部分。\n\n发出来主要是因为有人之前问了我一些当年的相关情况，但他们根本不熟悉当年的时间线，对很多基础情况凭简中的不完整信息乱说一通，我也没看到在简中网上有人整理过，我就发点吧，也算是知识性的补充。\n\n## 背景知识\n\nXX-19事件的开始的触发点是意大利3月8日在伦巴第地区实施“风乘”并取消威尼斯狂欢节。这一事件为其他国家设定了一个“样板”。因为在此之前，西方国家的人们普遍认为“风乘”是在他们国家是不可能的。这个触发事件类似于雷曼兄弟的破产。\n\n但是价格暴跌（争夺美元）的真正触发契机却是在一天后的2020年3月9日，当天俄罗斯（又是你！）强行退出欧佩克+，因为他们不想削减石油产量。（注：当时油价价格仅为40美元时，俄罗斯强退使油价继续下跌了9美元，隔夜时段下跌了30%，然后在下一个交易日又下跌了20%）。大量的原油仓位被追加保证金通知（注：margin call）带崩了本来就岌岌可危的权益类股票市场，而这触发了整个XX-19期间的首次跌停。\n\n随后在XX-19的恐慌期间，市场首先将高风险资产汇回到各国本国货币。因此，伴随着全球股市崩盘，英镑和欧元因为流动性紧张，他们的内币首先上涨。然后，随着情况恶化，他们的内币开始暴跌，因为所有人都开始涌入唯一安全的美元。随着XX-19变得更加严重，美元因流动性需求而走强，成为唯一强势的货币，直到美联储启动货币无限量互换解决了这一问题。美联储进行流动性互换之后，致美元走势出现大逆转。因为所有央行都可以从美联储借到无限量的美元，再没有了对美元的挤兑，美元开始走低。\n\n而当情况变得非常糟糕时，人们甚至会抛售黄金，唯一会上涨的是美国两年期国债，因为其在银行之间等同于现金，也是各大银行/投行向FED请求紧急注资的必要衍生品（国债价格不会上涨太多，更多的只是不会下跌）。但情况特别糟糕时，甚至十年期国债也会被卖掉以购买两年期，直到量化宽松来临。\n\nXX-19 期间金价下跌原因很多，包括但不限于“美元强势+通货紧缩风险+多头失望因为金价没有上涨+黄金的供需+3月之前已经有不少涨幅所以多头了结+多头头寸受到挤压+机构们为了满足其他更重要市场的保证金所以放弃外围边缘市场”。虽然事后可以解释得通，但是乱世中做空黄金，需要不小的胆量。\n\n准确的说，央行发布意外刺激措施通常不是完全出乎意料，当中央银行可能采取某些行动的日子里，你会听到人们谈论意外刺激的可能性。要知道有学者就以研究中央银行的行动为生，加上需要刺激前通常有领先指标的担忧迹象。无论如何，你会听到人们谈论意外刺激的可能性。\n\n比如信贷利差突然扩大（人们不愿意相互借贷），这可能会导致中央银行召开临时会议。在临时会议期间，你不会事先知道会议发生（举行）。他们通常会公布他们的决定，然后回溯解释他们为什么这么做，通常是意外的降息，但极端情况下也有QE。\n\n## 时间线\n\n美联储首次正式采取行动是在3月3日，但是杯水车薪，但此次行动并未阻止全球所有资产的恐慌抛售。\n\n于是FED取消并提前了原定于18日的FOMC会议，改为在15日周末直接宣布意外的降息决定 + 小QE（注：虽然我们现在管他叫小QE，但是实际上规模依然是很大的。只是说比起后来的无限量QE比起来，当时是小QE），但人们显然已经被吓傻了，当天美股依然跌停，全球对美元的需求只增不减。\n\n好巧不巧，其实当时欧洲央行这个猪队友在15日早些时候特意“隆重”地宣布他们将在今年一共进行1200亿欧元的QE（注：你可以大致理解为人行在危机时宣布临时降息0.05%那种感觉），这大大失望了市场，反而促成了当天的狂跌。迫不得已，美联储只能紧急召开临时会议（为欧央行擦屁股），宣布他们将每月进行1.5万亿美元的回购操作，来试图稳定全球市场，但即便如此，显然也不够，美元依然在暴涨。\n\n然后，美联储在19日开启了对所有央行的无限量货币互换和借贷，以保护全球所有其他国家经济体，避免经济影响继续扩散（注：美联储在19日以前就已经加大了货币互换量，但19日开始彻底宣布，如果有任何国家的央行想从美联储做货币互换或借贷，美联储都会不限量提供。美联储非但并没有趁火打劫要求惩罚性互换条件，借贷也没有要求借贷抵押物，完全是有求必应。整个2020美国事实上主动出手帮助稳定了全球其他国家的经济（注尤其是新兴发展中国家的经济体，避免了危机进一步发酵。美联储完全没有像是有些人恶意说的趁着危机“故意吸血”，事实上要不是美国主动出手阻止全球的系统性风险向新兴国家扩散，而真的选择了“从新兴国家吸血”，很多新兴国家到今天可能依然没处理完2020年的影响。当然美联储出手防止金融风险无序扩散当然也对美国有显著正面影响，也不只是利他主义）。（注：货币互换和借贷大部分是外汇sawp，之后是要还的。借的是SOFR basis swap，只不过当时美联储利率是0，所以swap也是无息的。由于还款时间也很宽松，所以可以理解为中长期的美元无息借贷。）\n\n此时（注：19日），美国十年期国债价格开始反转，因为国债市场开始预期后面还会有更大规模QE（注：就是我们常说的，“做国债的比做股指的要聪明”），但其他市场包括ES和欧元仍在狂跌。\n\n最终，美联储在23日推出了无限量QE，从那时起市场开始转变。在3月23日，美联储表示，他们将每天购买750亿美元的国债和500亿美元的MBS，时长无约束，金额无上限（注：也就是无限量QE）。\n\n## 市场影响（主要关于美股）\n\n好了，现在很多人可能说当时那么大好的机会，肯定都赚疯了吧。事实上有些同僚定是赚疯了，但也有不少同僚破产的。\n\n在俄罗斯之后，美股随着黄金下跌，但由于很多人还是抱着“逢跌就买”的心里，所以美股随后几天又上涨回来（注：现在看起来像是做了最后的挣扎），然后接下来继续下跌。\n\n在15日，仅在宣布小规模QE后15分钟，ES就跌停，并在接下来的几天继续跌停（注：抄底就是这样的，一般不是真的底，具体可以看我写的“论散户接飞刀”的文章，另外再次强调：虽然我们现在管他叫小QE，但是实际上规模依然是很大的。而在当时我们并不知道未来会不会还有QE，我们只知道这是一个超大规模刺激。谁也不能预测到未来还有无限量QE。）\n\n在15日宣布小QE的事后，美股出现了三次100点（400跳）级别的奇怪波动。当时美股还是隔夜时段，在开始时就是平开（注：现在回顾，在宣布QE后美股应该在15日跳高，但没有跳高的时候就应该小心。）隔夜时段开盘后，价格迅速上涨10秒，急速冲高100多点（但我们都期待价格远远不只会走100点）。可是冲高10秒后很快就陷入困境，然后在75秒内反向冲刺接近跌停价。而正当空头快乐时，价格突然又暴涨一分钟，几乎回到了第一波10秒中冲高的最高价格（而在过程中，许多多头甚至购买了更多以平均降低成本）。\n\n然后接下来的2分10秒内，美股下探跌停价并建立双底，然后突然又暴涨了一分钟（大概回到到最初10秒移动距离的一半那么多）。最后再次下跌，出现三重底，然后横盘了大概了1分钟。之后直线瞬间冲向跌停，而接下来的几天更是一直暴跌不回头。\n\n由于15日的行情如此复杂，不管是做多还是做空，都是过山车一样的盈亏，考虑到宣布QE——大幅震荡——跌停，整个过程一共也就10多分钟，而且三重底后之后马上就跌停了，再无逃跑机会。随后RTH时段开盘接着跌停，除非你在RTH竞价的时候就选择巨亏出场，但凡犹豫了，许多人就再也没有机会了，因为价格再次打开的一瞬间就会被强平，许多人其实就在这一波破产了。\n\n而且此时国债也非常不好做，在15日由于宣布了QE，因此美债价格是高开的（注：符合一般的预期），但是在开盘后的几分钟就被美股带崩，迅速调转趋势，急速冲低。股和债的走势在那几天成了完全正相关（注：一般人们普遍认为股债价格应该是逆相关运动的，但由于人们过于恐慌，所以国债不再是债，而是成了另一种“特殊”的大宗商品。）\n\n随后，在3月23日无限制QE公布时，美股15分钟内飙升了800跳，之后在高部横盘两个小时，然后依旧向下走向跌停。（注：是的，在无限制QE公布当天，美股依旧跌停了。这两次宣布QE的当天都是跌停，而且国债也依旧被带崩，模仿了美股的走势，先升、后降、再升，直到当天尾盘的时候才走出了“合理的走势”——因QE而收盘高于开盘价）\n\n美股真正的反转发生在第二天的24日，但在上涨途中仍然困难重重。在接下来的几天里，美股只回到了18日至20日的价格水平，在全球其他大类资产快速收复失地的时候，美股几乎横盘了一周。\n\n“在全球其他大类资产快速收复失地的时候”，是的，在23日无限量QE之后，其他的市场基本都涨了，只有一直普遍被认为是“冲高先锋”的美股一直在横盘，而在所有冲高的市场中，其中最佳的市场是黄金。\n\n最初在3月9日，俄罗斯退出欧佩克+后，黄金开始下跌。黄金在15日小QE时稍微反弹，但之后仍然下跌（注：对黄金而言是暴跌，和美股走势一致，这有违乱世买黄金的一般理念）。但从19日到20日的时候（注：美元不再稀缺），黄金就已经开始稳定并保持。\n\n在23日无限量QE后，黄金开盘直线上涨，两天内上涨超过2000跳。在三天内就恢复到俄罗斯退出之前的水平，形成了强大的多重趋势性动能。\n\n搞笑的是，恐慌性抛售了黄金那么多天，爆了那么多仓，但它在两天半就收回了整个XX-19期间所有跌幅，第三天就开始创新高。事实上在23日的QE之后，黄金保持了以周为单位的单边直线上升，全程几乎没有出现过大回调。\n\n剩下外汇、国债、大宗商品的情况都差不多，本质也都是“做了符合美元走跌的情况下该有的走势”，其中国债的上升也较为坎坷，但比起美股来讲还是清晰的多。\n\n但当时我被迫遵循家里长辈的强烈要求，所以那两周都在PEK“蛤蜊”，我就带个笔电回来，就两块屏幕，然后“蛤蜊”还不是单间，网还差的要命，因此要不然也不会在电脑前，一样会错过这一波。而且我的自有资金账户已经被限制交易了（没爆仓，但是被risk desk flagged，我最大仓位只有之前的四分之一），而另一个做套期保值账户的资金很大部分不是我自己的，只能委托看管，不能乱动。如果在电脑前，感觉ES的日内第一波，黄金和外汇的第二波我应该会抢进去，应该还是有大幅盈利的。但之后连“pf!zer”那一波也因为我的negligence，直到用手机在WX的新闻上看到，再打开电脑就实在是太迟了，就，就有点难受，虽然当天晚些时候和后续两天还是吃到了点……所以晴天雨天，哪怕不出海，最好也别筛网……话又说回来，YOLO的30不打游戏，难道等60打吗？老年电竞队打得过谁？\n\n还有额外两点想说的\n\n- 在极度波动的时期，很难解释市场为什么没有做”明显正确的事“。所以，在极度波动的时期，不要试图理解为什么，也不要基于逻辑交易。只需接受市场行为极其古怪。顺应市场流动而非逻辑，因为在恐慌期间逻辑是无效的。\n- 在危急时刻，国债的第一波反映总是难以预测。比如2022年3月，在鹰派美联储的背景下，国债应该下跌。但如果市场认为美联储变得过于鹰派（这会损害经济，同时面对欧洲潜在xx扩大的可能性），那么国债价格实际上会上升，作为避险操作。这是一个非常微妙的平衡，你必须谨慎行事，很难准确判断“如果说了什么，市场就会认为美联储变得过于鹰派”。虽然股市的走势更明确（无论美联储多么鹰派，只要不鸽派，总会下跌），但争夺成交的竞争更激烈。\n\n## 题外话\n\n无限量QE光国债就是是每天买750亿美元，而当FED当年在2010年为应对2008的第一次QE时，每月QE的量还没有2020年一天QE的多。\n\n俄罗斯实际上引发了2020年和2022年恐慌的抛售。\n\n意大利你好的不学，净学些罪大恶极的，之前欧债危机你也是头一号（注：欧债危机主要也是意大利，希腊经济总量非常小，所以风险非常可控。但意大利要是暴雷，欧元区肯定是保不住的，意大利是欧元区第四大（现在是第三大）经济体，而希腊gdp规模在欧盟只是第16）。\n","tags":["Undefined"]},{"title":"中南大学机器学习课程第二次作业","url":"/2023/11/14/16/","content":"\n# 逻辑回归\n\n回归，是指假设一个模型，设定一些参数，计算合适的参数以拟合逼近现有数据。\n\n#### Linear Regression\n$$\nh_\\theta(x) = θ^Tx+θ_0\n$$\n\n#### Logistic Regression\n$$\nh_\\theta(x) = g(θ^Tx+θ_0) = P(y=1|x,θ)\n$$\n\n\n线性回归用一条直线模型去拟合数据，用来确定两种或两种以上变量间相互依赖的定量关系\n\n逻辑回归计算样本属于某个标签的概率，构建一个分类边界，用来对数据进行二分类或者多分类。\n\n上次实验我们用梯度下降训练了一个线性回归模型，这次我们实现一个逻辑回归模型来进行二分类的收入判断任务。\n\n##### 注意事项：\n本实验可能用到的函数：`np.mean`, `np.std`, `np.add`, `np.sum`, `np.mutual`, `np.dot`\n\n本实验大部分变量为numpy array的数据类型，在计算时尽量化为numpy array类型进行计算\n### 任务一：读取和预处理数据\n第一步导入数据。压缩包中的train.csv中存储了原始数据，每人拥有年龄，工作类型等14个维度，共32561个样本。最后一个维度为本次实验的label，即收入是否大于50k。\n\n做机器学习应用的时候很多时间是花费在特征处理上，我们注意到原始数据存在许多维度为非数字的数据，是不能直接用于构建模型的。我们可以通过离散化，把一个维度扩展到多个维度。如教育程度：（小学，初中，高中+）可以被扩展到如下三个维度：小学学历（是，否），初中学历（是，否），高中学历以上（是，否）。\n\n经上述处理后的数据存储在X_train文件中，每个样本的维度被扩展到了106维，本实验直接使用X_train的数据构建模型。\n\n```\nimport numpy as np \nfrom matplotlib import pyplot as plt\n\ndef getdata(X_train,Y_train):\n    X = np.genfromtxt(X_train,delimiter=',',skip_header=1) #32561个样本*106个特征\n    Y = np.genfromtxt(Y_train,delimiter=',',skip_header=1) #32561个label\n    return X,Y\ndef shuffle(X,Y):\n    #打乱X,Y,避免数据存在初始的排序，影响训练效果\n    randomize = np.arange(len(X)) #不同的库用的不太一样，返回的对象也不太一样。python自带的range()不支持numpy的shuffle\n    np.random.shuffle(randomize)\n    return (X[randomize], Y[randomize]) #ndarray的参数是数组时，返回一个依参数排序后的数组    \ndef train_test_split(X, Y, test_size=0.1314):\n    #按一个比例分出一部分验证集\n    train_len = int(round(len(X)*(1-test_size)))\n    return X[0:train_len], Y[0:train_len], X[train_len:None], Y[train_len:None]\nX,Y = getdata('X_train','Y_train')\nX, Y, X_test, Y_test = train_test_split(X, Y)\nX.shape \n```\n\n```\n(28282, 106)\n```\n\n### 任务二：数据归一化\n归一化把每个特征的数据映射到0到1之间，消除指标之间的量纲影响，同时可以避免某些特征对模型预测结果的影响过大。\n\n常用的归一化方法有两种：\n\n一是利用最大最小值(min-max 归一化)；\n\n二是利用平均值方差(z-score 0均值标准化)。\n\n一般来说0均值标准化调整了数据的分布，使之更易于训练。\n\n```\ndef normalization(X):\n    \"\"\"\n    将X中的数据映射到0-1之间\n    参数：\n        X:数据\n    返回：\n        归一化之后的X\n    注意：\n        测试在只归一化0,1,3,4,5,7,10,12,25,26,27,28列特征时，效果会比较好\n        具体原因可探讨\n    \"\"\"    \n    ### START THE CODE ###\n    for i in [0,1,3,4,5,7,10,12,25,26,27,28]:\n        mu = np.mean(X[:,i], axis=0)\n        sigma = np.std(X[:,i], axis=0)\n        X[:,i] = (X[:,i]-mu)/sigma\n    ### END THE CODE ###\n   \nreturn X\n\nX = normalization(X)\nX_test = normalization(X_test)\nX[:1]\n```\n\n```\narray([[ 0.02997349, -1.06586717,  1.        ,  0.14215522, -0.21607549,\n        -0.03383413,  0.        , -0.26256323,  0.        ,  0.        ,\n        -0.1885562 ,  0.        ,  4.9041296 ,  0.        ,  0.        ,\n         0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n         0.        ,  0.        ,  0.        ,  0.        ,  1.        ,\n        -0.11434365, -0.69111392, -0.23540742, -0.03992059,  0.        ,\n         0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n         1.        ,  0.        ,  0.        ,  1.        ,  0.        ,\n         0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n         0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n         0.        ,  0.        ,  0.        ,  0.        ,  1.        ,\n         0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n         0.        ,  0.        ,  0.        ,  1.        ,  0.        ,\n         0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n         0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n         0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n         0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n         0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n         0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n         0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n         0.        ,  0.        ,  1.        ,  0.        ,  0.        ,\n         0.        ]])\n```\n\n### 任务三：完成sigmoid函数\n\nsigmoid funtion函数原指曲线是 “S”形的函数，logistic function则指满足某个公式形式的一系列函数。\n在机器学习中，其一般特指以下函数（standard logistic function）：\n$$\nf(x) = \\frac{1}{1+e^{-z}}\n$$\n\n```\ndef sigmoid(z):\n    \"\"\"\n    参数：\n        z\n    返回：\n        sigmoid(z)\n    \"\"\"   \n\n    ### START THE CODE ###\n​    s = 1 / (1 + np.exp(-z))\n    ### END THE CODE ###\n\nreturn np.clip(s, 1e-6, 1-1e-6)\n#clip:重要的处理，将超出范围的值强制置为边界值，避免y_pred为0，从而导致下面交叉熵损失无法计算\n#aeN: a*10的N次方\n\nsigmoid(0.5)\n```\n\n```\n0.6224593312018546\n```\n\n### 任务四：完成交叉熵损失函数\n$$\nJ(\\theta)=-\\frac{1}{m}\\sum_1^m[y^ilog(h_\\theta(x^i))+(1-y^i)log(1-h_\\theta(x^i))]\n$$\n\n损失函数用于评价模型预测同实际情况的差异，越小说明预测越准确。\n\n概念上, 损失函数针对单个样本，代价函数针对总体。但作为优化目标时二者无不同。\n\n交叉熵数学意义上衡量的是两个概率分布间的差异，本实验以交叉熵损失为优化目标函数。\n\n```\ndef cost(y_pred, y_label, m):\n    \"\"\"\n    代价函数，这里计算的是所有样本损失函数的和\n    参数：\n        y_pred：模型预测的值\n        y_label：数据实际标签的值\n        m：数据的样本数\n    返回：\n        cst: 预测值同标签值之间的代价\n    \"\"\"   \n    ### START THE CODE ###\n    cst = -np.sum(y_label * np.log(y_pred) + (1 - y_label) * np.log(1-y_pred)) / m\n    ### END THE CODE ###\n    \nreturn cst\n\ncost(0.4,0.6,1) #numpy的log以e为底\n```\n\n```\n0.7541046886308893\n```\n\n### 任务五：构建逻辑回归模型\n$$\n\\hat y=sig(θ_1*x_1+θ_2*x_2+...+θ_n*x_n+θ_0)\n$$\n\n接下来先设置模型所需要的参数，可以自己修改观察对模型的影响。\n\n对于样本的偏置θ0，有两种处理方法：\n一种是作为一个维度添加到array θ上，相应样本也要添加一个值全为1的维度；\n\n一种是单独拿出来更新，在梯度下降时分别处理。\n\n本实验采取的是第二种方法。\n\n最后完成模型所需的两个基本函数predict，和accuracy。\n\n```\ndef predict(X, theta, theta_0):\n    \"\"\"\n    预测\n    参数：\n        X：样本特征\n        theta：权重参数 \n        theta_0: 偏置参数\n    返回：\n        Y_pred: 样本的预测值 0~1\n    \"\"\"      \n    ### START THE CODE ###\n    theta = np.array(theta)\n    Y_pred = sigmoid(np.dot(X,theta) + theta_0)\n    ### END THE CODE ###\n    \nreturn Y_pred\n\ndef accuracy(Y_hat, Y_label):\n    \"\"\"\n    准确率\n    参数：\n        Y_hat：样本最终分类 0 or 1\n        Y_label：样本标签\n    返回：\n        acc: 分类准确率\n    \"\"\"      \n    ### START THE CODE ###\n    acc = np.sum(Y_hat == Y_label) / len(Y_label)\n    ### END THE CODE ###\n    \nreturn acc\n\npredict([0.4,0.8],[0.1,0.2],[0.15])\n```\n\n```\narray([0.58661758])\n```\n\n### 任务六：用随机梯度下降算法训练模型\n全样本的梯度下降，在样本过大时，更新一次参数会需要巨大计算量。我们可以每次从中随机取出一定大小的样本，进行小批量随机梯度下降。\n随机取样部分已完成，只需根据样本梯度下降更新参数即可。\n\n根据我们的优化目标（默认为交叉熵），对损失函数求导，得到梯度计算公式为：\n$$\n(h_\\theta(x^i)-y)x^i\n$$\n$θ，θ_0$更新时分别处理\n\n```\ndef gradient_descent(x_bt, y_bt, theta, theta_0, learning_rate):\n    \"\"\"\n    用每次取出的一个batch的数据训练模型\n    参数：\n        x_bt:本次更新所用样本\n        y_bt:本次更新样本的标签\n        theta,theta_0：模型参数\n    返回:\n        theta:更新后的theta\n        theta_0:更新后的theta_0\n    过程：\n        用theta,theta_0进行一次预测\n        计算预测误差\n        计算theta, theta_0各自的梯度，取均值\n        用梯度更新theta_0和theta\n    \"\"\" \n\n    ### START THE CODE ###\n​    pred_error = predict(x_bt,theta,theta_0) - y_bt\n​    theta_grad= np.mean(np.dot(pred_error ,x_bt),axis = 0)\n​    theta_0_grad= np.mean(pred_error)\n​    theta = theta - learning_rate * theta_grad\n​    theta_0 = theta_0 - learning_rate * theta_0_grad\n    ### END THE CODE ###\n\n    return theta,theta_0\n\ngradient_descent(np.array([[1]]),np.array([1]),np.array([0.2]),np.array([0.1]),0.02)\n```\n\n```\n(array([0.20851115]), array([0.10851115]))\n```\n\n```\n#模型的基本参数：\ntheta = np.zeros(X.shape[1],) #106个权重参数，初值全为0\ntheta_0 = np.zeros(1,) #1个偏置参数，初值为0\n\n#训练参数\nmax_iter = 80 #迭代次数\nbatch_size = 32 #随机梯度下降中每次取样个数\nlearning_rate = 0.02 #学习率，可以尝试不同的学习率，如0.2、0.002、0.0002\nnum_train = len(Y)\nnum_test = len(Y_test)\n\ndef train(X, Y, theta, theta_0, max_iter, batch_size, learning_rate):\n    #用于记录训练中损失和准确率的变化\n    train_cost = []\n    test_cost = []\n    train_acc = []\n    test_acc = []\n\nfor epoch in range(max_iter):\n    X, Y = shuffle(X, Y) #随机打乱各行数据，这样参数不易陷入局部最优，模型能够更容易达到收敛。 \n    for i in range(int(np.floor(len(Y)/batch_size))): #每个batch更新一次\n        x_bt = X[i*batch_size:(i+1)*batch_size] #32个样本*106维\n        y_bt = Y[i*batch_size:(i+1)*batch_size] #32个label\n        #每个batch的样本更新参数theta,theta_0\n        theta,theta_0 = gradient_descent(x_bt,y_bt,theta,theta_0,learning_rate)\n    #记录每个epoch更新后，训练集上损失的变化和准确率的变化\n    Y_pred = predict(X, theta, theta_0)\n    Y_hat = np.round(Y_pred)\n    train_acc.append(accuracy(Y_hat, Y))\n    train_cost.append(cost(Y_pred, Y, num_train))\n    #记录每个epoch更新后，测试集上损失的变化和准确率的变化\n    Y_test_pred = predict(X_test, theta, theta_0)\n    Y_test_hat = np.round(Y_test_pred)\n    test_acc.append(accuracy(Y_test_hat, Y_test))\n    test_cost.append(cost(Y_test_pred, Y_test, num_test))\n    \nreturn train_cost,test_cost,train_acc,test_acc\n\ntrain_cost,test_cost,train_acc,test_acc = train(X, Y, theta, theta_0, max_iter, batch_size, learning_rate)      \nlen(train_cost)\n```\n\n```\n80\n```\n\n### 任务七：观察模型在训练集和验证集上的表现\n用matplotlib(plt)里的方法生成图表，观察随着迭代进行，模型损失和准确率的变化\n\n```\n#子图1：损失\np1 = plt.subplot(121)\np1.plot(train_cost)\np1.plot(test_cost)\np1.legend(['train', 'test'])\np1.set_title(\"cost\")\n\n#子图2，准确率\np2 = plt.subplot(122)\np2.plot(train_acc)\np2.plot(test_acc)\np2.legend(['train', 'test'])\np2.set_title(\"accuracy\")\nplt.show()\n```\n\n### 样例输出\n由于训练过程有一定随机性，训练结果可能存在不同\n","tags":["机器学习"]},{"title":"货币的最终答案","url":"/2023/10/19/15/","content":"\n# 说在正文前\n\n本文首发的时候恰逢新冠疫情爆发，当时黄金约1400左右。然后是资本市场段时间内去杠杆，黄金也迎来了一波下跌。然后评论区质疑的有之，阴阳怪气的嘲讽的有之。后来我了解了一下，最多持有黄金的也只持有了40天左右。所以其实为了造成不必要的误会，先申明下，本文不构成投资建议，如若据此操作后果自负。\n\n比如这次美元最差也是失去东亚锚，最严重的结果是失去算货币地位。不管什么情况，美股都会暴跌，然后黄金也会经历一波去杠杆下跌。这个时候一些杠精肯定会阴阳怪气说黄金跌了赶紧买啊之类。但是市场上肯定有意志坚定的长期投资者买入。不过我很清楚，这种投资者比例太小。所以还是这个申明，本文不做投资建议，据此操作后果自负。\n\n互联网现在的算法非常符合“奶头乐”的定义，明显是一个短期刺激而缺乏长期考量。热点过后，流量已经变现失去了价值，那么之后就很少有人再去回顾。\n\n# 正文\n\n黄金的价格其实是两个因素决定的。第一个就是工业因素，比如黄金能补牙啊，黄金能做5g芯片的原料啊。这个由供求关系决定。还有一个因素，就是货币因素。也就是说，当信用货币失去信任的时候，黄金会显示出作为最终货币的价格。但是在美元大行其道的太平年间，这个因素被掩盖了，那么黄金基本上也就只表现出工业因素的价格。\n\n大家都是生活在信用货币年代的，没有经历过货币信任危机的事件，其实上一次货币面临信任危机的时候是第二次世界大战。\n\n逻辑也好解释，货币面临信任危机，那么当时的统治阶级基本上就要到头了。这时候不搏一把，就要被民众吊在广场上了，至于能不能赢都是第二位的。\n\n现在美国的统治阶级面临的是同样的问题，美元的两个锚，石油锚和东亚锚。其中东亚锚中国已经有退出的意思了。现在东亚锚的结算量基本上是石油锚结算量的五六倍。如果彻底失去了东亚锚，那么美元就黄了。\n\n如果美元黄了，世界就事实上失去了结算货币。这时候只有黄金出来，给各国货币作背书，世界贸易才能继续下去。这个其实是阳谋，看一下这几年各国已经在偷偷的往自己央行里面存黄金了。\n\n大家都在为，美元失去结算货币地位的情况做准备。\n\n其实从贸易战开始，中国就开始有步骤的退出东亚锚了。现在美国为什么不敢大规模量化宽松美元？因为以前有中国的东亚锚作为背书，量化宽松出来的美元有购买力。但是现在中国要退出东亚锚了，这时候美元的量化宽松却不会相应的增加购买力，只能敲响美元的丧钟。美国本土势力的诉求只有一个，就是让我们加强东亚锚。但是我们中国的态度很坚决，绝对不给美国背锅。那么很明显了，失去了东亚锚的情况下，美元丧失结算货币地位只是时间问题。期间美国肯定会有战术性动作，那就是收割一把欧洲或者日本等等。但只要中国坚决退出东亚锚，美元的结局就已经注定。那么到时候世界结算秩序，就只能由黄金来维持。各国的货币通过不同的途径挂钩黄金，由黄金给货币背书，然后用类似货币互换的方法保持贸易。\n\n黄金还有一个孪生兄弟，白银。黄金实在是各方争夺的焦点，太引人注目了。但是白银分布太广泛，美洲+澳大利亚，银矿储备占了世界的60%以上。\n\n当世界重构结算制度的时候，美元很可能挂钩白银，形成银本位稳定市场。\n\n以上，就是世界各国本土势力，应对危机很可能的保全之道。\n\n最后讲一下一个奇葩，那就是犹太势力力推的数字货币（比特币等）。\n\n大家看一下，比特币这样的货币其实就是用数字模拟了黄金的所有特性，包括总量一定，不可更改等等。黄金是天然稀缺性保证了信用，比特币是利用数字规则保证了稀缺性，从而保证了信用。犹太势力人为的把比特币“制作”为黄金最大的对手，因为数字化结算成本远远低于黄金。但是目前来看，我国央行是不支持比特币的。没有了中国的支持，比特币只能在西方结算体系中自娱自乐了。\n\n# 补充\n\n这里增加一下我对比特币等数字货币的理解。其实作为这些数字货币的底层技术区块链等，是非常的有前景的技术，我国已经将数字人民币法币化了。但是犹太势力发明这种技术的初衷是让比特币匿名洗钱转移资产的作用。就单纯的比较而言，比特币等数字货币的规则也能保证比特币的稀缺性和不可篡改，基本就是完美模拟了黄金的天然属性。因为央行黄金储备啊包括金矿什么的都在本土势力那边，在这种世纪大变局下，犹太势力可不想让黄金这种不在自己控制范围内的东西抢了风头。而且从实际交易来看，比特币这些数字货币已经表现出了优于黄金的一些特点，比如银行结算体系（现在很多欧美银行都支持比特币结算）等。马斯克等大佬也支持特斯拉用比特币结算。黄金么，你弄块金砖去做交易，不说路上被抢的风险，光检测真假就能烦死你。\n\n最关键的，我国央行已经反复表态了对比特币的态度，那就是反对。那这就明确了，在实物黄金和数字黄金的站队中，只要我国（东亚锚）站队了实物黄金，基本上就代表了本土势力这边会胜出了。\n\n就现在的情况来看，目力所能及，所有的因素都在支持黄金王者归来。\n\n想起了那句朴素的话，是金子，总会发光的。\n\n# 20220320\n\n中国鼠年后，俄罗斯对乌克兰开始军事行动，实际上这就是挑战美国霸权了。\n\n美国也用了非军事手段外最严厉的措施，关闭俄罗斯几大银行的swift系统。\n\n现在乌克兰战争基本到了尾声，**基本可以确定俄罗斯获胜了**。俄罗斯胜利就等于动摇了美国军事霸权，动摇了美国军事霸权就等于动摇了美元的结算地位。而我们中国，则开始了内循环，不在以外贸赚取美元为目标。那么在东亚和欧洲两个方向，美元的地位都被动摇了。这次美元的加息，是美国本土势力最后的自救动作，极力想挽回美元的信用。但可以肯定的是，巨额的国债决定了这次加息只能以失败告终。从国债利率倒挂已经可以看出，加息对资本并没有产生多少作用，**那么2022年美联储只能停止加息，然后降息加扩表。这个时候国际资本将抛弃美元，疯狂的买入可以保存价值的产品。**中国和俄罗斯资产肯定是选择之一，但是在这个新老交替的时候，国际资本还不敢过于重仓中国和俄罗斯（沙俄时期曾经有没收犹太资本的动作，所以名声一直臭到了现在。）那么现在最值得信任的，仍然是古老的黄金。\n\n现在各国本土势力基本上通过央行在购买黄金，国际资本则想办法在交易中心交割黄金。但黄金现存开采出的总量一共有多少？有个传说，国际标准的游泳池，世界上的现存黄金加起来只能填满五十个这样的游泳池。黄金一共就这么多，加上央行放在金库里面的，世界上流通的可以交易的黄金有多少？现在能买到的就是赚到。\n\n再说一下比特币。犹太势力曾经也做过美元失去结算地位后的预案，那就是大肆宣传的数字黄金比特币。说实话，技术上比特币已经完全具备了黄金的所有特点，然后还得到了犹太势力的银行的认可。但最麻烦的是中国没有接受这样的预案，反而宣布比特币非法。我是建议我的读者不要碰比特币的，后面虽然肯能还会涨，但说不定什么时候泡沫就破了。\n\n最后说一下，本文不指导投资问题。\n\n# 20220624\n\n现在局势的发展，大体上都是按照这个脉络在走。俄罗斯在冲击世界结算秩序的欧洲部分（连带中东），中国的外汇储备也在持续降低，美元在慢慢退出世界结算货币的地位，而黄金在1830的位置等待着王者归来的时刻。\n\n回顾一下，俄罗斯突袭乌克兰，实际上就是一个目的，**冲击现有的世界结算秩序之欧洲部分。包括突然宣布天然气用卢布结算，这无疑是动摇了美元全球体系下的欧洲结算秩序。**卢布吃下美元的份额后，一部分美元开始回流美国本土，这直接导致了美国通胀失控，美联储别无他法只能狠心的加息。而这些，我在2020年美国疫情大放水的时候，就预测到了。。。\n\n而现在美国严厉加息的时候，**我很确定，今年年底左右，美联储就会结束加息，转而重新大放水。**\n\n**说到根本，加息保的是美元，而宽松是保美国现有贵族的指正地位。**当然，美国肯定是两个都想保。但明显了，俄罗斯在乌克兰那边已经动手了，而且美国还不敢用军事手段，所以再怎么加息，美元的欧洲体系是肯定保不住了。很简单么，你不能用金融手段解决军事问题。加息已经把美国国债收益率加到了3%以上了，但俄罗斯还是能让石油价格继续上涨（控制了供给端，所以你怎么加息都没用。）再这么下去就要国债违约了。而且现在中国还没正式冲击亚洲结算体系呢，还不如乘美元现在还值点钱的时候，疯狂宽松降息，保住国债和美股不崩盘，而美元的地盘，在中俄的军事冲击下，只能放弃了。。。。。\n\n那么，降息和扩表需要一个理由，**那就是原油价格下调。而要调整原油价格，就只能跟俄罗斯妥协**，喜剧同志估计这次要杯具了。跟俄罗斯妥协后，俄罗斯事实上把乌克兰纳入势力范围，然后基本上就是慢慢登顶欧洲之王的位置了（标志性事件，欧洲全部用卢布结算天然气）。\n\n中国这次选择余地更大，很可能不用军事手段冲击美元结算地位，而是等待世界失去结算秩序以后虹吸资本。。。。\n","tags":["禁评"]},{"title":"中南大学学习通毛概章节测试答案","url":"/2023/10/17/14/","content":"\n# 【2023年秋季】毛泽东思想和中国特色社会主义理论体系概论\n\n**第一章 毛泽东思想及其历史地位**\n\n**1.1**\n\nA C ABC\n\n**1.2**\n\nC B B\n\n**1.3**\n\nABC ABC ABC AB\n\n**1.4**\n\nABC ABCD B\n\n**1.5**\n\nABC B A\n\n**第二章 新民主主义革命理论**\n\n**2.1**\n\nB C A ABC\n\n**2.2**\n\nA B B C ABC\n\n**2.3**\n\nABD BCD AC AB\n\n**2.4**\n\nA A D AB\n\n**2.5**\n\nC B D\n\n**2.6**\n\nD ABC\n\n**第三章 社会主义改造理论**\n\n**3.1**\n\nABC ABCD B B\n\n**3.2**\n\nABCD ABC AB C\n\n**3.3**\n\nB C C D\n\n**3.4**\n\nABC ABCD D\n\n**3.5**\n\nABCD C C\n\n**第四章 社会主义建设道路初步探索的理论成果**\n\n**4.1**\n\nBCD C C B 错\n\n**4.2**\n\nACD ABCD BD ABD B\n\n**4.3**\n\nABCD B D 错 对\n\n**4.4**\n\nABCD ABD ACD A A\n","tags":["毛概"]},{"title":"拉萨尔幽灵的再现","url":"/2023/10/12/13/","content":"\n苏修集团近年来翻来复去地要求苏联人民为“提高福利”而“不懈劳动”。勃列日涅夫喊得尤为起劲，今年六月他在莫斯科说，劳动是“获得福利的唯一源泉” ;去年七月在基辅讲,“只有劳动才能为我们保障生活福利”;去年九月又到乌兹别克鼓吹“提高苏联人的福利”的“可靠途径是劳动、劳动、劳动”。\n\n苏修其他领导人和报刊的这类言论也到处可见，什么“福利的来源只有一个”，“这就是劳动”，“提高人民福利的途径除了劳动再没有别的办法”，等等。\n\n苏修领导集团这一套谬论是早在苏修二十四大上就定下的。翻开苏修二十四大的文件，在《关于一九七一～一九七五年苏联发展国民经济五年计划的指示》中，就有“劳动是财富的源泉”，只有劳动越多，福利才越多的十分荒谬的说法。提起“劳动是财富的源泉”和“劳动是福利的唯一源泉”，不能不使人想起机会主义的祖师爷拉萨尔。他早在一百多年前就提出了“劳动分工是一切财富的源泉”的谬论。  之后《哥达纲领》这一机会主义文件又一次贩卖了这一黑货,胡说什么“劳动是一切财富和一切文化的源泉”。当时就受到伟大的无产阶级的革命导师马克思和恩格斯的痛斥。\n\n**马克思明确指出,“劳动不是一切财富的源泉”,劳动者只有“事先就以所有者的身分来对待自然界这个一切劳动资料和劳动对象的第一源泉，  把自然界当作隶属于他的东西来处置，他的劳动才成为使用价值的源泉，因而也成为财富的源泉”。马克思在《哥达纲领批判》中一针见血地指出，拉萨尔谬论的要害，正在于对谁占有劳动的物质条件，即生产资料归谁所有这一根本条件避而不谈。**在当年德国无产阶级同资产阶级的矛盾日益尖锐的情况下，号称“马克思的学生”的拉萨尔竭力在工人中宣扬劳资合作，竭力欺骗和蒙蔽工人阶级，要他们不去注意生产资料归资本家占有这一事实，而埋头为资产阶级卖命劳动。\n\n事隔一百多年，拉萨尔的幽灵在克里姆林宫再现了。在资本主义已经复辟了的苏联，这原是不足为怪的。**同样号称“马克思的学生”的勃列日涅夫之流如今大吹大擂地贩卖拉萨尔的破烂货，是和拉萨尔一样，妄图用劳动的空谈来掩盖苏联日益尖锐的阶级矛盾，强迫人民卖命为苏修叛徒集团劳动，以维持他们的反动统治。在苏修叛徒集团的统治下，苏联的广大劳动人民早已失去了生产资料，失去了作为国家主人所拥有的最根本的权利，重又成为雇佣劳动者，遭受一小撮官僚垄断资产阶级的残酷剥削和压榨。**近年来，苏联劳动人民采取各种形式反抗苏修的统治，旷工、罢工和消极怠工，以及大量的工人流动，已给苏修经济造成巨大损失。\n\n据苏联《劳动报》报道，由于青年工人大量流动，一九七一年仅俄罗斯联邦工业系统就损失三十四亿卢布。苏联一九七二年出版的《科学技术进步，和劳动生产率》一书说，工人怠工、停工使企业损失的工时占总工时的百分之十五到二十。苏联一经济学家对美国记者说，由于旷工、怠工和事故，苏联一年的损失达一百八十亿美元。\n\n面对着广大人民日益强烈的反抗和苏修国内严重的经济困境，苏修集团深感不安。**他们在加强法西斯镇压的同时，不得不大肆进行欺骗宣传，要人们相信，苏联劳动人民今天所遭受的生活困苦，是劳动得不够，只有加强劳动，才得以改善。其实，人们已越来越清楚，在今日之苏联，为所谓“福利”而劳动，不过是为一小撮官僚垄断资产阶级的“特权”而卖命。这一小撮人通过利润和税金等形式无偿地占有工人创造的大量财富，并通过高工资、高奖金和其他额外收入，贪婪地榨取劳动人民的血汗。**一些工人气愤地说:“领导人、厂长，汽车别墅....应有尽有，而我们工人只有两只手。”这就是苏修叛徒集团口口声声讲的所谓为“福利”而劳动!\n\n“提高人民福利”是假，强迫人民劳动是真。苏修集团让广大苏联人民为他们“劳动、劳动、再劳动”，就是想使他们这一小撮人获得“福利、福利、又福利”。这就是为什么他们不惜重新拾起拉萨尔的破旗来招摇过市。\n\n**但是，拉萨尔显然帮不了勃列日涅夫的忙，相反只能暴露新老机会主义者是一丘之貉，只能使苏联人民更加认清勃列日涅夫之流从理论到行动，彻头彻尾都是马列主义的叛徒。**\n","tags":["禁评"]},{"title":"中南大学机器学习课程第一次作业","url":"/2023/10/08/29/","content":"\n描述：这是一个有部分代码缺失的notebook，需要完成的就是将 `### START CODE HERE ###` 和`### END CODE HERE ###`之间的代码补全\n\n# 线性回归\n\n某城市的电网系统需要升级，以应对日益增长的用电需求。电网系统需要考虑最高温度对城市的峰值用电量的影响。项目负责人需要预测明天城市的峰值用电量，他搜集了以往的数据。现在，负责人提供了他搜集到的数据，并请求你帮他训练出一个模型，这个模型能够很好地预测明天城市的峰值用电量。\n## 1- 准备\n先导入必要的python包\n\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\n%matplotlib inline\n```\n\n导入负责人提供的数据，并可视化数据\n\n```\ndata = np.loadtxt('data.txt')\n#data 第一列为温度信息 第二列为人口信息\nX_raw = data[:,0].reshape(-1,1)\n#data 第三列为用电量信息\nY = data[:,2].reshape(-1,1)\nplt.xlabel('High temperature')\nplt.ylabel('Peak demand ')\nplt.scatter(X_raw,Y)\nprint('X shape:',X_raw.shape)\nprint('Y shape:',Y.shape)\nprint('some X[:5]:\\n',X_raw[:5])\nprint('some Y[:5]:\\n',Y[:5])\n```\n\n结果\n\n```\nX shape: (80, 1)\nY shape: (80, 1)\nsome X[:5]:\n [[38.24]\n [36.53]\n [32.92]\n [26.59]\n [20.05]]\nsome Y[:5]:\n [[4.04]\n [2.84]\n [3.2 ]\n [3.42]\n [2.32]]\n```\n\n根据对数据可视化结果的分析，决定使用回归算法训练一个模型，用来预测明天城市的峰值用电量。首先考虑单变量的线性回归模型。\n\n## 2- 单变量线性回归理论介绍\n\n### 单变量线性回归模型\n\n单变量线性回归的模型由两个参数$\\theta_0$,$\\theta_1$来表示一条直线：$$Peak\\ demand \\approx \\theta_0 + \\theta_1 \\cdot (High\\ temperature) 。$$\n\n我们的目标也就是找到一条\"最符合\"的直线，确定这条直线的参数$\\theta_i$。\n\n设输入的特征——最高温度(F)为$x^{(i)} \\in \\mathbb{R}^{n+1}$，$i=1,\\cdots,m$。$m$为样本总数，在该例子中$m$=80。$n$为特征的个数，这里为$1$。则：$x^{(i)} \\in \\mathbb{R}^2 = \\begin{bmatrix} 1 \\\\ \\text{high temperature for day} i\\end{bmatrix}。$\n\n设输出为$y^{(i)} \\in \\mathbb{R}$，表示第$i$天的峰值用电量。\n\n参数为$\\theta \\in \\mathbb{R}^{n+1} = \\begin{bmatrix} \\theta_0 \\\\ \\theta_1 \\\\ \\vdots \\\\ \\theta_n \\end{bmatrix}$。这里$n=1$。\n\n在该例子中，模型为一条直线，模型可表示为：\n$$h_{\\theta}(x) = \\theta^T x = \\theta_0 + \\theta_1 x 。$$\n### **注意**：\n这里的$\\theta^T$是一个向量，$\\theta_0,\\theta_1$是标量。使用向量化表示的原因为：（1）简化数学公式的书写（2）与程序代码中的表示保持一致，且使用向量化的代码实现可以加速运算，**因此一般能不用`for`循环的地方都不用`for`循环**。 \n\n下面用一个简单的例子说明向量化的代码运算更快。\n\n```\n# 随机初始化两个向量，计算它们的点积\nx = np.random.rand(10000000,1)\ny = np.random.rand(10000000,1)\nans = 0\nstart = time.time()\nfor i in range(10000000):\n    ans += x[i,0]/y[i,0]\nend = time.time()\nprint('for循环的计算时间: %.2fs'%(end - start))\nprint('计算结果：%.2f'%(ans))\nstart = time.time()\nans = np.dot(x.T,y)\nend = time.time()\nprint('向量化的计算时间: %.2fs'%(end - start))\nprint('计算结果：%.2f'%(ans))\n```\n\n结果\n\n```\nfor循环的计算时间: 4.67s\n计算结果：89066284.16\n向量化的计算时间: 0.00s\n计算结果：2500035.03\n```\n\n因为$\\theta_0 + \\theta_1 x=\\begin{bmatrix} 1 \\quad x \\end{bmatrix} \\begin{bmatrix} \\theta_0 \\\\ \\theta_1 \\end{bmatrix} 。$\n因此，为了方便编程，我们需要给每一个$x^{(i)}$的前面再加一列1。使得每一个$x^{(i)}$成为一个2维向量。\n\n### 预测结果\n\n模型需要根据输入自变量 $x^{(i)}$ 和参数 $\\theta$ 来输出预测结果 $predict\\_y^{(i)}$。\n\n将自变量 $x^{(i)}$ 作为模型的输入，模型根据输入和当前参数 $\\theta$ 输出预测结果：\n\n$$\npredict\\_y^{(i)} = h_\\theta(x^{(i)})。\n$$\n\n其中 $h_\\theta()$ 为模型在参数为 $\\theta$ 情况下，对于输入的预测函数。  \n\n\n在预测阶段，$x$作为自变量。\n### 损失函数\n\n模型的预测结果和实际结果有差距，为了衡量它们之间的差距，或者说量化使用这个模型产生的损失，我们定义损失函数$l(predict\\_y^{(i)}, y^{(i)})$。这里我们使用平方损失：\n$$\nl(predict\\_y, y) = \\left ( predict\\_y^{(i)} - y^{(i)} \\right )^2。\n$$\n\n上述损失函数表示一个样本的损失，整个训练集的损失使用$J(\\theta)$表示：\n$$\n\\begin{aligned}\nJ(\\theta) & = \\frac{1}{2m} \\sum_{i=1}^{m}l(predict\\_y^{(i)}, y^{(i)}) \\\\\n& = \\frac{1}{2m} \\sum_{i=1}^{m} \\left ( h_\\theta(x^{(i)}) - y^{(i)} \\right )^2 \\\\\n& = \\frac{1}{2m} \\sum_{i=1}^{m} \\left ( \\theta^T x^{(i)} - y^{(i)} \\right )^2。\n\\end{aligned}\n$$\n（其中数字2的作用是方便求导时的运算）\n\n为了使模型取得较好的预测效果，需要最小化训练集上的损失，即$\\underset{\\theta}{\\min} J(\\theta)$。\n\n在损失阶段，$\\theta$ 作为自变量。\n\n### 梯度下降法\n\n为了得到使损失函数$J(\\theta)$最小化的$\\theta$，可以使用梯度下降法。\n\n假设一开始$J(\\theta)$的值在紫色点上，为了降低$J(\\theta)$值，需要$\\theta_1$往右边移动，这个方向是$J(\\theta)$在$\\theta_1$上的负梯度。只要$\\theta$不断往负梯度方向移动，$J(\\theta)$一定可以降到最低值。梯度下降法就是使参数$\\theta$不断往负梯度移动，经过有限次迭代(更新$\\theta$值)之后，损失函数$J(\\theta)$达到最低值。\n\n梯度下降法的过程：\n1. 初始化参数向量$\\theta$。\n\n2. 开始迭代\n\n   A.根据实际输入$x$和参数$\\theta$预测输出，\n   \n   B. 根据预测输出值和实际输出值之间的差距，计算损失函数$J(\\theta)$，\n   \n   C. 计算损失函数对$\\theta$的梯度，\n   \n   D. 更新参数$\\theta$。\n\n\n## 3- 实现单变量线性回归模型 \n\n现在，我们开始实现 Regression 算法。\n\n### **任务1：** \n首先在$X$前面加上一列1，表示参数$\\theta_0$的系数，方便运算。$X$是形状为$(m,1)$的矩阵，一共$m$行数据，我们需要为每一行数据的前面加一列1，如下所示：  \n$$\n\\begin{bmatrix} x^{(0)} \\\\ x^{(1)} \\\\ \\vdots \\\\x^{(m-1)}  \\end{bmatrix} \\longrightarrow\n\\begin{bmatrix} 1\\quad x^{(0)} \\\\ 1\\quad x^{(1)} \\\\ \\vdots \\\\ 1\\ x^{(m-1)}  \\end{bmatrix}。\n$$\n**提示**：可以使用`np.hstack`把两个矩阵水平合在一起。用1初始化向量或矩阵的函数是`np.ones`。(函数详情可使用python的帮助函数`help`，比如`help(np.ones)`，或者自行用搜索引擎检索。)\n\n```\ndef preprocess_data(X):\n    \"\"\"输入预处理 在X前面加一列1\n    参数：\n        X:原始数据,shape为(m,1)\n\t返回：\n    \tX_train: 在X加一列1的数据,shape为(m,2)\n\t\"\"\"\n\nm = X.shape[0]   # m 是数据X的行数\n\n### START CODE HERE ###\n\ntemp=np.ones((m,1))\nX_train = np.hstack((temp,X))\n\n### END CODE HERE ###\n\nreturn X_train\n```\n\n```\nX = preprocess_data(X_raw)\nprint('new X shape:',X.shape)\nprint('Y shape:',Y.shape)\nprint('new X[:5,:]=\\n',X[:5,:])\nprint('Y[:5,:]=\\n',Y[:5,:])\n```\n\n结果\n\n```\nnew X shape: (80, 2)\nY shape: (80, 1)\nnew X[:5,:]=\n [[ 1.   38.24]\n [ 1.   36.53]\n [ 1.   32.92]\n [ 1.   26.59]\n [ 1.   20.05]]\nY[:5,:]=\n [[4.04]\n [2.84]\n [3.2 ]\n [3.42]\n [2.32]]\n```\n\n### **任务2：** \n接着，初始化参数向量$\\theta$。$\\theta$的shape是$(2,1)$，我们随机初始化$\\theta$。\n\n**提示**：numpy的随机函数是`np.random.rand`。\n\n```\ndef init_parameter(shape):\n    \"\"\"初始化参数\n    参数：\n        shape: 参数形状\n\t返回：\n    \ttheta_init: 初始化后的参数\n\t\"\"\"\n\nnp.random.seed(0)\nm, n = shape\n\n### START CODE HERE ###\n\ntheta_init = np.random.rand(m,n)\n\n### END CODE HERE ###\n\nreturn theta_ini\n```\n\n```\ntheta = init_parameter((2,1))\nprint('theta shape is ',theta.shape)\nprint('theta = ',theta)\n```\n\n结果\n\n```\ntheta shape is  (2, 1)\ntheta =  [[0.5488135 ]\n [0.71518937]]\n```\n\n### **任务3：** \n通过已知 $X$ 和参数 $\\theta$ 计算预测的 $predict\\_Y$ 值。\n\n由于使用`for`循环单独计算每个预测值效率不高，因此我们需要用向量化的方法代替`for`循环。$X$ 大小为$m \\times (n+1)$($n$表示特征数量，这里$n=1$)，每行是一条样本特征向量，$\\theta$ 大小为$(n+1) \\times 1$，可以使用$X \\theta$（矩阵相乘）计算所有样本的预测结果,大小为$m\\times 1$。于是这里的线性模型就可以表示为：\n$$\nh_{\\theta}(X) = X \\theta。\n$$\n这里$h_{\\theta}(X)$的大小为$m \\times 1$，结果上等于 $predict\\_Y_\\theta$。\n\n**提示**：矩阵相乘 `np.dot(矩阵1，矩阵2)`。\n\n```\ndef compute_predict_Y(X,theta):\n    \"\"\"计算预测结果\n    参数：\n        X: 训练集数据特征,shape: (m, 2)\n        theta: 参数,shape: (2, 1)\n\t返回：\n    \tpredict_Y: 预测结果,shape: (m,1)\n\t\"\"\"\n\n### START CODE HERE ###\n\npredict_Y = np.dot(X,theta)\n\n### END CODE HERE ###\n\nreturn predict_Y\n\npredict_Y = compute_predict_Y(X,theta)\nprint(predict_Y[:5])\n```\n\n结果\n\n```\n[[27.89765487]\n [26.67468106]\n [24.09284744]\n [19.56569876]\n [14.8883603 ]]\n```\n\n### **任务4：** \n实现计算损失函数$J(\\theta)$的函数。   \n从公式\n$$\n\\begin{aligned}\nJ(\\theta) = \\frac{1}{2m} \\sum_{i=1}^{m} \\left ( predict\\_y_\\theta^{(i)} - y_\\theta^{(i)} \\right )^2\n\\end{aligned}\n$$\n可以看到有个求和，由于使用`for`循环效率不高，因此需要用向量化的方法代替`for`循环。$(predict\\_Y - Y)^2$计算所有样本的损失值，最后求和并除以$2m$得到$J(\\theta)$的值，得到的$J(\\theta)$是一个标量。   \n**提示**：矩阵乘法运算可使用`np.dot`函数，平方运算可使用`np.power(data, 2)`函数，求和运算可使用`np.sum`。\n\n```\ndef compute_J(predict_Y, Y):\n    \"\"\"计算损失的函数J\n    参数：\n        predict_Y: 预测结果,shape: (m, 1)\n        Y: 训练集数据标签,shape: (m, 1)\n\t返回：\n    \tloss: 损失值\n\t\"\"\"\n\nm = Y.shape[0]\n\n### START CODE HERE ###\n\nloss = np.sum(np.power((predict_Y-Y),2))/(2 * m)\n\n### END CODE HERE ###\n\nreturn loss\n```\n\n```\nfirst_loss = compute_J(predict_Y, Y)\nprint(\"first_loss = \", first_loss)\n```\n\n结果\n\n```\nfirst_loss =  144.05159786255672\n```\n\n### **任务5：**\n计算参数$\\theta$的梯度。梯度计算的公式为：\n$$\n\\frac{\\partial J(\\theta)}{\\partial \\theta_j} = \\frac{1}{m} \\sum_{i=1}^{m} \\left ( \\theta^T x^{(i)} - y \\right ) x_j^{(i)}。\n$$\n向量化公式为：\n$$\n\\text{gradients} =\\frac{1}{m} X^T (X \\theta - Y) 。\n$$\n**提示**：矩阵A的转置表示为`A.T`。$X\\theta$就是计算出的predict_Y。\n\n```\ndef compute_gradient(predict_Y, Y, X):\n    \"\"\"计算对参数theta的梯度值\n    参数：\n        predict_Y: 当前预测结果,shape: (m,1)\n        Y: 训练集数据标签,shape: (m, 1)\n        X: 训练集数据特征,shape: (m, 2)\n\t返回：\n    \tgradients: 对theta的梯度,shape:(2,1)\n\t\"\"\"\n\nm = X.shape[0]\n\n### START CODE HERE ###\n\ngradients = np.dot(X.T,predict_Y-Y) / m\n\n### END CODE HERE ###\n\nreturn gradients\n```\n\n```\ngradients_first = compute_gradient(predict_Y, Y, X)\nprint(\"gradients_first shape : \", gradients_first.shape)\nprint(\"gradients_first = \", gradients_first)\n```\n\n结果\n\n```\ngradients_first shape :  (2, 1)\ngradients_first =  [[ 16.0079445 ]\n [459.96770081]]\n```\n\n### **任务6：**\n用梯度下降法更新参数$\\theta$,实现`update_parameters`函数。\n\n**提示**：parameters = $\\theta$ - $learning\\_rate·gradients$\n\n```\ndef update_parameters(theta, gradients, learning_rate=0.0001):\n    \"\"\"更新参数theta\n    参数：\n        theta: 参数,shape: (2, 1)\n        gradients: 梯度,shape: (2, 1)\n        learning_rate: 学习率,默认为0.0001\n\t返回：\n    \tparameters: 更新后的参数,shape: (2, 1)\n\t\"\"\"\n\n### START CODE HERE ###\nparameters = theta - learning_rate * gradients\n### END CODE HERE ###\n\nreturn parameters\n```\n\n```\ntheta_one_iter = update_parameters(theta, gradients_first)\n\nprint(\"theta_one_iter = \", theta_one_iter)\n```\n\n结果\n\n```\ntheta_one_iter =  [[0.54721271]\n [0.6691926 ]]\n```\n\n### **任务7：**\n将前面定义的函数整合起来，实现完整的模型训练函数。\n\n$\\theta$迭代更新 `iter_num`次。迭代次数`iter_num`也是一个超参数，如果`iter_num`太小，损失函数$J(\\theta)$还没有收敛；如果`iter_num`太大，损失函数$J(\\theta)$早就收敛了，过多的迭代浪费时间。\n\n```\ndef model(X, Y, theta, iter_num = 100, learning_rate=0.0001):\n    \"\"\"线性回归模型\n    参数：\n        X: 训练集数据特征,shape: (m, n+1)\n        Y: 训练集数据标签,shape: (m, 1)\n        iter_num: 梯度下降的迭代次数\n        theta: 初始化的参数,shape: (n+1, 1)\n        learning_rate: 学习率,默认为0.0001\n    返回：\n        loss_history: 每次迭代的损失值\n        theta_history: 每次迭代更新后的参数\n        theta: 训练得到的参数\n    \"\"\"\n\nloss_history = []\ntheta_history = []\n\nfor i in range(iter_num):\n    ### START CODE HERE ###\n    # 预测\n​    predict_Y = compute_predict_Y(X,theta)\n    # 计算损失\n​    loss = compute_J(predict_Y,Y)\n    # 计算梯度\n​    gradients = compute_gradient(predict_Y,Y,X)\n    # 更新参数\n​    theta = update_parameters(theta,gradients,learning_rate)\n    ### END CODE HERE ###\n​    loss_history.append(loss)\n​    theta_history.append(theta)\n\nreturn loss_history, theta_history, theta\n```\n\n```\n# 感兴趣的同学可以自行尝试不同的学习率和迭代次数，最后提交时以100次迭代和0.0001的学习率重新运行一遍再提交\n\nloss_history, theta_history, theta = model(X, Y, theta, iter_num=100, learning_rate=0.0001)\n\nprint(\"theta = \", theta)\n\nplt.plot(loss_history)\nprint(\"loss = \", loss_history[-1])\n```\n\n下面是学习到的线性模型与原始数据的关系可视化。\n\n```\nplt.scatter(X[:,1],Y)\nx = np.arange(10,42)\nplt.plot(x,x*theta[1][0]+theta[0][0],'r')\n```\n\n现在直观地了解一下梯度下降的过程。\n\n```\ntheta_0 = np.linspace(0, 1, 50)\ntheta_1 = np.linspace(0, 1, 50)\ntheta_0, theta_1 = np.meshgrid(theta_0,theta_1)\nJ = np.zeros_like(theta_0)\npredict_Ys = np.zeros_like(predict_Y)\nprint(theta_0.shape)\nprint(theta_1.shape)\nprint(predict_Ys.shape)\nprint(J.shape)\n\nfor i in range(50):\n    for j in range(50):\n        predict_Y = compute_predict_Y(X, np.array([[theta_0[i,j]],[theta_1[i,j]]]))\n        J[i,j] = compute_J(predict_Y, Y)\n\nplt.contourf(theta_0, theta_1, J, 10, alpha = 0.6, cmap = plt.cm.coolwarm)\nC = plt.contour(theta_0, theta_1, J, 10, colors = 'black')\n\n# 画出损失函数J的历史位置\n\nhistory_num = len(theta_history)\ntheta_0_history = np.zeros(history_num)\ntheta_1_history = np.zeros(history_num)\nfor i in range(history_num):\n    theta_0_history[i],theta_1_history[i] = theta_history[i][0,0],theta_history[i][1,0]\nplt.scatter(theta_0_history, theta_1_history, c=\"r\")\n```\n\n可以看到，$J(\\theta)$的值不断地往最低点移动。在y轴，$J(\\theta)$下降的比较快，在x轴，$J(\\theta)$下降的比较慢。\n\n## 4- 实现多变量线性回归模型\n\n上述例子是单变量回归的例子，样本的特征只有一个一天的最高温度。负责人经过分析后发现，城市一天的峰值用电量还与城市人口有关系，因此，他在回归模型中添加城市人口变量$x_2$，你的任务是训练这个多变量回归方程：\n$$\nh(x) = \\theta^T x = \\theta_0 * 1 + \\theta_1 * x_1 + \\theta_2 * x_2。\n$$\n之前实现的梯度下降法使用的对象是$\\theta$和$X$向量，实现的梯度下降函数适用于单变量回归和多变量回归。不难发现上面使用的向量化公式在多变量回归里依然不变，因此代码也基本一致,直接调用前面实现的函数即可。\n\n### **任务8：** \n现在，训练一个多变量回归模型。\n\n```\n#读取数据，X取data的前两列\nX = data[:,0:2].reshape(-1, 2)\nY = data[:,2].reshape(-1, 1)\n\n### START CODE HERE ###\n# 直接调用上面实现过的函数\n# 同样为X的前面添加一列1,使得X的shape从80x2 -> 80x3\nX = preprocess_data(X)\n# 初始化参数theta ,theta的shape应为 3x1\ntheta = init_parameter((3,1))\n# 传入模型训练,learning_rate设为0.0001\nloss_history, theta_history, theta = model(X,Y,theta,iter_num=100,learning_rate=0.0001)\n### END CODE HERE ###\n\nprint(\"theta = \", theta)\n\nplt.plot(loss_history)\nprint(\"loss = \", loss_history[-1])\n```\n\n结果\n\n```\ntheta =  [[0.52593585]\n [0.06715361]\n [0.57583208]]\nloss =  0.10300473270580184\n```\n\n## 5- 特征归一化\n\n特征归一化可以确保特征在相同的尺度，加快梯度下降的收敛过程。\n\n### **任务9：** \n对数据进行零均值单位方差归一化处理。零均值单位方差归一化公式：\n$$\nx_i = \\frac{x_i - \\mu_i}{\\sigma_i}\n$$\n其中$i$表示第$i$个特征，$\\mu_i$表示第$i$个特征的均值，$\\sigma_i$表示第$i$个特征的标准差。进行零均值单位方差归一化处理后，数据符合标准正态分布，即均值为0，标准差为1。\n\n**注意**，使用新样本进行预测时，需要对样本的特征进行相同的缩放处理。\n\n**提示**：求特征的均值，使用numpy的函数`np.mean`;求特征的标准差，使用numpy的函数`np.std`，需要注意对哪个维度求均值和标准差。比如，对矩阵A的每列求均值`np.mean(A,axis=0)`。\n\n```\nX = data[:,0:2].reshape((-1, 2))\nY = data[:,2].reshape((-1, 1))\n\n### START CODE HERE ###\n# 计算特征的均值 mu\nmu = np.mean( X , axis=0 )\n# 计算特征的标准差 sigma\nsigma = np.std( X , axis=0 )\n# 零均值单位方差归一化\nX_norm = ( X - mu ) / sigma\n# 训练多变量回归模型\n# X_norm前面加一列1\nX = preprocess_data(X_norm)\n# 初始化参数theta\ntheta = init_parameter((3,1))\n# 传入模型训练,learning_rate设为0.1\nloss_history, theta_history, theta = model(X,Y,theta,iter_num = 100, learning_rate=0.1)\n### END CODE HERE ###\n\nprint(\"mu = \", mu)\nprint(\"sigma = \", sigma)\n\nprint(\"theta = \", theta)\n\nplt.plot(loss_history)\nprint(\"loss = \", loss_history[-1])\n```\n\n我们来直观地了解特征尺度归一化的梯度下降的过程。这里只展示单变量回归梯度下降过程。\n\n```\nX_show = X[:,0:2]\nX_show = preprocess_data(X_show)\n\ntheta_0 = np.linspace(-2, 3, 50)\ntheta_1 = np.linspace(-2, 3, 50)\ntheta_0, theta_1 = np.meshgrid(theta_0,theta_1)\nJ = np.zeros_like(theta_0)\n\nfor i in range(50):\n    for j in range(50):\n        predict_Y = compute_predict_Y(X_show, np.array([[2.877],[theta_0[i,j]],[theta_1[i,j]]]))\n        J[i,j] = compute_J(predict_Y, Y)\n\nplt.contourf(theta_0, theta_1, J, 10, alpha = 0.6, cmap = plt.cm.coolwarm)\nC = plt.contour(theta_0, theta_1, J, 10, colors = 'black')\n\n# 画出损失函数J的历史位置\n\nhistory_num = len(theta_history)\ntheta_0_history = np.zeros(history_num)\ntheta_1_history = np.zeros(history_num)\nfor i in range(history_num):\n    theta_0_history[i],theta_1_history[i] = theta_history[i][2,0],theta_history[i][1,0]\nplt.scatter(theta_0_history, theta_1_history, c=\"r\")\n```\n\n可以看到，$J(\\theta)$的值不断地往最低点移动。与没有进行特征尺度归一化的图相比，归一化后，每个维度的变化幅度大致相同，这有助于$J(\\theta)$的值快速下降到最低点。\n\n## 6- 法线方程 (The normal equations)\n\n对于求函数极小值问题，可以使用求导数的方法，令函数的导数为0，然后求解方程，得到解析解。法线方程正是使用这种方法来求解损失函数$J(\\theta)$的极小值，而线性回归的损失函数$J(\\theta)$是一个凸函数，所以极小值就是最小值。\n\n法线方程的求解过程详见课件，法线方程的公式是：\n$$\n\\theta = (X^T X)^{-1} X^T Y\n$$\n\n如果$m \\le n +1$，那么$X^T X$是奇异矩阵，即$X^T X$不可逆。\n$X^T X$不可逆的原因可能是：\n\n- 特征之间冗余，比如特征向量中两个特征是线性相关的。\n- 特征太多，删去一些特征再进行运算。\n\n法线方程的缺点之一就是会出现$X^T X$不可逆的情况，可以通过正则化的方式解决。另一个缺点是，如果样本的个数太多，特征数量太多($n \\gt 10000$)，法线方程的运算会很慢（求逆矩阵的运算复杂）。\n\n### **任务10：** \n下面来实现法线方程。  \n**提示**：Numpy 求逆矩阵的函数是`np.linalg.inv`。\n\n```\ndef normal_equation(X, Y):\n    \"\"\"法线方程求解线性回归方程的参数\n    参数：\n        X: 训练集数据特征,shape: (m, n+1)\n        Y: 训练集数据标签,shape: (m, 1)\n    返回：\n        theta: 线性回归方程的参数\n    \"\"\"\n\n### START CODE HERE ###\ntheta = np.dot(np.dot(np.linalg.inv(np.dot(X.T,X)),X.T),Y)\n### END CODE HERE ###\n\nreturn theta\n```\n\n```\ntheta = normal_equation(X, Y)\n\nprint(\"theta = \", theta)\n```\n\n结果\n\n```\ntheta =  [[2.861875  ]\n [0.70429906]\n [0.04092011]]\n```\n\n可以自行对比一下直接用正规方程求解出的$\\theta$与用线性回归模型训练出的$\\theta$之间的差异，会\"惊奇\"地发现两者几乎一模一样。\n\n## 7- 预测结果 \n\n### **任务11：** \n假设明天的最高温度是$x_1 = 40$°C，人口$x_2 = 3.3$百万，使用通过正规方程计算得到的$\\theta$预测明天的城市的峰值用电量（单位：GW）吧！  \n**注意**，$x$要进行同样的特征尺度归一化处理。\n\n```\ndef predict(theta,x):\n    \"\"\"预测峰值用电量\n    参数：\n        X: 需要预测数据的特征,shape: (m, n+1), 这里只预测一天的结果, m=1\n        theta: 最终确定的参数,shape: (n+1, 1)\n    返回：\n        prediction: 预测结果,shape: (m, 1)\n    \"\"\"\n\n### START CODE HERE ###\n\n# 零均值单位方差归一化\nx = (x-mu)/sigma\n# 在x前面加一列\nx = np.hstack([[[1]],x])\n#用theta和处理后的x计算预测值\nprediction = np.dot(theta.T,x.T)\n### END CODE HERE ###\n\nreturn prediction\n\n#明天的特征\nx = np.array([[40,3.3]])\nprint('预计明天的峰值用电量为：%.2f GW'%(predict(theta,x))) \n```\n\n结果\n\n```\n预计明天的峰值用电量为：4.25 GW\n```\n\n## 8- 多项式回归\n以上都是线性模型，当我们数据的特征$X$与预测结果$Y$之间没有明显的线性关系，而且又找不到合适的映射函数时，可以尝试多项式回归。\n下面导入另一组最高气温与用电量数据，我们用线性模型试一试看看效果发现并不太好。\n\n```\ndata1 = np.loadtxt('data1.txt')\nX = data1[:,0].reshape(-1,1)\nY = data1[:,1].reshape(-1,1)\n\nplt.scatter(X,Y)\nX = np.hstack((np.ones((X.shape[0],1)),X))\ntheta = normal_equation(X,Y)\nplt.plot(np.sort(X[:,1]),np.dot(X,theta)[np.argsort(X[:,1])],'r')\n```\n\n多项式回归的最大优点就是可以通过增加$X$的高次项对实测点进行逼近，直至满意为止。事实上，多项式回归可以处理相当一类非线性问题，它在回归分析中占有重要的地位，**因为任一函数都可以分段用多项式来逼近**。因此，在通常的实际问题中，不论依变量与其他自变量的关系如何，我们总可以用多项式回归来进行分析。假设数据的特征只有一个$a$，多项式的最高次数为$K$，那么多项式回归方程为：\n$$\nh(x) = \\theta^T x = \\theta_0 \\times a^0 + \\theta_1 \\times a^1 + \\theta_2 \\times a^2 + \\cdots + \\theta_K \\times a^K。\n$$\n若令$x = \\begin{bmatrix} a^0, a^1, a^2, \\cdots, a^K \\end{bmatrix}^T$，那么\n$$\nh(x) = \\theta^T x = \\theta_0 \\times x_0 + \\theta_1 \\times x_1 + \\theta_2 \\times x_2, \\cdots, \\theta_K \\times x_K，\n$$\n这就变为多变量线性回归了。\n\n### **任务12：**\n现在想要得到一个如下的多项式模型，$K=2$，直接用上面的正规方程进行求解。\n$$\n    h(x) = \\theta^T x = \\theta_0 \\times 1 + \\theta_1 \\times x + \\theta_2 \\times x^2。\n$$\n输入数据$X$变为:\n$$\n\\begin{bmatrix} x^{(0)} \\\\ x^{(1)} \\\\ \\vdots \\\\x^{(m-1)}  \\end{bmatrix} \\longrightarrow\n\\begin{bmatrix} 1\\quad x^{(0)}\\quad {x^{(0)}}^2 \\\\ 1\\quad x^{(1)} \\quad {x^{(1)}}^2\\\\ \\vdots \\\\ 1\\ x^{(m-1)}\\quad {x^{(m-1)}}^2  \\end{bmatrix}。\n$$\n```\ndata1 = np.loadtxt('data1.txt')\nX = data1[:,0].reshape(-1,1)\nY = data1[:,1].reshape(-1,1)\n\nm = X.shape[0]    # m 是数据X的行数\nX_square = np.power(X,2)\n\n### START CODE HERE ###\n\n# 对X 前面加1， 后面加平方，变为 m x 3 的矩阵\n\nX = np.hstack((np.ones((m,1)),X))\nX = np.hstack((X,X_square))\n\n# 用法线方程求解theta\n\ntheta = normal_equation(X,Y)\n\n### END CODE HERE ###\n\nplt.scatter(X[:,1],Y)\nplt.plot(np.sort(X[:,1]),np.dot(X,theta)[np.argsort(X[:,1])],'r')\n```\n\n所有任务到这里就结束了，下面是对上面的数据进行任意多项式拟合的结果，你可以通过改变$K$的值来调整多项式的阶数，看看不同模型的效果(但不设的太大, $K \\le 193$)。可以看到，越复杂的模型，虽然拟合数据的效果越好，但是其泛化能力就会很差，所以模型的选择应该要尽量符合实际需求。\n\n```\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import StandardScaler\n\ndef PolynomialRegression(degree):\n    return Pipeline([\n        (\"poly\",PolynomialFeatures(degree=degree)),\n        (\"std_scaler\",StandardScaler()),\n        (\"lin_reg\",LinearRegression())    \n    ])\nX = data1[:,0].reshape(-1,1)\nY = data1[:,1].reshape(-1,1)\n\nK = 15  #可以调整K的值(0<=K<=193)\n\npoly_reg = PolynomialRegression(degree=K)\npoly_reg.fit(X,Y.squeeze())\ny_predict = poly_reg.predict(X)\nplt.scatter(X,Y)\nplt.plot(np.sort(X[:,0]),y_predict[np.argsort(X[:,0])],color='r')\n```\n\n## 学习调包sklearn (Optional)\n\n```\nimport matplotlib.pyplot as plt\nplt.rcParams[\"font.sans-serif\"]=[\"SimHei\"] #设置字体\nplt.rcParams[\"axes.unicode_minus\"]=False #该语句解决图像中的“-”负号的乱码问题\n\ndata = np.loadtxt(\"data.txt\")\n# data 数据第一列为人口信息\nX_data = data[:, 0].reshape(-1,1)\n# data 数据第三列为城市峰值用电量\ny_data = data[:, 2].reshape(-1,1)\nprint(\"X shape: \", X_data.shape)\nprint(\"y shape: \", y_data.shape)\n```\n\n结果\n\n```\nX shape:  (80, 1)\ny shape:  (80, 1)\n```\n\n```\nfrom sklearn.linear_model import LinearRegression\nlinear_reg = LinearRegression()\n\nlinear_reg.fit(X_data, y_data)\n\nX_test = np.array([[8], [45]])\ny_pred = linear_reg.predict(X_test)\nplt.plot(X_data,y_data,\".\")\nplt.plot(X_test, y_pred,\"r-\")\nplt.xlabel(\"Temperture\")\nplt.ylabel(\"PeakDemand\")\nplt.title(\"Linear Regression model predictions\")\nplt.show()\n```\n\n","tags":["机器学习"]},{"title":"刘梦熊：问题在经济 根子在政治","url":"/2023/09/11/28/","content":"\n来源：联合早报 2023年8月21日\n\n导语：在美国和西方发达国家，经济繁荣、衰退、复苏、繁荣周而复始，有其周期性和相应的经济对策。但中国是政治挂帅，政治凌驾经济，而且习惯只算政治账，不算经济账。当前中国经济盛极而衰， 正是由于中共只搞局部经济体制改革，迟迟不启动政治体制改革带来的恶果。\n\n当前中国经济面临私企倒闭潮、外企撤离潮、投资大幅萎缩潮、出生人口下降潮、消费严重不足潮、债务连环爆煲潮，员工大规模失业潮，政府财税失血潮…………投资、出口、消费三大经济引擎全部动力不足乃至死火。中国国家统计局日前公布的7月份经济数据，不是疲弱下挫就是远逊预期，明显呈现通缩特征。第二季度外资投资额只有区区49亿美元，同比下跌87%！中国恒大、碧桂园两大房地产巨头“债可敌国”，象征整个行业崩溃累及相连产业陷入危机……以致美国总统拜登惊呼，中国经济下滑对世界犹如“定时炸弹”。\n\n中国坊间流传段子：“经济新三大引擎是国家统计局、中宣部、新华社”，“挽救经济的工具箱里只剩喇叭(意即“靠吹”)” 。作为世界第二大经济体的中国，自改革开放以来一路高歌猛进，为何数年之间风云突变，急剧下滑？一句话：问题在经济，根子在政治。\n\n中国是当今世上经济被政治捆绑得最厉害的国家，没有之一！1966年至1976年文化大革命，国民经济到了崩溃边缘。 1978年5月，胡耀邦推动”实践是检验真理的唯一标准”的思想解放运动，大力平反冤假错案，解放大批老干部；为所谓“地主， 富农、反革命分子、坏分子、右派分子”摘帽，恢复公民权；在这基础上，1978年底，在邓小平等老一辈领导人推动下，中共十一届三中全会果断中止“阶级斗争为纲”，将工作重心转移到“经济建设为中心”，开启了改革开放新时期。这之后， 农村改革，废除人民公社制，包产到户；开放沿海城市；允许私营企业进入市场，大量吸收劳动力；到海外招商引资，港澳台、美欧日企业不仅带进资金、先进科学技术、成套设备，而且引进市场经济、法治、知识产权，现代企业管理制度等观念；随着2001年中国加入世界贸易组织(WTO)，更加搭上经济全球化快车，在国际分工中成为世界工厂，积累了世界最丰厚的外汇储备，成为世界第二大经济体。\n\n**A. 中美友好是经济发展重要动力**\n\n必须指出，改革开放之初，邓小平等老一辈领导人努力达成如下党内共识：中国要实现现代化， 一定要搞改革开放；而开放和引进的主要对像是美国。因此，改善和发展对美关系，是改革开放的内在要求，也是冷战格局下确保国家安全的根本要求。事实上，从美国给予中国最惠国贸易待遇到支持中国加入WTO，对中国开放市场，大量进口中国商品；美国企业大规模投资中国；向中国输出尖端科技；每年为中国培养大量留学人材，中美友好互利共赢，亦成为中国经济发展重要动力之一。\n\n改革开放30多年是稳步上升轨，近年来却陷入螺旋式下降轨，透过现像看本质，令经济逆转最根本原因在政治。\n\n第一，中国经济上升期主因是中共政治上中止阶级斗争为纲，坚持经济建设为中心，因而解放了生产力。近年经济恶化，主因是政治上强化意识形态，坚持”马克思是对的”，消灭私有制，强调斗争哲学，滥用国家安全、反间谍概念，对投资者和专业人士造成动辄误触法网的心理威胁，导致外商和游客对中国裹足不前。\n\n第二，经济上升期是在认识上坚持市场在资源配置方面的决定性作用，在政策上鼓励私营企业发展，保护”傻子瓜子”年广久一类民营企业家的合法权益和人身安全。\n\n但近年经济滑坡重要原因之一是“国进民退” 的恶果：在认知上片面强调“党领导一切”，与中共十三大报告“党政分开，政企分开”改革方向背道而驰，在私企、外企设立党委、党支部，令国务院颁布的《公司法》《物权法》规定的企业自主权形同虚设，私企因此担心随时会发生”第二次公私合营”。此外，在舆论上“消灭私有制”、“私营经济退场论”、“私企职工共管共享论”此起彼伏，令投资者人心惶惶。\n\n在政策上，地方政府视私企为韭菜，由“乱收费、乱摊派、乱罚款”发展到“乱立案、乱抓人、 乱没收”，将对私企的罚款没收作为政府创收手段 之一。河北省著名农民企业家孙大午被罗织罪名入狱，大午集团巨额资产被价拍走，巧取豪夺令人心寒！所谓“行业整顿”充满随意性，一纸公文消灭一个行业，毁掉一批上市公司并非神话，而是现实!\n\n**B. 勒令移民公司交出移民档案**\n\n种种不公正待遇令私营企业家发出“利用我们是你们(中共)无奈的选择，消灭我们是你们(中共)崇高的理想”的哀鸣，投资信心尽失，因而”润(RUN)”意顿生。\n\n如今，当局又透过打击移民公司，勒令交出移 民档案企图刹止“润潮”。中国私人企业和国际外资企业都是私有制的产物，目睹私企悲惨遭遇，外企自然兔死狐悲，心有余悸，感觉中国投资环境充 满不确定性和不稳定性，从而避之则吉。私企、外企两大经济主力军信心大失，中国经济岂能不走下坡？\n\n第三，经济上升期重要原因，是中共在思想上强调“实践是检验真理的唯一标准”，提倡“实事求是，解放思想”，令整个社会形成允许独立思考、敢于探索，有利于激发原创动力的良好氛围。故此人才辈出，万众创业，明星企业大量涌现，促进生产力发展。但近年经济倒退的重要背景之一， 正是有人违反中共中央第二份历史决议关于“禁止任何形式的个人崇拜”规定，鼓吹“忠诚不绝对， 绝对不忠诚”，宣扬“定于一尊，一锤定音”，把个人崇拜推向新的高峰。\n\n后邓小平时代形成的集体领导格局无疾而终， 干部队伍中吹牛拍马之辈当红得道，弹冠相庆。相反，正直敢言能干之士遭逆向淘汰；加上乱划敏感词汇，乱订封号标准的言论、网络监控，导致社会上万马齐喑，纠错机制缺位，以致违反经济规律、 违反科学规律、违反自然规律乃至违反地缘政治规律的充满随意性拍板畅通无阻，给经济运行带来巨大冲击和惨重损失。\n\n**C. 泛政治化环境窒碍经济发展**\n\n例如冠病疫情三年，泛政治化成风，将明明是科学问题的公共卫生政策探讨，无限上纲为制度之争，提出不切实际的“坚持动态清零不动摇”口号，任意封城封路封关，停工停业停产，企业的生产、流通、营运惨遭腰斩，居民的人权、人身自由、人格尊严乃至居住权、财产权被恣意践踏，造成次生灾害远大于病毒本身，令世界工厂的产业链、供应链受到重创，是中国继大跃进、文革浩劫之后的第三次大折腾，经济损失惨重、公民权利受到破坏，政府公信力跌落且后患无穷!\n\n又如最近的河北省水灾，违反“水往低处流” 自然法则，让海拔较高的涿州为“保护”海拔较低 的雄安新区，无端成了泄洪区。涿州市民被拍脑袋工程祸害，人命财产损失惨重，是典型的三分天灾，七分人祸。\n\n如此投资环境，令人不寒而栗，自然窒碍了经济发展。\n\n第四，经济上升期重要动力之一，是中国在外交上将中美友好关系放到重中之重地位。正是2001 年九一一事件发生后，中国第一时间表态支持美国反恐，美国遂投桃报李支持中国加入WTO，让中国获得最大红利。但近年中国经济下挫，却与战狼外交有直接关连：君不见前几年国内一片“厉害了， 我的国”，自嗨，狂言“中国已在经济上、科技上、 综合国力上全面超越美国”；扬言“双赢就是中国赢两次”；明明还是一个发展中国家，却动辄宣称中国在某某领域“为人类指明方向”云云。\n\n国际交往欠缺风度，将毛泽东、周恩来的“外交无小事” “有理 有利有节” 遗训抛到九霄云外，撒野成惯性，四面树敌。尤其是去年2月俄罗斯侵略乌克兰以来，一不定性俄方行径为侵略，二对俄侵略罪行坚持不作谴责，三依然宣称“中俄友好无上限，合作无禁区”“会在各方面予以策应”; 中国舆论场叫嚣“俄罗斯的特别军事行动是反对美国霸权主义的正义斗争”……并且在大多数国家对俄侵乌的谴责声中，坚持与俄罗斯频繁进行海陆空联合军演，以致俄罗斯国防部长绍伊古表白“俄中不仅仅是盟友关系”。\n\n连年推行战狼外交的结果，令中美关系跌到 1972年尼克逊总统访华以来最低点，中欧、中英、 中日、中韩、中澳、中加等关系全部跌至几十年来谷底。一带一路、大撒币的结果，只是糟蹋了中国老百姓的民脂民膏，并没有换来真正盟友。\n\n在中共强调“马克思主义行”根本价值观、与俄罗斯抱团取暖，单方面宣布“中英联合声明过时失效”、部署武统台湾等一系列事态演变面前，美国及西方发达国家盟友却意识到，基于国家安全和对以规则为基础国际秩序的维护，有必要“去风险化”，减少对中国产业链，供应链的依赖，并在高科技领域的对华投资、交易予以脱钩，避免养虎为患，反噬自己。\n\n古人云成也萧何败也萧何。外交上亲俄反美的实质表现，理所当然令中国逐渐失去美国和西方的资金、技术、市场，实际上终结了改革开放，重回闭关锁国，其必然趋势则是中国经济大幅萎缩、失业压力山大、广大民众重新返贫。\n\n常言道：经济是基础，政治是经济的集中表现，又曰“外交是内政的延续”。在美国和西方发 达国家，经济繁荣、衰退、复苏、繁荣周而复始， 有其周期性和相应的经济对策。但中国是政治挂帅，政治凌驾经济，而且习惯只算政治账，不算经济账。当前中国经济盛极而衰，正是由于中共只搞局部经济体制改革，迟迟不启动政治体制改革带来的恶果!\n\n**D. 不受制衡绝对权力才是最大腐败**\n\n企图回归改革开放前那套原教旨社会主义，甚至回到阶级斗争为纲、个人崇拜盛行的毛泽东文革时代，以此求得保住共产党的政权安全，只会让僵化的斯大林政治体制下产生的各种社会矛盾越积越多，越激越大。由此令私企痛感君子不立危墙之下，令外商惊悟危邦不入，则中国整个产业链、供应链，资金链将“火烧连营七百里”，这是目前中国经济结构性大坍方，反令共产党政权安全地动山摇的原因。中国前总理温家宝在任内最后一次记者招待会上，曾语重心长地警告：“如果不进行政治体制改革，经济体制改革的成果就会得而复失，类似文化大革命那样的历史悲剧，也有可能重演！”须知不受监督、制约、制衡的绝对权力，才是最大的绝对的腐败，且是各领域包括官场、军队、司法、外援撒币，医疗药业，教育、工程等等腐败的总根子! 药方并不难开：政治体制改革，包括实行宪政、民主、普选制、官员财产申报公示、司法独立、保障言论新闻自由进行舆论监督………是保障经济高速优质发展必由之路。\n\n越南推行革新开放，政治上从党内民主扩展到社会民主，带动经济健康蓬勃发展，对外关系包括对美俄西方及亚细安友好融洽。样板就在眼前。政治造成的经济逆境，必须在政治上对症下药。问题是，从井岗山到延安到西柏坡到登上天安门城楼“一路风尘一路歌”的农民起义军领袖第二代，在“打江山，坐江山”的历史惯性思维下，有通过政治体制改革，实现经济市场化、社会法治化、政治民主化的历史使命感和远见魄力吗?\n","tags":["禁评"]},{"title":"实验二","url":"/2023/05/06/24/","content":"\n# 实验二\n\n## 任务一\n\n- 定义一个视图，包括定单的编号、时间、金额以及收货人的姓名、国家代码和国家名称。\n\n  ```\n  CREATE VIEW OCS (orderNo, orderTime, orderCost, reciName, CountryID, CountryName)\n  AS SELECT Orders.cOrderNo, dOrderDate, mTotalCost, vFirstName+' '+vLastName, Country.cCountryID, cCountry\n  FROM Orders\n  LEFT OUTER JOIN Recipient\n  ON Orders.cOrderNo = Recipient.cOrderNo\n  LEFT OUTER JOIN Country\n  ON Recipient.cCountryId = Country.cCountryId;\n  ```\n\n- 基于（1）中定义的视图，查询所有国家代码为‘001’的收货人的姓名和他们所下定单的笔数及定单的总金额。\n\n  ```\n  SELECT reciName, CountryID, CountryName, count(*) TotalOrders, sum(orderCost) SumOrdercost\n  FROM OCS\n  GROUP BY reciName, CountryName, CountryID\n  HAVING CountryID = '001';\n  \n  ```\n\n- 视图定义如下：\n\n  ```\n  CREATE VIEW vwOrderWrapper\n     AS\n     SELECT cOrderNo, cToyId, siQty, vDescription, mWrapperRate\n     FROM OrderDetail JOIN Wrapper\n     ON OrderDetail.cWrapperId = Wrapper.cWrapperId\n  ```\n\n  执行以下更新命令并分析该命令的执行结果。\n\n  ```\n  UPDATE vwOrderWrapper\n     SET siQty = 2, mWrapperRate = mWrapperRate + 1 \n     WHERE cOrderNo = ‘000001’\n  ```\n\n​\t\t运行结果：视图或函数 'vwOrderWrapper' 不可更新，因为修改会影响多个基表。\n\n​\t\t原因：该视图与两个表相关联\n\n## 任务二\n\n- 在OrderDetail上定义一个触发器，当向OrderDetail表中新增一条记录时，自动修改Toys表中玩具的库存数量（siToyQoh）。\n\n  ```\n  CREATE TRIGGER UpdateSiToyQoh ON OrderDetail\n      AFTER INSERT\n      AS\n          UPDATE Toys\n          SET siToyQoh = siToyQoh - 1\n          WHERE cToyId IN (SELECT cToyId FROM inserted);\n  ```\n\n  测试语句\n\n  ```\n  INSERT INTO OrderDetail VALUES ('000001', '000009', 2, 'N', NULL, NULL, 38.8800);\n  DELETE OrderDetail WHERE cOrderNo = '000001' AND cToyId = '000009';\n  ```\n\n- Orders表是GlobalToyz数据库里的一张核心的表，对这张表上做的任何更新动作（增、删、改）都需要记录下来，这是数据库审计（Audit）的基本思想。要求设计一张表存储对Orders表的更新操作，包括操作者、操作时间、操作类型、更新前的数据、更新后的数据。设计触发器实现对Orders表的审计。\n\n  ```\n  CREATE TABLE Audit(\n      Operator VARCHAR(10),\n      OperateTime DATETIME,\n      OperateWay CHAR(6),\n      OldData VARCHAR(100),\n      NewData VARCHAR(100)\n  )\n  \n  CREATE TRIGGER AuditOrders ON Orders\n      FOR INSERT, DELETE, UPDATE\n      AS BEGIN\n              DECLARE @oper VARCHAR(30) = SYSTEM_USER\n              DECLARE @operTime DATETIME = GETDATE()\n              DECLARE @opway CHAR(6) \n              DECLARE @del INT = (SELECT COUNT(*) FROM deleted)\n              DECLARE @ins INT = (SELECT COUNT(*) FROM inserted)\n              IF @del != 0\n                  IF @ins != 0\n                      SELECT @opway = 'UPDATE'\n                  ELSE\n                      SELECT @opway = 'DELETE'\n              ELSE\n                  SELECT @opway = 'INSERT'\n              DECLARE @olddata VARCHAR(100);\n              DECLARE @newdata VARCHAR(100);\n              SELECT @olddata = (SELECT cOrderNo + CAST(dOrderDate AS VARCHAR(23)) + cCartId +\n                                 cShopperId + cShippingModeId + str(mShippingCharges) +\n                                 str(mGiftWrapCharges) + cOrderProcessed +\n                                 str(mTotalCost) + CAST(dExpDelDate AS VARCHAR(23))\n                          FROM deleted) \n              SELECT @newdata = (SELECT cOrderNo + CAST(dOrderDate AS VARCHAR(23)) + cCartId +\n                                 cShopperId + cShippingModeId + str(mShippingCharges) +\n                                 str(mGiftWrapCharges) + cOrderProcessed +\n                                 str(mTotalCost) + CAST(dExpDelDate AS VARCHAR(23))\n                          FROM inserted) \n              INSERT INTO Audit values (@oper, @operTime, @opway, @olddata, @newdata);\n      END\n  --测试语句\n  INSERT INTO Orders VALUES ('000011', GETDATE(), '000005', '000007', '03', 21, 2, 'Y', 59, GETDATE());\n  UPDATE Orders\n      SET cCartId = '000008'\n      WHERE cOrderNo = '000011'\n  DELETE Orders WHERE cOrderNo = '000011';\n  ```\n\n## 任务三\n\n- 修改表ShoppingCart的结构，在表中新增一个字段‘Status’。该字段取值为1，表示该玩具为本次下订单时要购买的玩具。在表ShoppingCart中生成一些模拟数据。\n\n  ```\n  ALTER TABLE ShoppingCart\n  ADD\n      Status INT CHECK (Status = 0 OR Status = 1) DEFAULT 0;\n      \n  UPDATE ShoppingCart\n  SET Status = (SELECT CAST(FLOOR(RAND(convert(varbinary, newid())) * 2) AS INT))\n  ```\n\n- 当购物者确认定单时，应该包含下面的步骤：\n\n  > 产生新的定单号。\n  >\n  > 定单号，当前日期，购物车ID，和购物者ID加到Orders表中。\n  >\n  > 定单号，玩具ID和数量加到OrderDetail表中。\n  >\n  > 在OrderDetail表中更新玩具成本。（提示：Toy cost = Quantity * Toy Rate）。\n  >\n  > 从ShoppingCart表中将本次已购买的玩具删除。\n\n​\t\t将上述步骤定义为一个事务。编写一个存储过程以购物车ID（cCartId）和购物者ID(cShopperId)为参数，实现这个事务。用在第\t\t（1）题中生成的模拟数据测试存储过程。\n\n```\nCREATE PROCEDURE P\n(\n    @cCartID CHAR(6),\n    @cShopperID CHAR(6)\n)\nAS\n    BEGIN\n        BEGIN TRANSACTION\n            DECLARE @ret INT = 0;\n            DECLARE @ordno CHAR(6) = RIGHT('000000'+CONVERT(CHAR(2),(SELECT max(CAST(cOrderNo AS INT)) FROM Orders) + 1), 6);\n            DECLARE @orddate DATETIME = GETDATE()\n            DECLARE @shipmod CHAR(2) = RIGHT('00'+CONVERT(VARCHAR, CEILING(RAND(convert(varbinary, newid())) * 3)), 2);\n            DECLARE @shipcharge money = CAST(CEILING(RAND(convert(varbinary, newid())) * 90) AS MONEY)\n            DECLARE @num INT = (SELECT COUNT(*) FROM ShoppingCart WHERE cCartId = @cCartID AND Status = 1)\n            IF @num != 0\n                BEGIN\n                    INSERT INTO Orders VALUES\n                    (@ordno, @orddate, @cCartID, @cShopperID, @shipmod, @shipcharge, NULL, 'Y', NULL, @orddate)\n                    DECLARE @ctoyID CHAR(6), @siqty SMALLINT;\n                    DECLARE cursor_temp CURSOR LOCAL SCROLL FOR\n                    (SELECT cToyId, siQty FROM ShoppingCart WHERE cCartId = @cCartID AND Status = 1)\n                    OPEN cursor_temp\n                    FETCH FIRST FROM cursor_temp INTO @ctoyID, @siqty;\n                    WHILE(@@fetch_status = 0)\n                        BEGIN\n                            INSERT INTO OrderDetail VALUES\n                            (@ordno, @ctoyID, @siqty, 'N', NULL, NULL, NULL)\n                            UPDATE OrderDetail\n                            SET mToyCost = siQty * (SELECT mToyRate FROM Toys WHERE Toys.cToyId = @ctoyID)\n                            WHERE cOrderNo = @ordno;\n                            DELETE FROM ShoppingCart\n                            WHERE cToyId = @ctoyID AND cCartId = @cCartID;\n                            FETCH NEXT FROM cursor_temp INTO @ctoyID, @siqty;\n                        END\n                    CLOSE cursor_temp\n                    DEALLOCATE cursor_temp;\n                END\n        IF @ret = 0\n            BEGIN\n                COMMIT TRANSACTION\n                PRINT N'成功更新--finished'\n            END\n        ELSE\n            BEGIN\n                ROLLBACK TRANSACTION\n                PRINT N'Status为0--rollback'\n            END\n    END\ngo\n--测试样例\nEXEC P @cCartID = '000001', @cShopperID = '000015';\nEXEC P @cCartID = '000002', @cShopperID = '000024';\n```\n\n## 任务四\n\n- 基于表Orders和Shopper，以下列格式生成报表：（要求用游标实现）\n\n  >       购货人ID   XXX    购货人姓名   XXX    \n  >       购货人地址  XXXXXX \n  >       定单号XXX  定单时间XXX  定单金额XXX\n  >       定单号XXX  定单时间XXX  定单金额XXX\n\n  ```\n  BEGIN\n      DECLARE @sid CHAR(6), @sname VARCHAR(40), @sAddress VARCHAR(40), @ordno CHAR(6), @ordtime VARCHAR(100), @ordmoney MONEY\n      DECLARE cursor_1 CURSOR LOCAL SCROLL FOR\n      (SELECT Orders.cShopperId, vFirstName + vLastName AS Name, vAddress, cOrderNo, CONVERT(VARCHAR(100), dOrderDate, 120), mTotalCost\n       FROM Orders\n       LEFT OUTER JOIN Shopper\n       ON Orders.cShopperId = Shopper.cShopperId)\n      OPEN cursor_1\n      FETCH FIRST FROM cursor_1 INTO @sid, @sname, @sAddress, @ordno, @ordtime, @ordmoney;\n      PRINT N'订单报表如下:'\n      WHILE (@@fetch_status = 0)\n          BEGIN\n              PRINT N'购货人ID： ' + @sid + CHAR(9) + N'购货人姓名： ' + @sname;\n              PRINT N'购货人地址： ' + @sAddress;\n              PRINT N'订单号： ' + @ordno + N'  订单时间：' + @ordtime + N'  订单金额：' + convert(varchar(10),@ordmoney);\n              FETCH NEXT FROM cursor_1 INTO @sid, @sname, @sAddress, @ordno, @ordtime, @ordmoney;\n          END\n      CLOSE cursor_1\n      DEALLOCATE cursor_1;\n  END\n  ```\n\n- 编写代码，分析玩具和地域的关系，例如哪个城市的购买者对哪一种、哪一类或哪一个品牌的玩具更有兴趣。这道题是个开放的题目，同学们可以按照自己的理解从不同的角度进行分析。实验报告中需给出代码、结果截图和对分析结果的文字描述。\n\n  ```\n  SELECT cCity, cToyId INTO ##T1 FROM Orders\n  LEFT OUTER JOIN OrderDetail\n  ON Orders.cOrderNo = OrderDetail.cOrderNo\n  LEFT OUTER JOIN Shopper\n  ON Orders.cShopperId = Shopper.cShopperId\n  \n  SELECT cCity, ##T1.cToyId, cBrandId, cCategoryId  INTO ##T2 FROM ##T1\n  LEFT OUTER JOIN Toys\n  ON ##T1.cToyId = Toys.cToyId\n  WHERE vToyName IS NOT NULL;\n  \n  SELECT cCity AS N'城市', cBrandName AS N'品牌', COUNT(cBrandName) AS N'总计'\n  INTO ##T3\n  FROM ##T2\n  LEFT OUTER JOIN ToyBrand ON\n  ##T2.cBrandId = ToyBrand.cBrandId\n  GROUP BY cBrandName, cCity\n  \n  --测试案例\n  SELECT TOP 3 城市, 品牌, 总计 FROM ##T3 WHERE 总计 > 1;\n  ```\n","tags":["SQL Server"]},{"title":"实验一","url":"/2023/05/06/23/","content":"\n# 实验一\n\n## 任务一\n\n- 创建一张表Orders_Jan，表的结构与Orders相同，将Orders表中month为‘Jan’的订单记录复制到表Orders_Jan中。\n\n  ```\n  SELECT * \n  INTO Orders_Jan \n  FROM ORDERS \n  WHERE month = 'Jan';\n  ```\n\n- 将Orders表中month为‘Jan’的订单记录全部删掉。\n\n  ```\n  DELETE FROM ORDERS WHERE month = 'Jan';\n  ```\n\n- 对曾经下过金额（dollars）大于500的订单的客户，将其discnt值增加2个百分点（+2）。\n\n  ```\n  UPDATE CUSTOMERS \n  SET discnt = discnt + 2\n  WHERE cid \n  IN (SELECT cid FROM ORDERS WHERE dollars > 500);\n  ```\n\n- 写一段TSQL程序，向表Orders中增加5000条记录，要求订单尽可能均匀地分布在12个月中。\n\n  ```\n  DECLARE @i INT = 1\n  DECLARE @maxm INT;\n  SELECT @maxm = max(ordno) FROM ORDERS /*获取表单中最大值*/\n  WHILE @i <= 5000\n  BEGIN\n      DECLARE @newno INT = @maxm + @i;\n      DECLARE @newmon INT;\n      SELECT @newmon = (SELECT CAST(CEILING(RAND() * 12) AS INT))\n      DECLARE @strnewmon VARCHAR(4);\n      SELECT @strnewmon =\n             CASE\n                 WHEN @newmon = 1 THEN 'Jan'\n                 WHEN @newmon = 2 THEN 'Feb'\n                 WHEN @newmon = 3 THEN 'Mar'\n                 WHEN @newmon = 4 THEN 'Apr'\n                 WHEN @newmon = 5 THEN 'May'\n                 WHEN @newmon = 6 THEN 'Jun'\n                 WHEN @newmon = 7 THEN 'Jul'\n                 WHEN @newmon = 8 THEN 'Aug'\n                 WHEN @newmon = 9 THEN 'Sep'\n                 WHEN @newmon = 10 THEN 'Oct'\n                 WHEN @newmon = 11 THEN 'Nov'\n                 WHEN @newmon = 12 THEN 'Dec'\n              END\n      DECLARE @newcid VARCHAR(4);\n      SELECT @newcid = 'C' + (SELECT CAST(CEILING(RAND() * 500) AS VARCHAR(3)))\n      DECLARE @newqty INT;\n      SELECT @newqty = (SELECT CAST(floor(RAND() * 1000) AS INT))\n      DECLARE @newdollars DECIMAL(10, 2);\n      SELECT @newdollars = (SELECT CAST(ceiling(RAND() * 1000) AS DECIMAL(10,2)))\n      INSERT INTO ORDERS (ordno, month, cid, qty, dollars)\n      values (@newno, @strnewmon, @newcid, @newqty, @newdollars);\n      SELECT @i = @i + 1;\n  END\n  ```\n\n- 在表Orders的’month’字段上建立索引。\n\n  ```\n  CREATE INDEX MONTH_INDEX ON ORDERS(month(50));\n  ```\n\n- 创建一个视图order_month_summary，视图中的字段包括月份、该月的订单总量和该月的订单总金额。基于视图order_month_summary，查询第一季度各个月份的订单总量和订单总金额。\n\n  ```\n  CREATE VIEW order_month__summary (month, countorders, sumdollars)\n  AS SELECT month, count(*), sum(dollars)\n     FROM ORDERS\n     GROUP BY month\n     HAVING month = 'Jan' or month = 'Feb' or month = 'Jun'\n     COLLATE Chinese_PRC_CI_AI;\n  ```\n\n## 任务二\n\n- 查找属于California和Florida州的顾客的名、姓和emailID。\n\n  ```\n  SELECT vFirstName, vLastName, vEmailId\n  FROM Shopper\n  WHERE cShopperId IN (SELECT cShopperId FROM Orders) \n    AND (cState = 'California' or cState = 'Florida');\n  ```\n\n- 查找定单号码、顾客ID，定单的总价值，并以定单的总价值的升序排列。\n\n  ```\n  SELECT cOrderNo, cShopperId, mTotalCost \n  FROM Orders \n  ORDER BY mTotalCost;\n  ```\n\n- 查找在orderDetail表中vMessage为空值的行。\n\n  ```\n  SELECT * \n  FROM OrderDetail \n  WHERE vMessage IS NULL ;\n  ```\n\n- 查找玩具名字中有“Racer”字样的所有玩具的基本资料。\n\n  ```\n  SELECT * \n  FROM Toys \n  WHERE vToyName LIKE '%Racer%';\n  ```\n\n- 根据2016年的玩具销售总数，查找“Pick of the Month”玩具的前五名玩具的ID。\n\n  ```\n  SELECT cToyId \n  FROM PickOfMonth \n  GROUP BY cToyId \n  ORDER BY sum(iTotalSold)\n  LIMIT 5;\n  ```\n\n- 根据OrderDetail表，查找玩具总价值大于￥50的定单的号码和玩具总价值。\n\n  ```\n  SELECT cOrderNo, mToyCost \n  FROM OrderDetail \n  WHERE mToyCost > 50;\n  ```\n\n- 查找一份包含所有装运信息的报表，包括：Order Number, Shipment Date, Actual Delivery Date, Days in Transit. (提示：Days in Transit = Actual Delivery Date – Shipment Date) \n\n  ```\n  SELECT cOrderNo, dShipmentDate, dActualDeliveryDate, DATEDIFF( dActualDeliveryDate , dShipmentDate ) AS DaysInTransit\n  FROM Shipment;\n  ```\n\n- 查找所有玩具的名称、商标和种类（Toy Name, Brand, Category）。\n\n  ```\n  SELECT Toys.vToyName ToyName, ToyBrand.cBrandName Brand, Category.cCategory Category\n  FROM Toys\n  LEFT OUTER JOIN ToyBrand\n  ON Toys.cBrandId = ToyBrand.cBrandId\n  LEFT OUTER JOIN Category\n  ON Toys.cCategoryId = Category.cCategoryId;\n  ```\n\n- 查找玩具的名称和所有玩具的购物车ID。如果玩具不在购物车中，也需在结果中出现。\n\n  ```\n  SELECT Toys.vToyName, ShoppingCart.cCartId\n  FROM Toys\n  LEFT OUTER JOIN ShoppingCart\n  ON Toys.cToyId = ShoppingCart.cToyId;\n  ```\n\n- 以下列格式查找所有购物者的名字和他们的简称：（Initials, vFirstName, vLastName）,例如Angela Smith的Initials为A.S。\n\n  ```\n  SELECT concat(substring(vFirstName,1,1),'.',substring(vLastName,1,1)) Initials,vFirstName,vLastName \n  FROM shopper;\n  ```\n\n- 查找所有玩具的平均价格，并舍入到整数。\n\n  ```\n  SELECT ROUND(avg(mtoyrate),0) averagerate \n  FROM toys;\n  ```\n\n- 查找所有购买者和收货人的名、姓、地址和所在城市，要求保留结果中的重复记录。\n\n  ```\n  SELECT Shopper.vFirstName BuyerFisrtName , Shopper.vLastName BuyerLastName , Shopper.vAddress BuyerAddress, Shopper.cCity BuyerCity,\n      Recipient.vFirstName ReciFirstName ,Recipient.vLastName ReciLastName,Recipient.vAddress ReciAdress, Recipient.cCity ReciCity\n  FROM Orders\n  LEFT OUTER JOIN Shopper\n  ON Orders.cShopperId = Shopper.cShopperId\n  LEFT OUTER JOIN Recipient\n  ON Orders.cOrderNo = Recipient.cOrderNo;\n  ```\n\n- 查找没有包装的所有玩具的名称。（要求用子查询实现）\n\n  ```\n  SELECT vToyName\n  FROM Toys\n  WHERE cToyId IN (SELECT cToyId\n                   FROM OrderDetail\n                   WHERE cWrapperId IS NULL);\n  ```\n\n- 查找已收货定单的定单号码以及下定单的时间。（要求用子查询实现）\n\n  ```\n  SELECT cOrderNo, dOrderDate\n  FROM Orders\n  WHERE cOrderNo IN (SELECT cOrderNo\n                     FROM Shipment\n                     WHERE dActualDeliveryDate IS NULL);\n  ```\n\n- 查找从来没有下过订单的顾客。\n\n  ```\n  SELECT *\n  FROM Shopper\n  WHERE Shopper.cShopperId NOT IN (SELECT Orders.cShopperId FROM Orders);\n  ```\n\n- 删除“Largo”牌的所有玩具。\n\n  ```\n  DELETE FROM Toys WHERE cBrandId IN\n  (SELECT cBrandId FROM ToyBrand WHERE cBrandName = 'Largo');\n  /*存在外键约束，无法删除*/\n  ```\n\n","tags":["MySQL"]},{"title":"算法分析与设计实践","url":"/2023/04/26/11/","content":"\n# P1302 可见矩形\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1302\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n给定平面上 n 个互不相交（指公共面积为零）的正方形，它们的顶点坐标均为整数。设坐标原点为 O(0,0)。对于任一正方形 R，如果可以找到 R 的边上 2 个不同的点 A 和 B，使  三角形OAB 的内部与其他正方形无公共点，则称正方形 R 是从 O 点可见的正方形。\n\n对于给定的 n 个互不相交的正方形，计算从坐标原点 O 可见的正方形个数。\n\n### 输入格式\n\n输入文件的第一行是正方形个数n（1≤n≤10001≤n≤1000）\n\n接下来n行中，每行有三个表示正方形的整数 X,Y,L。其中，X 和 Y 表示正方形的左下角顶点坐标，L表示边长，1≤X,Y,Z≤10000。\n\n### 输出格式\n\n输出文件仅有一行包含一个整数，表示从坐标原点 O 可见的正方形个数。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n3\n2 6 4\n1 4 1\n2 4 1\n```\n\n#### 样例输出 #1\n\n```\n3\n```\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t设正方形的左下端点（aa，bb），边长为cc，参数cmp=aa+bb+cc。不难发现，cmp较小的正方形可以遮挡cmp较大的正方形，于是记录每个正方形的斜率范围。即最小斜率bb/(aa+cc)和最大斜率(bb+cc)/aa，并针对cmp参数进行递增排序\n\n​\t\t建立二维数组a负责储存不可用的斜率范围，a数组奇数编号储存起始斜率，偶数编号储存截止斜率。于是便可用数组a表示所有不可用范围。初始的斜率范围即为k[1].s到k[1].l，下面依次使各正方形的斜率进入数组。\n\n​\t\t第i号正方形进入数组：比k[i].s还小的元素直接照抄，不需更改，直到找到第一个大于等于k[i].s的元素。若该元素编号为奇数，即为一个范围的起始位置，说明k[i].s的进入产生了一个新的不可用范围，直接使k[i].s进入数组。若该元素编号为偶数，即为一个范围的结束位置，说明k[i].s处在某个范围内部，不需要产生新的起始点，不进行操作，继续向下查找元素。处在k[i].s和k[i].l之间的元素无需理会，直到找到第一个大于等于k[i].l的元素，对k[i].l的操作跟k[i].s基本相同。\n\n### 算法代码\n\n```\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n;\nint ans;\nstruct node{\n\tdouble l,s,cmp;\n}k[100100];\nbool cmp(node x,node y){\n\treturn x.cmp<y.cmp;\n}\ndouble a[10001][10001];\nint cnt[10001];\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c>'9'||c<'0'){\n\t\tif(c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<3)+(x<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint main(){\n\tn=read();\n\tint aa,bb,cc;\n\tfor(int i=1;i<=n;i++){\n\t\taa=read();\n\t\tbb=read();\n\t\tcc=read();\n\t\tk[i].l=(bb+cc)*1.0/aa;\n\t\tk[i].s=bb*1.0/(aa+cc);\n\t\tk[i].cmp=aa+bb+cc;\n\t}\n\tsort(k+1,k+1+n,cmp);\n\ta[1][1]=k[1].s;\n\ta[1][2]=k[1].l;\n\tcnt[1]=2;\n\tfor(int i=2;i<=n;i++){\n\t\tint t=1;\n\t\twhile(a[i-1][t]<k[i].s&&t<=cnt[i-1]){\n\t\t\ta[i][t]=a[i-1][t];\n\t\t\tt++;\n\t\t}\n\t\tint l=t;\n\t\tcnt[i]=t-1;\n\t\tif(t%2==1){\n\t\t\ta[i][++cnt[i]]=k[i].s;\n\t\t\tif(a[i-1][t]==a[i][t]) l=t+1;\n\t\t} \n\t\twhile(a[i-1][t]<=k[i].l&&t<=cnt[i-1]){\n\t\t\tt++;\n\t\t}\n\t\tint r=t;\n\t\tif(t%2==1){\n\t\t\ta[i][++cnt[i]]=k[i].l;\n\t\t\tif(a[i-1][t-1]==a[i][cnt[i]]) r--;\n\t\t} \n\t\twhile(t<=cnt[i-1]){\n\t\t\ta[i][++cnt[i]]=a[i-1][t]; \n\t\t\tt++;\n\t\t}\n\t\tif(r-l>=1) ans++;\n\t\telse{\n\t\t\tif(r%2==1) ans++;\n\t\t}\n\t}\n\tcout<<ans+1;\n\treturn 0;\n}\n```\n\n## 总结与讨论\n\n算法的时间复杂度比较高。\n\n\n\n# P1784 数独\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1784\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n数独是根据 $9 \\times 9$ 盘面上的已知数字，推理出所有剩余空格的数字，并满足每一行、每一列、每一个粗线宫内的数字均含 $1 - 9$ ，不重复。每一道合格的数独谜题都有且仅有唯一答案，推理方法也以此为基础，任何无解或多解的题目都是不合格的。\n\n芬兰一位数学家号称设计出全球最难的“数独游戏”，并刊登在报纸上，让大家去挑战。\n\n这位数学家说，他相信只有“智慧最顶尖”的人才有可能破解这个“数独之谜”。\n\n据介绍，目前数独游戏的难度的等级有一到五级，一是入门等级，五则比较难。不过这位数学家说，他所设计的数独游戏难度等级是十一，可以说是所以数独游戏中，难度最高的等级。他还表示，他目前还没遇到解不出来的数独游戏，因此他认为“最具挑战性”的数独游戏并没有出现。\n\n### 输入格式\n\n一个未填的数独。\n\n### 输出格式\n\n填好的数独。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n8 0 0 0 0 0 0 0 0 \n0 0 3 6 0 0 0 0 0 \n0 7 0 0 9 0 2 0 0 \n0 5 0 0 0 7 0 0 0 \n0 0 0 0 4 5 7 0 0 \n0 0 0 1 0 0 0 3 0 \n0 0 1 0 0 0 0 6 8 \n0 0 8 5 0 0 0 1 0 \n0 9 0 0 0 0 4 0 0\n```\n\n#### 样例输出 #1\n\n```\n8 1 2 7 5 3 6 4 9 \n9 4 3 6 8 2 1 7 5 \n6 7 5 4 9 1 2 8 3 \n1 5 4 2 3 7 8 9 6 \n3 6 9 8 4 5 7 2 1 \n2 8 7 1 6 9 5 3 4 \n5 2 1 9 7 4 3 6 8 \n4 3 8 5 2 6 9 1 7 \n7 9 6 3 1 8 4 5 2\n```\n\n### 样例 #2\n\n#### 样例输入 #2\n\n```\n9 0 0 8 0 0 0 0 0\n0 0 0 0 0 0 5 0 0 \n0 0 0 0 0 0 0 0 0 \n0 2 0 0 1 0 0 0 3\n0 1 0 0 0 0 0 6 0\n0 0 0 4 0 0 0 7 0\n7 0 8 6 0 0 0 0 0 \n0 0 0 0 3 0 1 0 0 \n4 0 0 0 0 0 2 0 0 \n```\n\n#### 样例输出 #2\n\n```\n9 7 2 8 5 3 6 1 4 \n1 4 6 2 7 9 5 3 8 \n5 8 3 1 4 6 7 2 9 \n6 2 4 7 1 8 9 5 3 \n8 1 7 3 9 5 4 6 2 \n3 5 9 4 6 2 8 7 1 \n7 9 8 6 2 1 3 4 5 \n2 6 5 9 3 4 1 8 7 \n4 3 1 5 8 7 2 9 6 \n```\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t数独是源自18世纪瑞士的一种数学游戏。是一种运用纸、笔进行演算的逻辑游戏。玩家需要根据9×9盘面上的已知数字，推理出所有剩余空格的数字，并满足每一行、每一列、每一个粗线宫（3×3）内的数字均含1-9，不重复。\n\n​\t\t数独要求每一行、每一列、每一个3×3方阵内的数字，不重复。行和列重复判断是相当简单的。我们可以定义两个bool型二维数组，当此行（或列）填充数字时，我们可以直接把这行的这个数字打上true表示有数字了。\n\n### 算法代码\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint sd[11][11];//数独方阵定义 \nbool p[11][11],l[11][11],fz[11][11];//行，列，方阵。 \n\nvoid _out()\n{\n    cout<<endl;\n\tfor(int i=1;i<=9;i++)\n\t{\t\n  \t\tfor(int j=1;j<=9;j++)\n\t\t\tcout<<sd[i][j]<<\" \";\n\t\tcout<<endl;\n\t}\n\texit(0); \n}\nvoid dfs(int x,int y)\n{\n\tif(sd[x][y]!=0)//如果原来这个位置有数字，跳过。 \n\t\tif(x==9&&y==9)_out();//当行列都为9，填充完成，输出\n\t\telse if(y==9)dfs(x+1,1);//当列数为9，搜索下一排。 \n\t\telse dfs(x,y+1);//搜下一列 \n\telse//原来的地方没有数字，准备填充！ \n\t\tfor(int i=1;i<=9;i++)\n\t\t\tif((!p[x][i])&&(!l[y][i])&&(!fz[(x-1)/3*3+(y-1)/3+1][i]))\n\t\t\t//判断是不是重复了。\n\t\t\t{\n\t\t\t\tsd[x][y]=i;//填充！ \n\t\t\t\tp[x][i]=l[y][i]=fz[(x-1)/3*3+(y-1)/3+1][i]=true;//打上标记。 \n\t\t\t\tif(x==9&&y==9)_out();//全部填完！输出\n\t\t\t\telse if(y==9)dfs(x+1,1);//同上！搜下一行。\n\t\t\t\telse dfs(x,y+1);//搜下一列！ \n\t\t\t\tsd[x][y]=0; //恢复标记。 \n\t\t\t\tp[x][i]=l[y][i]=fz[(x-1)/3*3+(y-1)/3+1][i]=false;//恢复标记。 \n\t\t\t}\n}\nint main()\n{\n\tfor(int i=1;i<=9;i++)\n\t\tfor(int j=1;j<=9;j++)\n\t\t{\n\t\t\tint t;//定义tmp（防止下面代码太长？） \n\t\t\tcin>>t;//输入 \n\t\t\tif(t!=0)\n\t\t\t\tp[i][t]=l[j][t]=fz[(i-1)/3*3+(j-1)/3+1][t]=true;\n\t\t\t//填充的不是0的话，表示原来有数字了。打上标记。\t\n\t\t\tsd[i][j]=t;//填充进数独。 \n\t\t}\t\n\tdfs(1,1);//搜索\n\treturn 0;//结束 \n}\n```\n\n## 总结与讨论\n\n​\t\t算法的难点在于判断数字的重复。\n\n\n\n# P1229 遍历问题\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1229\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n我们都很熟悉二叉树的前序、中序、后序遍历，在数据结构中常提出这样的问题：已知一棵二叉树的前序和中序遍历，求它的后序遍历，相应的，已知一棵二叉树的后序遍历和中序遍历序列你也能求出它的前序遍历。然而给定一棵二叉树的前序和后序遍历，你却不能确定其中序遍历序列，考虑如下图中的几棵二叉树：\n\n ![](https://cdn.luogu.com.cn/upload/pic/73.png) \n\n所有这些二叉树都有着相同的前序遍历和后序遍历，但中序遍历却不相同。\n\n### 输入格式\n\n输A数据共两行，第一行表示该二叉树的前序遍历结果s1，第二行表示该二叉树的后序遍历结果s2。\n\n### 输出格式\n\n输出可能的中序遍历序列的总数，结果不超过长整型数。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\nabc                           \ncba\n```\n\n#### 样例输出 #1\n\n```\n4\n```\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t给定中能确定树的具体结构，是因为可以确定是左子树还是右子树，而之给定前和后，则不能确定，这就是会出现不同树结构的原因。只有前和后那么主要问题就是没有办法处理只有一个子树的情况，因为这种情况不知道子树究竟是这个节点的左子树还是右子树，也就是说其实这道题要判断遍历中存在着多少个只有一棵子树的情况。对于前，如果一个结点的下个结点等于后中对应结点的前一个结点的话，那么这个结点就是根节点且其只有一个子树。sum初始化为1，出现一个只有一棵子树的情况，就把sum*2。\n\n```\n#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int i;\n    long long c=1;\n    string s1,s2,s3;\n    cin >> s1 >> s2;\n    for (i=0; i<s1.length()-1; i++) {\n        s3 = s1.substr(i,2); // 截取相邻的两个字符串\n        reverse(s3.begin(),s3.end()); // 反转\n        if (s2.find(s3) != string::npos) c *= 2; // 匹配成功则总数*2\n    }\n    cout << c << endl;\n}\n```\n\n## 总结与讨论\n\n​\t\t乍一看很难，实则找规律。\n\n\n\n# P1387 最大正方形\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1387\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n在一个 n×mn×m的只包含 0和1的矩阵里找出一个不包含 0的最大正方形，输出边长。\n\n### 输入格式\n\n输入文件第一行为两个整数n,m(1≤n,m≤100)，接下来 n 行，每行 m 个数字，用空格隔开，0 或 1。\n\n### 输出格式\n\n一个整数，最大正方形的边长。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n4 4\n0 1 1 1\n1 1 1 0\n0 1 1 0\n1 1 0 1\n```\n\n#### 样例输出 #1\n\n```\n2\n```\n\n## 算法\n\n### 问题分析与算法设计\n\n暴力算法：枚举每一个点作为所选正方形的左上角的点，然后枚举正方形边长，逐一判断。\n\n### 算法代码\n\n```\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool f[202][202]={0},p;\nint n,m,i,j,k,x,y,ans=0;\n\nint main()\n{\n  cin>>m;\n  cin>>n;\n  for (int i=0; i<n; i++)\n    for (int j=0; j<m; j++)\n      cin>>f[i][j];          \n  for (int i=0; i<n; i++)\n    for (int j=0; j<m; j++)\n      for (int k=min(n,m); k>ans; k--){\n          p=1;\n          for (int x=i; x<i+k; x++){\n              for (int y=j; y<j+k; y++){\n                  if (!f[x][y])      \n                      {\n                        p=0; \n                        break;   \n                      }\n              }\n              if (!p){\n              \tbreak;\n              }     \n            }\n          if (p){\n              ans=k; \n              break;       \n            }\n        }\n  cout<<ans<<endl;                \n  return 0;\n}\n```\n\n## 总结与讨论\n\n​\t\t时间复杂度略高，还需要改进。\n\n\n\n# P1123 取数游戏\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1123\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n一个$N \\times M$的由非负整数构成的数字矩阵，你需要在其中取出若干个数字，使得取出的任意两个数字不相邻（若一个数字在另外一个数字相邻$8$个格子中的一个即认为这两个数字相邻），求取出数字和最大是多少。\n\n### 输入格式\n\n第1行有一个正整数$T$，表示了有$T$组数据。\n\n对于每一组数据，第一行有两个正整数$N$和$M$，表示了数字矩阵为$N$行$M$列。\n\n接下来$N$行，每行$M$个非负整数，描述了这个数字矩阵。\n\n### 输出格式\n\n$T$行，每行一个非负整数，输出所求得的答案。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n3\n4 4\n67 75 63 10\n29 29 92 14\n21 68 71 56\n8 67 91 25\n2 3\n87 70 85\n10 3 17\n3 3\n1 1 1\n1 99 1\n1 1 1\n```\n\n#### 样例输出 #1\n\n```\n271\n172\n99\n```\n\n#### 提示\n\n对于第1组数据，取数方式如下：\n\n[67] 75 63 10\n\n29 29 [92] 14\n\n[21] 68 71 56\n\n8 67 [91] 25\n\n对于$20\\%$的数据，$N, M≤3$；\n\n对于$40\\%$的数据，$N,M≤4$；\n\n对于$60\\%$的数据，$N, M≤5$；\n\n对于$100\\%$的数据，$N, M≤6,T≤20$。\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t对于本题，如果使用贪心法，每次去最大值，那么可以发现有问题。因为每取一个数，相邻的数就不能再取，那么每次决策就会影响下次结果，从而导致贪心决策不能最优化。动态规划也是如此，在动态规划中，每一个分步决策不能影响后续结果，所以此算法也排除。\n\n​\t\t根据数据范围，所以可以考虑暴力枚举，而对于一个图，以及一个变化的状态，深度优先搜索（dfs） 应该是一个比较适合的算法。\n再考虑每个数的状态。显然，对于一个数，有取与不取两种状态，状态改变取决于周围取数的变化。我们用 mark[ i ][ j ] 记录点 ( i , j ) 附近有几个数，若 mark[i] [j] ! = 0 就代表不能取这个数。\n\n### 算法代码\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int d[8][2]={1,0,-1,0,0,1,0,-1,1,1,-1,1,1,-1,-1,-1};//方向数组用来控制搜索时的方向 \nint t,n,m,s[8][8],mark[8][8],ans,mx;\n\nvoid dfs(int x,int y){//搜索函数，表示搜索点(x,y) \n\tif(y==m+1){//当y到边界时，搜索下一行 \n\t\tdfs(x+1,1);\n\t\treturn;\n\t}\n\tif(x==n+1){//当x到边界时，搜索结束，刷新最大值 \n\t\tmx=max(ans,mx);\n\t\treturn;\n\t}\n\t\n\tdfs(x,y+1);// 不取此数的情况 \n\t\n\tif(mark[x][y]==0){ //取此数的情况（需保证此数周围没有取其他数，即mark[i][j]==0）\n\t\tans+=s[x][y];\n\t\tfor(int fx=0;fx<8;++fx){ //标记周围的数 \n\t\t\t++mark[x+d[fx][0]][y+d[fx][1]];\n\t\t}\n\t\tdfs(x,y+1);\n\t\tfor(int fx=0;fx<8;++fx){ //回溯 \n\t\t\t--mark[x+d[fx][0]][y+d[fx][1]];\n\t\t}\n\t\tans-=s[x][y];\n\t}\n\t\n}\nint main(){\n\tcin>>t; \n\twhile(t--){\n\t\tmemset(s,0,sizeof(s));\n\t\tmemset(mark,0,sizeof(mark));//在做每个数据前都要初始化数组 \n\t\tcin>>n>>m;\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tfor(int j=1;j<=m;++j){\n\t\t\t\tcin>>s[i][j];\n\t\t\t}\n\t\t}\n\t\tmx=0;\n\t\tdfs(1,1);//从点(1,1)开始搜索 \n\t\tcout<<mx<<endl;\n\t}\n\treturn 0;\n}\n```\n\n## 总结与讨论\n\n​\t\t主要需要确定算法和考虑标记状态。\n\n\n\n# P1576 最小花费\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1576\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n在 $n$ 个人中，某些人的银行账号之间可以互相转账。这些人之间转账的手续费各不相同。给定这些人之间转账时需要从转账金额里扣除百分之几的手续费，请问 $A$ 最少需要多少钱使得转账后 $B$ 收到 $100$ 元。\n\n### 输入格式\n\n第一行输入两个正整数 $n,m$，分别表示总人数和可以互相转账的人的对数。\n\n以下 $m$ 行每行输入三个正整数 $x,y,z$，表示标号为 $x$ 的人和标号为 $y$ 的人之间互相转账需要扣除 $z\\%$ 的手续费 $(z<100)$。\n\n最后一行输入两个正整数 $A,B$。数据保证 $A$ 与 $B$ 之间可以直接或间接地转账。\n\n### 输出格式\n\n输出 $A$ 使得 $B$ 到账 $100$ 元最少需要的总费用。精确到小数点后 $8$ 位。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n3 3                                     \n1 2 1\n2 3 2\n1 3 3\n1 3\n```\n\n#### 样例输出 #1\n\n```\n103.07153164\n```\n\n#### 提示\n\n$1\\le n \\le 2000,m\\le 100000$。\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t将本题抽象化之后不难发现本题就是最短路径问题，可采用Dijkstra算法解决。最小花费就是把每个人看做一个点，每次转账看做一个边，把花费看做边权，并且要建双向边。 i，j互相转账就相当于节点i和j之间有一条权值为（1-z%）的边，求一条路径使路径上各边权值乘积最大。结果就是100/max。 \n\n### 算法代码\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n,m,a,b;//意思如题意\nbool mark[2005];//记下该点有无被遍历过\ndouble d[2005];//B点到该点的费用\nvector < pair <int,int> > s[2005];//用可变数组来记两点之间能否到达和费用如何，相较于普通数组更加方便\nmultiset <pair <int,int> > f;//multiset里用pair 是按前面的数排序\n\nvoid dij() {\n\tfor(int i=1; i<=n; i++) d[i]=1e9;//若B到达不了，则费用无限大\n\td[b]=100;//B到B，100元\n\tf.insert(make_pair(d[b],b));\n\tfor(int i=1; i<=n; i++) {\n\t\twhile(!f.empty()&&mark[(*f.begin()).second]) f.erase(f.begin());//如果该点被遍历过则不要\n\t\tint p=(*f.begin()).second;//遍历点\n\t\tmark[p]=1;\n\t\tfor(int j=0; j<s[p].size(); j++) {\n\t\t\tint h=s[p][j].second,z=s[p][j].first;//h为加入点\n\t\t\tdouble mon=d[p]/(100-z)*100;//费用\n\t\t\tif(mon<d[h]) {\n\t\t\t\td[h]=mon;\n\t\t\t\tf.insert(make_pair(d[h],h));\n\t\t\t}//取最小，加入。\n\t\t}\n\t}\n}\nint main() {\n\tcin>>m>>n;\n\tfor(int i=0; i<m; i++) {\n\t\tint u,v,w;//u、v为点，w为费用\n\t\tcin>>u>>v>>w;\n\t\ts[u].push_back(make_pair(w,v));\n\t\ts[v].push_back(make_pair(w,u));\n\t}\n\tcin>>a>>b;\n\tdij();\n\tprintf(\"%.8f\",d[a]);\n\treturn 0;\n}\n```\n\n## 总结与讨论\n\n​\t\t本题可以借助数据结构，更加方便，如堆，优先队列，multiset。\n\n\n\n# P2141 [NOIP2014 普及组] 珠心算测验\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P2141\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n珠心算是一种通过在脑中模拟算盘变化来完成快速运算的一种计算技术。珠心算训练，既能够开发智力，又能够为日常生活带来很多便利，因而在很多学校得到普及。\n\n\n某学校的珠心算老师采用一种快速考察珠心算加法能力的测验方法。他随机生成一个正整数集合，集合中的数各不相同，然后要求学生回答：其中有多少个数，恰好等于集合中另外两个（不同的）数之和？\n\n\n最近老师出了一些测验题，请你帮忙求出答案。\n\n\n(本题目为 2014NOIP 普及 T1)\n\n### 输入格式\n\n共两行，第一行包含一个整数 $n$，表示测试题中给出的正整数个数。\n\n\n第二行有 $n$ 个正整数，每两个正整数之间用一个空格隔开，表示测试题中给出的正整数。\n\n### 输出格式\n\n一个整数，表示测验题答案。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n4\n1 2 3 4\n```\n\n#### 样例输出 #1\n\n```\n2\n```\n\n#### 提示\n\n【样例说明】\n\n\n由 $1+2=3,1+3=4$，故满足测试要求的答案为 $2$。  \n\n注意，加数和被加数必须是集合中的两个不同的数。\n\n\n【数据说明】\n\n\n对于 $100\\%$ 的数据，$3 \\leq n \\leq 100$，测验题给出的正整数大小不超过 $10,000$。\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t采用三个数组，一个存储数值，另外两个标记数值状态。其中一个存储输入数值的状态，另一个存储数值相加之和的状态。最后遍历两个数组即可。\n\n### 算法代码\n\n```\n#include<iostream>\n#include<cstdio>\nusing namespace std;\nint t[200005],g[200005];\nint n,a[105],ans;\nint main(){\n    cin>>n;\n    for (int i=1;i<=n;i++){\n        cin>>a[i];//读入\n        g[a[i]]=1;//在集合中赋值为1\n    }\n    for (int i=1;i<n;i++){//枚举\n        for (int j=i+1;j<=n;j++){\n            t[a[i]+a[j]]++;//被加出来了\n        }\n    }\n    for (int i=1;i<=200002;i++){\n        if (t[i]>0&&g[i]) ans++;//判断是否满足，满足ans++\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n```\n\n## 总结与讨论\n\n​\t\t此题算法简单，暴力算法即可求解，倘若数据范围未给出或者指明很大，则另当别论。\n\n\n\n# P1004 [NOIP2000 提高组] 方格取数\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1004\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n设有 $N \\times N$ 的方格图 $(N \\le 9)$，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 $0$。如下图所示（见样例）:\n\n```plain\nA\n 0  0  0  0  0  0  0  0\n 0  0 13  0  0  6  0  0\n 0  0  0  0  7  0  0  0\n 0  0  0 14  0  0  0  0\n 0 21  0  0  0  4  0  0\n 0  0 15  0  0  0  0  0\n 0 14  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0\n                         B\n```\n某人从图的左上角的 $A$ 点出发，可以向下行走，也可以向右走，直到到达右下角的 $B$ 点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 $0$）。  \n此人从 $A$ 点到 $B$ 点共走两次，试找出 $2$ 条这样的路径，使得取得的数之和为最大。\n\n### 输入格式\n\n输入的第一行为一个整数 $N$（表示 $N \\times N$ 的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的 $0$ 表示输入结束。\n\n### 输出格式\n\n只需输出一个整数，表示 $2$ 条路径上取得的最大的和。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n8\n2 3 13\n2 6  6\n3 5  7\n4 4 14\n5 2 21\n5 6  4\n6 3 15\n7 2 14\n0 0  0\n```\n\n#### 样例输出 #1\n\n```\n67\n```\n\n#### 提示\n\nNOIP 2000 提高组第四题\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t本题采用深度优先算法解决，并且采用四维dp。之所以不用二维dp，原因在于，局部最优解不是全局最优解。\n\n​\t\t设dp[i] [j] [k] [l] 存放的是两个人同时分别走到i,j和k,l点时的最大路径和。易知，两个同时走的人均需遵守只能向下或向右的规则，那么两个人的选择2 x 2就一共有四种可能，即1.都往下走。2.一个往下，一个往右。3.一个往右，一个往下。4.都往右走。\n\n​\t\t倘若某格子有人走过了，另一个人倘若也需要经过那个格子，只需在原算法基础上减掉那个格子的值即可，而无需考虑将其数值置零的问题。\n\n### 算法代码\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint a[10][10];\nint dp[10][10][10][10];\n\nint main()\n{\n\tint n;\n\tcin >> n;\t\n\t//输入数据\n\tint x,y,num;\n\twhile (1){\n\t\tcin >> x >> y >> num;\n\t\tif ( !x && !y && !num )\n\t\t\tbreak;\n\t\ta[x][y] = num;\n\t}\t\n\t//四重循环\n\tint i,j,k,l;\n\tfor ( i=1; i<=n; ++i )\n\t\tfor ( j=1; j<=n; ++j )\n\t\t\tfor ( k=1; k<=n; ++k )\n\t\t\t\tfor ( l=1; l<=n; ++l ){\n\t\t\t\t\tdp[i][j][k][l] = max ( max (max ( dp[i-1][j][k-1][l], dp[i-1][j][k][l-1] ), dp[i][j-1][k-1][l] ), dp[i][j-1][k][l-1] ) + a[i][j] + a[k][l];\n\t\t\t\t\t//注意相同去重\n\t\t\t\t\tif ( i==k && j== l )\n\t\t\t\t\t\tdp[i][j][k][l] -= a[k][l];\n\t\t\t\t}\n\tcout << dp[n][n][n][n] << endl;\n}\n```\n\n## 总结与讨论\n\n​\t\t本题难点在于理解两次局部最优解和全局最优解的不同之处。对于四维dp理解不到位也很难写出该算法。\n\n\n\n# P1006 [NOIP2008 提高组] 传纸条\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1006\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排坐成一个 $m$ 行 $n$ 列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标 $(1,1)$，小轩坐在矩阵的右下角，坐标 $(m,n)$。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。\n\n在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。\n\n还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用 $0$ 表示），可以用一个 $[0,100]$ 内的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。现在，请你帮助小渊和小轩找到这样的两条路径。\n\n### 输入格式\n\n第一行有两个用空格隔开的整数 $m$ 和 $n$，表示班里有 $m$ 行 $n$ 列。\n\n接下来的 $m$ 行是一个 $m \\times n$ 的矩阵，矩阵中第 $i$ 行 $j$ 列的整数表示坐在第 $i$ 行 $j$ 列的学生的好心程度。每行的 $n$ 个整数之间用空格隔开。\n\n### 输出格式\n\n输出文件共一行一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n3 3\n0 3 9\n2 8 5\n5 7 0\n```\n\n#### 样例输出 #1\n\n```\n34\n```\n\n#### 提示\n\n**【数据范围】**\n\n对于 $30\\%$ 的数据，满足 $1 \\le m,n \\le 10$。  \n对于 $100\\%$ 的数据，满足 $1 \\le m,n \\le 50$。\n\n**【题目来源】**\n\nNOIP 2008 提高组第三题。\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t最好想的做法是四维dp，设f[i][j][k] [l]为从小渊传到小轩的纸条到达(i,j)，从小轩传给小渊的纸条到达(k,l)的路径上取得的最大的好心程度和。完全可以换一个思路想，即求从给定的起点出发走到指定位置的两条最短严格不相交路线。那么特别显然，转移方程是 f[i] [j] [k] [l]=max( f[i][j-1][k-1] [l] , f[i-1] [j] [k] [l-1] , f[i] [j-1] [k] [l-1] , f[i-1] [j] [k-1] [l] )+a[i] [j]+a[k] [l]。要小心l的枚举范围，应该是从j+1到m，只有这样，在枚举第二条路的时候可以控制下标的l不会和j有相等的可能，这样可以保证两条路一定不相交。由于终点的值是0，所以目标状态就是f[n] [m-1] [n-1] [m]。如果你不想这样做，那就让l直接从1枚举，但需要加一个判断，判断当前的(i,j)和(k,l)是不是重合了，如果重合那就把f数组对应的这个地方在转移后减掉一个a[i] [j]或者a[k] [l]。\n\n### 算法代码\n\n```\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#define maxn 55\nusing namespace std;\nint f[2 * maxn][maxn][maxn];\nint a[maxn][maxn];\nint n,m;\n \nint max_ele(int a,int b,int c,int d){\n    if (b>a)\n        a = b;\n    if (c>a)\n        a = c;\n    if (d>a)\n        a = d;\n    return a;\n}\n \nint main(){\n    cin >> n >> m;\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=m;j++)\n            cin >> a[i][j];\n    for (int k=1;k<=n+m-1;k++)\n        for (int i=1;i<=n;i++)\n            for (int j=1;j<=n;j++){\n                if (k-i+1<1 || k-j+1<1) //这里是判断纵坐标的合法性，如果纵坐标不合法那就跳过去\n                    continue;\n                 f[k][i][j] = max_ele(f[k-1][i][j],f[k-1][i-1][j-1],f[k-1][i][j-1],f[k-1][i-1][j]) + a[i][k-i+1] + a[j][k-j+1];\n                if (i==j) //判断重合路径\n                    f[k][i][j]-=a[i][k-i+1];\n            }\n \n \n    cout << f[n+m-1][n][n] << endl;\n    return 0;\n}\n```\n\n## 总结与讨论\n\n​\t\t算法时间复杂度是O(n^2 * m^2)。\n\n\n\n# P1018 [NOIP2000 提高组] 乘积最大\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1018\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n今年是国际数学联盟确定的“ 2000 ――世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰 90 周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友 XZ 也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：\n\n\n设有一个长度为 $N$ 的数字串，要求选手使用 $K$ 个乘号将它分成 $K+1$ 个部分，找出一种分法，使得这 $K+1$ 个部分的乘积能够为最大。\n\n\n同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：\n\n\n有一个数字串：$312$， 当 $N=3,K=1$ 时会有以下两种分法：\n\n1. $3  \\times  12=36$ \n2. $31  \\times   2=62$  \n\n\n这时，符合题目要求的结果是: $31  \\times  2 = 62$\n\n\n现在，请你帮助你的好朋友 XZ 设计一个程序，求得正确的答案。\n\n### 输入格式\n\n程序的输入共有两行：\n\n第一行共有 $2$ 个自然数 $N,K$\n\n第二行是一个长度为 $N$ 的数字串。\n\n### 输出格式\n\n结果显示在屏幕上，相对于输入，应输出所求得的最大乘积（一个自然数）。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n4  2\n1231\n```\n\n#### 样例输出 #1\n\n```\n62\n```\n\n#### 提示\n\n**数据范围与约定**\n\n对于 $60\\%$ 的测试数据满足 $6≤N≤20$。  \n对于所有测试数据，$6≤N≤40,1≤K≤6$。\n\nNOIp2000 提高组第二题\n\n## 算法\n\n### 问题分析与算法设计\n\n首先，这道题是显而易见的区间DP，那么，做这道题时，可以分为以下几步：\n1.确定状态，一般是f[i] [j]之类的，一般题目问什么，就设什么，这道题的状态定义为：f[ i ] [ j ]表示在前i个数中放j个乘号所得到的最大值。把这个状态带回题目，发现f[n−1] [k]恰为所求。\n2.确定阶段，这道题很显然是以乘号为阶段的，乘号具有明显的顺序性，即：先放完一个乘号，记录在DP数组中，放两个乘号是才能顺利调用之前的计算结果。\n3.确定状态转移方程：f[i] [j] = max(f[i] [j],f[i−1] [k−1]∗num(k,j))。\n4.初始化，这道题肯定是要初始化的，即 f [i] [0]时（前i个数中放0个乘号所得到的最大值就是i本身）\n\n### 算法代码\n\n```\n#include<bits/stdc++.h>\n\n#define INF 0x3f3f3f3f\n#define ll long long\n\nusing namespace std;\n\nstring s;\nll n,m,f[50][10];//f[i][j]:前i个数字放j个乘号\n\nll js(ll x,ll y)//将字符串从x位到y位转换为一个数字\n{\n\tll sum = 0;\n\tfor(int i = x;i <= y;++i)\n\t{\n\t\tsum = sum * 10;\n\t\tsum += s[i] - 48;\n\t}\n\treturn sum;\n}\n\nint main()\n{\n\tcin >> n >> m;\n\tcin >> s;\n\tfor(int i = 0;i < n;++i)\n\t{\n\t\tf[i][0] = js(0,i);//初始化\n\t}\n\tfor(int i = 1;i <= m;++i)//放i个乘号\n\t{\n\t\tfor(int j = i;j < n;++j)//在第j个位置放乘号，j不能=n，因为乘号必须要放在数字之间\n\t\t{\n\t\t\tfor(int k = i;k <= j;++k)//分割线\n\t\t\t{\n\t\t\t\tf[j][i] = max(f[j][i],f[k - 1][i - 1] * js(k,j));\n\t\t\t}\n\t\t}\n\t} \n\tcout << f[n - 1][m] << endl; \n\treturn 0;\n} \n```\n\n## 总结与讨论\n\n​\t\t或许暴力算法也能解决？\n\n\n\n# P1016 [NOIP1999 提高组] 旅行家的预算\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1016\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n一个旅行家想驾驶汽车以最少的费用从一个城市到另一个城市（假设出发时油箱是空的）。给定两个城市之间的距离 $D_1$、汽车油箱的容量 $C$（以升为单位）、每升汽油能行驶的距离 $D_2$、出发点每升汽油价格$P$和沿途油站数 $N$（$N$ 可以为零），油站 $i$ 离出发点的距离 $D_i$、每升汽油价格 $P_i$（$i=1,2,…,N$）。计算结果四舍五入至小数点后两位。如果无法到达目的地，则输出 `No Solution`。\n\n### 输入格式\n\n第一行，$D_1$，$C$，$D_2$，$P$，$N$。\n\n接下来有 $N$ 行。\n\n第 $i+1$ 行，两个数字，油站 $i$ 离出发点的距离 $D_i$ 和每升汽油价格 $P_i$。\n\n### 输出格式\n\n所需最小费用，计算结果四舍五入至小数点后两位。如果无法到达目的地，则输出 `No Solution`。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n275.6 11.9 27.4 2.8 2\n102.0 2.9\n220.0 2.2\n```\n\n#### 样例输出 #1\n\n```\n26.95\n```\n\n#### 提示\n\n$N \\le 6$，其余数字$ \\le 500$。\n\n## 算法\n\n### 问题分析与算法设计\n\n首先做如下定义：加油站距离数组dis[n+2], 汽油价格数组pri[n+2], 两者一一对应。\n\n接着对这两个数组初始化，dis[0] = 0; pri[0] = p; // 将出发点的距离 0 和 油价p 放入数组\n\n　　　　　　　　　　　　　　dis[n+1] = d1; pri[n+1] = 0; // 终点的距离 d1, 油价 0 放入数组\n\n将之后输入的N行数据按照距离从小到大排列，需要注意的是，交换距离的时候需要将对应的价格也交换。\n\n那么只需要从距离最小的点开始出发，依次进行计算。\n\n### 算法代码\n\n```\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef struct\n{\n    double dis;\n    double price;\n}station;\nint wrong=99999;\nstation st[100000];\ndouble d1,c,d2,p;\nint n;\nint now;//当前所在位置\nint t;\ndouble maxn;//最远走到哪里\n\ndouble res;//剩余；\ndouble price_sum=0;//总价钱\nint cmp(station a,station b)\n{\n    return a.dis<b.dis;\n}\nint func(int now)\n{\n    int index=wrong;//next\n    for(int i=now+1;i<=n&&st[i].dis-st[now].dis<=maxn;i++)//找能到的加油站\n    {\n        if(st[i].price<st[now].price)//能到&&便宜\n        {\n            price_sum+=(st[i].dis-st[now].dis)/d2*st[now].price;\n            res=0;\n            return i;\n        }\n        if(index==wrong||st[i].price<st[index].price)\n            index=i;//能到，不便宜\n\n    }\n    if(d1-st[now].dis<=maxn)//没有更便宜的，且能到终点了\n    {\n        price_sum+=(d1-st[now].dis-res)/d2*st[now].price;\n        return wrong;\n    }\n    if(index==wrong)\n    {\n        //到不了下个站\n        cout<<\"No Solution\"<<endl;\n        return -1;\n    }\n\n    else//没有更便宜的，又不能一次到终点\n    {\n        price_sum+=c*st[now].price;\n        res+=(maxn-(st[index].dis-st[now].dis));\n        return index;\n    }\n}\nint main()\n{\n\n    cin>>d1>>c>>d2>>p>>n;\n\n    st[0].dis=0;\n    st[0].price=p;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>st[i].dis>>st[i].price;\n    }\n\n    sort(st,st+n+1,cmp);\n    now=0;\n    maxn=c*d2;\n\n    do\n    {\n        t=func(now);\n        now=t;\n        if(t==-1)\n            return 0;\n    }while(t!=wrong);\n\n    cout<<fixed<<setprecision(2)<<price_sum<<endl;\n    return 0;\n}\n```\n\n## 总结与讨论\n\n​\t\t需要注意的地方：1、每次都需要判断是否能够到达下一个加油站，如果无法到达，则直接退出。\n\n　　　　　　　　\t\t2、每次在当前能够走到的最远距离内进行判断，寻找是否有比当前油价更低的加油站。如果没有更低的，价格相等也可以。\n\n　　　　　　　　\t\t3、由于最后一点 pir[n+1]  的油价为0，所以要对其特殊处理。\n\n\n\n# P2434 [SDOI2005]区间\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P2434\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n现给定 $n$ 个闭区间 $[a_i, b_i]$（$1 \\le i \\le n$）。这些区间的并可以表示为一些不相交的闭区间的并。你的任务就是在这些表示方式中找出包含最少区间的方案。你的输出应该按照区间的升序排列。这里如果说两个区间 $[a, b]$ 和 $[c, d]$ 是按照升序排列的，那么我们有 $a \\le b < c \\le d$。\n\n请写一个程序：\n\n读入这些区间；\n\n计算满足给定条件的不相交闭区间；\n\n把这些区间按照升序输出。\n\n### 输入格式\n\n第一行包含一个整数 $n$（$3 \\le n \\le 50000$）为区间的数目。  \n以下 $n$ 行为对区间的描述，第 $i$ 行为对第 $i$ 个区间的描述，为两个整数 $a_i, b_i$（$1 \\le a _ i \\leq b _ i \\le 1000000$），表示一个区间 $[a_i, b_i]$。\n\n### 输出格式\n\n输出计算出来的不相交的区间。每一行都是对一个区间的描述，包括两个用空格分开的整数，为区间的上下界。你应该把区间按照升序排序。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n5\n5 6\n1 4\n10 10\n6 9\n8 10\n```\n\n#### 样例输出 #1\n\n```\n1 4\n5 10\n```\n\n#### 提示\n\n对于 $100 \\%$ 的数据，$3 \\le n \\le 50000$，$1 \\le a _ i \\leq b _ i \\le 1000000$。\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t将所有区间按左端点排序，然后将n个区间扫一遍，若能合并成一个大区间便合并， 并用l,r记录当前区间的左右端点，若不能合并（即q[i].l>r），输出，并重置l,r\n\n### 算法代码\n\n```\n#include <bits/stdc++.h>\n#define N 50005\nusing namespace std;\n \nint n; \n \nstruct node\n{\n    int l,r;\n}q[N];\nbool cmp(node x,node y) {return x.l<y.l;}\n \nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%d%d\",&q[i].l,&q[i].r);\n    sort(q+1,q+1+n,cmp);\n    int l=q[1].l,r=q[1].r;\n    for(int i=2;i<=n;i++)\n    {\n        if(q[i].l>r)\n        {\n            printf(\"%d %d\\n\",l,r);\n            l=q[i].l;r=q[i].r;\n        }\n        else r=max(r,q[i].r);\n    }\n    printf(\"%d %d\",l,r);\n    return 0;\n}\n```\n\n## 总结与讨论\n\n​\t\t这题也可用线段树完成，先将每一段区间插入线段树，然后用两个指针l=1,r=1扫[l,r]，若区间[l,r]被覆盖，r++,若不是，重置l,r，并在 l !=r时输出\n\n\n\n# P3842 [TJOI2007]线段\n\n## 题目描述\n\n在一个 $n \\times n$ 的平面上，在每一行中有一条线段，第 $i$ 行的线段的左端点是$(i, L_{i})$，右端点是$(i, R_{i})$。\n\n你从 $(1,1)$ 点出发，要求沿途走过所有的线段，最终到达 $(n,n)$ 点，且所走的路程长度要尽量短。\n\n更具体一些说，你在任何时候只能选择向下走一步（行数增加 $1$）、向左走一步（列数减少 $1$）或是向右走一步（列数增加 $1$）。当然，由于你不能向上行走，因此在从任何一行向下走到另一行的时候，你必须保证已经走完本行的那条线段。\n\n### 输入格式\n\n第一行有一个整数 $n$。\n\n以下 $n$ 行，在第 $i$ 行（总第 $(i+1)$ 行）的两个整数表示 $L_i$ 和 $R_i$。\n\n### 输出格式\n\n仅包含一个整数，你选择的最短路程的长度。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n6\n2 6\n3 4\n1 3\n1 2\n3 6\n4 5\n```\n\n#### 样例输出 #1\n\n```\n24\n```\n\n#### 提示\n\n我们选择的路线是\n\n```\n (1, 1) (1, 6)\n (2, 6) (2, 3)\n (3, 3) (3, 1)\n (4, 1) (4, 2)\n (5, 2) (5, 6)\n (6, 6) (6, 4) (6, 6)\n```\n不难计算得到，路程的总长度是 $24$。 \n\n对于 $100\\%$ 的数据中，$n \\le 2 \\times 10^4$，$1 \\le L_i \\le R_i \\le n$。\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t比较典型的DP，首先先想，每一层的最优肯定是由上一层限制的左端点或者右端点下来得到的，那么就可以有状态转移方程了。f[i] [0]表示走完第i行且停在第i行的左端点最少用的步数，f[i] [1]同理，停在右端点的最少步数。\n​\t\t那么转移就很简单了，走完当前行且停到左端点，那么一定是从右端点过来的，那么从上一行左端点转移的话就是f[i] [0]=abs(上一行左端点的坐标-本行右端点的坐标+本行线段长度)\n\n### 算法代码\n\n```\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,hang,ans=0;\nint l[20005];\nint r[20005];\nint f[29999][3];//F[X][0] left max \n\nint main(){\n scanf(\"%d\",&n);\n for(int i=1;i<=n;i++) scanf(\"%d%d\",&l[i],&r[i]);\n f[1][1]=r[1]-1;\n f[1][0]=r[1]-1+r[1]-l[1];\n for(int i=2;i<=n;i++){\n   if(l[i-1]>=r[i]){\n      f[i][1]=min(r[i]-l[i]+r[i]-l[i]+f[i-1][0]+1+l[i-1]-r[i],r[i]-l[i]+r[i]-l[i]+f[i-1][1]+1+r[i-1]-r[i]);\n      f[i][0]=min(f[i-1][0]+1+l[i-1]-l[i],f[i-1][1]+1+r[i-1]-l[i]); \n      }\n      else if(r[i-1]<=l[i]) {\n       f[i][0]=min(r[i]-l[i]+r[i]-l[i]+f[i-1][1]+1+l[i]-r[i-1],r[i]-l[i]+r[i]-l[i]+f[i-1][0]+1+l[i]-l[i-1]);\n       f[i][1]=min(f[i-1][1]+1+r[i]-r[i-1],f[i-1][0]+1+r[i]-l[i-1]);\n   }\n   else if(l[i]<=l[i-1]&&r[i]>=r[i-1]){\n    f[i][0]=min(r[i]-l[i]+f[i-1][1]+1+r[i]-r[i-1],r[i]-l[i]+r[i]-l[i]+f[i-1][0]+1+l[i-1]-l[i]);\n    f[i][1]=min(r[i]-l[i]+r[i]-l[i]+f[i-1][1]+1+r[i]-r[i-1],r[i]-l[i]+f[i-1][0]+1+l[i-1]-l[i]); \n   }\n   else if(l[i]>=l[i-1]&&r[i]<=r[i-1]){\n    f[i][0]=min(r[i]-l[i]+f[i-1][1]+1+r[i-1]-r[i],r[i]-l[i]+r[i]-l[i]+f[i-1][0]+1+l[i]-l[i-1]);\n    f[i][1]=min(r[i]-l[i]+r[i]-l[i]+f[i-1][1]+1+r[i-1]-r[i],r[i]-l[i]+f[i-1][0]+1+l[i]-l[i-1]);\n   }\n   else if(l[i]>=l[i-1]&&l[i]<=r[i-1]){\n    f[i][0]=min(r[i]-l[i]+f[i-1][1]+1+r[i]-r[i-1],r[i]-l[i]+r[i]-l[i]+f[i-1][0]+1+l[i]-l[i-1]);\n    f[i][1]=min(r[i-1]-l[i]+r[i]-l[i]+f[i-1][1]+1,f[i-1][0]+1+r[i]-l[i-1]); \n   }\n   else if(r[i]>=l[i-1]&&r[i]<=r[i-1]){\n    f[i][1]=min(r[i]-l[i]+r[i]-l[i]+f[i-1][1]+1+r[i-1]-r[i],r[i]-l[i]+l[i-1]-l[i]+f[i-1][0]+1);\n    f[i][0]=min(r[i]-l[i]+f[i-1][1]+1+r[i-1]-r[i],r[i]-l[i]+f[i-1][0]+1+r[i]-l[i-1]);\n   } \n }\n ans=min(f[n][0]+n-l[n],f[n][1]+n-r[n]);\n cout<<ans;\n return 0;\n} \n```\n\n## 总结与讨论\n\n​\t\t贪心算法基本不可解。\n\n\n\n# P5414 [YNOI2019] 排序\n\n## 题目描述\n\n对于一个数列 $\\{7, 1, 2, 3\\}$ 进行排序，我们可以把 $7$ 从头移动到尾。但是这个操作的成本是 $7$，并不是最佳的。最佳的排序方式是将连续的 $1,2,3$ 移动到 $7$ 的前面。这样的话，总的操作成本就是 $1+2+3=6$，比之前的成本 $7$ 要小。\n\n你的任务是，对于一个给定的数列，输出对这个数列进行排序的最小成本。\n\n### 输入格式\n\n输入文件名为sort.in。\n\n每个输入文件包含多组数据。\n\n输入文件的第一行，包含一个正整数 $T$，代表该输入文件中所含的数据组数。\n\n接下来是 $T$ 组数据，每组数据的格式如下：\n\n每组数据包含 $2$ 行；\n\n第一行包含一个正整数 $n$，代表数列中元素的个数，其中 $0 < n \\leq 10^2$；\n\n第二行包含 $n$ 个整数，两个数之间以一个空格隔开，代表数列中的元素 $k_i$，其中$-10^{7} \\leq k_i \\leq 10^{7}$。\n\n### 输出格式\n\n输出文件名为sort.out。\n\n输出文件包含 $T$ 行，分别对应 $T$ 组数据的答案，即对数列进行排序的最小成本。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n1\n4\n7 1 2 3\n```\n\n#### 样例输出 #1\n\n```\n6\n```\n\n#### 提示\n\n对于 $60\\%$ 的数据：$0 < n \\leq 60$，$-10^{7} \\leq k_i \\leq 10^{7}$\n\n对于 $80\\%$ 的数据：$0 < n \\leq 80$，$-10^{7} \\leq k_i \\leq 10^{7}$\n\n对于 $100\\%$ 的数据：$0 < n ≤ 10^2$，$-10^{7} \\leq k_i \\leq 10^{7}$\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t这道题就是移动几个数字使得数列单调上升，每次移动可以移动到任意位置，花费就是移动数字的大小。看到这个题之后，我们可以得到 ：最优解不可能把同一个数字移动2次及以上。既然我们可以一次把它移到正确的位置上，那么这个数字就可以理解为直接被移走了。那么问题就变成了：删除几个数字，使得数列单调递增，所求的是移走数字的最小和。 使得删除的和最小，就意味着留下的和最大。那么问题就变成了：保留几个单调递增的数字，使得和最大。\n\n### 算法代码\n\n```\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N=205;\nint a[N],dp[N];\n\nint read(){\n\tint x=0; \n\tchar c=getchar();\n\twhile(c<'0'||c>'9') \n\t\tc=getchar();\n\twhile('0'<=c&&c<='9'){ \n\t\tx=(x<<3)+(x<<1)+(c^48); \n\t\tc=getchar();\n\t}\n\treturn x;\n}\n\nint main(){\n\tint i,j,n;\n\tfor(int T=read(),sum=0,ans=0;T;T--,sum=0,ans=0){\n\t\tn=read(); \n\t\tfor(i=1;i<=n;i++){\n\t\t\ta[i]=read(),sum+=a[i];\n\t\t\tfor(j=1;j<i;j++)\n\t\t\t\tif(a[j]<=a[i]&&dp[i]<dp[j])\n\t\t\t\t\tdp[i]=dp[j];\n\t\t\tdp[i]+=a[i];\n\t\t}\n\t\tfor(i=1;i<=n;i++)\n\t\t\tans=max(ans,dp[i]);\n\t\tprintf(\"%d\\n\",sum-ans);\n\t}\n}\n```\n\n## 总结与讨论\n\n​\t\t将问题转化之后其实并不是太难。\n\n\n\n# P2023 [AHOI2009] 维护序列\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P2023\n- 登陆账号：SkyTravelar\n\n## 题目背景\n\n老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。\n\n## 题目描述\n\n有一个长为 $n$ 的数列 $\\{a_n\\}$，有如下三种操作形式：\n\n1. 格式 `1 t g c`，表示把所有满足 $t\\le i\\le g$ 的 $a_i$ 改为 $a_i\\times c$ ;\n2. 格式 `2 t g c` 表示把所有满足 $t\\le i\\le g$ 的 $a_i$ 改为 $a_i+c$ ;\n3. 格式 `3 t g` 询问所有满足 $t\\le i\\le g$ 的 $a_i$ 的和，由于答案可能很大，你只需输出这个数模 $p$ 的值。\n\n### 输入格式\n\n第一行两个整数 $n$ 和 $p$。\n\n第二行含有 $n$ 个非负整数，表示数列 $\\{a_i\\}$ 。\n\n第三行有一个整数 $m$，表示操作总数。\n\n从第四行开始每行描述一个操作，同一行相邻两数之间用一个空格隔开，每行开头和末尾没有多余空格。\n\n### 输出格式\n\n对每个操作 3，按照它在输入中出现的顺序，依次输出**一行一个整数**表示询问结果。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n7 43\n1 2 3 4 5 6 7\n5\n1 2 5 5\n3 2 4\n2 3 7 9\n3 1 3\n3 4 7\n```\n\n#### 样例输出 #1\n\n```\n2\n35\n8\n```\n\n#### 提示\n\n##### 样例输入输出 1 解释\n\n- 初始时数列为 $\\{1,2,3,4,5,6,7\\}$。\n- 经过第 $1$ 次操作后，数列为 $\\{1,10,15,20,25,6,7\\}$。\n- 对第 $2$ 次操作，和为 $10+15+20=45$，模 $43$ 的结果是 $2$。\n- 经过第 $3$ 次操作后，数列为 $\\{1,10,24,29,34,15,16\\}$。\n- 对第 $4$ 次操作，和为 $1+10+24=35$，模 $43$ 的结果是 $35$。\n- 对第 $5$ 次操作，和为 $29+34+15+16=94$，模 $43$ 的结果是$8$。\n\n\n##### 数据规模与约定\n\n测试数据规模如下表所示：\n\n| 数据点编号 |  1   |   2    |   3    |    4    |    5    |    6    |    7    |    8    |   9,10   |\n| :--------: | :--: | :----: | :----: | :-----: | :-----: | :-----: | :-----: | :-----: | :------: |\n|    $n=$    | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |\n|    $m=$    | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |\n\n对于全部的测试点，保证 $0 \\leq p, a_i, c \\leq 10^9$，$1 \\leq t \\leq g \\leq n$。\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t本题较之平常的线段树,会有一点不同.就是多了一个乘的操作.所以我们需要令一个优先级,即先乘后加.因为加无论什么时候加都没有关系,但是乘会对整个答案产生影响.于是乎,只要打两个标记.在乘的时候,加的标记也要乘上那个值.\n\n### 算法代码\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=2e5+1;\nstruct Node{\n\tll l;\n\tll r;\n\tll k;\n\tll add;\n\tll mul;\n}tree[N*4];\nll n,m,Mod,pos;\ninline ll build_tree(ll value,ll l,ll r){\n\ttree[value]=Node{l,r,0,0,1};\n\tif (l==r){\n\t\tll num;\n\t\tscanf(\"%lld\",&num);\n\t\treturn tree[value].k=num%Mod;\n\t}\n\tll mid=(l+r)>>1;\n\treturn tree[value].k=(build_tree(value*2,l,mid)+build_tree(value*2+1,mid+1,r))%Mod;\n}\ninline void pushdown(ll value){\n\ttree[value*2].add=(tree[value].add+tree[value*2].add*tree[value].mul)%Mod;\n\ttree[value*2+1].add=(tree[value].add+tree[value*2+1].add*tree[value].mul)%Mod;\n\ttree[value*2].mul=(tree[value].mul*tree[value*2].mul)%Mod;\n\ttree[value*2+1].mul=(tree[value].mul*tree[value*2+1].mul)%Mod;\n\ttree[value*2].k=(tree[value].mul*tree[value*2].k+tree[value].add*(tree[value*2].r-tree[value*2].l+1))%Mod;\n\ttree[value*2+1].k=(tree[value].mul*tree[value*2+1].k+tree[value].add*(tree[value*2+1].r-tree[value*2+1].l+1))%Mod;\n\ttree[value].add=0;\n\ttree[value].mul=1;\n}\ninline ll query(ll value,ll L,ll R){\n\tpushdown(value);\n\tif (tree[value].l>=L&&tree[value].r<=R)\n\t\treturn tree[value].k%Mod;\n\tll mid=(tree[value].l+tree[value].r)>>1;\n    return ((L<=mid?query(value*2,L,R):0)+(R>mid?query(value*2+1,L,R):0))%Mod;\n}\ninline void updata(ll value,ll x,ll pos,ll L,ll R){\n\tpushdown(value);\n\tif (pos==1&&tree[value].l>=L&&tree[value].r<=R){\n\t\ttree[value].mul=(tree[value].mul*x)%Mod;\n        tree[value].add=(tree[value].add*x)%Mod;\n        tree[value].k=(tree[value].k*tree[value].mul)%Mod;\n        return;\n\t}\n\tif(pos==2&&tree[value].l>=L&&tree[value].r<=R){\n        tree[value].add=(tree[value].add+x)%Mod;\n        tree[value].k=(tree[value].k+tree[value].add*(tree[value].r-tree[value].l+1))%Mod;\n        return;\n    }\n    ll mid=(tree[value].l+tree[value].r)/2;\n    if(L<=mid)\n        updata(value*2,x,pos,L,R);\n    if(R>mid)\n        updata((value*2)+1,x,pos,L,R);\n    tree[value].k=(tree[value*2].k+tree[value*2+1].k)%Mod;\n}\nint main(){\n\tscanf(\"%lld%lld\",&n,&Mod);\n\tbuild_tree(1,1,n);\n\tcin>>m;\n\tfor (ll i=1;i<=m;i++){\n\t\tcin>>pos;\n\t\tll x,y;\n\t\tcin>>x>>y; \n\t\tif (pos!=3){\n\t\t\tll k;\n\t\t\tcin>>k;\n\t\t\tupdata(1,k,pos,x,y);\n\t\t}\n\t\telse if (pos==3)\n\t\t\tprintf(\"%lld\\n\",query(1,x,y));\n\t}\n}\n```\n\n## 总结与讨论\n\n​\t\t难","tags":["算法分析与设计"]},{"title":"十六进制转二进制并输出","url":"/2023/04/26/12/","content":"\n要求如下:\n\n- 从键盘输入两个四位十六进制数。\n- 将这两个数以二进制形式输出，要求输出的0和1颜色交替变化。\n- 找出这两个数中的偶数，若有则以十进制输出，若无，输出“NO”。\n- 计算这两个数的平方和。\n- 数据的输入和结果的输出都要有必要的提示，且提示独占一行。\n- 要使用到子程序。\n\n实现如下：\n\n```\ndata segment\n  str1 db 0ah,0dh,'Input number1 :',0ah,0dh,'$'\n  str2 db 0ah,0dh,'Input number2 :',0ah,0dh,'$' \n  str3 db 0ah,0dh,'Output number1 bin :',0ah,0dh,'$'\n  str4 db 0ah,0dh,'Output number2 bin :',0ah,0dh,'$'\n  str5 db 0ah,0dh,'Judge number1 oushu :',0ah,0dh,'$'\n  str6 db 0ah,0dh,'Judge number2 oushu :',0ah,0dh,'$'\n  str7 db 0ah,0dh,'Output powsum :',0ah,0dh,'$'\n  str8 db 0ah,0dh,'Program End !!!',0ah,0dh,'$'\nnum dw 2 dup(?)\n  str db 5,?,5 dup(?)\n  a dw ?\n  d dw ?\n  f dw ?\ndata ends\ncode segment\n  assume cs:code,ds:data\n  main proc far             ;主函数\nstart:\n  mov ax,data\n  mov ds,ax\n  \n  lea dx,str1\n  mov ah,09h\n  int 21h\n  call input\n  mov ax,num                \n  mov num+2,ax              ;将输入的第一个16进制数存到num+2中\n\n  lea dx,str2\n  mov ah,09h\n  int 21h\n  call input                ;第二个输入的16进制数存到num中\n  \n  lea dx,str3\n  mov ah,09h\n  int 21h\n  mov bx,num+2\n  call bin                  ;将第一个数以2进制输出\n  \n  lea dx,str4\n  mov ah,09h\n  int 21h\n  mov bx,num\ncall bin                  ;将第二个数以2进制输出\n\n  lea dx,str5\n  mov ah,09h\n  int 21h\n  mov bx,num+2\n  call oushu                ;判断第一个数是否为偶数\n\n  lea dx,str6\n  mov ah,09h\n  int 21h\n  mov bx,num\n  call oushu                ;判断第二个数是否为偶数\n  \n  lea dx,str7\n  mov ah,09h\n  int 21h\n  call powsum               ;将两数平方相加并以16进制输出\n\n  lea dx,str8\n  mov ah,09h\n  int 21h\n\n  mov ax,4c00h\n  int 21h  \nmain endp\n\ninput proc near              ;子程序1：输入16进制数\n  lea dx,str\n  mov ah,0ah\n  int 21h\n  lea si,str+2\n  mov cx,4\n  mov dx,0\nA1:\n push cx                    ;保护cx防止被后面左移改变\n  mov al,[si]\n  cmp al,'0'                 ;判断与0的大小，小于则退出\n  jb A4\n  cmp al,'F'                 ;判断与F的大小，大于则退出\n  ja A4\n  cmp al,'9'                 ;判断与9的大小\njbe A2\n  sub al,07h\nA2: \n  sub al,30h\n  cbw                        ;扩大al为ax，用于存4位16进制数\n  add dx,ax                  ;加到dx，dx用来存每次变化后的结果\n  cmp cx,1                   ;防止在将第4位数加入后仍左移\n  jz A3\n  mov cl,4\n  shl dx,cl                  ;dx左移4位，便于下一位16进制数加入dx\nA3:\n  inc si\n  pop cx\n  loop A1\nA4: \n  mov num ,dx  \n  ret\ninput endp \n\nbin proc near                ;子程序2：输出2进制，颜色交替\n  mov cx,8                   ;循环8次，每次输出两位颜色交替2进制数\n  mov dx,0\nB1:\n  mov ax,0\n  shl bx,1\n  adc al,0                   ;循环左移1位，将cf表示位最高位2进制数\n  push cx                    ;保护cx避免后面重复输出1次时发生改变\n  push bx                    ;保护bx避免改变\n  add al,30h\n  mov cx,1\n  mov bl,04h                ;设置为红色\n  mov bh,0\n  mov ah,09h\n  int 10h\n  mov ah,03h                ;03号功能读取当前光标位置，确定dh的有坐标和dl的x坐标\n  int 10h\n  inc dl                    ;光标右移1位\n  mov ah,02h                ;02号功能设置光标位置\n  int 10h\n  pop bx\n  mov ax,0\n\n  shl bx,1\n  adc al,0\n  push bx\n  add al,30h\n  mov cx,1\n  mov bl,0ah               ;设置为浅绿色\n  mov bh,0\n  mov ah,09h\n  int 10h\n  mov ah,03h\n  int 10h\n  inc dl\n  mov ah,02h\n  int 10h\n  pop bx\n  pop cx\n  loop B1\n  \n  ret\nbin endp\noushu proc near            ;子程序3：判断偶数并输出\n  push bx                  ;保护bx\n  and bx,0001h             ;取2进制的末位\n  mov cx,8\nC1:\n  cmp bl,0h                ;判断2进制末位为0则偶数\n  jz C2\n  mov ah,02h               ;非偶数输出’NO’\n  mov dl,'N'\n  int 21h\n  mov ah,02h\n  mov dl,'O'\n  int 21h\n  pop bx\n  jmp C3\n\nC2:\n  pop bx\n  mov cx,5\n  mov ax,bx\n  mov bx,10\nC4:\n  mov dx,0\n  div bx                    ;除10，余数压栈\n  add dl,30h\n  push dx\n  loop C4\n  mov cx,5\nC5:\n  pop dx\n  mov ah,02h                ;10进制输出\n  int 21h\n  loop C5\nC3:\n  ret\noushu endp\n\npowsum proc near            ;子程序4：计算平方和\n\n  mov ax,num\n  mul num\n  mov a,ax\n  mov d,dx\n\t\n  mov ax,num+2\n  mul num+2\n  add a,ax                  \n  adc d,dx                  ;将ax相加的进位与dx相加\n  adc f,0                   ;dx相加可能产生进位，cf为最高位16进制数\n  mov dx,f\n  add dl,30h\n  mov ah,02h\n  int 21h\n\t\n  mov cx,4\n  mov dx,d\nD1:\t\n  push cx\t\n  mov cl,4\n  rol dx,cl\t               ;循环左移，\n  push dx\n  and dl,0fh                 ;dx最末位为所要输出的16进制数\n  cmp dl,9\n  jbe D2\n  add dl,7h\nD2:\n  add dl,30h\n  mov ah,02h\n  int 21h \n  pop dx\n  pop cx\n  loop D1\n\n  mov cx,4\n  mov dx,a\nD3:\n  push cx\t\n  mov cl,4\n  rol dx,cl\t               ;循环左移\n  push dx\n  and dl,0fh                 ;ax最末位为所要输出的16进制数\n  cmp dl,9\n  jbe D4\n  add dl,7h\nD4:\n  add dl,30h\n  mov ah,02h\n  int 21h \n  pop dx\n  pop cx\n  loop D3\n  ret\npowsum endp\ncode ends\nend main\n```\n\n","tags":["汇编"]},{"title":"对二十个数进行排序","url":"/2022/12/12/10/","content":"```\ndata segment\narray \tdw 40 dup(0)\nten \tdb 10 \nfuyi \tdw -1\t\nflag\tdb 0\ndata ends\n\nstack segment \n\tdw 40 dup(0)\nstack ends\n\nassume cs:code, ds:data, ss:stack\n\ncode segment\n\tstart:\t\t\n\t\tmov ax,data\n        mov ds,ax\n        mov ax,stack\n        mov ss,ax\n        mov sp,80\n        mov si,0 \n        mov cx,20\t\n        call scan\t\n        mov cx,20\n        call sort\n        mov si,0\n        mov cx,20\n        call to_char\n        mov ax,4c00h\n        int 21h\n\tscan:\t\t\n\t\tpush ax\n        push bx\n        push dx\n\tl1:\t\t\n\t\tmov dx,0\t\t\t\n\tll2:\t\n\t\tmov ah,1\n        int 21h\t\t\t\t\n        cmp al,' '\n        je continue\t\t\t\n        cmp al,'-'\n        je negtive\t\t\t\n        sub al,30h\n        mov bl,al \n        mov ax,array[si]\n        mul ten\n        mov bh,0\n        add ax,bx\n        mov array[si],ax\n        jmp ll2\t\t\nnegtive:\n        inc dx\t\n        jmp ll2\t\t\t\ncontinue:\t\t\t\t\t\t\t\n        cmp dx,0\t\t\t\n        je l\t\n        mov ax,array[si]\n        imul fuyi\n        mov array[si],ax\n\t\tl:\t\n        add si,2\n        loop l1\n        pop dx\n        pop bx\n        pop ax\n        ret\n\tsort:\t\t\n\t\tpush di\n        push bx\n        push ax\t\t\t\n\t\tdec cx\n\ts1:\t\t\n\t\tmov di,cx\n\t\tmov bx,0\n    s2:\t\t\n    \tmov ax,array[bx]\n        cmp ax,array[bx+2]\n        jle s3\n        xchg ax,array[bx+2]\n        mov array[bx],ax\n\ts3:\t\t\n\t\tadd bx,2\n        loop s2\t\t\t\n        mov cx,di\n        loop s1\t\t\t\n        pop ax\n        pop bx\n        pop di\n        ret\t\t\t\nto_char:\n    \tpush ax\n    \tpush bx\n    \tpush dx\n    \tpush di   \t\n    \tmov dl,0ah\t\n    \tmov ah,2\n    \tint 21h    \t\n\tl2:\t\t\n\t\tpush cx\n\t\tmov bx,0\n\t\tmov flag,0\n\tl3:\t\t\t\t\t\t\t\t\t\t\t\n\t\tmov ax,[si]\n\t\tand ah,10000000b\n\t\tcmp ah,0\n\t\tje b\t\t\t\t\n\t\tmov ax,[si]\t\t\t\n\t\timul fuyi\n\t\tmov [si],ax\n\t\tmov flag,1\t\t\t\t\t\n\tb:\t\n\t\tinc bx\t\n\t\tmov cx,10\n\t\tcall divtw\n    \tmov dh,7\n    \tadd dl,30h\n    \tpush dx\t\n    \tcmp word ptr [si],0\n    \tje j\n    \tloop l3    \t\n    j:\t\n    \tcmp flag,1\n    \tjne q\n    \tinc bx\n\t\tmov dh,7\n\t\tmov dl,'-'\n\t\tpush dx    \t\n    q:\t\n    \tmov cx,bx\n    k:\t\n    \tpop dx\n    \tmov ah,2\n    \tint 21h\n    \tloop k\n    \tmov dl,' '\n    \tmov ah,2\n    \tint 21h    \t\n    \tpop cx\n   \t\tadd si,2\n    \tloop l2    \t\n    \tpop di\n    \tpop dx\n    \tpop bx\n    \tpop ax\n    \tret    \t\n divtw:\n \t\tpush ax\t\t\n\t\tmov dx,0\n\t\tmov ax,[si]\n\t\tdiv cx\n\t\tmov [si],ax\t\t\n\t\tpop ax\n\t\tret\t\t\t\t\t\t\t\t\ncode ends\nend start\n```\n\n","tags":["汇编"]},{"title":"输出斐波拉契数列前20项","url":"/2022/12/12/9/","content":"```\nDATAS SEGMENT\n VAL    DW 20 DUP(0)\nDATAS ENDS\nSTACKS SEGMENT\n DW 30 DUP(0)\nSTACKS ENDS\nCODES SEGMENT\n    ASSUME CS:CODES,DS:DATAS,SS:DATAS\nSTART:\n    MOV AX,DATAS\n    MOV DS,AX\n    MOV AX,STACKS\n    MOV SS,AX\n    MOV DI,0\n    MOV AX,1\n    MOV DX,1\n    JMP FIBO\n    \nFIBO:   MOV VAL[DI],AX\n\t\tADD DI,2\n\t\tMOV VAL[DI],DX\n\t\tADD DI,2\n\t\tADD AX,DX\n\t\tADD DX,AX\n\t\tCMP DI,40\n\t\tJAE  BACK\n\t\tCALL FIBO\n\t\tRET\n\t  \nBACK:   \n  MOV DI,0\n   MOV CX,20\n   MOV DX,0\n   \nL1:    \n        MOV AX,VAL[DI]\n  ADD DI,2\n  CMP AX,1000\n  JNB P1\n  CMP AX,100\n  JNB P2\n  CMP AX,10\n  JNB P3\n  CMP AX,1\n  JNB P4\n\n  \nP1:  MOV BX,1000\n  DIV BX\n  PUSH DX\n  MOV DX,AX\n  ADD DL,30H\n  MOV AH,2H\n  INT 21H\n  POP AX\n  MOV DX,0\n  \nP2:  MOV BX,100\n  DIV BX\n  PUSH DX\n  MOV DX,AX\n  ADD DL,30H\n  MOV AH,2H\n  INT 21H\n  POP AX\n  MOV DX,0\n  \nP3:     MOV BX,10\n  DIV BX\n  PUSH DX\n  MOV DX,AX\n  ADD DL,30H\n  MOV AH,2H\n  INT 21H\n  POP AX\n  MOV DX,0\n  \nP4:    \n        MOV BX,1\n  DIV BX\n  PUSH DX\n  MOV DX,AX\n  ADD DL,30H\n  MOV AH,2H\n  INT 21H\n  POP AX\n  \n  MOV DL,32\n  MOV AH,2H\n  INT 21H\n  MOV DX,0\n  LOOP L1\n  \n  MOV AX,4C00H\n  INT 21H\nCODES ENDS\n    END START\n\n```\n\n","tags":["汇编"]},{"title":"输出斐波拉契数列前50项","url":"/2022/12/12/8/","content":"```\nDATAS SEGMENT\n\tDW 200 DUP(0)\n   \nDATAS ENDS\n\nSTACKS SEGMENT\n    DW 30 DUP(0)\nSTACKS ENDS\n\nCODES SEGMENT\n    ASSUME CS:CODES,DS:DATAS,SS:STACKS\nSTART:\n\t.386\n\tMOV AX,DATAS\n\tMOV DS,AX\n\tMOV AX,STACKS\n\tMOV SS,AX\n\tMOV SI,0\n\tMOV DI,0 \n\tMOV EAX,1\n\tMOV EDX,0\n\tJMP PRINT11\nA:\n\tCALL FIBO\n\nFIBO:\n\tCMP DI,392\n\tJE BACK\n\t\n\tCMP DI,0\t\n\tJE SET1\n\nSET1BACK:\n\tCMP DI,8\n\tJE SET2\n\nSET2BACK:\n\tADD DI,8\n\tMOV EAX,DS:[DI-8]\n\tMOV EDX,DS:[DI-4]\n\tMOV ECX,DS:[DI-12]\n\tMOV EBX,DS:[DI-16]\n\tADD EAX,EBX\n\tADC EDX,ECX\n\tMOV DS:[DI],EAX\n\tMOV DS:[DI+4],EDX\n\tCALL PRINT\n\nPRINTBACK:\t\n\tCALL FIBO\n\t\n;==================================================\nSET1:\n\tMOV DS:[0],EAX\n\tMOV DS:[4],EDX\n\tADD DI,8\n\tJMP SET1BACK\n;==================================================\nSET2:\n\tMOV DS:[8],EAX\n\tMOV DS:[12],EDX\n\tJMP SET2BACK\n;==================================================\t\n\n;PRINT EDX EAX\nPRINT:\n\tPUSH EAX\n\tPUSH EBX\n\tPUSH ECX\n\tPUSH EDX\n\tCMP EDX,10B\n\tJNB P1\n\tCMP EDX,0\n\tJA  P2\n\tCMP EAX,1000000000\n\tJNB P2\n\tCMP EAX,100000000\n\tJNB P3\n\tCMP EAX,10000000\n\tJNB P4\n\tCMP EAX,1000000\n\tJNB P5\n\tCMP EAX,100000\n\tJNB P6\n\tCMP EAX,10000\n\tJNB P7\n\tCMP EAX,1000\n\tJNB P8\n\tCMP EAX,100\n\tJNB P9\n\tCMP EAX,10\n\tJNB P10\n\tCMP EAX,1\n\tJNB P11\n\nP1:\n\tMOV DL,1\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tMOV EAX,10011010001001110101010101100001B\n\tMOV EDX,0\n\nP2:\n\tMOV EBX,1000000000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP3:\n\tMOV EBX,100000000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP4:\n\tMOV EBX,10000000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP5:\n\tMOV EBX,1000000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP6:\n\tMOV EBX,100000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP7:\n\tMOV EBX,10000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP8:\n\tMOV EBX,1000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP9:\n\tMOV EBX,100\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP10:\n\tMOV EBX,10\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\t\n\nP11:\n\tMOV EBX,1\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\tMOV DL,32\n\tMOV AH,2H\n\tINT 21H\n\t\n\tPOP EDX\n\tPOP ECX\n\tPOP EBX\n\tPOP EAX\n\tJMP PRINTBACK\n;PRINT END\n\n\n;PRINT11\nPRINT11:\n\tPUSH EDX\n\tPUSH EAX\n\t\n\tMOV DL,1\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tMOV DL,32\n\tMOV AH,2H\n\tINT 21H\n\t\n\tMOV DL,1\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tMOV DL,32\n\tMOV AH,2H\n\tINT 21H\n\t\n\tPOP EAX\n\tPOP EDX\n\t\n\tJMP A\n\nBACK:\n\tMOV AX,4C00H\n   \tINT 21H\nCODES ENDS\n    END START\n```\n\n","tags":["汇编"]},{"title":"航班信息管理系统","url":"/2022/12/12/7/","content":"```\n#include <iostream>\n#include <string>   \n#include <iomanip>   \n#include <fstream> \n#include <random> \n#include <ctime>   \n#include <windows.h> \n\nusing namespace std;\n\ntypedef struct flightnode\n{\n\tstring flight_num;       //航班号\n\tstring time;             //起飞时间\n\tint date = 0;            //起飞日期\n\tstring start_place;      //出发地\n\tstring end_place;        //目的地\n\tfloat discount = 0;      //折扣\n\tint left = 0;            //余票\n\tfloat price = 0;         //价格\n\tflightnode* next = NULL;\n}*flightlist;\n\nstruct ticket\n{\n\tstring flight_num;\t  //航班号\n\tstring time;\t\t  //起飞时间\n\tstring start_place;\t  //出发地\n\tstring end_place;     //目的地\n\tfloat price = 0;      //价格\n\tint date = 0;         //起飞日期\n\tstring order_num;\t  //订单编号\n};\n\ntypedef struct passengernode\n{\n\tstring name;        //名字\n\tstring ID_num;      //证件号\n\tticket ticket;      //票\n\tint full = 0;       //预约标志  1表示预约状态\n\tpassengernode* next = NULL;\n}*passengerlist;\n\n//航班类信息\nvoid Init_flight(flightlist& h);\t\t//初始化航班\nvoid Load_flight(flightlist& h);\t\t//载入航班\nvoid Add_flight(flightlist& h);\t\t\t//添加航班\nvoid Check_flight(flightlist& h);\t\t//查找航班\nvoid Check_flightnum(flightlist& h);\t//航班号查找\nvoid Check_seplace(flightlist& h);\t\t//起始地查找\nvoid Check_all(flightlist& h);\t\t\t//浏览全部航班\nvoid Revise_flight(flightlist& h);\t\t//修改航班信息\nvoid Delete_flight(flightlist& h);\t\t//删除航班\nvoid Revise_time(flightlist& h);\t\t//修改起飞抵达时间\nvoid Revise_price(flightlist& h);\t\t//修改价格\nvoid Save_flight(flightlist& h);\t\t//保存航班信息\n//用户信息\nvoid Init_passenger(passengerlist& c);\t\t\t//初始化用户\nvoid Load_passenger(passengerlist& c);\t\t\t//载入用户信息\nvoid Book(flightlist& h, passengerlist& c);\t\t//定票\nvoid Qbook(flightlist& h, passengerlist& c);\t//退票\nvoid Check_book(passengerlist& c);\t\t\t\t//查询订单\nvoid Save_passenger(passengerlist& c);\t\t\t//保存用户信息\n//管理操作\nvoid manage(flightlist& flight, passengerlist& passenger);\nvoid password();//密码管理\n//通用\nvoid wait();\n\n\n\n\nvoid manage(flightlist& flight, passengerlist& passenger)\n{\n\twhile (1) {\n\t\tcout << \"航班信息管理系统\" << endl << endl;\n\t\tcout << \"主菜单\" << endl;\n\t\tcout << \"1.录入航班信息\" << endl;\n\t\tcout << \"2.查询航班\" << endl;\n\t\tcout << \"3.订票\" << endl;\n\t\tcout << \"4.退票\" << endl;\n\t\tcout << \"5.查询订单\" << endl;\n\t\tcout << \"6.修改航班信息\" << endl;\n\t\tcout << \"0.退出系统 \" << endl;\n\t\tcout << \"请输入您想要进行的功能：\";\n\t\tint i;\n\t\tcin >> i;\n\t\tsystem(\"cls\");\n\t\tswitch (i) {\n\t\tcase 1:Add_flight(flight); Save_flight(flight); wait(); break;\n\t\tcase 2:Check_flight(flight); wait(); break;\n\t\tcase 3:Book(flight, passenger); Save_flight(flight); Save_passenger(passenger); wait(); break;\n\t\tcase 4:Qbook(flight, passenger); Save_flight(flight); Save_passenger(passenger); wait(); break;\n\t\tcase 5:Check_book(passenger); wait(); break;\n\t\tcase 6:Revise_flight(flight); Save_flight(flight); wait(); break;\n\t\tcase 0:exit(0); break;\n\t\tdefault:cout << \"请检查你的输入！\" << endl; break;\n\t\t}\n\t}\n}\n\nvoid Sort_flight(flightlist& h)\n{\n\tflightlist p = h->next;  //指向第一个结点\n\twhile (p != NULL) {\n\t\tflightlist q = h->next;   //指向p后一个结点\n\t\twhile (q) {\n\t\t\tif (q->date > p->date) {\n\t\t\t\tflightnode temp = *p;   //临时保存指针交换\n\t\t\t\ttemp.next = q->next;\n\t\t\t\tq->next = p->next;\n\t\t\t\t*p = *q;\n\t\t\t\t*q = temp;\n\t\t\t}\n\t\t\tq = q->next;   //指针移动\n\t\t}\n\t\tp = p->next;    //指针移动\n\t}\n\n}\n\nvoid Init_flight(flightlist& h)//初始化航班\n{\n\th = new flightnode;  //头指针\n\th->next = NULL;\n}\n\nvoid Load_flight(flightlist& h)//载入航班\n{\n\tflightlist f = h;\n\tflightlist newp = new flightnode;\n\tifstream ifs(\"FlightList.txt\");\n\tif (!ifs.is_open()) {\n\t\tcout << \"文件未被打开！\" << endl;\n\t\treturn;\n\t}\n\twhile (ifs >> newp->flight_num >> newp->date >> newp->time >> newp->start_place >> newp->end_place >> newp->price >> newp->discount >> newp->left) {\n\t\tf->next = newp;\n\t\tf = f->next;\n\t\tnewp = new flightnode;\n\t}\n\tf->next = NULL;\n\tdelete newp;\n}\n\nvoid Add_flight(flightlist& h)//添加航班\n{\n\tchar mark = 'y';\n\tflightlist s, rear;\n\tfor (rear = h; rear->next != NULL; rear = rear->next) {}  // rear移动结点尾\n\twhile (mark == 'y' || mark == 'Y') {\n\t\ts = new flightnode;\n\t\tcout << \"请输入航班号：\";\n\t\tcin >> s->flight_num;\n\t\tcout << \"请输入起飞日期：\";\n\t\tcin >> s->date;\n\t\tcout << \"请输入起飞时间：\";\n\t\tcin >> s->time;\n\t\tcout << \"请输入出发地：\";\n\t\tcin >> s->start_place;\n\t\tcout << \"请输入目的地：\";\n\t\tcin >> s->end_place;\n\t\tcout << \"请输入价格：\";\n\t\tcin >> s->price;\n\t\tcout << \"请输入折扣：\";\n\t\tcin >> s->discount;\n\t\tcout << \"请输入余票：\";\n\t\tcin >> s->left;\n\t\trear->next = s;\n\t\trear = s;\n\t\tcout << \"添加成功！\" << endl;\n\t\tcout << \"是否继续添加？（是“y”/否“n”）：\";\n\t\tcin >> mark;\n\t}\n\trear->next = NULL;\n}\n\nvoid Check_flight(flightlist& h)//查找航班\n{\n\tint i;\n\tcout << \"查找方式\" << endl;\n\tcout << \"1.航班查找\" << endl;\n\tcout << \"2.起始地查找\" << endl;\n\tcout << \"3.浏览全部航班\" << endl;\n\tcout << \"请输入查找方式：\";\n\tcin >> i;\n\tswitch (i) {\n\tcase 1:Check_flightnum(h); break;\n\tcase 2:Check_seplace(h); break;\n\tcase 3:Check_all(h); break;\n\tdefault:break;\n\t}\n}\n\nvoid Check_flightnum(flightlist& h)//航班号查找\n{\n\tstring flightnum;\n\tflightlist p = h->next;\n\tcout << \"请输入航班号：\";\n\tcin >> flightnum;\n\tcout << setw(6) << \"航班号\" << setw(17) << \"起飞日期\" << setw(15) << \"起飞时间\" << setw(15) << \"出发地\" << setw(15) << \"目的地\" << setw(15) << \"价格\" << setw(15) << \"折扣\" << setw(15) << \"余票\" << endl;\n\twhile (p != NULL) {\n\t\tif (p->flight_num == flightnum) {\n\t\t\tcout << setw(6) << p->flight_num << setw(15) << p->date << \"日\" << setw(15) << p->time << setw(15) << p->start_place << setw(15) << p->end_place << setw(15) << p->price << setw(15) << p->discount << setw(15) << p->left << endl;\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t\tp = p->next;\n\t}\n\tcout << setw(32) << \"未查到任何信息。\";\n\twait();\n}\n\nvoid Check_seplace(flightlist& h)//起始地查找\n{\n\tstring start_place, end_place;\n\tcout << \"请输入出发地：\";\n\tcin >> start_place;\n\tcout << \"请输入目的地：\";\n\tcin >> end_place;\n\tflightlist p = h->next;\n\tcout << setw(6) << \"航班号\" << setw(17) << \"起飞日期\" << setw(15) << \"起飞时间\" << setw(15) << \"出发地\" << setw(15) << \"目的地\" << setw(15) << \"价格\" << setw(15) << \"折扣\" << setw(15) << \"余票\" << endl;\n\twhile (p != NULL) {\n\t\tif (p->start_place == start_place && p->end_place == end_place) {\n\t\t\tcout << setw(6) << p->flight_num << setw(15) << p->date << \"号\" << setw(15) << p->time << setw(15) << p->start_place << setw(15) << p->end_place << setw(15) << p->price << setw(15) << p->discount << setw(15) << p->left << endl;\n\t\t\treturn;\n\t\t}\n\t\tp = p->next;        //移动\n\t}\n\tcout << \"未查到任何信息\" << endl;\n\twait();\n}\n\nvoid Check_all(flightlist& h)//浏览全部航班\n{\n\tSort_flight(h);  //日期排序\n\tflightlist p = h->next;\n\tcout << setw(6) << \"航班号\" << setw(17) << \"起飞日期\" << setw(15) << \"起飞时间\" << setw(15) << \"出发地\" << setw(15) << \"目的地\" << setw(15) << \"价格\" << setw(15) << \"折扣\" << setw(15) << \"余票\" << endl;\n\twhile (p != NULL)\n\t{\n\t\tcout << setw(6) << p->flight_num << setw(15) << p->date << \"号\" << setw(15) << p->time << setw(15) << p->start_place << setw(15) << p->end_place << setw(15) << p->price << setw(15) << p->discount << setw(15) << p->left << endl;\n\t\tp = p->next;   //移动\n\t}\n}\n\nvoid Revise_flight(flightlist& h)//修改航班信息\n{\n\tflightlist f = h->next;\n\tint i;\n\tcout << \"修改内容:\" << endl;\n\tcout << \"1.删除航班\" << endl;\n\tcout << \"2.修改起飞时间\" << endl;\n\tcout << \"3.修改航班价格\" << endl;\n\tcout << \"4.返回\" << endl;\n\tcout << \"请输入查找方式：\";\n\tcin >> i;\n\tCheck_all(h);     //浏览全部\n\tswitch (i) {\n\tcase 1:Delete_flight(h); break;\n\tcase 2:Revise_time(h); break;\n\tcase 3:Revise_price(h); break;\n\tcase 4:return; break;\n\tdefault:cout << \"请检查你的输入！\" << endl; break;\n\t}\n}\n\nvoid Delete_flight(flightlist& h)//删除航班\n{\n\tflightlist p = h->next, q = h;  //q是p的前驱\n\tstring flightnum;\n\tcout << \"请输入您想要修改的航班号：\";\n\tcin >> flightnum;\n\twhile (p != NULL) {\n\t\tif (p->flight_num == flightnum) {\n\t\t\tq->next = p->next;      //p是要删除的结点，q是前一个结点\n\t\t\tdelete p;\n\t\t\tcout << \"删除成功！\";\n\t\t\twait();\n\t\t\treturn;\n\t\t}\n\t\tq = q->next;\n\t\tp = q->next;\n\t}\n\tcout << \"未查找到相关航班！\";\n\twait();\n}\n\nvoid Revise_time(flightlist& h)//修改起飞抵达时间\n{\n\tstring flightnum;\n\tflightlist p = h->next;\n\tcout << \"请输入您想要修改的航班号：\";\n\tcin >> flightnum;\n\twhile (p != NULL) {\n\t\tif (p->flight_num == flightnum) {\n\t\t\tcout << \"请输入新的起飞日期：\";\n\t\t\tcin >> p->date;\n\t\t\tcout << \"请输入新的起飞时间：\";\n\t\t\tcin >> p->time;\n\t\t\tcout << \"修改成功！\";\n\t\t\twait();\n\t\t\treturn;\n\t\t}\n\t\tp = p->next;\n\t}\n\tcout << \"没有您想要修改的航班号!\";\n\twait();\n}\n\nvoid Revise_price(flightlist& h)//修改价格\n{\n\tstring flightnum;\n\tflightlist p = h->next;\n\tcout << \"请输入您想要修改的航班号：\";\n\tcin >> flightnum;\n\twhile (p != NULL) {\n\t\tif (p->flight_num == flightnum) {\n\t\t\tcout << \"请输入新的价格：\";\n\t\t\tcin >> p->price;\n\t\t\tcout << \"请输入新的折扣：\";\n\t\t\tcin >> p->discount;\n\t\t\tcout << \"修改成功！\t\";\n\t\t\twait();\n\t\t\treturn;\n\t\t}\n\t\tp = p->next;\n\t}\n\tcout << \"没有您想要修改的航班号!\";\n\twait();\n}\n\nvoid Save_flight(flightlist& h)//保存航班信息\n{\n\tflightlist f = h->next;\n\tSort_flight(h);\n\tofstream ofs(\"FlightList.txt\");\n\tif (!ofs)\n\t{\n\t\tcout << \"存储失败！\";\n\t\treturn;\n\t}\n\twhile (f != NULL)\n\t{\n\t\tofs << f->flight_num << \" \" << f->date << \" \" << f->time << \" \" << f->start_place << \" \" << f->end_place << \" \" << f->price << \" \" << f->discount << \" \" << f->left << endl;\n\t\tf = f->next;\n\t}\n\tofs.close();   //关闭文件\n}\n\nvoid Init_passenger(passengerlist& c)//初始化用户\n{\n\tc = new passengernode;   //头结点\n\tc->next = NULL;\n}\n\nvoid Load_passenger(passengerlist& c)\n{\n\tpassengerlist p = c;\n\tpassengerlist newp = new passengernode;\n\tifstream ifs(\"PassengerList.txt\");\n\tif (!ifs.is_open()) {\n\t\tcout << \"文件未被打开！\" << endl;\n\t\treturn;\n\t}\n\tcout << \"数据读取成功！\" << endl;\n\tsystem(\"cls\");\n\twhile (ifs >> newp->name >> newp->ID_num >> newp->ticket.flight_num >> newp->ticket.date >> newp->ticket.time >> newp->ticket.start_place >> newp->ticket.end_place >> newp->ticket.price >> newp->ticket.order_num)\n\t{\n\t\tp->next = newp;\n\t\tp = p->next;\n\t\tnewp = new passengernode;\n\t}\n\tp->next = NULL;\n\tdelete newp;\n}\n\nvoid Book(flightlist& h, passengerlist& c)//订票\n{\n\tstring start_place, end_place, flightnum;\n\tint date;//航班信息\n\tflightlist p = h->next, q = h->next;\n\tpassengerlist s, r = c;\n\tchar mark, check = '1';\n\tchar mark02 = '1';         //标志\n\tfor (; r->next != NULL; r = r->next) {}   //r移动到结点尾\n\ts = new passengernode;\n\tcout << \"请输入乘客的姓名：\";\n\tcin >> s->name;\n\tcout << \"请输入乘客的证件号：\";\n\tcin >> s->ID_num;\n\tcout << \"请输入出发地：\";\n\tcin >> start_place;\n\tcout << \"请输入目的地：\";\n\tcin >> end_place;\n\tcout << \"请选择出发日期：\";\n\tcin >> date;\n\tcout << setw(6) << \"航班号\" << setw(17) << \"起飞日期\" << setw(15) << \"起飞时间\" << setw(15) << \"出发地\" << setw(15) << \"目的地\" << setw(15) << \"价格\" << setw(15) << \"折扣\" << setw(15) << \"余票\" << endl;\n\twhile (p != NULL)\n\t{\n\t\tif (p->start_place == start_place && p->end_place == end_place && p->date == date)//匹配日期相符的航班\n\t\t{\n\t\t\tcout << setw(6) << p->flight_num << setw(15) << p->date << \"号\" << setw(15) << p->time << setw(15) << p->start_place << setw(15) << p->end_place << setw(15) << p->price << setw(15) << p->discount << setw(15) << p->left << endl;\n\t\t\tcheck = '0';\n\t\t}\n\t\tp = p->next;\n\t}\n\tif (check == '1') {\n\t\tp = h->next;\n\t\tcout << \"无\" << setw(15) << \"无\" << setw(17) << \"无\" << setw(15) << \"无\" << setw(15) << \"无\" << setw(15) << \"无\" << setw(15) << \"无\" << setw(15) << \"无\" << endl;\n\t\tcout << \"该天没相关的航班\" << endl;\n\t\tif (mark02 == '1')\n\t\t\treturn;//结束\n\t}\n\tcout << \"是否进行购买？（Y/N）\";\n\tcin >> mark;\n\tif (mark == 'y' || mark == 'Y') {\n\t\tcout << \"请输入您想要购买的航班号：\";\n\t\tcin >> flightnum;\n\t\twhile (q != NULL) {\n\t\t\tif (q->flight_num == flightnum && q->start_place == start_place && q->end_place == end_place) {\n\t\t\t\tif (q->left == 0) {\n\t\t\t\t\tcout << \"余票不足，请选择是否预约（Y/N）\";\n\t\t\t\t\tcin >> mark;\n\t\t\t\t\tif (mark == 'y' || mark == 'Y') {\n\t\t\t\t\t\ts->full = 1;  //修改预约标志\n\t\t\t\t\t\ts->ticket.flight_num = flightnum;\n\t\t\t\t\t\ts->ticket.start_place = start_place;\n\t\t\t\t\t\ts->ticket.end_place = end_place;\n\t\t\t\t\t\ts->ticket.time = \"预约\";\n\t\t\t\t\t\ts->ticket.price = 000;\n\t\t\t\t\t\ts->ticket.date = date;\n\t\t\t\t\t\ts->ticket.order_num = \"预约\";\n\t\t\t\t\t\tcout << \" 预约成功\";\n\t\t\t\t\t\tr->next = s;\n\t\t\t\t\t\tr = s;\n\t\t\t\t\t\tr->next = NULL;\n\t\t\t\t\t\twait();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\treturn;  //不预约直接结束\n\t\t\t\t}\n\t\t\t\ts->ticket.flight_num = flightnum;\n\t\t\t\ts->ticket.start_place = start_place;\n\t\t\t\ts->ticket.end_place = end_place;\n\t\t\t\ts->ticket.time = q->time;\n\t\t\t\ts->ticket.price = q->price;\n\t\t\t\ts->ticket.date = q->date;\n\t\t\t\tsrand((unsigned int)time(0));\n\t\t\t\ts->ticket.order_num = q->flight_num + to_string(rand()) + to_string(rand());//订单编号\n\t\t\t\tr->next = s;\n\t\t\t\tr = s;\n\t\t\t\tr->next = NULL;\n\t\t\t\tcout << \"购票成功！\" << \"订单号为\" + s->ticket.order_num << endl;\n\t\t\t\tq->left--;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t\tq = q->next;\n\t\t}\n\t\tcout << \"航班号填入错误！\" << endl;\n\t\twait();\n\t}\n\telse {\n\t\treturn;//不进行购买直接结束\n\t}\n}\n\nvoid Qbook(flightlist& h, passengerlist& c)//退票\n{\n\tstring name, ID_num;\n\tbool mark = false;\n\tflightlist f = h->next;\n\tpassengerlist p = c->next, q = c, t = c->next;\n\tcout << \"请输入乘客的姓名：\";\n\tcin >> name;\n\tcout << \"请输入乘客的证件号：\";\n\tcin >> ID_num;\n\twhile (p != NULL) {\n\t\tif (p->name == name && p->ID_num == ID_num) {\n\t\t\tmark = true;   //找到乘客\n\t\t\twhile (f != NULL) {\n\t\t\t\tif (p->ticket.flight_num == f->flight_num) {\n\t\t\t\t\tf->left++;  //票数更新\n\t\t\t\t\twhile (t != NULL) {\n\t\t\t\t\t\tif (t->ticket.flight_num == p->ticket.flight_num && t->full == 1) {\n\t\t\t\t\t\t\tt->ticket.start_place = p->ticket.start_place;\n\t\t\t\t\t\t\tt->ticket.end_place = p->ticket.end_place;\n\t\t\t\t\t\t\tt->ticket.time = p->ticket.time;\n\t\t\t\t\t\t\tt->ticket.price = p->ticket.price;\n\t\t\t\t\t\t\tt->ticket.date = p->ticket.date;\n\t\t\t\t\t\t\tsrand((unsigned int)time(0));\n\t\t\t\t\t\t\tt->ticket.order_num = p->ticket.flight_num.c_str() + to_string(rand()) + to_string(rand());\n\t\t\t\t\t\t\tf->left--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt = t->next;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tf = f->next;\n\t\t\t}\n\t\t\tq->next = p->next;\n\t\t\tdelete p;\n\t\t\tcout << \"退票成功！\";\n\t\t\treturn;\n\t\t}\n\t\tq = q->next;\n\t\tp = q->next;\n\t}\n\tif (!mark) {\n\t\tcout << \"未找到相关乘客的订单\";\n\t\twait();\n\t}\n}\n\nvoid Check_book(passengerlist& c)//查询订票\n{\n\tstring name, ID_num;\n\tpassengerlist p = c->next;\n\tcout << \"请输入乘客的姓名：\";\n\tcin >> name;\n\tcout << \"请输入乘客的证件号：\";\n\tcin >> ID_num;\n\tcout << setw(8) << \"姓名\" << setw(15) << \"航班号\" << setw(17) << \"起飞日期\" << setw(15) << \"起飞时间\" << setw(15) << \"出发地\" << setw(15) << \"目的地\" << setw(15) << \"价格\" << setw(18) << \"订单编号\" << endl;\n\twhile (p != NULL) {\n\t\tif (p->name == name && p->ID_num == ID_num) {\n\t\t\tcout << setw(8) << p->name << setw(15) << p->ticket.flight_num << setw(15) << p->ticket.date << \"号\" << setw(15) << p->ticket.time << setw(15) << p->ticket.start_place << setw(15) << p->ticket.end_place << setw(15) << p->ticket.price << setw(18) << p->ticket.order_num << endl;\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t\tp = p->next;\n\t}\n\tcout << setw(32) << \"未查到任何信息。\";\n\twait();\n\treturn;\n}\n\nvoid Save_passenger(passengerlist& c)\n{\n\tpassengerlist p = c->next;\n\tofstream ofs(\"PassengerList.txt\");\n\tif (!ofs) {\n\t\tcout << \"存储失败！\";\n\t\treturn;\n\t}\n\twhile (p != NULL) {\n\t\tofs << p->name << \" \" << p->ID_num << \" \" << p->ticket.flight_num << \" \" << p->ticket.date << \" \" << p->ticket.time << \" \" << p->ticket.start_place << \" \" << p->ticket.end_place << \" \" << p->ticket.price << \" \" << p->ticket.order_num << endl;\n\t\tp = p->next;\n\t}\n\tofs.close();\n}\n\nvoid wait() {\n\tint a = getchar();\n\ta = getchar();\n\tsystem(\"cls\");\n}\n\nint main()\n{\n\tflightlist flight;\n\tpassengerlist passenger;\n\tInit_passenger(passenger); //初始用户信息\n\tLoad_passenger(passenger); //载入用户信息\n\tInit_flight(flight);       //初始化航班\n\tLoad_flight(flight);       //载入航班\n\tmanage(flight, passenger); //封装管理函数\n\treturn 0;\n}\n\n```\n\n","tags":["C++"]},{"title":"面向对象编程","url":"/2022/12/11/6/","content":"\n# C++核心编程\n\n本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。\n\n\n\n## 1 内存分区模型\n\nC++程序在执行时，将内存大方向划分为**4个区域**\n\n- 代码区：存放函数体的二进制代码，由操作系统进行管理的\n- 全局区：存放全局变量和静态变量以及常量\n- 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等\n- 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收\n\n\n\n\n\n\n\n**内存四区意义：**\n\n不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程\n\n\n\n\n\n### 1.1 程序运行前\n\n\t在程序编译后，生成了exe可执行程序，**未执行该程序前**分为两个区域\n\t\n\t**代码区：**\n\t\n\t\t存放 CPU 执行的机器指令\n\t\n\t\t代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可\n\t\n\t\t代码区是**只读**的，使其只读的原因是防止程序意外地修改了它的指令\n\t\n\t**全局区：**\n\t\n\t\t全局变量和静态变量存放在此.\n\t\n\t\t全局区还包含了常量区, 字符串常量和其他常量也存放在此.\n\t\n\t\t==该区域的数据在程序结束后由操作系统释放==.\n\n\n\n\n\n\n\n\n\n\n\n\n\n**示例：**\n\n```c++\n//全局变量\nint g_a = 10;\nint g_b = 10;\n\n//全局常量\nconst int c_g_a = 10;\nconst int c_g_b = 10;\n\nint main() {\n\n\t//局部变量\n\tint a = 10;\n\tint b = 10;\n\n\t//打印地址\n\tcout << \"局部变量a地址为： \" << (int)&a << endl;\n\tcout << \"局部变量b地址为： \" << (int)&b << endl;\n\n\tcout << \"全局变量g_a地址为： \" <<  (int)&g_a << endl;\n\tcout << \"全局变量g_b地址为： \" <<  (int)&g_b << endl;\n\n\t//静态变量\n\tstatic int s_a = 10;\n\tstatic int s_b = 10;\n\n\tcout << \"静态变量s_a地址为： \" << (int)&s_a << endl;\n\tcout << \"静态变量s_b地址为： \" << (int)&s_b << endl;\n\n\tcout << \"字符串常量地址为： \" << (int)&\"hello world\" << endl;\n\tcout << \"字符串常量地址为： \" << (int)&\"hello world1\" << endl;\n\n\tcout << \"全局常量c_g_a地址为： \" << (int)&c_g_a << endl;\n\tcout << \"全局常量c_g_b地址为： \" << (int)&c_g_b << endl;\n\n\tconst int c_l_a = 10;\n\tconst int c_l_b = 10;\n\tcout << \"局部常量c_l_a地址为： \" << (int)&c_l_a << endl;\n\tcout << \"局部常量c_l_b地址为： \" << (int)&c_l_b << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n打印结果：\n\n![1545017602518](assets/1545017602518.png)\n\n\n\n总结：\n\n* C++中在程序运行前分为全局区和代码区\n* 代码区特点是共享和只读\n* 全局区中存放全局变量、静态变量、常量\n* 常量区中存放 const修饰的全局常量  和 字符串常量\n\n\n\n\n\n\n### 1.2 程序运行后\n\n\n\n\t**栈区：**\n\t\n\t\t由编译器自动分配释放, 存放函数的参数值,局部变量等\n\t\n\t\t注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放\n\n\n\n**示例：**\n\n```c++\nint * func()\n{\n\tint a = 10;\n\treturn &a;\n}\n\nint main() {\n\n\tint *p = func();\n\n\tcout << *p << endl;\n\tcout << *p << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\t**堆区：**\n\t\n\t\t由程序员分配释放,若程序员不释放,程序结束时由操作系统回收\n\t\n\t\t在C++中主要利用new在堆区开辟内存\n\n**示例：**\n\n```c++\nint* func()\n{\n\tint* a = new int(10);\n\treturn a;\n}\n\nint main() {\n\n\tint *p = func();\n\n\tcout << *p << endl;\n\tcout << *p << endl;\n    \n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n**总结：**\n\n堆区数据由程序员管理开辟和释放\n\n堆区数据利用new关键字进行开辟内存\n\n\n\n\n\n\n\n\n\n### 1.3 new操作符\n\n\n\n\tC++中利用==new==操作符在堆区开辟数据\n\t\n\t堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==\n\t\n\t语法：` new 数据类型`\n\t\n\t利用new创建的数据，会返回该数据对应的类型的指针\n\n\n\n**示例1： 基本语法**\n\n```c++\nint* func()\n{\n\tint* a = new int(10);\n\treturn a;\n}\n\nint main() {\n\n\tint *p = func();\n\n\tcout << *p << endl;\n\tcout << *p << endl;\n\n\t//利用delete释放堆区数据\n\tdelete p;\n\n\t//cout << *p << endl; //报错，释放的空间不可访问\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n**示例2：开辟数组**\n\n```c++\n//堆区开辟数组\nint main() {\n\n\tint* arr = new int[10];\n\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tarr[i] = i + 100;\n\t}\n\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tcout << arr[i] << endl;\n\t}\n\t//释放数组 delete 后加 []\n\tdelete[] arr;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n## 2 引用\n\n### 2.1 引用的基本使用\n\n**作用： **给变量起别名\n\n**语法：** `数据类型 &别名 = 原名`\n\n\n\n**示例：**\n\n```C++\nint main() {\n\n\tint a = 10;\n\tint &b = a;\n\n\tcout << \"a = \" << a << endl;\n\tcout << \"b = \" << b << endl;\n\n\tb = 100;\n\n\tcout << \"a = \" << a << endl;\n\tcout << \"b = \" << b << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n### 2.2 引用注意事项\n\n* 引用必须初始化\n* 引用在初始化后，不可以改变\n\n示例：\n\n```C++\nint main() {\n\n\tint a = 10;\n\tint b = 20;\n\t//int &c; //错误，引用必须初始化\n\tint &c = a; //一旦初始化后，就不可以更改\n\tc = b; //这是赋值操作，不是更改引用\n\n\tcout << \"a = \" << a << endl;\n\tcout << \"b = \" << b << endl;\n\tcout << \"c = \" << c << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n### 2.3 引用做函数参数\n\n**作用：**函数传参时，可以利用引用的技术让形参修饰实参\n\n**优点：**可以简化指针修改实参\n\n\n\n**示例：**\n\n```C++\n//1. 值传递\nvoid mySwap01(int a, int b) {\n\tint temp = a;\n\ta = b;\n\tb = temp;\n}\n\n//2. 地址传递\nvoid mySwap02(int* a, int* b) {\n\tint temp = *a;\n\t*a = *b;\n\t*b = temp;\n}\n\n//3. 引用传递\nvoid mySwap03(int& a, int& b) {\n\tint temp = a;\n\ta = b;\n\tb = temp;\n}\n\nint main() {\n\n\tint a = 10;\n\tint b = 20;\n\n\tmySwap01(a, b);\n\tcout << \"a:\" << a << \" b:\" << b << endl;\n\n\tmySwap02(&a, &b);\n\tcout << \"a:\" << a << \" b:\" << b << endl;\n\n\tmySwap03(a, b);\n\tcout << \"a:\" << a << \" b:\" << b << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n\n```\n\n\n\n> 总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 2.4 引用做函数返回值\n\n\n\n作用：引用是可以作为函数的返回值存在的\n\n\n\n注意：**不要返回局部变量引用**\n\n用法：函数调用作为左值\n\n\n\n**示例：**\n\n```C++\n//返回局部变量引用\nint& test01() {\n\tint a = 10; //局部变量\n\treturn a;\n}\n\n//返回静态变量引用\nint& test02() {\n\tstatic int a = 20;\n\treturn a;\n}\n\nint main() {\n\n\t//不能返回局部变量的引用\n\tint& ref = test01();\n\tcout << \"ref = \" << ref << endl;\n\tcout << \"ref = \" << ref << endl;\n\n\t//如果函数做左值，那么必须返回引用\n\tint& ref2 = test02();\n\tcout << \"ref2 = \" << ref2 << endl;\n\tcout << \"ref2 = \" << ref2 << endl;\n\n\ttest02() = 1000;\n\n\tcout << \"ref2 = \" << ref2 << endl;\n\tcout << \"ref2 = \" << ref2 << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n​\t\n\n\n\n\n\n\n\n\n\n### 2.5 引用的本质\n\n本质：**引用的本质在c++内部实现是一个指针常量.**\n\n讲解示例：\n\n```C++\n//发现是引用，转换为 int* const ref = &a;\nvoid func(int& ref){\n\tref = 100; // ref是引用，转换为*ref = 100\n}\nint main(){\n\tint a = 10;\n    \n    //自动转换为 int* const ref = &a; 指针常量是指针指向不可改，也说明为什么引用不可更改\n\tint& ref = a; \n\tref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20;\n    \n\tcout << \"a:\" << a << endl;\n\tcout << \"ref:\" << ref << endl;\n    \n\tfunc(a);\n\treturn 0;\n}\n```\n\n结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 2.6 常量引用\n\n\n\n**作用：**常量引用主要用来修饰形参，防止误操作\n\n\n\n在函数形参列表中，可以加==const修饰形参==，防止形参改变实参\n\n\n\n**示例：**\n\n\n\n```C++\n//引用使用的场景，通常用来修饰形参\nvoid showValue(const int& v) {\n\t//v += 10;\n\tcout << v << endl;\n}\n\nint main() {\n\n\t//int& ref = 10;  引用本身需要一个合法的内存空间，因此这行错误\n\t//加入const就可以了，编译器优化代码，int temp = 10; const int& ref = temp;\n\tconst int& ref = 10;\n\n\t//ref = 100;  //加入const后不可以修改变量\n\tcout << ref << endl;\n\n\t//函数中利用常量引用防止误操作修改实参\n\tint a = 10;\n\tshowValue(a);\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n## 3 函数提高\n\n### 3.1 函数默认参数\n\n\n\n在C++中，函数的形参列表中的形参是可以有默认值的。\n\n语法：` 返回值类型  函数名 （参数= 默认值）{}`\n\n\n\n**示例：**\n\n```C++\nint func(int a, int b = 10, int c = 10) {\n\treturn a + b + c;\n}\n\n//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值\n//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数\nint func2(int a = 10, int b = 10);\nint func2(int a, int b) {\n\treturn a + b;\n}\n\nint main() {\n\n\tcout << \"ret = \" << func(20, 20) << endl;\n\tcout << \"ret = \" << func(100) << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n### 3.2 函数占位参数\n\n\n\nC++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置\n\n\n\n**语法：** `返回值类型 函数名 (数据类型){}`\n\n\n\n在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术\n\n\n\n**示例：**\n\n```C++\n//函数占位参数 ，占位参数也可以有默认参数\nvoid func(int a, int) {\n\tcout << \"this is func\" << endl;\n}\n\nint main() {\n\n\tfunc(10,10); //占位参数必须填补\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n### 3.3 函数重载\n\n#### 3.3.1 函数重载概述\n\n\n\n**作用：**函数名可以相同，提高复用性\n\n\n\n**函数重载满足条件：**\n\n* 同一个作用域下\n* 函数名称相同\n* 函数参数**类型不同**  或者 **个数不同** 或者 **顺序不同**\n\n\n\n**注意:**  函数的返回值不可以作为函数重载的条件\n\n\n\n**示例：**\n\n```C++\n//函数重载需要函数都在同一个作用域下\nvoid func()\n{\n\tcout << \"func 的调用！\" << endl;\n}\nvoid func(int a)\n{\n\tcout << \"func (int a) 的调用！\" << endl;\n}\nvoid func(double a)\n{\n\tcout << \"func (double a)的调用！\" << endl;\n}\nvoid func(int a ,double b)\n{\n\tcout << \"func (int a ,double b) 的调用！\" << endl;\n}\nvoid func(double a ,int b)\n{\n\tcout << \"func (double a ,int b)的调用！\" << endl;\n}\n\n//函数返回值不可以作为函数重载条件\n//int func(double a, int b)\n//{\n//\tcout << \"func (double a ,int b)的调用！\" << endl;\n//}\n\n\nint main() {\n\n\tfunc();\n\tfunc(10);\n\tfunc(3.14);\n\tfunc(10,3.14);\n\tfunc(3.14 , 10);\n\t\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 3.3.2 函数重载注意事项\n\n\n\n* 引用作为重载条件\n* 函数重载碰到函数默认参数\n\n\n\n\n\n**示例：**\n\n```C++\n//函数重载注意事项\n//1、引用作为重载条件\n\nvoid func(int &a)\n{\n\tcout << \"func (int &a) 调用 \" << endl;\n}\n\nvoid func(const int &a)\n{\n\tcout << \"func (const int &a) 调用 \" << endl;\n}\n\n\n//2、函数重载碰到函数默认参数\n\nvoid func2(int a, int b = 10)\n{\n\tcout << \"func2(int a, int b = 10) 调用\" << endl;\n}\n\nvoid func2(int a)\n{\n\tcout << \"func2(int a) 调用\" << endl;\n}\n\nint main() {\n\t\n\tint a = 10;\n\tfunc(a); //调用无const\n\tfunc(10);//调用有const\n\n\n\t//func2(10); //碰到默认参数产生歧义，需要避免\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n## **4** 类和对象\n\n\n\nC++面向对象的三大特性为：==封装、继承、多态==\n\n\n\nC++认为==万事万物都皆为对象==，对象上有其属性和行为\n\n\n\n**例如：**\n\n\t人可以作为对象，属性有姓名、年龄、身高、体重...，行为有走、跑、跳、吃饭、唱歌...\n\t\n\t车也可以作为对象，属性有轮胎、方向盘、车灯...,行为有载人、放音乐、放空调...\n\t\n\t具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类\n\n### 4.1 封装\n\n#### 4.1.1  封装的意义\n\n封装是C++面向对象三大特性之一\n\n封装的意义：\n\n* 将属性和行为作为一个整体，表现生活中的事物\n* 将属性和行为加以权限控制\n\n\n\n**封装意义一：**\n\n\t在设计类的时候，属性和行为写在一起，表现事物\n\n**语法：** `class 类名{   访问权限： 属性  / 行为  };`\n\n\n\n**示例1：**设计一个圆类，求圆的周长\n\n**示例代码：**\n\n```C++\n//圆周率\nconst double PI = 3.14;\n\n//1、封装的意义\n//将属性和行为作为一个整体，用来表现生活中的事物\n\n//封装一个圆类，求圆的周长\n//class代表设计一个类，后面跟着的是类名\nclass Circle\n{\npublic:  //访问权限  公共的权限\n\n\t//属性\n\tint m_r;//半径\n\n\t//行为\n\t//获取到圆的周长\n\tdouble calculateZC()\n\t{\n\t\t//2 * pi  * r\n\t\t//获取圆的周长\n\t\treturn  2 * PI * m_r;\n\t}\n};\n\nint main() {\n\n\t//通过圆类，创建圆的对象\n\t// c1就是一个具体的圆\n\tCircle c1;\n\tc1.m_r = 10; //给圆对象的半径 进行赋值操作\n\n\t//2 * pi * 10 = = 62.8\n\tcout << \"圆的周长为： \" << c1.calculateZC() << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n**示例2：**设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号\n\n\n\n\n\n**示例2代码：**\n\n```C++\n//学生类\nclass Student {\npublic:\n\tvoid setName(string name) {\n\t\tm_name = name;\n\t}\n\tvoid setID(int id) {\n\t\tm_id = id;\n\t}\n\n\tvoid showStudent() {\n\t\tcout << \"name:\" << m_name << \" ID:\" << m_id << endl;\n\t}\npublic:\n\tstring m_name;\n\tint m_id;\n};\n\nint main() {\n\n\tStudent stu;\n\tstu.setName(\"德玛西亚\");\n\tstu.setID(250);\n\tstu.showStudent();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n\n```\n\n\n\n\n\n\n\n\n\n**封装意义二：**\n\n类在设计时，可以把属性和行为放在不同的权限下，加以控制\n\n访问权限有三种：\n\n\n\n1. public        公共权限  \n2. protected 保护权限\n3. private      私有权限\n\n\n\n\n\n\n\n**示例：**\n\n```C++\n//三种权限\n//公共权限  public     类内可以访问  类外可以访问\n//保护权限  protected  类内可以访问  类外不可以访问\n//私有权限  private    类内可以访问  类外不可以访问\n\nclass Person\n{\n\t//姓名  公共权限\npublic:\n\tstring m_Name;\n\n\t//汽车  保护权限\nprotected:\n\tstring m_Car;\n\n\t//银行卡密码  私有权限\nprivate:\n\tint m_Password;\n\npublic:\n\tvoid func()\n\t{\n\t\tm_Name = \"张三\";\n\t\tm_Car = \"拖拉机\";\n\t\tm_Password = 123456;\n\t}\n};\n\nint main() {\n\n\tPerson p;\n\tp.m_Name = \"李四\";\n\t//p.m_Car = \"奔驰\";  //保护权限类外访问不到\n\t//p.m_Password = 123; //私有权限类外访问不到\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n#### 4.1.2 struct和class区别\n\n\n\n在C++中 struct和class唯一的**区别**就在于 **默认的访问权限不同**\n\n区别：\n\n* struct 默认权限为公共\n* class   默认权限为私有\n\n\n\n```C++\nclass C1\n{\n\tint  m_A; //默认是私有权限\n};\n\nstruct C2\n{\n\tint m_A;  //默认是公共权限\n};\n\nint main() {\n\n\tC1 c1;\n\tc1.m_A = 10; //错误，访问权限是私有\n\n\tC2 c2;\n\tc2.m_A = 10; //正确，访问权限是公共\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.1.3 成员属性设置为私有\n\n\n\n**优点1：**将所有成员属性设置为私有，可以自己控制读写权限\n\n**优点2：**对于写权限，我们可以检测数据的有效性\n\n\n\n**示例：**\n\n```C++\nclass Person {\npublic:\n\n\t//姓名设置可读可写\n\tvoid setName(string name) {\n\t\tm_Name = name;\n\t}\n\tstring getName()\n\t{\n\t\treturn m_Name;\n\t}\n\n\n\t//获取年龄 \n\tint getAge() {\n\t\treturn m_Age;\n\t}\n\t//设置年龄\n\tvoid setAge(int age) {\n\t\tif (age < 0 || age > 150) {\n\t\t\tcout << \"你个老妖精!\" << endl;\n\t\t\treturn;\n\t\t}\n\t\tm_Age = age;\n\t}\n\n\t//情人设置为只写\n\tvoid setLover(string lover) {\n\t\tm_Lover = lover;\n\t}\n\nprivate:\n\tstring m_Name; //可读可写  姓名\n\t\n\tint m_Age; //只读  年龄\n\n\tstring m_Lover; //只写  情人\n};\n\n\nint main() {\n\n\tPerson p;\n\t//姓名设置\n\tp.setName(\"张三\");\n\tcout << \"姓名： \" << p.getName() << endl;\n\n\t//年龄设置\n\tp.setAge(50);\n\tcout << \"年龄： \" << p.getAge() << endl;\n\n\t//情人设置\n\tp.setLover(\"苍井\");\n\t//cout << \"情人： \" << p.m_Lover << endl;  //只写属性，不可以读取\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n**练习案例1：设计立方体类**\n\n设计立方体类(Cube)\n\n求出立方体的面积和体积\n\n分别用全局函数和成员函数判断两个立方体是否相等。\n\n\n\n![1545533548532](assets/1545533548532.png)\n\n\n\n\n\n\n\n\n\n\n\n**练习案例2：点和圆的关系**\n\n设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。\n\n\n\n![1545533829184](assets/1545533829184.png)\n\n\n\n\n\n\n\n### 4.2 对象的初始化和清理\n\n\n\n*  生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全\n*  C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。\n\n\n\n\n\n#### 4.2.1 构造函数和析构函数\n\n对象的**初始化和清理**也是两个非常重要的安全问题\n\n\t一个对象或者变量没有初始状态，对其使用后果是未知\n\t\n\t同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题\n\n\n\nc++利用了**构造函数**和**析构函数**解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。\n\n对象的初始化和清理工作是编译器强制要我们做的事情，因此如果**我们不提供构造和析构，编译器会提供**\n\n**编译器提供的构造函数和析构函数是空实现。**\n\n\n\n* 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。\n* 析构函数：主要作用在于对象**销毁前**系统自动调用，执行一些清理工作。\n\n\n\n\n\n**构造函数语法：**`类名(){}`\n\n1. 构造函数，没有返回值也不写void\n2. 函数名称与类名相同\n3. 构造函数可以有参数，因此可以发生重载\n4. 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次\n\n\n\n\n\n**析构函数语法：** `~类名(){}`\n\n1. 析构函数，没有返回值也不写void\n2. 函数名称与类名相同,在名称前加上符号  ~\n3. 析构函数不可以有参数，因此不可以发生重载\n4. 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次\n\n\n\n\n\n```C++\nclass Person\n{\npublic:\n\t//构造函数\n\tPerson()\n\t{\n\t\tcout << \"Person的构造函数调用\" << endl;\n\t}\n\t//析构函数\n\t~Person()\n\t{\n\t\tcout << \"Person的析构函数调用\" << endl;\n\t}\n\n};\n\nvoid test01()\n{\n\tPerson p;\n}\n\nint main() {\n\t\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n#### 4.2.2 构造函数的分类及调用\n\n两种分类方式：\n\n\t按参数分为： 有参构造和无参构造\n\t\n\t按类型分为： 普通构造和拷贝构造\n\n三种调用方式：\n\n\t括号法\n\t\n\t显示法\n\t\n\t隐式转换法\n\n\n\n**示例：**\n\n```C++\n//1、构造函数分类\n// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数\n// 按照类型分类分为 普通构造和拷贝构造\n\nclass Person {\npublic:\n\t//无参（默认）构造函数\n\tPerson() {\n\t\tcout << \"无参构造函数!\" << endl;\n\t}\n\t//有参构造函数\n\tPerson(int a) {\n\t\tage = a;\n\t\tcout << \"有参构造函数!\" << endl;\n\t}\n\t//拷贝构造函数\n\tPerson(const Person& p) {\n\t\tage = p.age;\n\t\tcout << \"拷贝构造函数!\" << endl;\n\t}\n\t//析构函数\n\t~Person() {\n\t\tcout << \"析构函数!\" << endl;\n\t}\npublic:\n\tint age;\n};\n\n//2、构造函数的调用\n//调用无参构造函数\nvoid test01() {\n\tPerson p; //调用无参构造函数\n}\n\n//调用有参的构造函数\nvoid test02() {\n\n\t//2.1  括号法，常用\n\tPerson p1(10);\n\t//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明\n\t//Person p2();\n\n\t//2.2 显式法\n\tPerson p2 = Person(10); \n\tPerson p3 = Person(p2);\n\t//Person(10)单独写就是匿名对象  当前行结束之后，马上析构\n\n\t//2.3 隐式转换法\n\tPerson p4 = 10; // Person p4 = Person(10); \n\tPerson p5 = p4; // Person p5 = Person(p4); \n\n\t//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明\n\t//Person p5(p4);\n}\n\nint main() {\n\n\ttest01();\n\t//test02();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n#### 4.2.3 拷贝构造函数调用时机\n\n\n\nC++中拷贝构造函数调用时机通常有三种情况\n\n* 使用一个已经创建完毕的对象来初始化一个新对象\n* 值传递的方式给函数参数传值\n* 以值方式返回局部对象\n\n\n\n**示例：**\n\n```C++\nclass Person {\npublic:\n\tPerson() {\n\t\tcout << \"无参构造函数!\" << endl;\n\t\tmAge = 0;\n\t}\n\tPerson(int age) {\n\t\tcout << \"有参构造函数!\" << endl;\n\t\tmAge = age;\n\t}\n\tPerson(const Person& p) {\n\t\tcout << \"拷贝构造函数!\" << endl;\n\t\tmAge = p.mAge;\n\t}\n\t//析构函数在释放内存之前调用\n\t~Person() {\n\t\tcout << \"析构函数!\" << endl;\n\t}\npublic:\n\tint mAge;\n};\n\n//1. 使用一个已经创建完毕的对象来初始化一个新对象\nvoid test01() {\n\n\tPerson man(100); //p对象已经创建完毕\n\tPerson newman(man); //调用拷贝构造函数\n\tPerson newman2 = man; //拷贝构造\n\n\t//Person newman3;\n\t//newman3 = man; //不是调用拷贝构造函数，赋值操作\n}\n\n//2. 值传递的方式给函数参数传值\n//相当于Person p1 = p;\nvoid doWork(Person p1) {}\nvoid test02() {\n\tPerson p; //无参构造函数\n\tdoWork(p);\n}\n\n//3. 以值方式返回局部对象\nPerson doWork2()\n{\n\tPerson p1;\n\tcout << (int *)&p1 << endl;\n\treturn p1;\n}\n\nvoid test03()\n{\n\tPerson p = doWork2();\n\tcout << (int *)&p << endl;\n}\n\n\nint main() {\n\n\t//test01();\n\t//test02();\n\ttest03();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n#### 4.2.4 构造函数调用规则\n\n默认情况下，c++编译器至少给一个类添加3个函数\n\n1．默认构造函数(无参，函数体为空)\n\n2．默认析构函数(无参，函数体为空)\n\n3．默认拷贝构造函数，对属性进行值拷贝\n\n\n\n构造函数调用规则如下：\n\n* 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造\n\n\n* 如果用户定义拷贝构造函数，c++不会再提供其他构造函数\n\n\n\n示例：\n\n```C++\nclass Person {\npublic:\n\t//无参（默认）构造函数\n\tPerson() {\n\t\tcout << \"无参构造函数!\" << endl;\n\t}\n\t//有参构造函数\n\tPerson(int a) {\n\t\tage = a;\n\t\tcout << \"有参构造函数!\" << endl;\n\t}\n\t//拷贝构造函数\n\tPerson(const Person& p) {\n\t\tage = p.age;\n\t\tcout << \"拷贝构造函数!\" << endl;\n\t}\n\t//析构函数\n\t~Person() {\n\t\tcout << \"析构函数!\" << endl;\n\t}\npublic:\n\tint age;\n};\n\nvoid test01()\n{\n\tPerson p1(18);\n\t//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作\n\tPerson p2(p1);\n\n\tcout << \"p2的年龄为： \" << p2.age << endl;\n}\n\nvoid test02()\n{\n\t//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造\n\tPerson p1; //此时如果用户自己没有提供默认构造，会出错\n\tPerson p2(10); //用户提供的有参\n\tPerson p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供\n\n\t//如果用户提供拷贝构造，编译器不会提供其他构造函数\n\tPerson p4; //此时如果用户自己没有提供默认构造，会出错\n\tPerson p5(10); //此时如果用户自己没有提供有参，会出错\n\tPerson p6(p5); //用户自己提供拷贝构造\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n#### 4.2.5 深拷贝与浅拷贝\n\n\n\n深浅拷贝是面试经典问题，也是常见的一个坑\n\n\n\n浅拷贝：简单的赋值拷贝操作\n\n\n\n深拷贝：在堆区重新申请空间，进行拷贝操作\n\n\n\n**示例：**\n\n```C++\nclass Person {\npublic:\n\t//无参（默认）构造函数\n\tPerson() {\n\t\tcout << \"无参构造函数!\" << endl;\n\t}\n\t//有参构造函数\n\tPerson(int age ,int height) {\n\t\t\n\t\tcout << \"有参构造函数!\" << endl;\n\n\t\tm_age = age;\n\t\tm_height = new int(height);\n\t\t\n\t}\n\t//拷贝构造函数  \n\tPerson(const Person& p) {\n\t\tcout << \"拷贝构造函数!\" << endl;\n\t\t//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题\n\t\tm_age = p.m_age;\n\t\tm_height = new int(*p.m_height);\n\t\t\n\t}\n\n\t//析构函数\n\t~Person() {\n\t\tcout << \"析构函数!\" << endl;\n\t\tif (m_height != NULL)\n\t\t{\n\t\t\tdelete m_height;\n\t\t}\n\t}\npublic:\n\tint m_age;\n\tint* m_height;\n};\n\nvoid test01()\n{\n\tPerson p1(18, 180);\n\n\tPerson p2(p1);\n\n\tcout << \"p1的年龄： \" << p1.m_age << \" 身高： \" << *p1.m_height << endl;\n\n\tcout << \"p2的年龄： \" << p2.m_age << \" 身高： \" << *p2.m_height << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n> 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题\n\n\n\n\n\n\n\n\n\n#### 4.2.6 初始化列表\n\n\n\n**作用：**\n\nC++提供了初始化列表语法，用来初始化属性\n\n\n\n**语法：**`构造函数()：属性1(值1),属性2（值2）... {}`\n\n\n\n**示例：**\n\n```C++\nclass Person {\npublic:\n\n\t////传统方式初始化\n\t//Person(int a, int b, int c) {\n\t//\tm_A = a;\n\t//\tm_B = b;\n\t//\tm_C = c;\n\t//}\n\n\t//初始化列表方式初始化\n\tPerson(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}\n\tvoid PrintPerson() {\n\t\tcout << \"mA:\" << m_A << endl;\n\t\tcout << \"mB:\" << m_B << endl;\n\t\tcout << \"mC:\" << m_C << endl;\n\t}\nprivate:\n\tint m_A;\n\tint m_B;\n\tint m_C;\n};\n\nint main() {\n\n\tPerson p(1, 2, 3);\n\tp.PrintPerson();\n\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n#### 4.2.7 类对象作为类成员\n\n\n\nC++类中的成员可以是另一个类的对象，我们称该成员为 对象成员\n\n\n\n例如：\n\n```C++\nclass A {}\nclass B\n{\n    A a；\n}\n```\n\n\n\nB类中有对象A作为成员，A为对象成员\n\n\n\n那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？\n\n\n\n**示例：**\n\n```C++\nclass Phone\n{\npublic:\n\tPhone(string name)\n\t{\n\t\tm_PhoneName = name;\n\t\tcout << \"Phone构造\" << endl;\n\t}\n\n\t~Phone()\n\t{\n\t\tcout << \"Phone析构\" << endl;\n\t}\n\n\tstring m_PhoneName;\n\n};\n\n\nclass Person\n{\npublic:\n\n\t//初始化列表可以告诉编译器调用哪一个构造函数\n\tPerson(string name, string pName) :m_Name(name), m_Phone(pName)\n\t{\n\t\tcout << \"Person构造\" << endl;\n\t}\n\n\t~Person()\n\t{\n\t\tcout << \"Person析构\" << endl;\n\t}\n\n\tvoid playGame()\n\t{\n\t\tcout << m_Name << \" 使用\" << m_Phone.m_PhoneName << \" 牌手机! \" << endl;\n\t}\n\n\tstring m_Name;\n\tPhone m_Phone;\n\n};\nvoid test01()\n{\n\t//当类中成员是其他类对象时，我们称该成员为 对象成员\n\t//构造的顺序是 ：先调用对象成员的构造，再调用本类构造\n\t//析构顺序与构造相反\n\tPerson p(\"张三\" , \"苹果X\");\n\tp.playGame();\n\n}\n\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n#### 4.2.8 静态成员\n\n静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员\n\n静态成员分为：\n\n\n\n*  静态成员变量\n   *  所有对象共享同一份数据\n   *  在编译阶段分配内存\n   *  类内声明，类外初始化\n*  静态成员函数\n   *  所有对象共享同一个函数\n   *  静态成员函数只能访问静态成员变量\n\n\n\n\n\n\n\n**示例1 ：**静态成员变量\n\n```C++\nclass Person\n{\n\t\npublic:\n\n\tstatic int m_A; //静态成员变量\n\n\t//静态成员变量特点：\n\t//1 在编译阶段分配内存\n\t//2 类内声明，类外初始化\n\t//3 所有对象共享同一份数据\n\nprivate:\n\tstatic int m_B; //静态成员变量也是有访问权限的\n};\nint Person::m_A = 10;\nint Person::m_B = 10;\n\nvoid test01()\n{\n\t//静态成员变量两种访问方式\n\n\t//1、通过对象\n\tPerson p1;\n\tp1.m_A = 100;\n\tcout << \"p1.m_A = \" << p1.m_A << endl;\n\n\tPerson p2;\n\tp2.m_A = 200;\n\tcout << \"p1.m_A = \" << p1.m_A << endl; //共享同一份数据\n\tcout << \"p2.m_A = \" << p2.m_A << endl;\n\n\t//2、通过类名\n\tcout << \"m_A = \" << Person::m_A << endl;\n\n\n\t//cout << \"m_B = \" << Person::m_B << endl; //私有权限访问不到\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n**示例2：**静态成员函数\n\n```C++\nclass Person\n{\n\npublic:\n\n\t//静态成员函数特点：\n\t//1 程序共享一个函数\n\t//2 静态成员函数只能访问静态成员变量\n\t\n\tstatic void func()\n\t{\n\t\tcout << \"func调用\" << endl;\n\t\tm_A = 100;\n\t\t//m_B = 100; //错误，不可以访问非静态成员变量\n\t}\n\n\tstatic int m_A; //静态成员变量\n\tint m_B; // \nprivate:\n\n\t//静态成员函数也是有访问权限的\n\tstatic void func2()\n\t{\n\t\tcout << \"func2调用\" << endl;\n\t}\n};\nint Person::m_A = 10;\n\n\nvoid test01()\n{\n\t//静态成员变量两种访问方式\n\n\t//1、通过对象\n\tPerson p1;\n\tp1.func();\n\n\t//2、通过类名\n\tPerson::func();\n\n\n\t//Person::func2(); //私有权限访问不到\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n### 4.3 C++对象模型和this指针\n\n\n\n#### 4.3.1 成员变量和成员函数分开存储\n\n\n\n在C++中，类内的成员变量和成员函数分开存储\n\n只有非静态成员变量才属于类的对象上\n\n\n\n```C++\nclass Person {\npublic:\n\tPerson() {\n\t\tmA = 0;\n\t}\n\t//非静态成员变量占对象空间\n\tint mA;\n\t//静态成员变量不占对象空间\n\tstatic int mB; \n\t//函数也不占对象空间，所有函数共享一个函数实例\n\tvoid func() {\n\t\tcout << \"mA:\" << this->mA << endl;\n\t}\n\t//静态成员函数也不占对象空间\n\tstatic void sfunc() {\n\t}\n};\n\nint main() {\n\n\tcout << sizeof(Person) << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n#### 4.3.2 this指针概念\n\n通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的\n\n每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码\n\n那么问题是：这一块代码是如何区分那个对象调用自己的呢？\n\n\n\nc++通过提供特殊的对象指针，this指针，解决上述问题。**this指针指向被调用的成员函数所属的对象**\n\n\n\nthis指针是隐含每一个非静态成员函数内的一种指针\n\nthis指针不需要定义，直接使用即可\n\n\n\nthis指针的用途：\n\n*  当形参和成员变量同名时，可用this指针来区分\n*  在类的非静态成员函数中返回对象本身，可使用return *this\n\n```C++\nclass Person\n{\npublic:\n\n\tPerson(int age)\n\t{\n\t\t//1、当形参和成员变量同名时，可用this指针来区分\n\t\tthis->age = age;\n\t}\n\n\tPerson& PersonAddPerson(Person p)\n\t{\n\t\tthis->age += p.age;\n\t\t//返回对象本身\n\t\treturn *this;\n\t}\n\n\tint age;\n};\n\nvoid test01()\n{\n\tPerson p1(10);\n\tcout << \"p1.age = \" << p1.age << endl;\n\n\tPerson p2(10);\n\tp2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);\n\tcout << \"p2.age = \" << p2.age << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n#### 4.3.3 空指针访问成员函数\n\n\n\nC++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针\n\n\n\n如果用到this指针，需要加以判断保证代码的健壮性\n\n\n\n**示例：**\n\n```C++\n//空指针访问成员函数\nclass Person {\npublic:\n\n\tvoid ShowClassName() {\n\t\tcout << \"我是Person类!\" << endl;\n\t}\n\n\tvoid ShowPerson() {\n\t\tif (this == NULL) {\n\t\t\treturn;\n\t\t}\n\t\tcout << mAge << endl;\n\t}\n\npublic:\n\tint mAge;\n};\n\nvoid test01()\n{\n\tPerson * p = NULL;\n\tp->ShowClassName(); //空指针，可以调用成员函数\n\tp->ShowPerson();  //但是如果成员函数中用到了this指针，就不可以了\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n#### 4.3.4 const修饰成员函数\n\n\n\n**常函数：**\n\n* 成员函数后加const后我们称为这个函数为**常函数**\n* 常函数内不可以修改成员属性\n* 成员属性声明时加关键字mutable后，在常函数中依然可以修改\n\n\n\n**常对象：**\n\n* 声明对象前加const称该对象为常对象\n* 常对象只能调用常函数\n\n\n\n\n\n\n\n**示例：**\n\n```C++\nclass Person {\npublic:\n\tPerson() {\n\t\tm_A = 0;\n\t\tm_B = 0;\n\t}\n\n\t//this指针的本质是一个指针常量，指针的指向不可修改\n\t//如果想让指针指向的值也不可以修改，需要声明常函数\n\tvoid ShowPerson() const {\n\t\t//const Type* const pointer;\n\t\t//this = NULL; //不能修改指针的指向 Person* const this;\n\t\t//this->mA = 100; //但是this指针指向的对象的数据是可以修改的\n\n\t\t//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量\n\t\tthis->m_B = 100;\n\t}\n\n\tvoid MyFunc() const {\n\t\t//mA = 10000;\n\t}\n\npublic:\n\tint m_A;\n\tmutable int m_B; //可修改 可变的\n};\n\n\n//const修饰对象  常对象\nvoid test01() {\n\n\tconst Person person; //常量对象  \n\tcout << person.m_A << endl;\n\t//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问\n\tperson.m_B = 100; //但是常对象可以修改mutable修饰成员变量\n\n\t//常对象访问成员函数\n\tperson.MyFunc(); //常对象不能调用const的函数\n\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n### 4.4 友元\n\n\n\n生活中你的家有客厅(Public)，有你的卧室(Private)\n\n客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去\n\n但是呢，你也可以允许你的好闺蜜好基友进去。\n\n\n\n在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术\n\n\n\n友元的目的就是让一个函数或者类 访问另一个类中私有成员\n\n\n\n友元的关键字为  ==friend==\n\n\n\n友元的三种实现\n\n* 全局函数做友元\n* 类做友元\n* 成员函数做友元\n\n\n\n\n\n#### 4.4.1 全局函数做友元\n\n```C++\nclass Building\n{\n\t//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容\n\tfriend void goodGay(Building * building);\n\npublic:\n\n\tBuilding()\n\t{\n\t\tthis->m_SittingRoom = \"客厅\";\n\t\tthis->m_BedRoom = \"卧室\";\n\t}\n\n\npublic:\n\tstring m_SittingRoom; //客厅\n\nprivate:\n\tstring m_BedRoom; //卧室\n};\n\n\nvoid goodGay(Building * building)\n{\n\tcout << \"好基友正在访问： \" << building->m_SittingRoom << endl;\n\tcout << \"好基友正在访问： \" << building->m_BedRoom << endl;\n}\n\n\nvoid test01()\n{\n\tBuilding b;\n\tgoodGay(&b);\n}\n\nint main(){\n\n\ttest01();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n\n#### 4.4.2 类做友元\n\n\n\n```C++\nclass Building;\nclass goodGay\n{\npublic:\n\n\tgoodGay();\n\tvoid visit();\n\nprivate:\n\tBuilding *building;\n};\n\n\nclass Building\n{\n\t//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容\n\tfriend class goodGay;\n\npublic:\n\tBuilding();\n\npublic:\n\tstring m_SittingRoom; //客厅\nprivate:\n\tstring m_BedRoom;//卧室\n};\n\nBuilding::Building()\n{\n\tthis->m_SittingRoom = \"客厅\";\n\tthis->m_BedRoom = \"卧室\";\n}\n\ngoodGay::goodGay()\n{\n\tbuilding = new Building;\n}\n\nvoid goodGay::visit()\n{\n\tcout << \"好基友正在访问\" << building->m_SittingRoom << endl;\n\tcout << \"好基友正在访问\" << building->m_BedRoom << endl;\n}\n\nvoid test01()\n{\n\tgoodGay gg;\n\tgg.visit();\n\n}\n\nint main(){\n\n\ttest01();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n\n\n\n#### 4.4.3 成员函数做友元\n\n\n\n```C++\nclass Building;\nclass goodGay\n{\npublic:\n\n\tgoodGay();\n\tvoid visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容\n\tvoid visit2(); \n\nprivate:\n\tBuilding *building;\n};\n\n\nclass Building\n{\n\t//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容\n\tfriend void goodGay::visit();\n\npublic:\n\tBuilding();\n\npublic:\n\tstring m_SittingRoom; //客厅\nprivate:\n\tstring m_BedRoom;//卧室\n};\n\nBuilding::Building()\n{\n\tthis->m_SittingRoom = \"客厅\";\n\tthis->m_BedRoom = \"卧室\";\n}\n\ngoodGay::goodGay()\n{\n\tbuilding = new Building;\n}\n\nvoid goodGay::visit()\n{\n\tcout << \"好基友正在访问\" << building->m_SittingRoom << endl;\n\tcout << \"好基友正在访问\" << building->m_BedRoom << endl;\n}\n\nvoid goodGay::visit2()\n{\n\tcout << \"好基友正在访问\" << building->m_SittingRoom << endl;\n\t//cout << \"好基友正在访问\" << building->m_BedRoom << endl;\n}\n\nvoid test01()\n{\n\tgoodGay  gg;\n\tgg.visit();\n\n}\n\nint main(){\n    \n\ttest01();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n### 4.5 运算符重载\n\n\n\n运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型\n\n\n\n#### 4.5.1 加号运算符重载\n\n\n\n作用：实现两个自定义数据类型相加的运算\n\n\n\n```C++\nclass Person {\npublic:\n\tPerson() {};\n\tPerson(int a, int b)\n\t{\n\t\tthis->m_A = a;\n\t\tthis->m_B = b;\n\t}\n\t//成员函数实现 + 号运算符重载\n\tPerson operator+(const Person& p) {\n\t\tPerson temp;\n\t\ttemp.m_A = this->m_A + p.m_A;\n\t\ttemp.m_B = this->m_B + p.m_B;\n\t\treturn temp;\n\t}\n\n\npublic:\n\tint m_A;\n\tint m_B;\n};\n\n//全局函数实现 + 号运算符重载\n//Person operator+(const Person& p1, const Person& p2) {\n//\tPerson temp(0, 0);\n//\ttemp.m_A = p1.m_A + p2.m_A;\n//\ttemp.m_B = p1.m_B + p2.m_B;\n//\treturn temp;\n//}\n\n//运算符重载 可以发生函数重载 \nPerson operator+(const Person& p2, int val)  \n{\n\tPerson temp;\n\ttemp.m_A = p2.m_A + val;\n\ttemp.m_B = p2.m_B + val;\n\treturn temp;\n}\n\nvoid test() {\n\n\tPerson p1(10, 10);\n\tPerson p2(20, 20);\n\n\t//成员函数方式\n\tPerson p3 = p2 + p1;  //相当于 p2.operaor+(p1)\n\tcout << \"mA:\" << p3.m_A << \" mB:\" << p3.m_B << endl;\n\n\n\tPerson p4 = p3 + 10; //相当于 operator+(p3,10)\n\tcout << \"mA:\" << p4.m_A << \" mB:\" << p4.m_B << endl;\n\n}\n\nint main() {\n\n\ttest();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n> 总结1：对于内置的数据类型的表达式的的运算符是不可能改变的\n\n> 总结2：不要滥用运算符重载\n\n\n\n\n\n\n\n#### 4.5.2 左移运算符重载\n\n\n\n作用：可以输出自定义数据类型\n\n\n\n```C++\nclass Person {\n\tfriend ostream& operator<<(ostream& out, Person& p);\n\npublic:\n\n\tPerson(int a, int b)\n\t{\n\t\tthis->m_A = a;\n\t\tthis->m_B = b;\n\t}\n\n\t//成员函数 实现不了  p << cout 不是我们想要的效果\n\t//void operator<<(Person& p){\n\t//}\n\nprivate:\n\tint m_A;\n\tint m_B;\n};\n\n//全局函数实现左移重载\n//ostream对象只能有一个\nostream& operator<<(ostream& out, Person& p) {\n\tout << \"a:\" << p.m_A << \" b:\" << p.m_B;\n\treturn out;\n}\n\nvoid test() {\n\n\tPerson p1(10, 20);\n\n\tcout << p1 << \"hello world\" << endl; //链式编程\n}\n\nint main() {\n\n\ttest();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n> 总结：重载左移运算符配合友元可以实现输出自定义数据类型\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.5.3 递增运算符重载\n\n\n\n作用： 通过重载递增运算符，实现自己的整型数据\n\n\n\n```C++\nclass MyInteger {\n\n\tfriend ostream& operator<<(ostream& out, MyInteger myint);\n\npublic:\n\tMyInteger() {\n\t\tm_Num = 0;\n\t}\n\t//前置++\n\tMyInteger& operator++() {\n\t\t//先++\n\t\tm_Num++;\n\t\t//再返回\n\t\treturn *this;\n\t}\n\n\t//后置++\n\tMyInteger operator++(int) {\n\t\t//先返回\n\t\tMyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；\n\t\tm_Num++;\n\t\treturn temp;\n\t}\n\nprivate:\n\tint m_Num;\n};\n\n\nostream& operator<<(ostream& out, MyInteger myint) {\n\tout << myint.m_Num;\n\treturn out;\n}\n\n\n//前置++ 先++ 再返回\nvoid test01() {\n\tMyInteger myInt;\n\tcout << ++myInt << endl;\n\tcout << myInt << endl;\n}\n\n//后置++ 先返回 再++\nvoid test02() {\n\n\tMyInteger myInt;\n\tcout << myInt++ << endl;\n\tcout << myInt << endl;\n}\n\nint main() {\n\n\ttest01();\n\t//test02();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n> 总结： 前置递增返回引用，后置递增返回值\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.5.4 赋值运算符重载\n\n\n\nc++编译器至少给一个类添加4个函数\n\n1. 默认构造函数(无参，函数体为空)\n2. 默认析构函数(无参，函数体为空)\n3. 默认拷贝构造函数，对属性进行值拷贝\n4. 赋值运算符 operator=, 对属性进行值拷贝\n\n\n\n\n\n如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题\n\n\n\n\n\n**示例：**\n\n```C++\nclass Person\n{\npublic:\n\n\tPerson(int age)\n\t{\n\t\t//将年龄数据开辟到堆区\n\t\tm_Age = new int(age);\n\t}\n\n\t//重载赋值运算符 \n\tPerson& operator=(Person &p)\n\t{\n\t\tif (m_Age != NULL)\n\t\t{\n\t\t\tdelete m_Age;\n\t\t\tm_Age = NULL;\n\t\t}\n\t\t//编译器提供的代码是浅拷贝\n\t\t//m_Age = p.m_Age;\n\n\t\t//提供深拷贝 解决浅拷贝的问题\n\t\tm_Age = new int(*p.m_Age);\n\n\t\t//返回自身\n\t\treturn *this;\n\t}\n\n\n\t~Person()\n\t{\n\t\tif (m_Age != NULL)\n\t\t{\n\t\t\tdelete m_Age;\n\t\t\tm_Age = NULL;\n\t\t}\n\t}\n\n\t//年龄的指针\n\tint *m_Age;\n\n};\n\n\nvoid test01()\n{\n\tPerson p1(18);\n\n\tPerson p2(20);\n\n\tPerson p3(30);\n\n\tp3 = p2 = p1; //赋值操作\n\n\tcout << \"p1的年龄为：\" << *p1.m_Age << endl;\n\n\tcout << \"p2的年龄为：\" << *p2.m_Age << endl;\n\n\tcout << \"p3的年龄为：\" << *p3.m_Age << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\t//int a = 10;\n\t//int b = 20;\n\t//int c = 30;\n\n\t//c = b = a;\n\t//cout << \"a = \" << a << endl;\n\t//cout << \"b = \" << b << endl;\n\t//cout << \"c = \" << c << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n#### 4.5.5 关系运算符重载\n\n\n\n**作用：**重载关系运算符，可以让两个自定义类型对象进行对比操作\n\n\n\n**示例：**\n\n```C++\nclass Person\n{\npublic:\n\tPerson(string name, int age)\n\t{\n\t\tthis->m_Name = name;\n\t\tthis->m_Age = age;\n\t};\n\n\tbool operator==(Person & p)\n\t{\n\t\tif (this->m_Name == p.m_Name && this->m_Age == p.m_Age)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tbool operator!=(Person & p)\n\t{\n\t\tif (this->m_Name == p.m_Name && this->m_Age == p.m_Age)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstring m_Name;\n\tint m_Age;\n};\n\nvoid test01()\n{\n\t//int a = 0;\n\t//int b = 0;\n\n\tPerson a(\"孙悟空\", 18);\n\tPerson b(\"孙悟空\", 18);\n\n\tif (a == b)\n\t{\n\t\tcout << \"a和b相等\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"a和b不相等\" << endl;\n\t}\n\n\tif (a != b)\n\t{\n\t\tcout << \"a和b不相等\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"a和b相等\" << endl;\n\t}\n}\n\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n#### 4.5.6 函数调用运算符重载\n\n\n\n* 函数调用运算符 ()  也可以重载\n* 由于重载后使用的方式非常像函数的调用，因此称为仿函数\n* 仿函数没有固定写法，非常灵活\n\n\n\n**示例：**\n\n```C++\nclass MyPrint\n{\npublic:\n\tvoid operator()(string text)\n\t{\n\t\tcout << text << endl;\n\t}\n\n};\nvoid test01()\n{\n\t//重载的（）操作符 也称为仿函数\n\tMyPrint myFunc;\n\tmyFunc(\"hello world\");\n}\n\n\nclass MyAdd\n{\npublic:\n\tint operator()(int v1, int v2)\n\t{\n\t\treturn v1 + v2;\n\t}\n};\n\nvoid test02()\n{\n\tMyAdd add;\n\tint ret = add(10, 10);\n\tcout << \"ret = \" << ret << endl;\n\n\t//匿名对象调用  \n\tcout << \"MyAdd()(100,100) = \" << MyAdd()(100, 100) << endl;\n}\n\nint main() {\n\n\ttest01();\n\ttest02();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n### 4.6  继承\n\n**继承是面向对象三大特性之一**\n\n有些类与类之间存在特殊的关系，例如下图中：\n\n![1544861202252](assets/1544861202252.png)\n\n我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。\n\n这个时候我们就可以考虑利用继承的技术，减少重复代码\n\n\n\n#### 4.6.1 继承的基本语法\n\n\n\n例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同\n\n接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处\n\n\n\n**普通实现：**\n\n```C++\n//Java页面\nclass Java \n{\npublic:\n\tvoid header()\n\t{\n\t\tcout << \"首页、公开课、登录、注册...（公共头部）\" << endl;\n\t}\n\tvoid footer()\n\t{\n\t\tcout << \"帮助中心、交流合作、站内地图...(公共底部)\" << endl;\n\t}\n\tvoid left()\n\t{\n\t\tcout << \"Java,Python,C++...(公共分类列表)\" << endl;\n\t}\n\tvoid content()\n\t{\n\t\tcout << \"JAVA学科视频\" << endl;\n\t}\n};\n//Python页面\nclass Python\n{\npublic:\n\tvoid header()\n\t{\n\t\tcout << \"首页、公开课、登录、注册...（公共头部）\" << endl;\n\t}\n\tvoid footer()\n\t{\n\t\tcout << \"帮助中心、交流合作、站内地图...(公共底部)\" << endl;\n\t}\n\tvoid left()\n\t{\n\t\tcout << \"Java,Python,C++...(公共分类列表)\" << endl;\n\t}\n\tvoid content()\n\t{\n\t\tcout << \"Python学科视频\" << endl;\n\t}\n};\n//C++页面\nclass CPP \n{\npublic:\n\tvoid header()\n\t{\n\t\tcout << \"首页、公开课、登录、注册...（公共头部）\" << endl;\n\t}\n\tvoid footer()\n\t{\n\t\tcout << \"帮助中心、交流合作、站内地图...(公共底部)\" << endl;\n\t}\n\tvoid left()\n\t{\n\t\tcout << \"Java,Python,C++...(公共分类列表)\" << endl;\n\t}\n\tvoid content()\n\t{\n\t\tcout << \"C++学科视频\" << endl;\n\t}\n};\n\nvoid test01()\n{\n\t//Java页面\n\tcout << \"Java下载视频页面如下： \" << endl;\n\tJava ja;\n\tja.header();\n\tja.footer();\n\tja.left();\n\tja.content();\n\tcout << \"--------------------\" << endl;\n\n\t//Python页面\n\tcout << \"Python下载视频页面如下： \" << endl;\n\tPython py;\n\tpy.header();\n\tpy.footer();\n\tpy.left();\n\tpy.content();\n\tcout << \"--------------------\" << endl;\n\n\t//C++页面\n\tcout << \"C++下载视频页面如下： \" << endl;\n\tCPP cp;\n\tcp.header();\n\tcp.footer();\n\tcp.left();\n\tcp.content();\n\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n**继承实现：**\n\n```C++\n//公共页面\nclass BasePage\n{\npublic:\n\tvoid header()\n\t{\n\t\tcout << \"首页、公开课、登录、注册...（公共头部）\" << endl;\n\t}\n\n\tvoid footer()\n\t{\n\t\tcout << \"帮助中心、交流合作、站内地图...(公共底部)\" << endl;\n\t}\n\tvoid left()\n\t{\n\t\tcout << \"Java,Python,C++...(公共分类列表)\" << endl;\n\t}\n\n};\n\n//Java页面\nclass Java : public BasePage\n{\npublic:\n\tvoid content()\n\t{\n\t\tcout << \"JAVA学科视频\" << endl;\n\t}\n};\n//Python页面\nclass Python : public BasePage\n{\npublic:\n\tvoid content()\n\t{\n\t\tcout << \"Python学科视频\" << endl;\n\t}\n};\n//C++页面\nclass CPP : public BasePage\n{\npublic:\n\tvoid content()\n\t{\n\t\tcout << \"C++学科视频\" << endl;\n\t}\n};\n\nvoid test01()\n{\n\t//Java页面\n\tcout << \"Java下载视频页面如下： \" << endl;\n\tJava ja;\n\tja.header();\n\tja.footer();\n\tja.left();\n\tja.content();\n\tcout << \"--------------------\" << endl;\n\n\t//Python页面\n\tcout << \"Python下载视频页面如下： \" << endl;\n\tPython py;\n\tpy.header();\n\tpy.footer();\n\tpy.left();\n\tpy.content();\n\tcout << \"--------------------\" << endl;\n\n\t//C++页面\n\tcout << \"C++下载视频页面如下： \" << endl;\n\tCPP cp;\n\tcp.header();\n\tcp.footer();\n\tcp.left();\n\tcp.content();\n\n\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n**总结：**\n\n继承的好处：==可以减少重复的代码==\n\nclass A : public B; \n\nA 类称为子类 或 派生类\n\nB 类称为父类 或 基类\n\n\n\n**派生类中的成员，包含两大部分**：\n\n一类是从基类继承过来的，一类是自己增加的成员。\n\n从基类继承过过来的表现其共性，而新增的成员体现了其个性。\n\n\n\n\n\n\n\n\n\n#### 4.6.2 继承方式\n\n\n\n继承的语法：`class 子类 : 继承方式  父类`\n\n\n\n**继承方式一共有三种：**\n\n* 公共继承\n* 保护继承\n* 私有继承\n\n\n\n\n\n![img](assets/clip_image002.png)\n\n\n\n\n\n**示例：**\n\n```C++\nclass Base1\n{\npublic: \n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C;\n};\n\n//公共继承\nclass Son1 :public Base1\n{\npublic:\n\tvoid func()\n\t{\n\t\tm_A; //可访问 public权限\n\t\tm_B; //可访问 protected权限\n\t\t//m_C; //不可访问\n\t}\n};\n\nvoid myClass()\n{\n\tSon1 s1;\n\ts1.m_A; //其他类只能访问到公共权限\n}\n\n//保护继承\nclass Base2\n{\npublic:\n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C;\n};\nclass Son2:protected Base2\n{\npublic:\n\tvoid func()\n\t{\n\t\tm_A; //可访问 protected权限\n\t\tm_B; //可访问 protected权限\n\t\t//m_C; //不可访问\n\t}\n};\nvoid myClass2()\n{\n\tSon2 s;\n\t//s.m_A; //不可访问\n}\n\n//私有继承\nclass Base3\n{\npublic:\n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C;\n};\nclass Son3:private Base3\n{\npublic:\n\tvoid func()\n\t{\n\t\tm_A; //可访问 private权限\n\t\tm_B; //可访问 private权限\n\t\t//m_C; //不可访问\n\t}\n};\nclass GrandSon3 :public Son3\n{\npublic:\n\tvoid func()\n\t{\n\t\t//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到\n\t\t//m_A;\n\t\t//m_B;\n\t\t//m_C;\n\t}\n};\n```\n\n\n\n\n\n\n\n\n\n#### 4.6.3 继承中的对象模型\n\n\n\n**问题：**从父类继承过来的成员，哪些属于子类对象中？\n\n\n\n**示例：**\n\n```C++\nclass Base\n{\npublic:\n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C; //私有成员只是被隐藏了，但是还是会继承下去\n};\n\n//公共继承\nclass Son :public Base\n{\npublic:\n\tint m_D;\n};\n\nvoid test01()\n{\n\tcout << \"sizeof Son = \" << sizeof(Son) << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n利用工具查看：\n\n\n\n![1545881904150](assets/1545881904150.png)\n\n\n\n打开工具窗口后，定位到当前CPP文件的盘符\n\n然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名\n\n\n\n效果如下图：\n\n\n\n![1545882158050](assets/1545882158050.png)\n\n\n\n> 结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.6.4 继承中构造和析构顺序\n\n\n\n子类继承父类后，当创建子类对象，也会调用父类的构造函数\n\n\n\n问题：父类和子类的构造和析构顺序是谁先谁后？\n\n\n\n**示例：**\n\n```C++\nclass Base \n{\npublic:\n\tBase()\n\t{\n\t\tcout << \"Base构造函数!\" << endl;\n\t}\n\t~Base()\n\t{\n\t\tcout << \"Base析构函数!\" << endl;\n\t}\n};\n\nclass Son : public Base\n{\npublic:\n\tSon()\n\t{\n\t\tcout << \"Son构造函数!\" << endl;\n\t}\n\t~Son()\n\t{\n\t\tcout << \"Son析构函数!\" << endl;\n\t}\n\n};\n\n\nvoid test01()\n{\n\t//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反\n\tSon s;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n> 总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反\n\n\n\n\n\n\n\n\n\n\n\n#### 4.6.5 继承同名成员处理方式\n\n\n\n问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？\n\n\n\n* 访问子类同名成员   直接访问即可\n* 访问父类同名成员   需要加作用域\n\n\n\n**示例：**\n\n```C++\nclass Base {\npublic:\n\tBase()\n\t{\n\t\tm_A = 100;\n\t}\n\n\tvoid func()\n\t{\n\t\tcout << \"Base - func()调用\" << endl;\n\t}\n\n\tvoid func(int a)\n\t{\n\t\tcout << \"Base - func(int a)调用\" << endl;\n\t}\n\npublic:\n\tint m_A;\n};\n\n\nclass Son : public Base {\npublic:\n\tSon()\n\t{\n\t\tm_A = 200;\n\t}\n\n\t//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数\n\t//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域\n\tvoid func()\n\t{\n\t\tcout << \"Son - func()调用\" << endl;\n\t}\npublic:\n\tint m_A;\n};\n\nvoid test01()\n{\n\tSon s;\n\n\tcout << \"Son下的m_A = \" << s.m_A << endl;\n\tcout << \"Base下的m_A = \" << s.Base::m_A << endl;\n\n\ts.func();\n\ts.Base::func();\n\ts.Base::func(10);\n\n}\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\treturn EXIT_SUCCESS;\n}\n```\n\n总结：\n\n1. 子类对象可以直接访问到子类中同名成员\n2. 子类对象加作用域可以访问到父类同名成员\n3. 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.6.6 继承同名静态成员处理方式\n\n\n\n问题：继承中同名的静态成员在子类对象上如何进行访问？\n\n\n\n静态成员和非静态成员出现同名，处理方式一致\n\n\n\n- 访问子类同名成员   直接访问即可\n- 访问父类同名成员   需要加作用域\n\n\n\n**示例：**\n\n```C++\nclass Base {\npublic:\n\tstatic void func()\n\t{\n\t\tcout << \"Base - static void func()\" << endl;\n\t}\n\tstatic void func(int a)\n\t{\n\t\tcout << \"Base - static void func(int a)\" << endl;\n\t}\n\n\tstatic int m_A;\n};\n\nint Base::m_A = 100;\n\nclass Son : public Base {\npublic:\n\tstatic void func()\n\t{\n\t\tcout << \"Son - static void func()\" << endl;\n\t}\n\tstatic int m_A;\n};\n\nint Son::m_A = 200;\n\n//同名成员属性\nvoid test01()\n{\n\t//通过对象访问\n\tcout << \"通过对象访问： \" << endl;\n\tSon s;\n\tcout << \"Son  下 m_A = \" << s.m_A << endl;\n\tcout << \"Base 下 m_A = \" << s.Base::m_A << endl;\n\n\t//通过类名访问\n\tcout << \"通过类名访问： \" << endl;\n\tcout << \"Son  下 m_A = \" << Son::m_A << endl;\n\tcout << \"Base 下 m_A = \" << Son::Base::m_A << endl;\n}\n\n//同名成员函数\nvoid test02()\n{\n\t//通过对象访问\n\tcout << \"通过对象访问： \" << endl;\n\tSon s;\n\ts.func();\n\ts.Base::func();\n\n\tcout << \"通过类名访问： \" << endl;\n\tSon::func();\n\tSon::Base::func();\n\t//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问\n\tSon::Base::func(100);\n}\nint main() {\n\n\t//test01();\n\ttest02();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n> 总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.6.7 多继承语法\n\n\n\nC++允许**一个类继承多个类**\n\n\n\n语法：` class 子类 ：继承方式 父类1 ， 继承方式 父类2...`\n\n\n\n多继承可能会引发父类中有同名成员出现，需要加作用域区分\n\n\n\n**C++实际开发中不建议用多继承**\n\n\n\n\n\n\n\n**示例：**\n\n```C++\nclass Base1 {\npublic:\n\tBase1()\n\t{\n\t\tm_A = 100;\n\t}\npublic:\n\tint m_A;\n};\n\nclass Base2 {\npublic:\n\tBase2()\n\t{\n\t\tm_A = 200;  //开始是m_B 不会出问题，但是改为mA就会出现不明确\n\t}\npublic:\n\tint m_A;\n};\n\n//语法：class 子类：继承方式 父类1 ，继承方式 父类2 \nclass Son : public Base2, public Base1 \n{\npublic:\n\tSon()\n\t{\n\t\tm_C = 300;\n\t\tm_D = 400;\n\t}\npublic:\n\tint m_C;\n\tint m_D;\n};\n\n\n//多继承容易产生成员同名的情况\n//通过使用类名作用域可以区分调用哪一个基类的成员\nvoid test01()\n{\n\tSon s;\n\tcout << \"sizeof Son = \" << sizeof(s) << endl;\n\tcout << s.Base1::m_A << endl;\n\tcout << s.Base2::m_A << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n> 总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域\n\n\n\n\n\n\n\n\n\n\n\n#### 4.6.8 菱形继承\n\n\n\n**菱形继承概念：**\n\n\t两个派生类继承同一个基类\n\t\n\t又有某个类同时继承者两个派生类\n\t\n\t这种继承被称为菱形继承，或者钻石继承\n\n\n\n**典型的菱形继承案例：**\n\n\n\n![IMG_256](assets/clip_image002.jpg)\n\n\n\n**菱形继承问题：**\n\n\n\n1.     羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。\n\n2.     草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。\n\n\n\n**示例：**\n\n```C++\nclass Animal\n{\npublic:\n\tint m_Age;\n};\n\n//继承前加virtual关键字后，变为虚继承\n//此时公共的父类Animal称为虚基类\nclass Sheep : virtual public Animal {};\nclass Tuo   : virtual public Animal {};\nclass SheepTuo : public Sheep, public Tuo {};\n\nvoid test01()\n{\n\tSheepTuo st;\n\tst.Sheep::m_Age = 100;\n\tst.Tuo::m_Age = 200;\n\n\tcout << \"st.Sheep::m_Age = \" << st.Sheep::m_Age << endl;\n\tcout << \"st.Tuo::m_Age = \" <<  st.Tuo::m_Age << endl;\n\tcout << \"st.m_Age = \" << st.m_Age << endl;\n}\n\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n总结：\n\n* 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义\n* 利用虚继承可以解决菱形继承问题\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 4.7  多态\n\n#### 4.7.1 多态的基本概念\n\n\n\n**多态是C++面向对象三大特性之一**\n\n多态分为两类\n\n* 静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名\n* 动态多态: 派生类和虚函数实现运行时多态\n\n\n\n静态多态和动态多态区别：\n\n* 静态多态的函数地址早绑定  -  编译阶段确定函数地址\n* 动态多态的函数地址晚绑定  -  运行阶段确定函数地址\n\n\n\n下面通过案例进行讲解多态\n\n\n\n```C++\nclass Animal\n{\npublic:\n\t//Speak函数就是虚函数\n\t//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。\n\tvirtual void speak()\n\t{\n\t\tcout << \"动物在说话\" << endl;\n\t}\n};\n\nclass Cat :public Animal\n{\npublic:\n\tvoid speak()\n\t{\n\t\tcout << \"小猫在说话\" << endl;\n\t}\n};\n\nclass Dog :public Animal\n{\npublic:\n\n\tvoid speak()\n\t{\n\t\tcout << \"小狗在说话\" << endl;\n\t}\n\n};\n//我们希望传入什么对象，那么就调用什么对象的函数\n//如果函数地址在编译阶段就能确定，那么静态联编\n//如果函数地址在运行阶段才能确定，就是动态联编\n\nvoid DoSpeak(Animal & animal)\n{\n\tanimal.speak();\n}\n//\n//多态满足条件： \n//1、有继承关系\n//2、子类重写父类中的虚函数\n//多态使用：\n//父类指针或引用指向子类对象\n\nvoid test01()\n{\n\tCat cat;\n\tDoSpeak(cat);\n\n\n\tDog dog;\n\tDoSpeak(dog);\n}\n\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n总结：\n\n多态满足条件\n\n* 有继承关系\n* 子类重写父类中的虚函数\n\n多态使用条件\n\n* 父类指针或引用指向子类对象\n\n重写：函数返回值类型  函数名 参数列表 完全一致称为重写\n\n\n\n\n\n\n\n\n\n#### 4.7.2 多态案例一-计算器类\n\n\n\n案例描述：\n\n分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类\n\n\n\n多态的优点：\n\n* 代码组织结构清晰\n* 可读性强\n* 利于前期和后期的扩展以及维护\n\n\n\n**示例：**\n\n```C++\n//普通实现\nclass Calculator {\npublic:\n\tint getResult(string oper)\n\t{\n\t\tif (oper == \"+\") {\n\t\t\treturn m_Num1 + m_Num2;\n\t\t}\n\t\telse if (oper == \"-\") {\n\t\t\treturn m_Num1 - m_Num2;\n\t\t}\n\t\telse if (oper == \"*\") {\n\t\t\treturn m_Num1 * m_Num2;\n\t\t}\n\t\t//如果要提供新的运算，需要修改源码\n\t}\npublic:\n\tint m_Num1;\n\tint m_Num2;\n};\n\nvoid test01()\n{\n\t//普通实现测试\n\tCalculator c;\n\tc.m_Num1 = 10;\n\tc.m_Num2 = 10;\n\tcout << c.m_Num1 << \" + \" << c.m_Num2 << \" = \" << c.getResult(\"+\") << endl;\n\n\tcout << c.m_Num1 << \" - \" << c.m_Num2 << \" = \" << c.getResult(\"-\") << endl;\n\n\tcout << c.m_Num1 << \" * \" << c.m_Num2 << \" = \" << c.getResult(\"*\") << endl;\n}\n\n\n\n//多态实现\n//抽象计算器类\n//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护\nclass AbstractCalculator\n{\npublic :\n\n\tvirtual int getResult()\n\t{\n\t\treturn 0;\n\t}\n\n\tint m_Num1;\n\tint m_Num2;\n};\n\n//加法计算器\nclass AddCalculator :public AbstractCalculator\n{\npublic:\n\tint getResult()\n\t{\n\t\treturn m_Num1 + m_Num2;\n\t}\n};\n\n//减法计算器\nclass SubCalculator :public AbstractCalculator\n{\npublic:\n\tint getResult()\n\t{\n\t\treturn m_Num1 - m_Num2;\n\t}\n};\n\n//乘法计算器\nclass MulCalculator :public AbstractCalculator\n{\npublic:\n\tint getResult()\n\t{\n\t\treturn m_Num1 * m_Num2;\n\t}\n};\n\n\nvoid test02()\n{\n\t//创建加法计算器\n\tAbstractCalculator *abc = new AddCalculator;\n\tabc->m_Num1 = 10;\n\tabc->m_Num2 = 10;\n\tcout << abc->m_Num1 << \" + \" << abc->m_Num2 << \" = \" << abc->getResult() << endl;\n\tdelete abc;  //用完了记得销毁\n\n\t//创建减法计算器\n\tabc = new SubCalculator;\n\tabc->m_Num1 = 10;\n\tabc->m_Num2 = 10;\n\tcout << abc->m_Num1 << \" - \" << abc->m_Num2 << \" = \" << abc->getResult() << endl;\n\tdelete abc;  \n\n\t//创建乘法计算器\n\tabc = new MulCalculator;\n\tabc->m_Num1 = 10;\n\tabc->m_Num2 = 10;\n\tcout << abc->m_Num1 << \" * \" << abc->m_Num2 << \" = \" << abc->getResult() << endl;\n\tdelete abc;\n}\n\nint main() {\n\n\t//test01();\n\n\ttest02();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n> 总结：C++开发提倡利用多态设计程序架构，因为多态优点很多\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.7.3 纯虚函数和抽象类\n\n\n\n在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容\n\n\n\n因此可以将虚函数改为**纯虚函数**\n\n\n\n纯虚函数语法：`virtual 返回值类型 函数名 （参数列表）= 0 ;`\n\n\n\n当类中有了纯虚函数，这个类也称为==抽象类==\n\n\n\n**抽象类特点**：\n\n * 无法实例化对象\n * 子类必须重写抽象类中的纯虚函数，否则也属于抽象类\n\n\n\n\n\n**示例：**\n\n```C++\nclass Base\n{\npublic:\n\t//纯虚函数\n\t//类中只要有一个纯虚函数就称为抽象类\n\t//抽象类无法实例化对象\n\t//子类必须重写父类中的纯虚函数，否则也属于抽象类\n\tvirtual void func() = 0;\n};\n\nclass Son :public Base\n{\npublic:\n\tvirtual void func() \n\t{\n\t\tcout << \"func调用\" << endl;\n\t};\n};\n\nvoid test01()\n{\n\tBase * base = NULL;\n\t//base = new Base; // 错误，抽象类无法实例化对象\n\tbase = new Son;\n\tbase->func();\n\tdelete base;//记得销毁\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.7.4 多态案例二-制作饮品\n\n**案例描述：**\n\n制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料\n\n\n\n利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶\n\n\n\n![1545985945198](assets/1545985945198.png)\n\n\n\n**示例：**\n\n```C++\n//抽象制作饮品\nclass AbstractDrinking {\npublic:\n\t//烧水\n\tvirtual void Boil() = 0;\n\t//冲泡\n\tvirtual void Brew() = 0;\n\t//倒入杯中\n\tvirtual void PourInCup() = 0;\n\t//加入辅料\n\tvirtual void PutSomething() = 0;\n\t//规定流程\n\tvoid MakeDrink() {\n\t\tBoil();\n\t\tBrew();\n\t\tPourInCup();\n\t\tPutSomething();\n\t}\n};\n\n//制作咖啡\nclass Coffee : public AbstractDrinking {\npublic:\n\t//烧水\n\tvirtual void Boil() {\n\t\tcout << \"煮农夫山泉!\" << endl;\n\t}\n\t//冲泡\n\tvirtual void Brew() {\n\t\tcout << \"冲泡咖啡!\" << endl;\n\t}\n\t//倒入杯中\n\tvirtual void PourInCup() {\n\t\tcout << \"将咖啡倒入杯中!\" << endl;\n\t}\n\t//加入辅料\n\tvirtual void PutSomething() {\n\t\tcout << \"加入牛奶!\" << endl;\n\t}\n};\n\n//制作茶水\nclass Tea : public AbstractDrinking {\npublic:\n\t//烧水\n\tvirtual void Boil() {\n\t\tcout << \"煮自来水!\" << endl;\n\t}\n\t//冲泡\n\tvirtual void Brew() {\n\t\tcout << \"冲泡茶叶!\" << endl;\n\t}\n\t//倒入杯中\n\tvirtual void PourInCup() {\n\t\tcout << \"将茶水倒入杯中!\" << endl;\n\t}\n\t//加入辅料\n\tvirtual void PutSomething() {\n\t\tcout << \"加入枸杞!\" << endl;\n\t}\n};\n\n//业务函数\nvoid DoWork(AbstractDrinking* drink) {\n\tdrink->MakeDrink();\n\tdelete drink;\n}\n\nvoid test01() {\n\tDoWork(new Coffee);\n\tcout << \"--------------\" << endl;\n\tDoWork(new Tea);\n}\n\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.7.5 虚析构和纯虚析构\n\n\n\n多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码\n\n\n\n解决方式：将父类中的析构函数改为**虚析构**或者**纯虚析构**\n\n\n\n虚析构和纯虚析构共性：\n\n* 可以解决父类指针释放子类对象\n* 都需要有具体的函数实现\n\n虚析构和纯虚析构区别：\n\n* 如果是纯虚析构，该类属于抽象类，无法实例化对象\n\n\n\n虚析构语法：\n\n`virtual ~类名(){}`\n\n纯虚析构语法：\n\n` virtual ~类名() = 0;`\n\n`类名::~类名(){}`\n\n\n\n**示例：**\n\n```C++\nclass Animal {\npublic:\n\n\tAnimal()\n\t{\n\t\tcout << \"Animal 构造函数调用！\" << endl;\n\t}\n\tvirtual void Speak() = 0;\n\n\t//析构函数加上virtual关键字，变成虚析构函数\n\t//virtual ~Animal()\n\t//{\n\t//\tcout << \"Animal虚析构函数调用！\" << endl;\n\t//}\n\n\n\tvirtual ~Animal() = 0;\n};\n\nAnimal::~Animal()\n{\n\tcout << \"Animal 纯虚析构函数调用！\" << endl;\n}\n\n//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。\n\nclass Cat : public Animal {\npublic:\n\tCat(string name)\n\t{\n\t\tcout << \"Cat构造函数调用！\" << endl;\n\t\tm_Name = new string(name);\n\t}\n\tvirtual void Speak()\n\t{\n\t\tcout << *m_Name <<  \"小猫在说话!\" << endl;\n\t}\n\t~Cat()\n\t{\n\t\tcout << \"Cat析构函数调用!\" << endl;\n\t\tif (this->m_Name != NULL) {\n\t\t\tdelete m_Name;\n\t\t\tm_Name = NULL;\n\t\t}\n\t}\n\npublic:\n\tstring *m_Name;\n};\n\nvoid test01()\n{\n\tAnimal *animal = new Cat(\"Tom\");\n\tanimal->Speak();\n\n\t//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏\n\t//怎么解决？给基类增加一个虚析构函数\n\t//虚析构函数就是用来解决通过父类指针释放子类对象\n\tdelete animal;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n总结：\n\n\t1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象\n\t\n\t2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构\n\t\n\t3. 拥有纯虚析构函数的类也属于抽象类\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.7.6 多态案例三-电脑组装\n\n\n\n**案例描述：**\n\n\n\n电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）\n\n将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商\n\n创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口\n\n测试时组装三台不同的电脑进行工作\n\n\n\n\n\n**示例：**\n\n```C++\n#include<iostream>\nusing namespace std;\n\n//抽象CPU类\nclass CPU\n{\npublic:\n\t//抽象的计算函数\n\tvirtual void calculate() = 0;\n};\n\n//抽象显卡类\nclass VideoCard\n{\npublic:\n\t//抽象的显示函数\n\tvirtual void display() = 0;\n};\n\n//抽象内存条类\nclass Memory\n{\npublic:\n\t//抽象的存储函数\n\tvirtual void storage() = 0;\n};\n\n//电脑类\nclass Computer\n{\npublic:\n\tComputer(CPU * cpu, VideoCard * vc, Memory * mem)\n\t{\n\t\tm_cpu = cpu;\n\t\tm_vc = vc;\n\t\tm_mem = mem;\n\t}\n\n\t//提供工作的函数\n\tvoid work()\n\t{\n\t\t//让零件工作起来，调用接口\n\t\tm_cpu->calculate();\n\n\t\tm_vc->display();\n\n\t\tm_mem->storage();\n\t}\n\n\t//提供析构函数 释放3个电脑零件\n\t~Computer()\n\t{\n\n\t\t//释放CPU零件\n\t\tif (m_cpu != NULL)\n\t\t{\n\t\t\tdelete m_cpu;\n\t\t\tm_cpu = NULL;\n\t\t}\n\n\t\t//释放显卡零件\n\t\tif (m_vc != NULL)\n\t\t{\n\t\t\tdelete m_vc;\n\t\t\tm_vc = NULL;\n\t\t}\n\n\t\t//释放内存条零件\n\t\tif (m_mem != NULL)\n\t\t{\n\t\t\tdelete m_mem;\n\t\t\tm_mem = NULL;\n\t\t}\n\t}\n\nprivate:\n\n\tCPU * m_cpu; //CPU的零件指针\n\tVideoCard * m_vc; //显卡零件指针\n\tMemory * m_mem; //内存条零件指针\n};\n\n//具体厂商\n//Intel厂商\nclass IntelCPU :public CPU\n{\npublic:\n\tvirtual void calculate()\n\t{\n\t\tcout << \"Intel的CPU开始计算了！\" << endl;\n\t}\n};\n\nclass IntelVideoCard :public VideoCard\n{\npublic:\n\tvirtual void display()\n\t{\n\t\tcout << \"Intel的显卡开始显示了！\" << endl;\n\t}\n};\n\nclass IntelMemory :public Memory\n{\npublic:\n\tvirtual void storage()\n\t{\n\t\tcout << \"Intel的内存条开始存储了！\" << endl;\n\t}\n};\n\n//Lenovo厂商\nclass LenovoCPU :public CPU\n{\npublic:\n\tvirtual void calculate()\n\t{\n\t\tcout << \"Lenovo的CPU开始计算了！\" << endl;\n\t}\n};\n\nclass LenovoVideoCard :public VideoCard\n{\npublic:\n\tvirtual void display()\n\t{\n\t\tcout << \"Lenovo的显卡开始显示了！\" << endl;\n\t}\n};\n\nclass LenovoMemory :public Memory\n{\npublic:\n\tvirtual void storage()\n\t{\n\t\tcout << \"Lenovo的内存条开始存储了！\" << endl;\n\t}\n};\n\n\nvoid test01()\n{\n\t//第一台电脑零件\n\tCPU * intelCpu = new IntelCPU;\n\tVideoCard * intelCard = new IntelVideoCard;\n\tMemory * intelMem = new IntelMemory;\n\n\tcout << \"第一台电脑开始工作：\" << endl;\n\t//创建第一台电脑\n\tComputer * computer1 = new Computer(intelCpu, intelCard, intelMem);\n\tcomputer1->work();\n\tdelete computer1;\n\n\tcout << \"-----------------------\" << endl;\n\tcout << \"第二台电脑开始工作：\" << endl;\n\t//第二台电脑组装\n\tComputer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);;\n\tcomputer2->work();\n\tdelete computer2;\n\n\tcout << \"-----------------------\" << endl;\n\tcout << \"第三台电脑开始工作：\" << endl;\n\t//第三台电脑组装\n\tComputer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;\n\tcomputer3->work();\n\tdelete computer3;\n\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 5 文件操作\n\n\n\n程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放\n\n通过**文件可以将数据持久化**\n\nC++中对文件操作需要包含头文件 ==&lt; fstream &gt;==\n\n\n\n文件类型分为两种：\n\n1. **文本文件**     -  文件以文本的**ASCII码**形式存储在计算机中\n2. **二进制文件** -  文件以文本的**二进制**形式存储在计算机中，用户一般不能直接读懂它们\n\n\n\n操作文件的三大类:\n\n1. ofstream：写操作\n2. ifstream： 读操作\n3. fstream ： 读写操作\n\n\n\n### 5.1文本文件\n\n#### 5.1.1写文件\n\n   写文件步骤如下：\n\n1. 包含头文件   \n\n   \\#include <fstream\\>\n\n2. 创建流对象  \n\n   ofstream ofs;\n\n3. 打开文件\n\n   ofs.open(\"文件路径\",打开方式);\n\n4. 写数据\n\n   ofs << \"写入的数据\";\n\n5. 关闭文件\n\n   ofs.close();\n\n   \n\n文件打开方式：\n\n| 打开方式    | 解释                       |\n| ----------- | -------------------------- |\n| ios::in     | 为读文件而打开文件         |\n| ios::out    | 为写文件而打开文件         |\n| ios::ate    | 初始位置：文件尾           |\n| ios::app    | 追加方式写文件             |\n| ios::trunc  | 如果文件存在先删除，再创建 |\n| ios::binary | 二进制方式                 |\n\n**注意：** 文件打开方式可以配合使用，利用|操作符\n\n**例如：**用二进制方式写文件 `ios::binary |  ios:: out`\n\n\n\n\n\n**示例：**\n\n```C++\n#include <fstream>\n\nvoid test01()\n{\n\tofstream ofs;\n\tofs.open(\"test.txt\", ios::out);\n\n\tofs << \"姓名：张三\" << endl;\n\tofs << \"性别：男\" << endl;\n\tofs << \"年龄：18\" << endl;\n\n\tofs.close();\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n总结：\n\n* 文件操作必须包含头文件 fstream\n* 读文件可以利用 ofstream  ，或者fstream类\n* 打开文件时候需要指定操作文件的路径，以及打开方式\n* 利用<<可以向文件中写数据\n* 操作完毕，要关闭文件\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 5.1.2读文件\n\n\n\n读文件与写文件步骤相似，但是读取方式相对于比较多\n\n\n\n读文件步骤如下：\n\n1. 包含头文件   \n\n   \\#include <fstream\\>\n\n2. 创建流对象  \n\n   ifstream ifs;\n\n3. 打开文件并判断文件是否打开成功\n\n   ifs.open(\"文件路径\",打开方式);\n\n4. 读数据\n\n   四种方式读取\n\n5. 关闭文件\n\n   ifs.close();\n\n\n\n**示例：**\n\n```C++\n#include <fstream>\n#include <string>\nvoid test01()\n{\n\tifstream ifs;\n\tifs.open(\"test.txt\", ios::in);\n\n\tif (!ifs.is_open())\n\t{\n\t\tcout << \"文件打开失败\" << endl;\n\t\treturn;\n\t}\n\n\t//第一种方式\n\t//char buf[1024] = { 0 };\n\t//while (ifs >> buf)\n\t//{\n\t//\tcout << buf << endl;\n\t//}\n\n\t//第二种\n\t//char buf[1024] = { 0 };\n\t//while (ifs.getline(buf,sizeof(buf)))\n\t//{\n\t//\tcout << buf << endl;\n\t//}\n\n\t//第三种\n\t//string buf;\n\t//while (getline(ifs, buf))\n\t//{\n\t//\tcout << buf << endl;\n\t//}\n\n\tchar c;\n\twhile ((c = ifs.get()) != EOF)\n\t{\n\t\tcout << c;\n\t}\n\n\tifs.close();\n\n\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n总结：\n\n- 读文件可以利用 ifstream  ，或者fstream类\n- 利用is_open函数可以判断文件是否打开成功\n- close 关闭文件 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 5.2 二进制文件\n\n以二进制的方式对文件进行读写操作\n\n打开方式要指定为 ==ios::binary==\n\n\n\n#### 5.2.1 写文件\n\n二进制方式写文件主要利用流对象调用成员函数write\n\n函数原型 ：`ostream& write(const char * buffer,int len);`\n\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n\n\n\n**示例：**\n\n```C++\n#include <fstream>\n#include <string>\n\nclass Person\n{\npublic:\n\tchar m_Name[64];\n\tint m_Age;\n};\n\n//二进制文件  写文件\nvoid test01()\n{\n\t//1、包含头文件\n\n\t//2、创建输出流对象\n\tofstream ofs(\"person.txt\", ios::out | ios::binary);\n\t\n\t//3、打开文件\n\t//ofs.open(\"person.txt\", ios::out | ios::binary);\n\n\tPerson p = {\"张三\"  , 18};\n\n\t//4、写文件\n\tofs.write((const char *)&p, sizeof(p));\n\n\t//5、关闭文件\n\tofs.close();\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n总结：\n\n* 文件输出流对象 可以通过write函数，以二进制方式写数据\n\n\n\n\n\n\n\n\n\n\n\n#### 5.2.2 读文件\n\n二进制方式读文件主要利用流对象调用成员函数read\n\n函数原型：`istream& read(char *buffer,int len);`\n\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n\n示例：\n\n```C++\n#include <fstream>\n#include <string>\n\nclass Person\n{\npublic:\n\tchar m_Name[64];\n\tint m_Age;\n};\n\nvoid test01()\n{\n\tifstream ifs(\"person.txt\", ios::in | ios::binary);\n\tif (!ifs.is_open())\n\t{\n\t\tcout << \"文件打开失败\" << endl;\n\t}\n\n\tPerson p;\n\tifs.read((char *)&p, sizeof(p));\n\n\tcout << \"姓名： \" << p.m_Name << \" 年龄： \" << p.m_Age << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n- 文件输入流对象 可以通过read函数，以二进制方式读数据\n","tags":["C++"]},{"title":"日期类","url":"/2022/12/11/5/","content":"```\n#include<iostream>\n\nusing namespace std;\n\nclass Date\n{\npublic:\n    void set(int year, int month, int day)\n    {\n        this->year = year;\n        this->month = month;\n        this->day = day;\n    }\n    //前置++\n    Date& operator++()\n    {\n        if (day < 28)\n        {\n            day++;\n            return *this;\n        }\n        else if (month == 2)\n        {\n            if (day == 28 && !(year % 400 == 0 || (year % 4 == 0 && year % 100 != 0)))\n            {\n                day++;\n                return *this;\n            }\n            month++, day = 1;\n            return *this;\n        }\n        else if (day == 29)\n        {\n            day++;\n            return *this;\n        }\n        else if (day == 30)\n        {\n            switch (month)\n            {\n            case 4:case 6:case 9:case 11:\n                day = 1;\n                month++;\n                return *this;\n                break;\n            }\n            day++;\n            return *this;\n        }\n        else if (month == 12)\n        {\n            year++, month = 1, day = 1;\n            return *this;\n        }\n        else\n        {\n            month++;\n            day = 1;\n            return *this;\n        }\n    }\n    //后置++\n    Date operator++(int)\n    {\n        Date* temp = this;\n        return *temp;\n        ++(*this);\n    }\n    //前置--\n    Date& operator--()\n    {\n        if (day == 1)\n        {\n            switch (month)\n            {\n            case 2:case4:case 6:case 8:case 9:case 11:\n                day = 31;\n                month--;\n                break;\n            case 5:case 7:case 10:case 12:\n                day = 30;\n                month--;\n                break;\n            case 1:\n                month = 12;\n                year--;\n                day = 31;\n            case 3:\n                if (year % 4 != 0)\n                    month--;\n                day = 28;\n                month--;\n                day = 29;\n                break;\n            default:\n                break;\n            }\n\n        }\n        else\n            day--;\n        return *this;\n    }\n    //后置--\n    Date operator--(int)\n    {\n        Date* temp = this;\n        return *temp;\n        --(*this);\n    }\npublic:\n    int year;\n    int month;\n    int day;\n};\n\nvoid show(Date data)\n{\n    cout << \"年：\" << data.year << \"月：\" << data.month << \"日：\" << data.day << endl;\n}\n\nint main()\n{\n    Date data;\n    data.set(2012, 4, 29);\n    show(data);\n    int a;\n    cout << \"选择：1、后置递增\\t 2、前置递增\\t 3、后置递减\\t 4、前置递减\" << endl;\n    cin >> a;\n    switch (a)\n    {\n    case 1:\n        show(data++);\n        break;\n    case 2:\n        show(++data);\n        break;\n    case 3:\n        show(data--);\n        break;\n    case 4:\n        show(--data);\n        break;\n    default:\n        break;\n    }\n    return 0;\n}\n```\n","tags":["C++"]},{"title":"学生信息管理系统","url":"/2022/12/11/4/","content":"\n```\n#include<iostream>\n#include<string>\n#include<vector>\n#include<windows.h>\n#include<algorithm>\n\nusing namespace std;\n\nclass student\n{\npublic:\n    string s_name;\n    int s_id = 0;\n    int y_score = 0;//语文成绩\n    int s_score = 0;//数学成绩\n    int e_score = 0;//英语成绩\n    int s_total = 0;\n};\n\nvector<student> v;\nvector<student>z;\n\nvoid showmenu()\n{\n    cout << \"*******************************\" << endl;\n    cout << \"欢迎来到学生管理系统\" << endl;\n    cout << \"请选择您的操作\" << endl;\n    cout << \"1.添加学生\" << endl;\n    cout << \"2.输出学生列表\" << endl;\n    cout << \"3.对成绩进行排序\" << endl;\n    cout << \"4.根据学号查找学生信息\" << endl;\n    cout << \"输入其他字符退出程序\" << endl;\n    cout << \"*******************************\" << endl;\n}\n\nvoid showstudent(vector<student>& a)\n{\n    for (vector<student>::iterator it = a.begin(); it != a.end(); it++)\n    {\n        cout << \"姓名：\" << (*it).s_name << \"\\t学号：\" << (*it).s_id << \"\\t语文成绩：\" << (*it).y_score << \"\\t数学成绩：\" << (*it).s_score << \"\\t英语成绩：\" << (*it).e_score << \"\\t总成绩：\" << (*it).s_total << endl;\n    }\n}\n\nvoid showstudent1(vector<student>& a)\n{\n    int i = 1;\n    for (vector<student>::iterator it = a.begin(); it != a.end(); it++, i++)\n    {\n        cout << \"第\" << i << \"名： 姓名：\" << (*it).s_name << \"\\t学号：\" << (*it).s_id << \"\\t语文成绩：\" << (*it).y_score << \"\\t数学成绩：\" << (*it).s_score << \"\\t英语成绩：\" << (*it).e_score << \"\\t总成绩：\" << (*it).s_total << endl;\n    }\n}\n\nbool comp(const student& a, const student& b)\n{\n    return a.s_total > b.s_total;\n}\n\nint main()\n{\n    while (true)\n    {\n    aaa:\n        showmenu();\n        int a;\n        cin >> a;\n        system(\"cls\");\n        switch (a)\n        {\n        case 1:\n        {\n            student stu;\n            cout << \"姓名：\" << endl;\n            cin >> stu.s_name;\n            cout << \"学生号：\" << endl;\n            cin >> stu.s_id;\n            cout << \"语文成绩\" << endl;\n            cin >> stu.y_score;\n            cout << \"数学成绩\" << endl;\n            cin >> stu.s_score;\n            cout << \"英语成绩\" << endl;\n            cin >> stu.e_score;\n            stu.s_total = stu.y_score + stu.s_score + stu.e_score;\n            v.push_back(stu);\n            cout << \"添加成功！\" << endl;\n            Sleep(1000);\n            system(\"cls\");\n            break;\n        }\n        case 2:\n        {\n            showstudent(v);\n            system(\"pause\");\n            system(\"cls\");\n            break;\n        }\n        case 3:\n        {\n            z = v;\n            sort(z.begin(), z.end(), comp);\n            showstudent1(z);\n            system(\"pause\");\n            system(\"cls\");\n            break;\n        }\n        case 4:\n        {\n            int id;\n            cout << \"请输入学生id号：\" << endl;\n            cin >> id;\n            for (vector<student>::iterator it = v.begin(); it != v.end(); it++)\n            {\n                if ((*it).s_id == id)\n                {\n                    cout << \"查找成功 学生信息如下：\" << endl;\n                    cout << \"姓名：\" << (*it).s_name << \"\\t学号：\" << (*it).s_id << \"\\t语文成绩：\" << (*it).y_score << \"\\t数学成绩：\" << (*it).s_score << \"\\t英语成绩：\" << (*it).e_score << \"\\t总成绩：\" << (*it).s_total << endl;\n                    system(\"pause\");\n                    system(\"cls\");\n                    goto aaa;\n                }\n            }\n            cout << \"查无此人！\" << endl;\n            system(\"pause\");\n            system(\"cls\");\n            break;\n        }\n        default:\n        {\n            goto bbb;\n        }\n        }\n\n    }\nbbb:\n    return 0;\n}\n```\n\n","tags":["C++"]},{"title":"糖果机","url":"/2022/12/11/3/","content":"\n```\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<windows.h>\n\nusing namespace std;\n\nclass Users {\nprivate:\n\tmap<string, string> m;\npublic:\n\tUsers()\n\t{\n\t\tm[\"Administrator\"] = string(\"114514\");\n\t}\n\n\tbool check(string username, string password)\n\t{\n\t\tauto it = m.find(username);\n\t\tif (it == m.end())\n\t\t\treturn false;\n\t\tif (it->second != password)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tbool login()\n\t{\n\t\tputs(\"输入用户名:\");\n\t\tstring uname;\n\t\tcin >> uname;\n\t\tputs(\"输入密码:\");\n\t\tstring passw;\n\t\tcin >> passw;\n\t\tif (!check(uname, passw))\n\t\t{\n\t\t\tputs(\"用户名或密码错误\");\n\t\t\tSleep(600);\n\t\t\treturn false;\n\t\t}\n\t\tputs(\"登录成功\");\n\t\tSleep(600);\n\t\tsystem(\"cls\");\n\t\treturn true;\n\t}\n}users;\n\nclass CandyList {\nprivate:\n\tmap<string, int> list;//名字到id的映射\n\tvector<string> nameList;\npublic:\n\tCandyList()\n\t{\n\t\tnameList.resize(1);\n\t}\n\n\tint queryId(string name)//传入名字，返回id，不存在返回0\n\t{\n\t\tauto it = list.find(name);\n\t\tif (it != list.end())\n\t\t\treturn it->second;\n\t\treturn 0;\n\t}\n\n\tstring queryName(int id)//传入ID 返回名字\n\t{\n\t\tif (id > nameList.size())\n\t\t\treturn string(\"\");\n\t\treturn nameList[id];\n\t}\n\n\tint addCandyKind(string name)//无论有没有，都返回id\n\t{\n\t\tint id = queryId(name);\n\t\tif (id)\n\t\t\treturn id;\n\t\tid = list.size() + 1;\n\t\tlist[name] = id;\n\t\tnameList.push_back(name);\n\t\treturn id;\n\t}\n}candyList;\n\nclass Store {//仓库\nprivate:\n\tvector<pair<int, int> > s; //数量、单价\n\tint sum;\npublic:\n\tStore()\n\t{\n\t\ts.clear();\n\t\ts.resize(100);\n\t\tsum = 0;\n\t}\n\tint getSum()\n\t{\n\t\treturn sum;\n\t}\n\n\tint getPrice(int id)\n\t{\n\t\treturn s[id].second;\n\t}\n\n\tvoid displayCandy()\n\t{\n\t\tcout << \"编号\\t品名\\t剩余数量 单价\" << endl;\n\t\tfor (int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\tif (s[i].first > 0)\n\t\t\t{\n\t\t\t\tcout << i << \"\\t\" << candyList.queryName(i) << \"\\t\" << s[i].first << \"\\t \" << s[i].second << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid addCandy(string name, int num, int price = -1)\n\t{\n\t\tbool ok = 1;\n\t\tif (num < 1)\n\t\t\tok = 0, puts(\"数量错误\");\n\t\tif (price < -1 || price == 0)\n\t\t\tok = 0, puts(\"价格错误\");\n\t\tif (!ok)\n\t\t\treturn;\n\t\tint id = candyList.addCandyKind(name);\n\t\ts[id].first += num;\n\t\tsum += num;\n\t\tif (~price)\n\t\t\ts[id].second = price;//更新价格\n\t}\n\n\tint rmCandy(int id, int num, int pay)//卖糖\n\t{\n\t\tif (!id)\n\t\t{\n\t\t\tputs(\"编号错误！\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (s[id].first < num)\n\t\t{\n\t\t\tputs(\"数量不足\");\n\t\t\treturn 0;\n\t\t}\n\t\tint totPrice = num * s[id].second;\n\t\tif (pay < totPrice)\n\t\t{\n\t\t\tputs(\"钱不够\");\n\t\t\treturn -1;\n\t\t}\n\t\ts[id].first -= num;\n\t\tsum -= num;\n\t\treturn pay - totPrice;\n\t}\n}store;\n\nclass Show {//前端\nprivate:\n\tinline void read(int& x)\n\t{\n\t\tint s = 0, w = 1;\n\t\tchar ch = getchar();\n\t\twhile (ch < '0' || ch > '9')\n\t\t{\n\t\t\tif (ch == '-')\n\t\t\t\tw = -1;\n\t\t\tch = getchar();\n\t\t}\n\t\twhile (ch >= '0' && ch <= '9')\n\t\t\ts = s * 10 + ch - '0', ch = getchar();\n\t\tx = s * w;\n\t}\n\npublic:\n\tShow()\n\t{\n\t\tstore.addCandy(string(\"白砂糖\"), 10, 10);\n\t}\n\tvoid run()\n\t{\n\t\tprintf(\"启动中\");\n\t\tfor (int i = 0; i < 5; i++)\n\t\t{\n\t\t\tSleep(100);\n\t\t\tprintf(\".\");\n\t\t}\n\t\twhile (1)\n\t\t{\n\t\taa:\n\t\t\tsystem(\"cls\");\n\t\t\tif (store.getSum())\n\t\t\t\tprintf(\"营业中!\\n买糖请输入1\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"缺货 暂停营业！\\n\");\n\t\t\tputs(\"加糖请输入2\\n退出系统输入3\");\n\t\t\tint type = 0;\n\t\t\t//read(type);//提高容错性\n\t\t\tcin >> type;\n\t\t\tswitch (type)\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t{\n\t\t\t\tcout << \"欢迎光临！\" << endl;\n\t\t\t\tstore.displayCandy();\n\t\t\t\tputs(\"输入编号：\");\n\t\t\t\tint id;\n\t\t\t\tread(id);\n\t\t\t\tputs(\"输入数量：\");\n\t\t\t\tint num;\n\t\t\t\tread(num);\n\t\t\t\tputs(\"请付款：\");\n\t\t\t\tint pay;\n\t\t\t\tread(pay);\n\t\t\t\tint temp = store.rmCandy(id, num, pay);\n\t\t\t\tif (temp > 0)\n\t\t\t\t\tcout << \"给你找零:\" << temp << endl << \"\\n欢迎下次光临！\";\n\t\t\t\telse if (temp == 0)\n\t\t\t\t\tcout << \"交易成功 欢迎下次光临！\" << endl;\n\t\t\t\tSleep(1000);\n\t\t\t\tsystem(\"cls\");\n\t\t\t\tgoto aa;\n\t\t\t}\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\tif (!users.login())\n\t\t\t\t\tcontinue;\n\t\t\t\tputs(\"请输入品名\");\n\t\t\t\tstring name;\n\t\t\t\tcin >> name;\n\t\t\t\tint id = candyList.queryId(name);//不存在这个糖 id==0\n\t\t\t\tputs(\"请输入数量\");\n\t\t\t\tint num, price;\n\t\t\t\tbool transPrice = 0;\n\t\t\t\tread(num);\n\t\t\t\tif (!id)\n\t\t\t\t\tputs(\"输入定价(分/个)\"), read(price), transPrice = 1;\n\t\t\t\tif (transPrice)\n\t\t\t\t\tstore.addCandy(name, num, price);\n\t\t\t\telse\n\t\t\t\t\tstore.addCandy(name, num);\n\t\t\t\tgoto aa;\n\t\t\t}\n\t\t\tcase 3:\n\t\t\t{\n\t\t\t\tgoto flag;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tcout << \"输入错误！请重新输入！\" << endl;\n\t\t\t\tSleep(1000);\n\t\t\t\tgoto aa;\n\t\t\t}\n\t\t\t}\n\t\tflag:\n\t\t\tcout << \"正在退出\";\n\t\t\tfor (int i = 0; i < 5; i++)\n\t\t\t{\n\t\t\t\tSleep(100);\n\t\t\t\tprintf(\".\");\n\t\t\t}\n\t\t\tcout << \"\\n已退出！再见！\" << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n};\n\nint main()\n{\n\tShow machine;\n\tmachine.run();\n\tsystem(\"pause\");\n}\n```\n\n","tags":["C++"]},{"title":"打印玫瑰花","url":"/2022/12/11/2/","content":"\n```\n#include <stdio.h>\n#include <math.h>\n\nconst int max_iterations = 128;\nconst float stop_threshold = 0.01f;\nconst float grad_step = 0.01f;\nconst float clip_far = 10.0f;\n\nconst float PI = 3.14159265359f;\nconst float PI2 = 6.28318530718f;\nconst float DEG_TO_RAD = PI / 180.0f;\n\ntypedef struct { float x, y; } vec2;\ntypedef struct { float x, y, z; } vec3;\ntypedef struct { float m[9]; } mat3;\n\nconst vec3 light_pos = { 20.0f, 50.0f, 20.0f };\n\nfloat min(float a, float b) { return a < b ? a : b; }\nfloat max(float a, float b) { return a > b ? a : b; }\nfloat clamp(float f, float a, float b) { return max(min(f, b), a); }\nvec2 make2(float x, float y) { vec2 r = { x, y }; return r; }\nvec2 add2(vec2 a, vec2 b) { vec2 r = { a.x + b.x, a.y + b.y }; return r; }\nvec2 sub2(vec2 a, vec2 b) { vec2 r = { a.x - b.x, a.y - b.y }; return r; }\nfloat dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat length2(vec2 v) { return sqrt(dot2(v, v)); }\nvec3 make3(float x, float y, float z) { vec3 r = { x, y, z }; return r; }\nvec3 add3(vec3 a, vec3 b) { vec3 r = { a.x + b.x, a.y + b.y, a.z + b.z }; return r; }\nvec3 sub3(vec3 a, vec3 b) { vec3 r = { a.x - b.x, a.y - b.y, a.z - b.z }; return r; }\nvec3 mul3(vec3 a, vec3 b) { vec3 r = { a.x * b.x, a.y * b.y, a.z * b.z }; return r; }\nvec3 scale3(vec3 v, float s) { vec3 r = { v.x * s, v.y * s, v.z * s }; return r; }\nfloat dot3(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat length3(vec3 v) { return sqrt(dot3(v, v)); }\nvec3 normalize3(vec3 v) { return scale3(v, 1.0f / length3(v)); }\nvec3 mul(mat3 m, vec3 v) {\n    return make3(\n        m.m[0] * v.x + m.m[3] * v.y + m.m[6] * v.z,\n        m.m[1] * v.x + m.m[4] * v.y + m.m[7] * v.z,\n        m.m[2] * v.x + m.m[5] * v.y + m.m[8] * v.z);\n}\n\nmat3 rotationXY(float x, float y) {\n    vec2 c = { cos(x), cos(y) }, s = { sin(x), sin(y) };\n    mat3 m = {\n        c.y      , 0.0f, -s.y,\n        s.y * s.x,  c.x,  c.y * s.x,\n        s.y * c.x, -s.x,  c.y * c.x\n    };\n    return m;\n}\n\nfloat opI(float d1, float d2) { return max(d1, d2); }\nfloat opU(float d1, float d2) { return min(d1, d2); }\nfloat opS(float d1, float d2) { return max(-d1, d2); }\n\nfloat sdPetal(vec3 p, float s) {\n    p = add3(mul3(p, make3(0.8f, 1.5f, 0.8f)), make3(0.1f, 0.0f, 0.0f));\n    vec2 q = make2(length2(make2(p.x, p.z)), p.y);\n\n    float lower = length2(q) - 1.0f;\n    lower = opS(length2(q) - 0.97f, lower);\n    lower = opI(lower, q.y);\n\n    float upper = length2(sub2(q, make2(s, 0.0f))) + 1.0f - s;\n    upper = opS(upper, length2(sub2(q, make2(s, 0.0f))) + 0.97f - s);\n    upper = opI(upper, -q.y);\n    upper = opI(upper, q.x - 2.0f);\n\n    float region = length3(sub3(p, make3(1.0f, 0.0f, 0.0f))) - 1.0f;\n    return opI(opU(upper, lower), region);\n}\n\nfloat map(vec3 p) {\n    float d = 1000.0f, s = 2.0f;\n    mat3 r = rotationXY(0.1f, PI2 * 0.618034f);\n    r.m[0] *= 1.08f;  r.m[1] *= 1.08f;  r.m[2] *= 1.08f;\n    r.m[3] *= 0.995f; r.m[4] *= 0.995f; r.m[5] *= 0.995f;\n    r.m[6] *= 1.08f;  r.m[7] *= 1.08f;  r.m[8] *= 1.08f;\n    for (int i = 0; i < 21; i++) {\n        d = opU(d, sdPetal(p, s));\n        p = mul(r, p);\n        p = add3(p, make3(0.0, -0.02, 0.0));\n        s *= 1.05f;\n    }\n    return d;\n}\n\nvec3 gradient(vec3 pos) {\n    const vec3 dx = { grad_step, 0.0, 0.0 };\n    const vec3 dy = { 0.0, grad_step, 0.0 };\n    const vec3 dz = { 0.0, 0.0, grad_step };\n    return normalize3(make3(\n        map(add3(pos, dx)) - map(sub3(pos, dx)),\n        map(add3(pos, dy)) - map(sub3(pos, dy)),\n        map(add3(pos, dz)) - map(sub3(pos, dz))));\n}\n\nfloat ray_marching(vec3 origin, vec3 dir, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < max_iterations; i++) {\n        float dist = map(add3(origin, scale3(dir, depth)));\n        if (dist < stop_threshold)\n            return depth;\n        depth += dist * 0.3;\n        if (depth >= end)\n            return end;\n    }\n    return end;\n}\n\nfloat shading(vec3 v, vec3 n, vec3 eye) {\n    vec3 ev = normalize3(sub3(v, eye));\n    vec3 vl = normalize3(sub3(light_pos, v));\n    float diffuse = dot3(vl, n) * 0.5f + 0.5f;\n    vec3 h = normalize3(sub3(vl, ev));\n    float rim = pow(1.0f - max(-dot3(n, ev), 0.0f), 2.0f) * 0.15f;\n    float ao = clamp(v.y * 0.5f + 0.5f, 0.0f, 1.0f);\n    return (diffuse + rim) * ao;\n}\n\nvec3 ray_dir(float fov, vec2 pos) {\n    vec3 r = { pos.x, pos.y, -tan((90.0f - fov * 0.5f) * DEG_TO_RAD) };\n    return normalize3(r);\n}\n\nfloat f(vec2 fragCoord) {\n    vec3 dir = ray_dir(45.0f, fragCoord);\n    vec3 eye = { 0.0f, 0.0f, 4.5f };\n    mat3 rot = rotationXY(-1.0f, 1.0f);\n\n    dir = mul(rot, dir);\n    eye = mul(rot, eye);\n\n    float depth = ray_marching(eye, dir, 0.0f, clip_far);\n    vec3 pos = add3(eye, scale3(dir, depth));\n    if (depth >= clip_far)\n        return 0.0f;\n    else\n        return shading(pos, gradient(pos), eye);\n}\n\nint main() {\n    puts(\"\\033[91m\");\n    for (int y = 0; y < 80; y++) {\n        for (int x = 0; x < 160; x++)\n            putchar(\"  .,-:;+=*#@\"[(int)(f(make2((x / 160.0f - 0.5f) * 2.0f, (y / 80.0f - 0.5f) * -2.0f)) * 12.0f)]);\n        putchar('\\n');\n    }\n}\n```\n\n","tags":["C++"]},{"title":"ATM机","url":"/2022/12/11/1/","content":"\n```\n#include <string>\n#include <iostream>\n#include <vector>\n#include <Windows.h>\n#include <stdlib.h>\n#include <fstream>\n#include <ctime>\n\nusing namespace std;\n\nclass Account\n{\npublic:\n    string name;//姓名\n    int accountNumber = 0;//账号\n    int pinNumber = 0;//密码\n    int balance = 0;//余额\npublic:\n    bool welcome();//初始界面\n    void show();//打印菜单\n    void deposit();//存款\n    void withdrawal();//取款\n    void tran();//转账\n    void change();//修改密码\n    void getbalance();//查询余额\n    void print();//打印账号信息\n};\n\nvector<Account> account;\nAccount ATM;\nvector<Account>::iterator atm;\n\nvoid wait() {\n    int a = getchar();\n    a = getchar();\n}\n\nvoid keep() {\n    ofstream ofs(\"ATM.txt\");\n    if (ofs.is_open()) {\n        vector<Account>::iterator it;\n        for (it = account.begin(); it != account.end(); it++) {\n            ofs << it->name << \"\\t\" << it->accountNumber << \"\\t\" << it->pinNumber << \"\\t\" << it->balance << \"\\t\" << endl;\n        }\n        ofs.close();\n    }\n}\n\nvoid open() {\n    ifstream ifs(\"ATM.txt\");\n    if (ifs.is_open()) {\n        cout << \"文件打开成功！\" << endl;\n        system(\"cls\");\n        Account a;\n        while (ifs >> a.name >> a.accountNumber >> a.pinNumber >> a.balance) {\n            account.push_back(a);\n        }\n        ifs.close();\n    }\n    else {\n        cout << \"文件不存在！\" << endl;\n    }\n}\n\nbool Account::welcome() {\n    Account temp;\n    cout << \"欢迎使用！\\n请选择操作：\\n 1、登录\\n 2、开户\\n 3、退出\" << endl;\n    int a;\n    cin >> a;\n    system(\"cls\");\n    switch (a)\n    {\n    case 1: {\n        if (account.begin() == account.end()) {\n            cout << \"没有账号，无法登录！\" << endl;\n            wait();\n            return false;\n        }\n        else {\n            cout << \"请输入账号：\" << endl;\n            cin >> temp.accountNumber;\n            for (vector<Account>::iterator it = account.begin(); it != account.end(); it++) {\n                if (it->accountNumber == temp.accountNumber) {\n                    cout << \"请输入密码：\" << endl;\n                    cin >> temp.pinNumber;\n                    if (it->pinNumber == temp.pinNumber) {\n                        atm = it;\n                        cout << \"登陆成功！\" << endl;\n                        wait();\n                        return true;\n                    }\n                    else {\n                        cout << \"密码错误，无法登录！\" << endl;\n                        wait();\n                        return false;\n                    }\n                }\n            }\n            cout << \"账号不存在！\" << endl;\n            return false;\n        }\n    }\n    case 2: {\n        cout << \"请输入姓名：\" << endl;\n        cin >> temp.name;\n        cout << \"请输入密码：\" << endl;\n        cin >> temp.pinNumber;\n        srand(unsigned int(time(0)));\n        srand(temp.pinNumber + rand());\n        temp.accountNumber = rand() * 10000000 % 10000000 + 60000000;\n        cout << \"开户成功，您的账号为：\" << temp.accountNumber << endl;\n        account.push_back(temp);\n        wait();\n        return false;\n        break;\n    }\n    case 3: {\n        keep();\n        cout << \"感谢使用，再见！\" << endl;\n        exit(0);\n    }\n    default:return false; break;\n    }\n}\n\nvoid Account::show() {\n    system(\"cls\");\n    cout << \"请选择你需要的服务\" << endl;\n    cout << \"1、存款\" << endl;\n    cout << \"2、取款\" << endl;\n    cout << \"3、转账\" << endl;\n    cout << \"4、查询余额\" << endl;\n    cout << \"5、修改密码\" << endl;\n    cout << \"6、显示账号信息\" << endl;\n    cout << \"7、退出\" << endl;\n}\n\nvoid Account::deposit() {\n    int temp;\n    cout << \"请输入存款金额：\" << endl;\n    cin >> temp;\n    atm->balance += temp;\n    cout << \"存款成功！\" << endl;\n}\n\nvoid Account::withdrawal() {\n    cout << \"请输入取款金额：\" << endl;\n    int temp;\n    cin >> temp;\n    if (temp > atm->balance)\n        cout << \"余额不足！\" << endl;\n    else\n        atm->balance -= temp;\n    cout << \"成功！\" << endl;\n}\n\nvoid Account::tran() {\n    Account temp;\n    cout << \"请输入对方账户：\" << endl;\n    cin >> temp.accountNumber;\n    for (vector<Account>::iterator it = account.begin(); it != account.end(); it++) {\n        if (temp.accountNumber == it->accountNumber)\n        {\n            int a;\n            cout << \"请输入转账金额：\" << endl;\n            cin >> a;\n            if (a < atm->balance && a > 0) {\n                atm->balance -= a;\n                it->balance += a;\n                cout << \"转账成功！\" << endl;\n                return;\n            }\n            else if (a > atm->balance) {\n                cout << \"余额不足！\" << endl;\n                return;\n            }\n            else {\n                cout << \"输入错误！\" << endl;\n                return;\n            }\n        }\n    }\n    cout << \"账户不存在！\" << endl;\n    return;\n}\n\nvoid Account::change() {\n    cout << \"请输入新密码\" << endl;\n    cin >> atm->pinNumber;\n    cout << \"修改成功！\" << endl;\n}\n\nvoid Account::getbalance() {\n    cout << \"余额为：\" << atm->balance << endl;\n}\n\nvoid Account::print() {\n    cout << \"姓名：\" << atm->name << endl;\n    cout << \"账户名：\" << atm->accountNumber << endl;\n    cout << \"余额：\" << atm->balance << endl;\n}\n\nint main() {\n    open();\naaa:\n    system(\"cls\");\n    bool b = ATM.welcome();\n    while (b) {\n        int a;\n        ATM.show();\n        cin >> a;\n        switch (a) {\n        case 1:system(\"cls\"); (*atm).deposit(); wait(); break;\n        case 2:system(\"cls\"); (*atm).withdrawal(); wait(); break;\n        case 3:system(\"cls\"); (*atm).tran(); wait(); break;\n        case 4:system(\"cls\"); (*atm).getbalance(); wait(); break;\n        case 5:system(\"cls\"); (*atm).change(); wait(); break;\n        case 6:system(\"cls\"); (*atm).print(); wait(); break;\n        case 7:system(\"cls\"); keep(); cout << \"感谢使用，再见！\" << endl; b = false; break;\n        default:break;\n        }\n    }\n    goto aaa;\n}\n```\n\n","tags":["C++"]}]