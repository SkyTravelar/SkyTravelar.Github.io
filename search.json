[{"title":"中南大学学习通毛概章节测试答案","url":"/2023/10/17/14/","content":"\n# 【2023年秋季】毛泽东思想和中国特色社会主义理论体系概论\n\n**第一章 毛泽东思想及其历史地位**\n\n**1.1**\n\nA C ABC\n\n**1.2**\n\nC B B\n\n**1.3**\n\nABC ABC ABC AB\n\n**1.4**\n\nABC ABCD B\n\n**1.5**\n\nABC B A\n\n**第二章 新民主主义革命理论**\n\n**2.1**\n\nB C A ABC\n\n**2.2**\n\nA B B C ABC\n\n**2.3**\n\nABD BCD AC AB\n\n**2.4**\n\nA A D AB\n\n**2.5**\n\nC B D\n\n**2.6**\n\nD ABC\n\n**第三章 社会主义改造理论**\n\n**3.1**\n\nABC ABCD B B\n\n**3.2**\n\nABCD ABC AB C\n\n**3.3**\n\nB C C D\n\n**3.4**\n\nABC ABCD D\n\n**3.5**\n\nABCD C C\n\n**第四章 社会主义建设道路初步探索的理论成果**\n\n**4.1**\n\nBCD C C B 错\n\n**4.2**\n\nACD ABCD BD ABD B\n\n**4.3**\n\nABCD B D 错 对\n\n**4.4**\n\nABCD ABD ACD A A\n","tags":["毛概"]},{"title":"拉萨尔幽灵的再现","url":"/2023/10/12/13/","content":"\n苏修集团近年来翻来复去地要求苏联人民为“提高福利”而“不懈劳动”。勃列日涅夫喊得尤为起劲，今年六月他在莫斯科说，劳动是“获得福利的唯一源泉” ;去年七月在基辅讲,“只有劳动才能为我们保障生活福利”;去年九月又到乌兹别克鼓吹“提高苏联人的福利”的“可靠途径是劳动、劳动、劳动”。\n\n苏修其他领导人和报刊的这类言论也到处可见，什么“福利的来源只有一个”，“这就是劳动”，“提高人民福利的途径除了劳动再没有别的办法”，等等。\n\n苏修领导集团这一套谬论是早在苏修二十四大上就定下的。翻开苏修二十四大的文件，在《关于一九七一～一九七五年苏联发展国民经济五年计划的指示》中，就有“劳动是财富的源泉”，只有劳动越多，福利才越多的十分荒谬的说法。提起“劳动是财富的源泉”和“劳动是福利的唯一源泉”，不能不使人想起机会主义的祖师爷拉萨尔。他早在一百多年前就提出了“劳动分工是一切财富的源泉”的谬论。  之后《哥达纲领》这一机会主义文件又一次贩卖了这一黑货,胡说什么“劳动是一切财富和一切文化的源泉”。当时就受到伟大的无产阶级的革命导师马克思和恩格斯的痛斥。\n\n**马克思明确指出,“劳动不是一切财富的源泉”,劳动者只有“事先就以所有者的身分来对待自然界这个一切劳动资料和劳动对象的第一源泉，  把自然界当作隶属于他的东西来处置，他的劳动才成为使用价值的源泉，因而也成为财富的源泉”。马克思在《哥达纲领批判》中一针见血地指出，拉萨尔谬论的要害，正在于对谁占有劳动的物质条件，即生产资料归谁所有这一根本条件避而不谈。**在当年德国无产阶级同资产阶级的矛盾日益尖锐的情况下，号称“马克思的学生”的拉萨尔竭力在工人中宣扬劳资合作，竭力欺骗和蒙蔽工人阶级，要他们不去注意生产资料归资本家占有这一事实，而埋头为资产阶级卖命劳动。\n\n事隔一百多年，拉萨尔的幽灵在克里姆林宫再现了。在资本主义已经复辟了的苏联，这原是不足为怪的。**同样号称“马克思的学生”的勃列日涅夫之流如今大吹大擂地贩卖拉萨尔的破烂货，是和拉萨尔一样，妄图用劳动的空谈来掩盖苏联日益尖锐的阶级矛盾，强迫人民卖命为苏修叛徒集团劳动，以维持他们的反动统治。在苏修叛徒集团的统治下，苏联的广大劳动人民早已失去了生产资料，失去了作为国家主人所拥有的最根本的权利，重又成为雇佣劳动者，遭受一小撮官僚垄断资产阶级的残酷剥削和压榨。**近年来，苏联劳动人民采取各种形式反抗苏修的统治，旷工、罢工和消极怠工，以及大量的工人流动，已给苏修经济造成巨大损失。\n\n据苏联《劳动报》报道，由于青年工人大量流动，一九七一年仅俄罗斯联邦工业系统就损失三十四亿卢布。苏联一九七二年出版的《科学技术进步，和劳动生产率》一书说，工人怠工、停工使企业损失的工时占总工时的百分之十五到二十。苏联一经济学家对美国记者说，由于旷工、怠工和事故，苏联一年的损失达一百八十亿美元。\n\n面对着广大人民日益强烈的反抗和苏修国内严重的经济困境，苏修集团深感不安。**他们在加强法西斯镇压的同时，不得不大肆进行欺骗宣传，要人们相信，苏联劳动人民今天所遭受的生活困苦，是劳动得不够，只有加强劳动，才得以改善。其实，人们已越来越清楚，在今日之苏联，为所谓“福利”而劳动，不过是为一小撮官僚垄断资产阶级的“特权”而卖命。这一小撮人通过利润和税金等形式无偿地占有工人创造的大量财富，并通过高工资、高奖金和其他额外收入，贪婪地榨取劳动人民的血汗。**一些工人气愤地说:“领导人、厂长，汽车别墅....应有尽有，而我们工人只有两只手。”这就是苏修叛徒集团口口声声讲的所谓为“福利”而劳动!\n\n“提高人民福利”是假，强迫人民劳动是真。苏修集团让广大苏联人民为他们“劳动、劳动、再劳动”，就是想使他们这一小撮人获得“福利、福利、又福利”。这就是为什么他们不惜重新拾起拉萨尔的破旗来招摇过市。\n\n**但是，拉萨尔显然帮不了勃列日涅夫的忙，相反只能暴露新老机会主义者是一丘之貉，只能使苏联人民更加认清勃列日涅夫之流从理论到行动，彻头彻尾都是马列主义的叛徒。**\n","tags":["禁评"]},{"title":"中南大学机器学习课程第一次作业","url":"/2023/10/08/29/","content":"\n描述：这是一个有部分代码缺失的notebook，需要完成的就是将 `### START CODE HERE ###` 和`### END CODE HERE ###`之间的代码补全\n\n# 线性回归\n\n某城市的电网系统需要升级，以应对日益增长的用电需求。电网系统需要考虑最高温度对城市的峰值用电量的影响。项目负责人需要预测明天城市的峰值用电量，他搜集了以往的数据。现在，负责人提供了他搜集到的数据，并请求你帮他训练出一个模型，这个模型能够很好地预测明天城市的峰值用电量。\n## 1- 准备\n先导入必要的python包\n\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\n%matplotlib inline\n```\n\n导入负责人提供的数据，并可视化数据\n\n```\ndata = np.loadtxt('data.txt')\n#data 第一列为温度信息 第二列为人口信息\nX_raw = data[:,0].reshape(-1,1)\n#data 第三列为用电量信息\nY = data[:,2].reshape(-1,1)\nplt.xlabel('High temperature')\nplt.ylabel('Peak demand ')\nplt.scatter(X_raw,Y)\nprint('X shape:',X_raw.shape)\nprint('Y shape:',Y.shape)\nprint('some X[:5]:\\n',X_raw[:5])\nprint('some Y[:5]:\\n',Y[:5])\n```\n\n结果\n\n```\nX shape: (80, 1)\nY shape: (80, 1)\nsome X[:5]:\n [[38.24]\n [36.53]\n [32.92]\n [26.59]\n [20.05]]\nsome Y[:5]:\n [[4.04]\n [2.84]\n [3.2 ]\n [3.42]\n [2.32]]\n```\n\n根据对数据可视化结果的分析，决定使用回归算法训练一个模型，用来预测明天城市的峰值用电量。首先考虑单变量的线性回归模型。\n\n## 2- 单变量线性回归理论介绍\n\n### 单变量线性回归模型\n\n单变量线性回归的模型由两个参数$\\theta_0$,$\\theta_1$来表示一条直线：$$Peak\\ demand \\approx \\theta_0 + \\theta_1 \\cdot (High\\ temperature) 。$$\n\n我们的目标也就是找到一条\"最符合\"的直线，确定这条直线的参数$\\theta_i$。\n\n设输入的特征——最高温度(F)为$x^{(i)} \\in \\mathbb{R}^{n+1}$，$i=1,\\cdots,m$。$m$为样本总数，在该例子中$m$=80。$n$为特征的个数，这里为$1$。则：$x^{(i)} \\in \\mathbb{R}^2 = \\begin{bmatrix} 1 \\\\ \\text{high temperature for day} i\\end{bmatrix}。$\n\n设输出为$y^{(i)} \\in \\mathbb{R}$，表示第$i$天的峰值用电量。\n\n参数为$\\theta \\in \\mathbb{R}^{n+1} = \\begin{bmatrix} \\theta_0 \\\\ \\theta_1 \\\\ \\vdots \\\\ \\theta_n \\end{bmatrix}$。这里$n=1$。\n\n在该例子中，模型为一条直线，模型可表示为：\n$$h_{\\theta}(x) = \\theta^T x = \\theta_0 + \\theta_1 x 。$$\n### **注意**：\n这里的$\\theta^T$是一个向量，$\\theta_0,\\theta_1$是标量。使用向量化表示的原因为：（1）简化数学公式的书写（2）与程序代码中的表示保持一致，且使用向量化的代码实现可以加速运算，**因此一般能不用`for`循环的地方都不用`for`循环**。 \n\n下面用一个简单的例子说明向量化的代码运算更快。\n\n```\n# 随机初始化两个向量，计算它们的点积\nx = np.random.rand(10000000,1)\ny = np.random.rand(10000000,1)\nans = 0\nstart = time.time()\nfor i in range(10000000):\n    ans += x[i,0]/y[i,0]\nend = time.time()\nprint('for循环的计算时间: %.2fs'%(end - start))\nprint('计算结果：%.2f'%(ans))\nstart = time.time()\nans = np.dot(x.T,y)\nend = time.time()\nprint('向量化的计算时间: %.2fs'%(end - start))\nprint('计算结果：%.2f'%(ans))\n```\n\n结果\n\n```\nfor循环的计算时间: 4.67s\n计算结果：89066284.16\n向量化的计算时间: 0.00s\n计算结果：2500035.03\n```\n\n因为$\\theta_0 + \\theta_1 x=\\begin{bmatrix} 1 \\quad x \\end{bmatrix} \\begin{bmatrix} \\theta_0 \\\\ \\theta_1 \\end{bmatrix} 。$\n因此，为了方便编程，我们需要给每一个$x^{(i)}$的前面再加一列1。使得每一个$x^{(i)}$成为一个2维向量。\n\n### 预测结果\n\n模型需要根据输入自变量 $x^{(i)}$ 和参数 $\\theta$ 来输出预测结果 $predict\\_y^{(i)}$。\n\n将自变量 $x^{(i)}$ 作为模型的输入，模型根据输入和当前参数 $\\theta$ 输出预测结果：\n\n$$\npredict\\_y^{(i)} = h_\\theta(x^{(i)})。\n$$\n\n其中 $h_\\theta()$ 为模型在参数为 $\\theta$ 情况下，对于输入的预测函数。  \n\n\n在预测阶段，$x$作为自变量。\n### 损失函数\n\n模型的预测结果和实际结果有差距，为了衡量它们之间的差距，或者说量化使用这个模型产生的损失，我们定义损失函数$l(predict\\_y^{(i)}, y^{(i)})$。这里我们使用平方损失：\n$$\nl(predict\\_y, y) = \\left ( predict\\_y^{(i)} - y^{(i)} \\right )^2。\n$$\n\n上述损失函数表示一个样本的损失，整个训练集的损失使用$J(\\theta)$表示：\n$$\n\\begin{aligned}\nJ(\\theta) & = \\frac{1}{2m} \\sum_{i=1}^{m}l(predict\\_y^{(i)}, y^{(i)}) \\\\\n& = \\frac{1}{2m} \\sum_{i=1}^{m} \\left ( h_\\theta(x^{(i)}) - y^{(i)} \\right )^2 \\\\\n& = \\frac{1}{2m} \\sum_{i=1}^{m} \\left ( \\theta^T x^{(i)} - y^{(i)} \\right )^2。\n\\end{aligned}\n$$\n（其中数字2的作用是方便求导时的运算）\n\n为了使模型取得较好的预测效果，需要最小化训练集上的损失，即$\\underset{\\theta}{\\min} J(\\theta)$。\n\n在损失阶段，$\\theta$ 作为自变量。\n\n### 梯度下降法\n\n为了得到使损失函数$J(\\theta)$最小化的$\\theta$，可以使用梯度下降法。\n\n假设一开始$J(\\theta)$的值在紫色点上，为了降低$J(\\theta)$值，需要$\\theta_1$往右边移动，这个方向是$J(\\theta)$在$\\theta_1$上的负梯度。只要$\\theta$不断往负梯度方向移动，$J(\\theta)$一定可以降到最低值。梯度下降法就是使参数$\\theta$不断往负梯度移动，经过有限次迭代(更新$\\theta$值)之后，损失函数$J(\\theta)$达到最低值。\n\n梯度下降法的过程：\n1. 初始化参数向量$\\theta$。\n\n2. 开始迭代\n\n   A.根据实际输入$x$和参数$\\theta$预测输出，\n   \n   B. 根据预测输出值和实际输出值之间的差距，计算损失函数$J(\\theta)$，\n   \n   C. 计算损失函数对$\\theta$的梯度，\n   \n   D. 更新参数$\\theta$。\n\n\n## 3- 实现单变量线性回归模型 \n\n现在，我们开始实现 Regression 算法。\n\n### **任务1：** \n首先在$X$前面加上一列1，表示参数$\\theta_0$的系数，方便运算。$X$是形状为$(m,1)$的矩阵，一共$m$行数据，我们需要为每一行数据的前面加一列1，如下所示：  \n$$\n\\begin{bmatrix} x^{(0)} \\\\ x^{(1)} \\\\ \\vdots \\\\x^{(m-1)}  \\end{bmatrix} \\longrightarrow\n\\begin{bmatrix} 1\\quad x^{(0)} \\\\ 1\\quad x^{(1)} \\\\ \\vdots \\\\ 1\\ x^{(m-1)}  \\end{bmatrix}。\n$$\n**提示**：可以使用`np.hstack`把两个矩阵水平合在一起。用1初始化向量或矩阵的函数是`np.ones`。(函数详情可使用python的帮助函数`help`，比如`help(np.ones)`，或者自行用搜索引擎检索。)\n\n```\ndef preprocess_data(X):\n    \"\"\"输入预处理 在X前面加一列1\n    参数：\n        X:原始数据,shape为(m,1)\n\t返回：\n    \tX_train: 在X加一列1的数据,shape为(m,2)\n\t\"\"\"\n\nm = X.shape[0]   # m 是数据X的行数\n\n### START CODE HERE ###\n\ntemp=np.ones((m,1))\nX_train = np.hstack((temp,X))\n\n### END CODE HERE ###\n\nreturn X_train\n```\n\n```\nX = preprocess_data(X_raw)\nprint('new X shape:',X.shape)\nprint('Y shape:',Y.shape)\nprint('new X[:5,:]=\\n',X[:5,:])\nprint('Y[:5,:]=\\n',Y[:5,:])\n```\n\n结果\n\n```\nnew X shape: (80, 2)\nY shape: (80, 1)\nnew X[:5,:]=\n [[ 1.   38.24]\n [ 1.   36.53]\n [ 1.   32.92]\n [ 1.   26.59]\n [ 1.   20.05]]\nY[:5,:]=\n [[4.04]\n [2.84]\n [3.2 ]\n [3.42]\n [2.32]]\n```\n\n### **任务2：** \n接着，初始化参数向量$\\theta$。$\\theta$的shape是$(2,1)$，我们随机初始化$\\theta$。\n\n**提示**：numpy的随机函数是`np.random.rand`。\n\n```\ndef init_parameter(shape):\n    \"\"\"初始化参数\n    参数：\n        shape: 参数形状\n\t返回：\n    \ttheta_init: 初始化后的参数\n\t\"\"\"\n\nnp.random.seed(0)\nm, n = shape\n\n### START CODE HERE ###\n\ntheta_init = np.random.rand(m,n)\n\n### END CODE HERE ###\n\nreturn theta_ini\n```\n\n```\ntheta = init_parameter((2,1))\nprint('theta shape is ',theta.shape)\nprint('theta = ',theta)\n```\n\n结果\n\n```\ntheta shape is  (2, 1)\ntheta =  [[0.5488135 ]\n [0.71518937]]\n```\n\n### **任务3：** \n通过已知 $X$ 和参数 $\\theta$ 计算预测的 $predict\\_Y$ 值。\n\n由于使用`for`循环单独计算每个预测值效率不高，因此我们需要用向量化的方法代替`for`循环。$X$ 大小为$m \\times (n+1)$($n$表示特征数量，这里$n=1$)，每行是一条样本特征向量，$\\theta$ 大小为$(n+1) \\times 1$，可以使用$X \\theta$（矩阵相乘）计算所有样本的预测结果,大小为$m\\times 1$。于是这里的线性模型就可以表示为：\n$$\nh_{\\theta}(X) = X \\theta。\n$$\n这里$h_{\\theta}(X)$的大小为$m \\times 1$，结果上等于 $predict\\_Y_\\theta$。\n\n**提示**：矩阵相乘 `np.dot(矩阵1，矩阵2)`。\n\n```\ndef compute_predict_Y(X,theta):\n    \"\"\"计算预测结果\n    参数：\n        X: 训练集数据特征,shape: (m, 2)\n        theta: 参数,shape: (2, 1)\n\t返回：\n    \tpredict_Y: 预测结果,shape: (m,1)\n\t\"\"\"\n\n### START CODE HERE ###\n\npredict_Y = np.dot(X,theta)\n\n### END CODE HERE ###\n\nreturn predict_Y\n\npredict_Y = compute_predict_Y(X,theta)\nprint(predict_Y[:5])\n```\n\n结果\n\n```\n[[27.89765487]\n [26.67468106]\n [24.09284744]\n [19.56569876]\n [14.8883603 ]]\n```\n\n### **任务4：** \n实现计算损失函数$J(\\theta)$的函数。   \n从公式\n$$\n\\begin{aligned}\nJ(\\theta) = \\frac{1}{2m} \\sum_{i=1}^{m} \\left ( predict\\_y_\\theta^{(i)} - y_\\theta^{(i)} \\right )^2\n\\end{aligned}\n$$\n可以看到有个求和，由于使用`for`循环效率不高，因此需要用向量化的方法代替`for`循环。$(predict\\_Y - Y)^2$计算所有样本的损失值，最后求和并除以$2m$得到$J(\\theta)$的值，得到的$J(\\theta)$是一个标量。   \n**提示**：矩阵乘法运算可使用`np.dot`函数，平方运算可使用`np.power(data, 2)`函数，求和运算可使用`np.sum`。\n\n```\ndef compute_J(predict_Y, Y):\n    \"\"\"计算损失的函数J\n    参数：\n        predict_Y: 预测结果,shape: (m, 1)\n        Y: 训练集数据标签,shape: (m, 1)\n\t返回：\n    \tloss: 损失值\n\t\"\"\"\n\nm = Y.shape[0]\n\n### START CODE HERE ###\n\nloss = np.sum(np.power((predict_Y-Y),2))/(2 * m)\n\n### END CODE HERE ###\n\nreturn loss\n```\n\n```\nfirst_loss = compute_J(predict_Y, Y)\nprint(\"first_loss = \", first_loss)\n```\n\n结果\n\n```\nfirst_loss =  144.05159786255672\n```\n\n### **任务5：**\n计算参数$\\theta$的梯度。梯度计算的公式为：\n$$\n\\frac{\\partial J(\\theta)}{\\partial \\theta_j} = \\frac{1}{m} \\sum_{i=1}^{m} \\left ( \\theta^T x^{(i)} - y \\right ) x_j^{(i)}。\n$$\n向量化公式为：\n$$\n\\text{gradients} =\\frac{1}{m} X^T (X \\theta - Y) 。\n$$\n**提示**：矩阵A的转置表示为`A.T`。$X\\theta$就是计算出的predict_Y。\n\n```\ndef compute_gradient(predict_Y, Y, X):\n    \"\"\"计算对参数theta的梯度值\n    参数：\n        predict_Y: 当前预测结果,shape: (m,1)\n        Y: 训练集数据标签,shape: (m, 1)\n        X: 训练集数据特征,shape: (m, 2)\n\t返回：\n    \tgradients: 对theta的梯度,shape:(2,1)\n\t\"\"\"\n\nm = X.shape[0]\n\n### START CODE HERE ###\n\ngradients = np.dot(X.T,predict_Y-Y) / m\n\n### END CODE HERE ###\n\nreturn gradients\n```\n\n```\ngradients_first = compute_gradient(predict_Y, Y, X)\nprint(\"gradients_first shape : \", gradients_first.shape)\nprint(\"gradients_first = \", gradients_first)\n```\n\n结果\n\n```\ngradients_first shape :  (2, 1)\ngradients_first =  [[ 16.0079445 ]\n [459.96770081]]\n```\n\n### **任务6：**\n用梯度下降法更新参数$\\theta$,实现`update_parameters`函数。\n\n**提示**：parameters = $\\theta$ - $learning\\_rate·gradients$\n\n```\ndef update_parameters(theta, gradients, learning_rate=0.0001):\n    \"\"\"更新参数theta\n    参数：\n        theta: 参数,shape: (2, 1)\n        gradients: 梯度,shape: (2, 1)\n        learning_rate: 学习率,默认为0.0001\n\t返回：\n    \tparameters: 更新后的参数,shape: (2, 1)\n\t\"\"\"\n\n### START CODE HERE ###\nparameters = theta - learning_rate * gradients\n### END CODE HERE ###\n\nreturn parameters\n```\n\n```\ntheta_one_iter = update_parameters(theta, gradients_first)\n\nprint(\"theta_one_iter = \", theta_one_iter)\n```\n\n结果\n\n```\ntheta_one_iter =  [[0.54721271]\n [0.6691926 ]]\n```\n\n### **任务7：**\n将前面定义的函数整合起来，实现完整的模型训练函数。\n\n$\\theta$迭代更新 `iter_num`次。迭代次数`iter_num`也是一个超参数，如果`iter_num`太小，损失函数$J(\\theta)$还没有收敛；如果`iter_num`太大，损失函数$J(\\theta)$早就收敛了，过多的迭代浪费时间。\n\n```\ndef model(X, Y, theta, iter_num = 100, learning_rate=0.0001):\n    \"\"\"线性回归模型\n    参数：\n        X: 训练集数据特征,shape: (m, n+1)\n        Y: 训练集数据标签,shape: (m, 1)\n        iter_num: 梯度下降的迭代次数\n        theta: 初始化的参数,shape: (n+1, 1)\n        learning_rate: 学习率,默认为0.0001\n    返回：\n        loss_history: 每次迭代的损失值\n        theta_history: 每次迭代更新后的参数\n        theta: 训练得到的参数\n    \"\"\"\n\nloss_history = []\ntheta_history = []\n\nfor i in range(iter_num):\n    ### START CODE HERE ###\n    # 预测\n​    predict_Y = compute_predict_Y(X,theta)\n    # 计算损失\n​    loss = compute_J(predict_Y,Y)\n    # 计算梯度\n​    gradients = compute_gradient(predict_Y,Y,X)\n    # 更新参数\n​    theta = update_parameters(theta,gradients,learning_rate)\n    ### END CODE HERE ###\n​    loss_history.append(loss)\n​    theta_history.append(theta)\n\nreturn loss_history, theta_history, theta\n```\n\n```\n# 感兴趣的同学可以自行尝试不同的学习率和迭代次数，最后提交时以100次迭代和0.0001的学习率重新运行一遍再提交\n\nloss_history, theta_history, theta = model(X, Y, theta, iter_num=100, learning_rate=0.0001)\n\nprint(\"theta = \", theta)\n\nplt.plot(loss_history)\nprint(\"loss = \", loss_history[-1])\n```\n\n下面是学习到的线性模型与原始数据的关系可视化。\n\n```\nplt.scatter(X[:,1],Y)\nx = np.arange(10,42)\nplt.plot(x,x*theta[1][0]+theta[0][0],'r')\n```\n\n现在直观地了解一下梯度下降的过程。\n\n```\ntheta_0 = np.linspace(0, 1, 50)\ntheta_1 = np.linspace(0, 1, 50)\ntheta_0, theta_1 = np.meshgrid(theta_0,theta_1)\nJ = np.zeros_like(theta_0)\npredict_Ys = np.zeros_like(predict_Y)\nprint(theta_0.shape)\nprint(theta_1.shape)\nprint(predict_Ys.shape)\nprint(J.shape)\n\nfor i in range(50):\n    for j in range(50):\n        predict_Y = compute_predict_Y(X, np.array([[theta_0[i,j]],[theta_1[i,j]]]))\n        J[i,j] = compute_J(predict_Y, Y)\n\nplt.contourf(theta_0, theta_1, J, 10, alpha = 0.6, cmap = plt.cm.coolwarm)\nC = plt.contour(theta_0, theta_1, J, 10, colors = 'black')\n\n# 画出损失函数J的历史位置\n\nhistory_num = len(theta_history)\ntheta_0_history = np.zeros(history_num)\ntheta_1_history = np.zeros(history_num)\nfor i in range(history_num):\n    theta_0_history[i],theta_1_history[i] = theta_history[i][0,0],theta_history[i][1,0]\nplt.scatter(theta_0_history, theta_1_history, c=\"r\")\n```\n\n可以看到，$J(\\theta)$的值不断地往最低点移动。在y轴，$J(\\theta)$下降的比较快，在x轴，$J(\\theta)$下降的比较慢。\n\n## 4- 实现多变量线性回归模型\n\n上述例子是单变量回归的例子，样本的特征只有一个一天的最高温度。负责人经过分析后发现，城市一天的峰值用电量还与城市人口有关系，因此，他在回归模型中添加城市人口变量$x_2$，你的任务是训练这个多变量回归方程：\n$$\nh(x) = \\theta^T x = \\theta_0 * 1 + \\theta_1 * x_1 + \\theta_2 * x_2。\n$$\n之前实现的梯度下降法使用的对象是$\\theta$和$X$向量，实现的梯度下降函数适用于单变量回归和多变量回归。不难发现上面使用的向量化公式在多变量回归里依然不变，因此代码也基本一致,直接调用前面实现的函数即可。\n\n### **任务8：** \n现在，训练一个多变量回归模型。\n\n```\n#读取数据，X取data的前两列\nX = data[:,0:2].reshape(-1, 2)\nY = data[:,2].reshape(-1, 1)\n\n### START CODE HERE ###\n# 直接调用上面实现过的函数\n# 同样为X的前面添加一列1,使得X的shape从80x2 -> 80x3\nX = preprocess_data(X)\n# 初始化参数theta ,theta的shape应为 3x1\ntheta = init_parameter((3,1))\n# 传入模型训练,learning_rate设为0.0001\nloss_history, theta_history, theta = model(X,Y,theta,iter_num=100,learning_rate=0.0001)\n### END CODE HERE ###\n\nprint(\"theta = \", theta)\n\nplt.plot(loss_history)\nprint(\"loss = \", loss_history[-1])\n```\n\n结果\n\n```\ntheta =  [[0.52593585]\n [0.06715361]\n [0.57583208]]\nloss =  0.10300473270580184\n```\n\n## 5- 特征归一化\n\n特征归一化可以确保特征在相同的尺度，加快梯度下降的收敛过程。\n\n### **任务9：** \n对数据进行零均值单位方差归一化处理。零均值单位方差归一化公式：\n$$\nx_i = \\frac{x_i - \\mu_i}{\\sigma_i}\n$$\n其中$i$表示第$i$个特征，$\\mu_i$表示第$i$个特征的均值，$\\sigma_i$表示第$i$个特征的标准差。进行零均值单位方差归一化处理后，数据符合标准正态分布，即均值为0，标准差为1。\n\n**注意**，使用新样本进行预测时，需要对样本的特征进行相同的缩放处理。\n\n**提示**：求特征的均值，使用numpy的函数`np.mean`;求特征的标准差，使用numpy的函数`np.std`，需要注意对哪个维度求均值和标准差。比如，对矩阵A的每列求均值`np.mean(A,axis=0)`。\n\n```\nX = data[:,0:2].reshape((-1, 2))\nY = data[:,2].reshape((-1, 1))\n\n### START CODE HERE ###\n# 计算特征的均值 mu\nmu = np.mean( X , axis=0 )\n# 计算特征的标准差 sigma\nsigma = np.std( X , axis=0 )\n# 零均值单位方差归一化\nX_norm = ( X - mu ) / sigma\n# 训练多变量回归模型\n# X_norm前面加一列1\nX = preprocess_data(X_norm)\n# 初始化参数theta\ntheta = init_parameter((3,1))\n# 传入模型训练,learning_rate设为0.1\nloss_history, theta_history, theta = model(X,Y,theta,iter_num = 100, learning_rate=0.1)\n### END CODE HERE ###\n\nprint(\"mu = \", mu)\nprint(\"sigma = \", sigma)\n\nprint(\"theta = \", theta)\n\nplt.plot(loss_history)\nprint(\"loss = \", loss_history[-1])\n```\n\n我们来直观地了解特征尺度归一化的梯度下降的过程。这里只展示单变量回归梯度下降过程。\n\n```\nX_show = X[:,0:2]\nX_show = preprocess_data(X_show)\n\ntheta_0 = np.linspace(-2, 3, 50)\ntheta_1 = np.linspace(-2, 3, 50)\ntheta_0, theta_1 = np.meshgrid(theta_0,theta_1)\nJ = np.zeros_like(theta_0)\n\nfor i in range(50):\n    for j in range(50):\n        predict_Y = compute_predict_Y(X_show, np.array([[2.877],[theta_0[i,j]],[theta_1[i,j]]]))\n        J[i,j] = compute_J(predict_Y, Y)\n\nplt.contourf(theta_0, theta_1, J, 10, alpha = 0.6, cmap = plt.cm.coolwarm)\nC = plt.contour(theta_0, theta_1, J, 10, colors = 'black')\n\n# 画出损失函数J的历史位置\n\nhistory_num = len(theta_history)\ntheta_0_history = np.zeros(history_num)\ntheta_1_history = np.zeros(history_num)\nfor i in range(history_num):\n    theta_0_history[i],theta_1_history[i] = theta_history[i][2,0],theta_history[i][1,0]\nplt.scatter(theta_0_history, theta_1_history, c=\"r\")\n```\n\n可以看到，$J(\\theta)$的值不断地往最低点移动。与没有进行特征尺度归一化的图相比，归一化后，每个维度的变化幅度大致相同，这有助于$J(\\theta)$的值快速下降到最低点。\n\n## 6- 法线方程 (The normal equations)\n\n对于求函数极小值问题，可以使用求导数的方法，令函数的导数为0，然后求解方程，得到解析解。法线方程正是使用这种方法来求解损失函数$J(\\theta)$的极小值，而线性回归的损失函数$J(\\theta)$是一个凸函数，所以极小值就是最小值。\n\n法线方程的求解过程详见课件，法线方程的公式是：\n$$\n\\theta = (X^T X)^{-1} X^T Y\n$$\n\n如果$m \\le n +1$，那么$X^T X$是奇异矩阵，即$X^T X$不可逆。\n$X^T X$不可逆的原因可能是：\n\n- 特征之间冗余，比如特征向量中两个特征是线性相关的。\n- 特征太多，删去一些特征再进行运算。\n\n法线方程的缺点之一就是会出现$X^T X$不可逆的情况，可以通过正则化的方式解决。另一个缺点是，如果样本的个数太多，特征数量太多($n \\gt 10000$)，法线方程的运算会很慢（求逆矩阵的运算复杂）。\n\n### **任务10：** \n下面来实现法线方程。  \n**提示**：Numpy 求逆矩阵的函数是`np.linalg.inv`。\n\n```\ndef normal_equation(X, Y):\n    \"\"\"法线方程求解线性回归方程的参数\n    参数：\n        X: 训练集数据特征,shape: (m, n+1)\n        Y: 训练集数据标签,shape: (m, 1)\n    返回：\n        theta: 线性回归方程的参数\n    \"\"\"\n\n### START CODE HERE ###\ntheta = np.dot(np.dot(np.linalg.inv(np.dot(X.T,X)),X.T),Y)\n### END CODE HERE ###\n\nreturn theta\n```\n\n```\ntheta = normal_equation(X, Y)\n\nprint(\"theta = \", theta)\n```\n\n结果\n\n```\ntheta =  [[2.861875  ]\n [0.70429906]\n [0.04092011]]\n```\n\n可以自行对比一下直接用正规方程求解出的$\\theta$与用线性回归模型训练出的$\\theta$之间的差异，会\"惊奇\"地发现两者几乎一模一样。\n\n## 7- 预测结果 \n\n### **任务11：** \n假设明天的最高温度是$x_1 = 40$°C，人口$x_2 = 3.3$百万，使用通过正规方程计算得到的$\\theta$预测明天的城市的峰值用电量（单位：GW）吧！  \n**注意**，$x$要进行同样的特征尺度归一化处理。\n\n```\ndef predict(theta,x):\n    \"\"\"预测峰值用电量\n    参数：\n        X: 需要预测数据的特征,shape: (m, n+1), 这里只预测一天的结果, m=1\n        theta: 最终确定的参数,shape: (n+1, 1)\n    返回：\n        prediction: 预测结果,shape: (m, 1)\n    \"\"\"\n\n### START CODE HERE ###\n\n# 零均值单位方差归一化\nx = (x-mu)/sigma\n# 在x前面加一列\nx = np.hstack([[[1]],x])\n#用theta和处理后的x计算预测值\nprediction = np.dot(theta.T,x.T)\n### END CODE HERE ###\n\nreturn prediction\n\n#明天的特征\nx = np.array([[40,3.3]])\nprint('预计明天的峰值用电量为：%.2f GW'%(predict(theta,x))) \n```\n\n结果\n\n```\n预计明天的峰值用电量为：4.25 GW\n```\n\n## 8- 多项式回归\n以上都是线性模型，当我们数据的特征$X$与预测结果$Y$之间没有明显的线性关系，而且又找不到合适的映射函数时，可以尝试多项式回归。\n下面导入另一组最高气温与用电量数据，我们用线性模型试一试看看效果发现并不太好。\n\n```\ndata1 = np.loadtxt('data1.txt')\nX = data1[:,0].reshape(-1,1)\nY = data1[:,1].reshape(-1,1)\n\nplt.scatter(X,Y)\nX = np.hstack((np.ones((X.shape[0],1)),X))\ntheta = normal_equation(X,Y)\nplt.plot(np.sort(X[:,1]),np.dot(X,theta)[np.argsort(X[:,1])],'r')\n```\n\n多项式回归的最大优点就是可以通过增加$X$的高次项对实测点进行逼近，直至满意为止。事实上，多项式回归可以处理相当一类非线性问题，它在回归分析中占有重要的地位，**因为任一函数都可以分段用多项式来逼近**。因此，在通常的实际问题中，不论依变量与其他自变量的关系如何，我们总可以用多项式回归来进行分析。假设数据的特征只有一个$a$，多项式的最高次数为$K$，那么多项式回归方程为：\n$$\nh(x) = \\theta^T x = \\theta_0 \\times a^0 + \\theta_1 \\times a^1 + \\theta_2 \\times a^2 + \\cdots + \\theta_K \\times a^K。\n$$\n若令$x = \\begin{bmatrix} a^0, a^1, a^2, \\cdots, a^K \\end{bmatrix}^T$，那么\n$$\nh(x) = \\theta^T x = \\theta_0 \\times x_0 + \\theta_1 \\times x_1 + \\theta_2 \\times x_2, \\cdots, \\theta_K \\times x_K，\n$$\n这就变为多变量线性回归了。\n\n### **任务12：**\n现在想要得到一个如下的多项式模型，$K=2$，直接用上面的正规方程进行求解。\n$$\n    h(x) = \\theta^T x = \\theta_0 \\times 1 + \\theta_1 \\times x + \\theta_2 \\times x^2。\n$$\n输入数据$X$变为:\n$$\n\\begin{bmatrix} x^{(0)} \\\\ x^{(1)} \\\\ \\vdots \\\\x^{(m-1)}  \\end{bmatrix} \\longrightarrow\n\\begin{bmatrix} 1\\quad x^{(0)}\\quad {x^{(0)}}^2 \\\\ 1\\quad x^{(1)} \\quad {x^{(1)}}^2\\\\ \\vdots \\\\ 1\\ x^{(m-1)}\\quad {x^{(m-1)}}^2  \\end{bmatrix}。\n$$\n```\ndata1 = np.loadtxt('data1.txt')\nX = data1[:,0].reshape(-1,1)\nY = data1[:,1].reshape(-1,1)\n\nm = X.shape[0]    # m 是数据X的行数\nX_square = np.power(X,2)\n\n### START CODE HERE ###\n\n# 对X 前面加1， 后面加平方，变为 m x 3 的矩阵\n\nX = np.hstack((np.ones((m,1)),X))\nX = np.hstack((X,X_square))\n\n# 用法线方程求解theta\n\ntheta = normal_equation(X,Y)\n\n### END CODE HERE ###\n\nplt.scatter(X[:,1],Y)\nplt.plot(np.sort(X[:,1]),np.dot(X,theta)[np.argsort(X[:,1])],'r')\n```\n\n所有任务到这里就结束了，下面是对上面的数据进行任意多项式拟合的结果，你可以通过改变$K$的值来调整多项式的阶数，看看不同模型的效果(但不设的太大, $K \\le 193$)。可以看到，越复杂的模型，虽然拟合数据的效果越好，但是其泛化能力就会很差，所以模型的选择应该要尽量符合实际需求。\n\n```\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import StandardScaler\n\ndef PolynomialRegression(degree):\n    return Pipeline([\n        (\"poly\",PolynomialFeatures(degree=degree)),\n        (\"std_scaler\",StandardScaler()),\n        (\"lin_reg\",LinearRegression())    \n    ])\nX = data1[:,0].reshape(-1,1)\nY = data1[:,1].reshape(-1,1)\n\nK = 15  #可以调整K的值(0<=K<=193)\n\npoly_reg = PolynomialRegression(degree=K)\npoly_reg.fit(X,Y.squeeze())\ny_predict = poly_reg.predict(X)\nplt.scatter(X,Y)\nplt.plot(np.sort(X[:,0]),y_predict[np.argsort(X[:,0])],color='r')\n```\n\n## 学习调包sklearn (Optional)\n\n```\nimport matplotlib.pyplot as plt\nplt.rcParams[\"font.sans-serif\"]=[\"SimHei\"] #设置字体\nplt.rcParams[\"axes.unicode_minus\"]=False #该语句解决图像中的“-”负号的乱码问题\n\ndata = np.loadtxt(\"data.txt\")\n# data 数据第一列为人口信息\nX_data = data[:, 0].reshape(-1,1)\n# data 数据第三列为城市峰值用电量\ny_data = data[:, 2].reshape(-1,1)\nprint(\"X shape: \", X_data.shape)\nprint(\"y shape: \", y_data.shape)\n```\n\n结果\n\n```\nX shape:  (80, 1)\ny shape:  (80, 1)\n```\n\n```\nfrom sklearn.linear_model import LinearRegression\nlinear_reg = LinearRegression()\n\nlinear_reg.fit(X_data, y_data)\n\nX_test = np.array([[8], [45]])\ny_pred = linear_reg.predict(X_test)\nplt.plot(X_data,y_data,\".\")\nplt.plot(X_test, y_pred,\"r-\")\nplt.xlabel(\"Temperture\")\nplt.ylabel(\"PeakDemand\")\nplt.title(\"Linear Regression model predictions\")\nplt.show()\n```\n\n","tags":["机器学习"]},{"title":"刘梦熊：问题在经济 根子在政治","url":"/2023/09/11/28/","content":"\n来源：联合早报 2023年8月21日\n\n导语：在美国和西方发达国家，经济繁荣、衰退、复苏、繁荣周而复始，有其周期性和相应的经济对策。但中国是政治挂帅，政治凌驾经济，而且习惯只算政治账，不算经济账。当前中国经济盛极而衰， 正是由于中共只搞局部经济体制改革，迟迟不启动政治体制改革带来的恶果。\n\n当前中国经济面临私企倒闭潮、外企撤离潮、投资大幅萎缩潮、出生人口下降潮、消费严重不足潮、债务连环爆煲潮，员工大规模失业潮，政府财税失血潮…………投资、出口、消费三大经济引擎全部动力不足乃至死火。中国国家统计局日前公布的7月份经济数据，不是疲弱下挫就是远逊预期，明显呈现通缩特征。第二季度外资投资额只有区区49亿美元，同比下跌87%！中国恒大、碧桂园两大房地产巨头“债可敌国”，象征整个行业崩溃累及相连产业陷入危机……以致美国总统拜登惊呼，中国经济下滑对世界犹如“定时炸弹”。\n\n中国坊间流传段子：“经济新三大引擎是国家统计局、中宣部、新华社”，“挽救经济的工具箱里只剩喇叭(意即“靠吹”)” 。作为世界第二大经济体的中国，自改革开放以来一路高歌猛进，为何数年之间风云突变，急剧下滑？一句话：问题在经济，根子在政治。\n\n中国是当今世上经济被政治捆绑得最厉害的国家，没有之一！1966年至1976年文化大革命，国民经济到了崩溃边缘。 1978年5月，胡耀邦推动”实践是检验真理的唯一标准”的思想解放运动，大力平反冤假错案，解放大批老干部；为所谓“地主， 富农、反革命分子、坏分子、右派分子”摘帽，恢复公民权；在这基础上，1978年底，在邓小平等老一辈领导人推动下，中共十一届三中全会果断中止“阶级斗争为纲”，将工作重心转移到“经济建设为中心”，开启了改革开放新时期。这之后， 农村改革，废除人民公社制，包产到户；开放沿海城市；允许私营企业进入市场，大量吸收劳动力；到海外招商引资，港澳台、美欧日企业不仅带进资金、先进科学技术、成套设备，而且引进市场经济、法治、知识产权，现代企业管理制度等观念；随着2001年中国加入世界贸易组织(WTO)，更加搭上经济全球化快车，在国际分工中成为世界工厂，积累了世界最丰厚的外汇储备，成为世界第二大经济体。\n\n**A. 中美友好是经济发展重要动力**\n\n必须指出，改革开放之初，邓小平等老一辈领导人努力达成如下党内共识：中国要实现现代化， 一定要搞改革开放；而开放和引进的主要对像是美国。因此，改善和发展对美关系，是改革开放的内在要求，也是冷战格局下确保国家安全的根本要求。事实上，从美国给予中国最惠国贸易待遇到支持中国加入WTO，对中国开放市场，大量进口中国商品；美国企业大规模投资中国；向中国输出尖端科技；每年为中国培养大量留学人材，中美友好互利共赢，亦成为中国经济发展重要动力之一。\n\n改革开放30多年是稳步上升轨，近年来却陷入螺旋式下降轨，透过现像看本质，令经济逆转最根本原因在政治。\n\n第一，中国经济上升期主因是中共政治上中止阶级斗争为纲，坚持经济建设为中心，因而解放了生产力。近年经济恶化，主因是政治上强化意识形态，坚持”马克思是对的”，消灭私有制，强调斗争哲学，滥用国家安全、反间谍概念，对投资者和专业人士造成动辄误触法网的心理威胁，导致外商和游客对中国裹足不前。\n\n第二，经济上升期是在认识上坚持市场在资源配置方面的决定性作用，在政策上鼓励私营企业发展，保护”傻子瓜子”年广久一类民营企业家的合法权益和人身安全。\n\n但近年经济滑坡重要原因之一是“国进民退” 的恶果：在认知上片面强调“党领导一切”，与中共十三大报告“党政分开，政企分开”改革方向背道而驰，在私企、外企设立党委、党支部，令国务院颁布的《公司法》《物权法》规定的企业自主权形同虚设，私企因此担心随时会发生”第二次公私合营”。此外，在舆论上“消灭私有制”、“私营经济退场论”、“私企职工共管共享论”此起彼伏，令投资者人心惶惶。\n\n在政策上，地方政府视私企为韭菜，由“乱收费、乱摊派、乱罚款”发展到“乱立案、乱抓人、 乱没收”，将对私企的罚款没收作为政府创收手段 之一。河北省著名农民企业家孙大午被罗织罪名入狱，大午集团巨额资产被价拍走，巧取豪夺令人心寒！所谓“行业整顿”充满随意性，一纸公文消灭一个行业，毁掉一批上市公司并非神话，而是现实!\n\n**B. 勒令移民公司交出移民档案**\n\n种种不公正待遇令私营企业家发出“利用我们是你们(中共)无奈的选择，消灭我们是你们(中共)崇高的理想”的哀鸣，投资信心尽失，因而”润(RUN)”意顿生。\n\n如今，当局又透过打击移民公司，勒令交出移 民档案企图刹止“润潮”。中国私人企业和国际外资企业都是私有制的产物，目睹私企悲惨遭遇，外企自然兔死狐悲，心有余悸，感觉中国投资环境充 满不确定性和不稳定性，从而避之则吉。私企、外企两大经济主力军信心大失，中国经济岂能不走下坡？\n\n第三，经济上升期重要原因，是中共在思想上强调“实践是检验真理的唯一标准”，提倡“实事求是，解放思想”，令整个社会形成允许独立思考、敢于探索，有利于激发原创动力的良好氛围。故此人才辈出，万众创业，明星企业大量涌现，促进生产力发展。但近年经济倒退的重要背景之一， 正是有人违反中共中央第二份历史决议关于“禁止任何形式的个人崇拜”规定，鼓吹“忠诚不绝对， 绝对不忠诚”，宣扬“定于一尊，一锤定音”，把个人崇拜推向新的高峰。\n\n后邓小平时代形成的集体领导格局无疾而终， 干部队伍中吹牛拍马之辈当红得道，弹冠相庆。相反，正直敢言能干之士遭逆向淘汰；加上乱划敏感词汇，乱订封号标准的言论、网络监控，导致社会上万马齐喑，纠错机制缺位，以致违反经济规律、 违反科学规律、违反自然规律乃至违反地缘政治规律的充满随意性拍板畅通无阻，给经济运行带来巨大冲击和惨重损失。\n\n**C. 泛政治化环境窒碍经济发展**\n\n例如冠病疫情三年，泛政治化成风，将明明是科学问题的公共卫生政策探讨，无限上纲为制度之争，提出不切实际的“坚持动态清零不动摇”口号，任意封城封路封关，停工停业停产，企业的生产、流通、营运惨遭腰斩，居民的人权、人身自由、人格尊严乃至居住权、财产权被恣意践踏，造成次生灾害远大于病毒本身，令世界工厂的产业链、供应链受到重创，是中国继大跃进、文革浩劫之后的第三次大折腾，经济损失惨重、公民权利受到破坏，政府公信力跌落且后患无穷!\n\n又如最近的河北省水灾，违反“水往低处流” 自然法则，让海拔较高的涿州为“保护”海拔较低 的雄安新区，无端成了泄洪区。涿州市民被拍脑袋工程祸害，人命财产损失惨重，是典型的三分天灾，七分人祸。\n\n如此投资环境，令人不寒而栗，自然窒碍了经济发展。\n\n第四，经济上升期重要动力之一，是中国在外交上将中美友好关系放到重中之重地位。正是2001 年九一一事件发生后，中国第一时间表态支持美国反恐，美国遂投桃报李支持中国加入WTO，让中国获得最大红利。但近年中国经济下挫，却与战狼外交有直接关连：君不见前几年国内一片“厉害了， 我的国”，自嗨，狂言“中国已在经济上、科技上、 综合国力上全面超越美国”；扬言“双赢就是中国赢两次”；明明还是一个发展中国家，却动辄宣称中国在某某领域“为人类指明方向”云云。\n\n国际交往欠缺风度，将毛泽东、周恩来的“外交无小事” “有理 有利有节” 遗训抛到九霄云外，撒野成惯性，四面树敌。尤其是去年2月俄罗斯侵略乌克兰以来，一不定性俄方行径为侵略，二对俄侵略罪行坚持不作谴责，三依然宣称“中俄友好无上限，合作无禁区”“会在各方面予以策应”; 中国舆论场叫嚣“俄罗斯的特别军事行动是反对美国霸权主义的正义斗争”……并且在大多数国家对俄侵乌的谴责声中，坚持与俄罗斯频繁进行海陆空联合军演，以致俄罗斯国防部长绍伊古表白“俄中不仅仅是盟友关系”。\n\n连年推行战狼外交的结果，令中美关系跌到 1972年尼克逊总统访华以来最低点，中欧、中英、 中日、中韩、中澳、中加等关系全部跌至几十年来谷底。一带一路、大撒币的结果，只是糟蹋了中国老百姓的民脂民膏，并没有换来真正盟友。\n\n在中共强调“马克思主义行”根本价值观、与俄罗斯抱团取暖，单方面宣布“中英联合声明过时失效”、部署武统台湾等一系列事态演变面前，美国及西方发达国家盟友却意识到，基于国家安全和对以规则为基础国际秩序的维护，有必要“去风险化”，减少对中国产业链，供应链的依赖，并在高科技领域的对华投资、交易予以脱钩，避免养虎为患，反噬自己。\n\n古人云成也萧何败也萧何。外交上亲俄反美的实质表现，理所当然令中国逐渐失去美国和西方的资金、技术、市场，实际上终结了改革开放，重回闭关锁国，其必然趋势则是中国经济大幅萎缩、失业压力山大、广大民众重新返贫。\n\n常言道：经济是基础，政治是经济的集中表现，又曰“外交是内政的延续”。在美国和西方发 达国家，经济繁荣、衰退、复苏、繁荣周而复始， 有其周期性和相应的经济对策。但中国是政治挂帅，政治凌驾经济，而且习惯只算政治账，不算经济账。当前中国经济盛极而衰，正是由于中共只搞局部经济体制改革，迟迟不启动政治体制改革带来的恶果!\n\n**D. 不受制衡绝对权力才是最大腐败**\n\n企图回归改革开放前那套原教旨社会主义，甚至回到阶级斗争为纲、个人崇拜盛行的毛泽东文革时代，以此求得保住共产党的政权安全，只会让僵化的斯大林政治体制下产生的各种社会矛盾越积越多，越激越大。由此令私企痛感君子不立危墙之下，令外商惊悟危邦不入，则中国整个产业链、供应链，资金链将“火烧连营七百里”，这是目前中国经济结构性大坍方，反令共产党政权安全地动山摇的原因。中国前总理温家宝在任内最后一次记者招待会上，曾语重心长地警告：“如果不进行政治体制改革，经济体制改革的成果就会得而复失，类似文化大革命那样的历史悲剧，也有可能重演！”须知不受监督、制约、制衡的绝对权力，才是最大的绝对的腐败，且是各领域包括官场、军队、司法、外援撒币，医疗药业，教育、工程等等腐败的总根子! 药方并不难开：政治体制改革，包括实行宪政、民主、普选制、官员财产申报公示、司法独立、保障言论新闻自由进行舆论监督………是保障经济高速优质发展必由之路。\n\n越南推行革新开放，政治上从党内民主扩展到社会民主，带动经济健康蓬勃发展，对外关系包括对美俄西方及亚细安友好融洽。样板就在眼前。政治造成的经济逆境，必须在政治上对症下药。问题是，从井岗山到延安到西柏坡到登上天安门城楼“一路风尘一路歌”的农民起义军领袖第二代，在“打江山，坐江山”的历史惯性思维下，有通过政治体制改革，实现经济市场化、社会法治化、政治民主化的历史使命感和远见魄力吗?\n","tags":["禁评"]},{"title":"实验二","url":"/2023/05/06/24/","content":"\n# 实验二\n\n## 任务一\n\n- 定义一个视图，包括定单的编号、时间、金额以及收货人的姓名、国家代码和国家名称。\n\n  ```\n  CREATE VIEW OCS (orderNo, orderTime, orderCost, reciName, CountryID, CountryName)\n  AS SELECT Orders.cOrderNo, dOrderDate, mTotalCost, vFirstName+' '+vLastName, Country.cCountryID, cCountry\n  FROM Orders\n  LEFT OUTER JOIN Recipient\n  ON Orders.cOrderNo = Recipient.cOrderNo\n  LEFT OUTER JOIN Country\n  ON Recipient.cCountryId = Country.cCountryId;\n  ```\n\n- 基于（1）中定义的视图，查询所有国家代码为‘001’的收货人的姓名和他们所下定单的笔数及定单的总金额。\n\n  ```\n  SELECT reciName, CountryID, CountryName, count(*) TotalOrders, sum(orderCost) SumOrdercost\n  FROM OCS\n  GROUP BY reciName, CountryName, CountryID\n  HAVING CountryID = '001';\n  \n  ```\n\n- 视图定义如下：\n\n  ```\n  CREATE VIEW vwOrderWrapper\n     AS\n     SELECT cOrderNo, cToyId, siQty, vDescription, mWrapperRate\n     FROM OrderDetail JOIN Wrapper\n     ON OrderDetail.cWrapperId = Wrapper.cWrapperId\n  ```\n\n  执行以下更新命令并分析该命令的执行结果。\n\n  ```\n  UPDATE vwOrderWrapper\n     SET siQty = 2, mWrapperRate = mWrapperRate + 1 \n     WHERE cOrderNo = ‘000001’\n  ```\n\n​\t\t运行结果：视图或函数 'vwOrderWrapper' 不可更新，因为修改会影响多个基表。\n\n​\t\t原因：该视图与两个表相关联\n\n## 任务二\n\n- 在OrderDetail上定义一个触发器，当向OrderDetail表中新增一条记录时，自动修改Toys表中玩具的库存数量（siToyQoh）。\n\n  ```\n  CREATE TRIGGER UpdateSiToyQoh ON OrderDetail\n      AFTER INSERT\n      AS\n          UPDATE Toys\n          SET siToyQoh = siToyQoh - 1\n          WHERE cToyId IN (SELECT cToyId FROM inserted);\n  ```\n\n  测试语句\n\n  ```\n  INSERT INTO OrderDetail VALUES ('000001', '000009', 2, 'N', NULL, NULL, 38.8800);\n  DELETE OrderDetail WHERE cOrderNo = '000001' AND cToyId = '000009';\n  ```\n\n- Orders表是GlobalToyz数据库里的一张核心的表，对这张表上做的任何更新动作（增、删、改）都需要记录下来，这是数据库审计（Audit）的基本思想。要求设计一张表存储对Orders表的更新操作，包括操作者、操作时间、操作类型、更新前的数据、更新后的数据。设计触发器实现对Orders表的审计。\n\n  ```\n  CREATE TABLE Audit(\n      Operator VARCHAR(10),\n      OperateTime DATETIME,\n      OperateWay CHAR(6),\n      OldData VARCHAR(100),\n      NewData VARCHAR(100)\n  )\n  \n  CREATE TRIGGER AuditOrders ON Orders\n      FOR INSERT, DELETE, UPDATE\n      AS BEGIN\n              DECLARE @oper VARCHAR(30) = SYSTEM_USER\n              DECLARE @operTime DATETIME = GETDATE()\n              DECLARE @opway CHAR(6) \n              DECLARE @del INT = (SELECT COUNT(*) FROM deleted)\n              DECLARE @ins INT = (SELECT COUNT(*) FROM inserted)\n              IF @del != 0\n                  IF @ins != 0\n                      SELECT @opway = 'UPDATE'\n                  ELSE\n                      SELECT @opway = 'DELETE'\n              ELSE\n                  SELECT @opway = 'INSERT'\n              DECLARE @olddata VARCHAR(100);\n              DECLARE @newdata VARCHAR(100);\n              SELECT @olddata = (SELECT cOrderNo + CAST(dOrderDate AS VARCHAR(23)) + cCartId +\n                                 cShopperId + cShippingModeId + str(mShippingCharges) +\n                                 str(mGiftWrapCharges) + cOrderProcessed +\n                                 str(mTotalCost) + CAST(dExpDelDate AS VARCHAR(23))\n                          FROM deleted) \n              SELECT @newdata = (SELECT cOrderNo + CAST(dOrderDate AS VARCHAR(23)) + cCartId +\n                                 cShopperId + cShippingModeId + str(mShippingCharges) +\n                                 str(mGiftWrapCharges) + cOrderProcessed +\n                                 str(mTotalCost) + CAST(dExpDelDate AS VARCHAR(23))\n                          FROM inserted) \n              INSERT INTO Audit values (@oper, @operTime, @opway, @olddata, @newdata);\n      END\n  --测试语句\n  INSERT INTO Orders VALUES ('000011', GETDATE(), '000005', '000007', '03', 21, 2, 'Y', 59, GETDATE());\n  UPDATE Orders\n      SET cCartId = '000008'\n      WHERE cOrderNo = '000011'\n  DELETE Orders WHERE cOrderNo = '000011';\n  ```\n\n## 任务三\n\n- 修改表ShoppingCart的结构，在表中新增一个字段‘Status’。该字段取值为1，表示该玩具为本次下订单时要购买的玩具。在表ShoppingCart中生成一些模拟数据。\n\n  ```\n  ALTER TABLE ShoppingCart\n  ADD\n      Status INT CHECK (Status = 0 OR Status = 1) DEFAULT 0;\n      \n  UPDATE ShoppingCart\n  SET Status = (SELECT CAST(FLOOR(RAND(convert(varbinary, newid())) * 2) AS INT))\n  ```\n\n- 当购物者确认定单时，应该包含下面的步骤：\n\n  > 产生新的定单号。\n  >\n  > 定单号，当前日期，购物车ID，和购物者ID加到Orders表中。\n  >\n  > 定单号，玩具ID和数量加到OrderDetail表中。\n  >\n  > 在OrderDetail表中更新玩具成本。（提示：Toy cost = Quantity * Toy Rate）。\n  >\n  > 从ShoppingCart表中将本次已购买的玩具删除。\n\n​\t\t将上述步骤定义为一个事务。编写一个存储过程以购物车ID（cCartId）和购物者ID(cShopperId)为参数，实现这个事务。用在第\t\t（1）题中生成的模拟数据测试存储过程。\n\n```\nCREATE PROCEDURE P\n(\n    @cCartID CHAR(6),\n    @cShopperID CHAR(6)\n)\nAS\n    BEGIN\n        BEGIN TRANSACTION\n            DECLARE @ret INT = 0;\n            DECLARE @ordno CHAR(6) = RIGHT('000000'+CONVERT(CHAR(2),(SELECT max(CAST(cOrderNo AS INT)) FROM Orders) + 1), 6);\n            DECLARE @orddate DATETIME = GETDATE()\n            DECLARE @shipmod CHAR(2) = RIGHT('00'+CONVERT(VARCHAR, CEILING(RAND(convert(varbinary, newid())) * 3)), 2);\n            DECLARE @shipcharge money = CAST(CEILING(RAND(convert(varbinary, newid())) * 90) AS MONEY)\n            DECLARE @num INT = (SELECT COUNT(*) FROM ShoppingCart WHERE cCartId = @cCartID AND Status = 1)\n            IF @num != 0\n                BEGIN\n                    INSERT INTO Orders VALUES\n                    (@ordno, @orddate, @cCartID, @cShopperID, @shipmod, @shipcharge, NULL, 'Y', NULL, @orddate)\n                    DECLARE @ctoyID CHAR(6), @siqty SMALLINT;\n                    DECLARE cursor_temp CURSOR LOCAL SCROLL FOR\n                    (SELECT cToyId, siQty FROM ShoppingCart WHERE cCartId = @cCartID AND Status = 1)\n                    OPEN cursor_temp\n                    FETCH FIRST FROM cursor_temp INTO @ctoyID, @siqty;\n                    WHILE(@@fetch_status = 0)\n                        BEGIN\n                            INSERT INTO OrderDetail VALUES\n                            (@ordno, @ctoyID, @siqty, 'N', NULL, NULL, NULL)\n                            UPDATE OrderDetail\n                            SET mToyCost = siQty * (SELECT mToyRate FROM Toys WHERE Toys.cToyId = @ctoyID)\n                            WHERE cOrderNo = @ordno;\n                            DELETE FROM ShoppingCart\n                            WHERE cToyId = @ctoyID AND cCartId = @cCartID;\n                            FETCH NEXT FROM cursor_temp INTO @ctoyID, @siqty;\n                        END\n                    CLOSE cursor_temp\n                    DEALLOCATE cursor_temp;\n                END\n        IF @ret = 0\n            BEGIN\n                COMMIT TRANSACTION\n                PRINT N'成功更新--finished'\n            END\n        ELSE\n            BEGIN\n                ROLLBACK TRANSACTION\n                PRINT N'Status为0--rollback'\n            END\n    END\ngo\n--测试样例\nEXEC P @cCartID = '000001', @cShopperID = '000015';\nEXEC P @cCartID = '000002', @cShopperID = '000024';\n```\n\n## 任务四\n\n- 基于表Orders和Shopper，以下列格式生成报表：（要求用游标实现）\n\n  >       购货人ID   XXX    购货人姓名   XXX    \n  >       购货人地址  XXXXXX \n  >       定单号XXX  定单时间XXX  定单金额XXX\n  >       定单号XXX  定单时间XXX  定单金额XXX\n\n  ```\n  BEGIN\n      DECLARE @sid CHAR(6), @sname VARCHAR(40), @sAddress VARCHAR(40), @ordno CHAR(6), @ordtime VARCHAR(100), @ordmoney MONEY\n      DECLARE cursor_1 CURSOR LOCAL SCROLL FOR\n      (SELECT Orders.cShopperId, vFirstName + vLastName AS Name, vAddress, cOrderNo, CONVERT(VARCHAR(100), dOrderDate, 120), mTotalCost\n       FROM Orders\n       LEFT OUTER JOIN Shopper\n       ON Orders.cShopperId = Shopper.cShopperId)\n      OPEN cursor_1\n      FETCH FIRST FROM cursor_1 INTO @sid, @sname, @sAddress, @ordno, @ordtime, @ordmoney;\n      PRINT N'订单报表如下:'\n      WHILE (@@fetch_status = 0)\n          BEGIN\n              PRINT N'购货人ID： ' + @sid + CHAR(9) + N'购货人姓名： ' + @sname;\n              PRINT N'购货人地址： ' + @sAddress;\n              PRINT N'订单号： ' + @ordno + N'  订单时间：' + @ordtime + N'  订单金额：' + convert(varchar(10),@ordmoney);\n              FETCH NEXT FROM cursor_1 INTO @sid, @sname, @sAddress, @ordno, @ordtime, @ordmoney;\n          END\n      CLOSE cursor_1\n      DEALLOCATE cursor_1;\n  END\n  ```\n\n- 编写代码，分析玩具和地域的关系，例如哪个城市的购买者对哪一种、哪一类或哪一个品牌的玩具更有兴趣。这道题是个开放的题目，同学们可以按照自己的理解从不同的角度进行分析。实验报告中需给出代码、结果截图和对分析结果的文字描述。\n\n  ```\n  SELECT cCity, cToyId INTO ##T1 FROM Orders\n  LEFT OUTER JOIN OrderDetail\n  ON Orders.cOrderNo = OrderDetail.cOrderNo\n  LEFT OUTER JOIN Shopper\n  ON Orders.cShopperId = Shopper.cShopperId\n  \n  SELECT cCity, ##T1.cToyId, cBrandId, cCategoryId  INTO ##T2 FROM ##T1\n  LEFT OUTER JOIN Toys\n  ON ##T1.cToyId = Toys.cToyId\n  WHERE vToyName IS NOT NULL;\n  \n  SELECT cCity AS N'城市', cBrandName AS N'品牌', COUNT(cBrandName) AS N'总计'\n  INTO ##T3\n  FROM ##T2\n  LEFT OUTER JOIN ToyBrand ON\n  ##T2.cBrandId = ToyBrand.cBrandId\n  GROUP BY cBrandName, cCity\n  \n  --测试案例\n  SELECT TOP 3 城市, 品牌, 总计 FROM ##T3 WHERE 总计 > 1;\n  ```\n","tags":["SQL Server"]},{"title":"实验一","url":"/2023/05/06/23/","content":"\n# 实验一\n\n## 任务一\n\n- 创建一张表Orders_Jan，表的结构与Orders相同，将Orders表中month为‘Jan’的订单记录复制到表Orders_Jan中。\n\n  ```\n  SELECT * \n  INTO Orders_Jan \n  FROM ORDERS \n  WHERE month = 'Jan';\n  ```\n\n- 将Orders表中month为‘Jan’的订单记录全部删掉。\n\n  ```\n  DELETE FROM ORDERS WHERE month = 'Jan';\n  ```\n\n- 对曾经下过金额（dollars）大于500的订单的客户，将其discnt值增加2个百分点（+2）。\n\n  ```\n  UPDATE CUSTOMERS \n  SET discnt = discnt + 2\n  WHERE cid \n  IN (SELECT cid FROM ORDERS WHERE dollars > 500);\n  ```\n\n- 写一段TSQL程序，向表Orders中增加5000条记录，要求订单尽可能均匀地分布在12个月中。\n\n  ```\n  DECLARE @i INT = 1\n  DECLARE @maxm INT;\n  SELECT @maxm = max(ordno) FROM ORDERS /*获取表单中最大值*/\n  WHILE @i <= 5000\n  BEGIN\n      DECLARE @newno INT = @maxm + @i;\n      DECLARE @newmon INT;\n      SELECT @newmon = (SELECT CAST(CEILING(RAND() * 12) AS INT))\n      DECLARE @strnewmon VARCHAR(4);\n      SELECT @strnewmon =\n             CASE\n                 WHEN @newmon = 1 THEN 'Jan'\n                 WHEN @newmon = 2 THEN 'Feb'\n                 WHEN @newmon = 3 THEN 'Mar'\n                 WHEN @newmon = 4 THEN 'Apr'\n                 WHEN @newmon = 5 THEN 'May'\n                 WHEN @newmon = 6 THEN 'Jun'\n                 WHEN @newmon = 7 THEN 'Jul'\n                 WHEN @newmon = 8 THEN 'Aug'\n                 WHEN @newmon = 9 THEN 'Sep'\n                 WHEN @newmon = 10 THEN 'Oct'\n                 WHEN @newmon = 11 THEN 'Nov'\n                 WHEN @newmon = 12 THEN 'Dec'\n              END\n      DECLARE @newcid VARCHAR(4);\n      SELECT @newcid = 'C' + (SELECT CAST(CEILING(RAND() * 500) AS VARCHAR(3)))\n      DECLARE @newqty INT;\n      SELECT @newqty = (SELECT CAST(floor(RAND() * 1000) AS INT))\n      DECLARE @newdollars DECIMAL(10, 2);\n      SELECT @newdollars = (SELECT CAST(ceiling(RAND() * 1000) AS DECIMAL(10,2)))\n      INSERT INTO ORDERS (ordno, month, cid, qty, dollars)\n      values (@newno, @strnewmon, @newcid, @newqty, @newdollars);\n      SELECT @i = @i + 1;\n  END\n  ```\n\n- 在表Orders的’month’字段上建立索引。\n\n  ```\n  CREATE INDEX MONTH_INDEX ON ORDERS(month(50));\n  ```\n\n- 创建一个视图order_month_summary，视图中的字段包括月份、该月的订单总量和该月的订单总金额。基于视图order_month_summary，查询第一季度各个月份的订单总量和订单总金额。\n\n  ```\n  CREATE VIEW order_month__summary (month, countorders, sumdollars)\n  AS SELECT month, count(*), sum(dollars)\n     FROM ORDERS\n     GROUP BY month\n     HAVING month = 'Jan' or month = 'Feb' or month = 'Jun'\n     COLLATE Chinese_PRC_CI_AI;\n  ```\n\n## 任务二\n\n- 查找属于California和Florida州的顾客的名、姓和emailID。\n\n  ```\n  SELECT vFirstName, vLastName, vEmailId\n  FROM Shopper\n  WHERE cShopperId IN (SELECT cShopperId FROM Orders) \n    AND (cState = 'California' or cState = 'Florida');\n  ```\n\n- 查找定单号码、顾客ID，定单的总价值，并以定单的总价值的升序排列。\n\n  ```\n  SELECT cOrderNo, cShopperId, mTotalCost \n  FROM Orders \n  ORDER BY mTotalCost;\n  ```\n\n- 查找在orderDetail表中vMessage为空值的行。\n\n  ```\n  SELECT * \n  FROM OrderDetail \n  WHERE vMessage IS NULL ;\n  ```\n\n- 查找玩具名字中有“Racer”字样的所有玩具的基本资料。\n\n  ```\n  SELECT * \n  FROM Toys \n  WHERE vToyName LIKE '%Racer%';\n  ```\n\n- 根据2016年的玩具销售总数，查找“Pick of the Month”玩具的前五名玩具的ID。\n\n  ```\n  SELECT cToyId \n  FROM PickOfMonth \n  GROUP BY cToyId \n  ORDER BY sum(iTotalSold)\n  LIMIT 5;\n  ```\n\n- 根据OrderDetail表，查找玩具总价值大于￥50的定单的号码和玩具总价值。\n\n  ```\n  SELECT cOrderNo, mToyCost \n  FROM OrderDetail \n  WHERE mToyCost > 50;\n  ```\n\n- 查找一份包含所有装运信息的报表，包括：Order Number, Shipment Date, Actual Delivery Date, Days in Transit. (提示：Days in Transit = Actual Delivery Date – Shipment Date) \n\n  ```\n  SELECT cOrderNo, dShipmentDate, dActualDeliveryDate, DATEDIFF( dActualDeliveryDate , dShipmentDate ) AS DaysInTransit\n  FROM Shipment;\n  ```\n\n- 查找所有玩具的名称、商标和种类（Toy Name, Brand, Category）。\n\n  ```\n  SELECT Toys.vToyName ToyName, ToyBrand.cBrandName Brand, Category.cCategory Category\n  FROM Toys\n  LEFT OUTER JOIN ToyBrand\n  ON Toys.cBrandId = ToyBrand.cBrandId\n  LEFT OUTER JOIN Category\n  ON Toys.cCategoryId = Category.cCategoryId;\n  ```\n\n- 查找玩具的名称和所有玩具的购物车ID。如果玩具不在购物车中，也需在结果中出现。\n\n  ```\n  SELECT Toys.vToyName, ShoppingCart.cCartId\n  FROM Toys\n  LEFT OUTER JOIN ShoppingCart\n  ON Toys.cToyId = ShoppingCart.cToyId;\n  ```\n\n- 以下列格式查找所有购物者的名字和他们的简称：（Initials, vFirstName, vLastName）,例如Angela Smith的Initials为A.S。\n\n  ```\n  SELECT concat(substring(vFirstName,1,1),'.',substring(vLastName,1,1)) Initials,vFirstName,vLastName \n  FROM shopper;\n  ```\n\n- 查找所有玩具的平均价格，并舍入到整数。\n\n  ```\n  SELECT ROUND(avg(mtoyrate),0) averagerate \n  FROM toys;\n  ```\n\n- 查找所有购买者和收货人的名、姓、地址和所在城市，要求保留结果中的重复记录。\n\n  ```\n  SELECT Shopper.vFirstName BuyerFisrtName , Shopper.vLastName BuyerLastName , Shopper.vAddress BuyerAddress, Shopper.cCity BuyerCity,\n      Recipient.vFirstName ReciFirstName ,Recipient.vLastName ReciLastName,Recipient.vAddress ReciAdress, Recipient.cCity ReciCity\n  FROM Orders\n  LEFT OUTER JOIN Shopper\n  ON Orders.cShopperId = Shopper.cShopperId\n  LEFT OUTER JOIN Recipient\n  ON Orders.cOrderNo = Recipient.cOrderNo;\n  ```\n\n- 查找没有包装的所有玩具的名称。（要求用子查询实现）\n\n  ```\n  SELECT vToyName\n  FROM Toys\n  WHERE cToyId IN (SELECT cToyId\n                   FROM OrderDetail\n                   WHERE cWrapperId IS NULL);\n  ```\n\n- 查找已收货定单的定单号码以及下定单的时间。（要求用子查询实现）\n\n  ```\n  SELECT cOrderNo, dOrderDate\n  FROM Orders\n  WHERE cOrderNo IN (SELECT cOrderNo\n                     FROM Shipment\n                     WHERE dActualDeliveryDate IS NULL);\n  ```\n\n- 查找从来没有下过订单的顾客。\n\n  ```\n  SELECT *\n  FROM Shopper\n  WHERE Shopper.cShopperId NOT IN (SELECT Orders.cShopperId FROM Orders);\n  ```\n\n- 删除“Largo”牌的所有玩具。\n\n  ```\n  DELETE FROM Toys WHERE cBrandId IN\n  (SELECT cBrandId FROM ToyBrand WHERE cBrandName = 'Largo');\n  /*存在外键约束，无法删除*/\n  ```\n\n","tags":["MySQL"]},{"title":"算法分析与设计实践","url":"/2023/04/26/11/","content":"\n# P1302 可见矩形\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1302\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n给定平面上 n 个互不相交（指公共面积为零）的正方形，它们的顶点坐标均为整数。设坐标原点为 O(0,0)。对于任一正方形 R，如果可以找到 R 的边上 2 个不同的点 A 和 B，使  三角形OAB 的内部与其他正方形无公共点，则称正方形 R 是从 O 点可见的正方形。\n\n对于给定的 n 个互不相交的正方形，计算从坐标原点 O 可见的正方形个数。\n\n### 输入格式\n\n输入文件的第一行是正方形个数n（1≤n≤10001≤n≤1000）\n\n接下来n行中，每行有三个表示正方形的整数 X,Y,L。其中，X 和 Y 表示正方形的左下角顶点坐标，L表示边长，1≤X,Y,Z≤10000。\n\n### 输出格式\n\n输出文件仅有一行包含一个整数，表示从坐标原点 O 可见的正方形个数。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n3\n2 6 4\n1 4 1\n2 4 1\n```\n\n#### 样例输出 #1\n\n```\n3\n```\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t设正方形的左下端点（aa，bb），边长为cc，参数cmp=aa+bb+cc。不难发现，cmp较小的正方形可以遮挡cmp较大的正方形，于是记录每个正方形的斜率范围。即最小斜率bb/(aa+cc)和最大斜率(bb+cc)/aa，并针对cmp参数进行递增排序\n\n​\t\t建立二维数组a负责储存不可用的斜率范围，a数组奇数编号储存起始斜率，偶数编号储存截止斜率。于是便可用数组a表示所有不可用范围。初始的斜率范围即为k[1].s到k[1].l，下面依次使各正方形的斜率进入数组。\n\n​\t\t第i号正方形进入数组：比k[i].s还小的元素直接照抄，不需更改，直到找到第一个大于等于k[i].s的元素。若该元素编号为奇数，即为一个范围的起始位置，说明k[i].s的进入产生了一个新的不可用范围，直接使k[i].s进入数组。若该元素编号为偶数，即为一个范围的结束位置，说明k[i].s处在某个范围内部，不需要产生新的起始点，不进行操作，继续向下查找元素。处在k[i].s和k[i].l之间的元素无需理会，直到找到第一个大于等于k[i].l的元素，对k[i].l的操作跟k[i].s基本相同。\n\n### 算法代码\n\n```\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n;\nint ans;\nstruct node{\n\tdouble l,s,cmp;\n}k[100100];\nbool cmp(node x,node y){\n\treturn x.cmp<y.cmp;\n}\ndouble a[10001][10001];\nint cnt[10001];\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c>'9'||c<'0'){\n\t\tif(c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<3)+(x<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint main(){\n\tn=read();\n\tint aa,bb,cc;\n\tfor(int i=1;i<=n;i++){\n\t\taa=read();\n\t\tbb=read();\n\t\tcc=read();\n\t\tk[i].l=(bb+cc)*1.0/aa;\n\t\tk[i].s=bb*1.0/(aa+cc);\n\t\tk[i].cmp=aa+bb+cc;\n\t}\n\tsort(k+1,k+1+n,cmp);\n\ta[1][1]=k[1].s;\n\ta[1][2]=k[1].l;\n\tcnt[1]=2;\n\tfor(int i=2;i<=n;i++){\n\t\tint t=1;\n\t\twhile(a[i-1][t]<k[i].s&&t<=cnt[i-1]){\n\t\t\ta[i][t]=a[i-1][t];\n\t\t\tt++;\n\t\t}\n\t\tint l=t;\n\t\tcnt[i]=t-1;\n\t\tif(t%2==1){\n\t\t\ta[i][++cnt[i]]=k[i].s;\n\t\t\tif(a[i-1][t]==a[i][t]) l=t+1;\n\t\t} \n\t\twhile(a[i-1][t]<=k[i].l&&t<=cnt[i-1]){\n\t\t\tt++;\n\t\t}\n\t\tint r=t;\n\t\tif(t%2==1){\n\t\t\ta[i][++cnt[i]]=k[i].l;\n\t\t\tif(a[i-1][t-1]==a[i][cnt[i]]) r--;\n\t\t} \n\t\twhile(t<=cnt[i-1]){\n\t\t\ta[i][++cnt[i]]=a[i-1][t]; \n\t\t\tt++;\n\t\t}\n\t\tif(r-l>=1) ans++;\n\t\telse{\n\t\t\tif(r%2==1) ans++;\n\t\t}\n\t}\n\tcout<<ans+1;\n\treturn 0;\n}\n```\n\n## 总结与讨论\n\n算法的时间复杂度比较高。\n\n\n\n# P1784 数独\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1784\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n数独是根据 $9 \\times 9$ 盘面上的已知数字，推理出所有剩余空格的数字，并满足每一行、每一列、每一个粗线宫内的数字均含 $1 - 9$ ，不重复。每一道合格的数独谜题都有且仅有唯一答案，推理方法也以此为基础，任何无解或多解的题目都是不合格的。\n\n芬兰一位数学家号称设计出全球最难的“数独游戏”，并刊登在报纸上，让大家去挑战。\n\n这位数学家说，他相信只有“智慧最顶尖”的人才有可能破解这个“数独之谜”。\n\n据介绍，目前数独游戏的难度的等级有一到五级，一是入门等级，五则比较难。不过这位数学家说，他所设计的数独游戏难度等级是十一，可以说是所以数独游戏中，难度最高的等级。他还表示，他目前还没遇到解不出来的数独游戏，因此他认为“最具挑战性”的数独游戏并没有出现。\n\n### 输入格式\n\n一个未填的数独。\n\n### 输出格式\n\n填好的数独。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n8 0 0 0 0 0 0 0 0 \n0 0 3 6 0 0 0 0 0 \n0 7 0 0 9 0 2 0 0 \n0 5 0 0 0 7 0 0 0 \n0 0 0 0 4 5 7 0 0 \n0 0 0 1 0 0 0 3 0 \n0 0 1 0 0 0 0 6 8 \n0 0 8 5 0 0 0 1 0 \n0 9 0 0 0 0 4 0 0\n```\n\n#### 样例输出 #1\n\n```\n8 1 2 7 5 3 6 4 9 \n9 4 3 6 8 2 1 7 5 \n6 7 5 4 9 1 2 8 3 \n1 5 4 2 3 7 8 9 6 \n3 6 9 8 4 5 7 2 1 \n2 8 7 1 6 9 5 3 4 \n5 2 1 9 7 4 3 6 8 \n4 3 8 5 2 6 9 1 7 \n7 9 6 3 1 8 4 5 2\n```\n\n### 样例 #2\n\n#### 样例输入 #2\n\n```\n9 0 0 8 0 0 0 0 0\n0 0 0 0 0 0 5 0 0 \n0 0 0 0 0 0 0 0 0 \n0 2 0 0 1 0 0 0 3\n0 1 0 0 0 0 0 6 0\n0 0 0 4 0 0 0 7 0\n7 0 8 6 0 0 0 0 0 \n0 0 0 0 3 0 1 0 0 \n4 0 0 0 0 0 2 0 0 \n```\n\n#### 样例输出 #2\n\n```\n9 7 2 8 5 3 6 1 4 \n1 4 6 2 7 9 5 3 8 \n5 8 3 1 4 6 7 2 9 \n6 2 4 7 1 8 9 5 3 \n8 1 7 3 9 5 4 6 2 \n3 5 9 4 6 2 8 7 1 \n7 9 8 6 2 1 3 4 5 \n2 6 5 9 3 4 1 8 7 \n4 3 1 5 8 7 2 9 6 \n```\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t数独是源自18世纪瑞士的一种数学游戏。是一种运用纸、笔进行演算的逻辑游戏。玩家需要根据9×9盘面上的已知数字，推理出所有剩余空格的数字，并满足每一行、每一列、每一个粗线宫（3×3）内的数字均含1-9，不重复。\n\n​\t\t数独要求每一行、每一列、每一个3×3方阵内的数字，不重复。行和列重复判断是相当简单的。我们可以定义两个bool型二维数组，当此行（或列）填充数字时，我们可以直接把这行的这个数字打上true表示有数字了。\n\n### 算法代码\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint sd[11][11];//数独方阵定义 \nbool p[11][11],l[11][11],fz[11][11];//行，列，方阵。 \n\nvoid _out()\n{\n    cout<<endl;\n\tfor(int i=1;i<=9;i++)\n\t{\t\n  \t\tfor(int j=1;j<=9;j++)\n\t\t\tcout<<sd[i][j]<<\" \";\n\t\tcout<<endl;\n\t}\n\texit(0); \n}\nvoid dfs(int x,int y)\n{\n\tif(sd[x][y]!=0)//如果原来这个位置有数字，跳过。 \n\t\tif(x==9&&y==9)_out();//当行列都为9，填充完成，输出\n\t\telse if(y==9)dfs(x+1,1);//当列数为9，搜索下一排。 \n\t\telse dfs(x,y+1);//搜下一列 \n\telse//原来的地方没有数字，准备填充！ \n\t\tfor(int i=1;i<=9;i++)\n\t\t\tif((!p[x][i])&&(!l[y][i])&&(!fz[(x-1)/3*3+(y-1)/3+1][i]))\n\t\t\t//判断是不是重复了。\n\t\t\t{\n\t\t\t\tsd[x][y]=i;//填充！ \n\t\t\t\tp[x][i]=l[y][i]=fz[(x-1)/3*3+(y-1)/3+1][i]=true;//打上标记。 \n\t\t\t\tif(x==9&&y==9)_out();//全部填完！输出\n\t\t\t\telse if(y==9)dfs(x+1,1);//同上！搜下一行。\n\t\t\t\telse dfs(x,y+1);//搜下一列！ \n\t\t\t\tsd[x][y]=0; //恢复标记。 \n\t\t\t\tp[x][i]=l[y][i]=fz[(x-1)/3*3+(y-1)/3+1][i]=false;//恢复标记。 \n\t\t\t}\n}\nint main()\n{\n\tfor(int i=1;i<=9;i++)\n\t\tfor(int j=1;j<=9;j++)\n\t\t{\n\t\t\tint t;//定义tmp（防止下面代码太长？） \n\t\t\tcin>>t;//输入 \n\t\t\tif(t!=0)\n\t\t\t\tp[i][t]=l[j][t]=fz[(i-1)/3*3+(j-1)/3+1][t]=true;\n\t\t\t//填充的不是0的话，表示原来有数字了。打上标记。\t\n\t\t\tsd[i][j]=t;//填充进数独。 \n\t\t}\t\n\tdfs(1,1);//搜索\n\treturn 0;//结束 \n}\n```\n\n## 总结与讨论\n\n​\t\t算法的难点在于判断数字的重复。\n\n\n\n# P1229 遍历问题\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1229\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n我们都很熟悉二叉树的前序、中序、后序遍历，在数据结构中常提出这样的问题：已知一棵二叉树的前序和中序遍历，求它的后序遍历，相应的，已知一棵二叉树的后序遍历和中序遍历序列你也能求出它的前序遍历。然而给定一棵二叉树的前序和后序遍历，你却不能确定其中序遍历序列，考虑如下图中的几棵二叉树：\n\n ![](https://cdn.luogu.com.cn/upload/pic/73.png) \n\n所有这些二叉树都有着相同的前序遍历和后序遍历，但中序遍历却不相同。\n\n### 输入格式\n\n输A数据共两行，第一行表示该二叉树的前序遍历结果s1，第二行表示该二叉树的后序遍历结果s2。\n\n### 输出格式\n\n输出可能的中序遍历序列的总数，结果不超过长整型数。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\nabc                           \ncba\n```\n\n#### 样例输出 #1\n\n```\n4\n```\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t给定中能确定树的具体结构，是因为可以确定是左子树还是右子树，而之给定前和后，则不能确定，这就是会出现不同树结构的原因。只有前和后那么主要问题就是没有办法处理只有一个子树的情况，因为这种情况不知道子树究竟是这个节点的左子树还是右子树，也就是说其实这道题要判断遍历中存在着多少个只有一棵子树的情况。对于前，如果一个结点的下个结点等于后中对应结点的前一个结点的话，那么这个结点就是根节点且其只有一个子树。sum初始化为1，出现一个只有一棵子树的情况，就把sum*2。\n\n```\n#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int i;\n    long long c=1;\n    string s1,s2,s3;\n    cin >> s1 >> s2;\n    for (i=0; i<s1.length()-1; i++) {\n        s3 = s1.substr(i,2); // 截取相邻的两个字符串\n        reverse(s3.begin(),s3.end()); // 反转\n        if (s2.find(s3) != string::npos) c *= 2; // 匹配成功则总数*2\n    }\n    cout << c << endl;\n}\n```\n\n## 总结与讨论\n\n​\t\t乍一看很难，实则找规律。\n\n\n\n# P1387 最大正方形\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1387\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n在一个 n×mn×m的只包含 0和1的矩阵里找出一个不包含 0的最大正方形，输出边长。\n\n### 输入格式\n\n输入文件第一行为两个整数n,m(1≤n,m≤100)，接下来 n 行，每行 m 个数字，用空格隔开，0 或 1。\n\n### 输出格式\n\n一个整数，最大正方形的边长。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n4 4\n0 1 1 1\n1 1 1 0\n0 1 1 0\n1 1 0 1\n```\n\n#### 样例输出 #1\n\n```\n2\n```\n\n## 算法\n\n### 问题分析与算法设计\n\n暴力算法：枚举每一个点作为所选正方形的左上角的点，然后枚举正方形边长，逐一判断。\n\n### 算法代码\n\n```\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool f[202][202]={0},p;\nint n,m,i,j,k,x,y,ans=0;\n\nint main()\n{\n  cin>>m;\n  cin>>n;\n  for (int i=0; i<n; i++)\n    for (int j=0; j<m; j++)\n      cin>>f[i][j];          \n  for (int i=0; i<n; i++)\n    for (int j=0; j<m; j++)\n      for (int k=min(n,m); k>ans; k--){\n          p=1;\n          for (int x=i; x<i+k; x++){\n              for (int y=j; y<j+k; y++){\n                  if (!f[x][y])      \n                      {\n                        p=0; \n                        break;   \n                      }\n              }\n              if (!p){\n              \tbreak;\n              }     \n            }\n          if (p){\n              ans=k; \n              break;       \n            }\n        }\n  cout<<ans<<endl;                \n  return 0;\n}\n```\n\n## 总结与讨论\n\n​\t\t时间复杂度略高，还需要改进。\n\n\n\n# P1123 取数游戏\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1123\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n一个$N \\times M$的由非负整数构成的数字矩阵，你需要在其中取出若干个数字，使得取出的任意两个数字不相邻（若一个数字在另外一个数字相邻$8$个格子中的一个即认为这两个数字相邻），求取出数字和最大是多少。\n\n### 输入格式\n\n第1行有一个正整数$T$，表示了有$T$组数据。\n\n对于每一组数据，第一行有两个正整数$N$和$M$，表示了数字矩阵为$N$行$M$列。\n\n接下来$N$行，每行$M$个非负整数，描述了这个数字矩阵。\n\n### 输出格式\n\n$T$行，每行一个非负整数，输出所求得的答案。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n3\n4 4\n67 75 63 10\n29 29 92 14\n21 68 71 56\n8 67 91 25\n2 3\n87 70 85\n10 3 17\n3 3\n1 1 1\n1 99 1\n1 1 1\n```\n\n#### 样例输出 #1\n\n```\n271\n172\n99\n```\n\n#### 提示\n\n对于第1组数据，取数方式如下：\n\n[67] 75 63 10\n\n29 29 [92] 14\n\n[21] 68 71 56\n\n8 67 [91] 25\n\n对于$20\\%$的数据，$N, M≤3$；\n\n对于$40\\%$的数据，$N,M≤4$；\n\n对于$60\\%$的数据，$N, M≤5$；\n\n对于$100\\%$的数据，$N, M≤6,T≤20$。\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t对于本题，如果使用贪心法，每次去最大值，那么可以发现有问题。因为每取一个数，相邻的数就不能再取，那么每次决策就会影响下次结果，从而导致贪心决策不能最优化。动态规划也是如此，在动态规划中，每一个分步决策不能影响后续结果，所以此算法也排除。\n\n​\t\t根据数据范围，所以可以考虑暴力枚举，而对于一个图，以及一个变化的状态，深度优先搜索（dfs） 应该是一个比较适合的算法。\n再考虑每个数的状态。显然，对于一个数，有取与不取两种状态，状态改变取决于周围取数的变化。我们用 mark[ i ][ j ] 记录点 ( i , j ) 附近有几个数，若 mark[i] [j] ! = 0 就代表不能取这个数。\n\n### 算法代码\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int d[8][2]={1,0,-1,0,0,1,0,-1,1,1,-1,1,1,-1,-1,-1};//方向数组用来控制搜索时的方向 \nint t,n,m,s[8][8],mark[8][8],ans,mx;\n\nvoid dfs(int x,int y){//搜索函数，表示搜索点(x,y) \n\tif(y==m+1){//当y到边界时，搜索下一行 \n\t\tdfs(x+1,1);\n\t\treturn;\n\t}\n\tif(x==n+1){//当x到边界时，搜索结束，刷新最大值 \n\t\tmx=max(ans,mx);\n\t\treturn;\n\t}\n\t\n\tdfs(x,y+1);// 不取此数的情况 \n\t\n\tif(mark[x][y]==0){ //取此数的情况（需保证此数周围没有取其他数，即mark[i][j]==0）\n\t\tans+=s[x][y];\n\t\tfor(int fx=0;fx<8;++fx){ //标记周围的数 \n\t\t\t++mark[x+d[fx][0]][y+d[fx][1]];\n\t\t}\n\t\tdfs(x,y+1);\n\t\tfor(int fx=0;fx<8;++fx){ //回溯 \n\t\t\t--mark[x+d[fx][0]][y+d[fx][1]];\n\t\t}\n\t\tans-=s[x][y];\n\t}\n\t\n}\nint main(){\n\tcin>>t; \n\twhile(t--){\n\t\tmemset(s,0,sizeof(s));\n\t\tmemset(mark,0,sizeof(mark));//在做每个数据前都要初始化数组 \n\t\tcin>>n>>m;\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tfor(int j=1;j<=m;++j){\n\t\t\t\tcin>>s[i][j];\n\t\t\t}\n\t\t}\n\t\tmx=0;\n\t\tdfs(1,1);//从点(1,1)开始搜索 \n\t\tcout<<mx<<endl;\n\t}\n\treturn 0;\n}\n```\n\n## 总结与讨论\n\n​\t\t主要需要确定算法和考虑标记状态。\n\n\n\n# P1576 最小花费\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1576\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n在 $n$ 个人中，某些人的银行账号之间可以互相转账。这些人之间转账的手续费各不相同。给定这些人之间转账时需要从转账金额里扣除百分之几的手续费，请问 $A$ 最少需要多少钱使得转账后 $B$ 收到 $100$ 元。\n\n### 输入格式\n\n第一行输入两个正整数 $n,m$，分别表示总人数和可以互相转账的人的对数。\n\n以下 $m$ 行每行输入三个正整数 $x,y,z$，表示标号为 $x$ 的人和标号为 $y$ 的人之间互相转账需要扣除 $z\\%$ 的手续费 $(z<100)$。\n\n最后一行输入两个正整数 $A,B$。数据保证 $A$ 与 $B$ 之间可以直接或间接地转账。\n\n### 输出格式\n\n输出 $A$ 使得 $B$ 到账 $100$ 元最少需要的总费用。精确到小数点后 $8$ 位。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n3 3                                     \n1 2 1\n2 3 2\n1 3 3\n1 3\n```\n\n#### 样例输出 #1\n\n```\n103.07153164\n```\n\n#### 提示\n\n$1\\le n \\le 2000,m\\le 100000$。\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t将本题抽象化之后不难发现本题就是最短路径问题，可采用Dijkstra算法解决。最小花费就是把每个人看做一个点，每次转账看做一个边，把花费看做边权，并且要建双向边。 i，j互相转账就相当于节点i和j之间有一条权值为（1-z%）的边，求一条路径使路径上各边权值乘积最大。结果就是100/max。 \n\n### 算法代码\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n,m,a,b;//意思如题意\nbool mark[2005];//记下该点有无被遍历过\ndouble d[2005];//B点到该点的费用\nvector < pair <int,int> > s[2005];//用可变数组来记两点之间能否到达和费用如何，相较于普通数组更加方便\nmultiset <pair <int,int> > f;//multiset里用pair 是按前面的数排序\n\nvoid dij() {\n\tfor(int i=1; i<=n; i++) d[i]=1e9;//若B到达不了，则费用无限大\n\td[b]=100;//B到B，100元\n\tf.insert(make_pair(d[b],b));\n\tfor(int i=1; i<=n; i++) {\n\t\twhile(!f.empty()&&mark[(*f.begin()).second]) f.erase(f.begin());//如果该点被遍历过则不要\n\t\tint p=(*f.begin()).second;//遍历点\n\t\tmark[p]=1;\n\t\tfor(int j=0; j<s[p].size(); j++) {\n\t\t\tint h=s[p][j].second,z=s[p][j].first;//h为加入点\n\t\t\tdouble mon=d[p]/(100-z)*100;//费用\n\t\t\tif(mon<d[h]) {\n\t\t\t\td[h]=mon;\n\t\t\t\tf.insert(make_pair(d[h],h));\n\t\t\t}//取最小，加入。\n\t\t}\n\t}\n}\nint main() {\n\tcin>>m>>n;\n\tfor(int i=0; i<m; i++) {\n\t\tint u,v,w;//u、v为点，w为费用\n\t\tcin>>u>>v>>w;\n\t\ts[u].push_back(make_pair(w,v));\n\t\ts[v].push_back(make_pair(w,u));\n\t}\n\tcin>>a>>b;\n\tdij();\n\tprintf(\"%.8f\",d[a]);\n\treturn 0;\n}\n```\n\n## 总结与讨论\n\n​\t\t本题可以借助数据结构，更加方便，如堆，优先队列，multiset。\n\n\n\n# P2141 [NOIP2014 普及组] 珠心算测验\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P2141\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n珠心算是一种通过在脑中模拟算盘变化来完成快速运算的一种计算技术。珠心算训练，既能够开发智力，又能够为日常生活带来很多便利，因而在很多学校得到普及。\n\n\n某学校的珠心算老师采用一种快速考察珠心算加法能力的测验方法。他随机生成一个正整数集合，集合中的数各不相同，然后要求学生回答：其中有多少个数，恰好等于集合中另外两个（不同的）数之和？\n\n\n最近老师出了一些测验题，请你帮忙求出答案。\n\n\n(本题目为 2014NOIP 普及 T1)\n\n### 输入格式\n\n共两行，第一行包含一个整数 $n$，表示测试题中给出的正整数个数。\n\n\n第二行有 $n$ 个正整数，每两个正整数之间用一个空格隔开，表示测试题中给出的正整数。\n\n### 输出格式\n\n一个整数，表示测验题答案。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n4\n1 2 3 4\n```\n\n#### 样例输出 #1\n\n```\n2\n```\n\n#### 提示\n\n【样例说明】\n\n\n由 $1+2=3,1+3=4$，故满足测试要求的答案为 $2$。  \n\n注意，加数和被加数必须是集合中的两个不同的数。\n\n\n【数据说明】\n\n\n对于 $100\\%$ 的数据，$3 \\leq n \\leq 100$，测验题给出的正整数大小不超过 $10,000$。\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t采用三个数组，一个存储数值，另外两个标记数值状态。其中一个存储输入数值的状态，另一个存储数值相加之和的状态。最后遍历两个数组即可。\n\n### 算法代码\n\n```\n#include<iostream>\n#include<cstdio>\nusing namespace std;\nint t[200005],g[200005];\nint n,a[105],ans;\nint main(){\n    cin>>n;\n    for (int i=1;i<=n;i++){\n        cin>>a[i];//读入\n        g[a[i]]=1;//在集合中赋值为1\n    }\n    for (int i=1;i<n;i++){//枚举\n        for (int j=i+1;j<=n;j++){\n            t[a[i]+a[j]]++;//被加出来了\n        }\n    }\n    for (int i=1;i<=200002;i++){\n        if (t[i]>0&&g[i]) ans++;//判断是否满足，满足ans++\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n```\n\n## 总结与讨论\n\n​\t\t此题算法简单，暴力算法即可求解，倘若数据范围未给出或者指明很大，则另当别论。\n\n\n\n# P1004 [NOIP2000 提高组] 方格取数\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1004\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n设有 $N \\times N$ 的方格图 $(N \\le 9)$，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 $0$。如下图所示（见样例）:\n\n```plain\nA\n 0  0  0  0  0  0  0  0\n 0  0 13  0  0  6  0  0\n 0  0  0  0  7  0  0  0\n 0  0  0 14  0  0  0  0\n 0 21  0  0  0  4  0  0\n 0  0 15  0  0  0  0  0\n 0 14  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0\n                         B\n```\n某人从图的左上角的 $A$ 点出发，可以向下行走，也可以向右走，直到到达右下角的 $B$ 点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 $0$）。  \n此人从 $A$ 点到 $B$ 点共走两次，试找出 $2$ 条这样的路径，使得取得的数之和为最大。\n\n### 输入格式\n\n输入的第一行为一个整数 $N$（表示 $N \\times N$ 的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的 $0$ 表示输入结束。\n\n### 输出格式\n\n只需输出一个整数，表示 $2$ 条路径上取得的最大的和。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n8\n2 3 13\n2 6  6\n3 5  7\n4 4 14\n5 2 21\n5 6  4\n6 3 15\n7 2 14\n0 0  0\n```\n\n#### 样例输出 #1\n\n```\n67\n```\n\n#### 提示\n\nNOIP 2000 提高组第四题\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t本题采用深度优先算法解决，并且采用四维dp。之所以不用二维dp，原因在于，局部最优解不是全局最优解。\n\n​\t\t设dp[i] [j] [k] [l] 存放的是两个人同时分别走到i,j和k,l点时的最大路径和。易知，两个同时走的人均需遵守只能向下或向右的规则，那么两个人的选择2 x 2就一共有四种可能，即1.都往下走。2.一个往下，一个往右。3.一个往右，一个往下。4.都往右走。\n\n​\t\t倘若某格子有人走过了，另一个人倘若也需要经过那个格子，只需在原算法基础上减掉那个格子的值即可，而无需考虑将其数值置零的问题。\n\n### 算法代码\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint a[10][10];\nint dp[10][10][10][10];\n\nint main()\n{\n\tint n;\n\tcin >> n;\t\n\t//输入数据\n\tint x,y,num;\n\twhile (1){\n\t\tcin >> x >> y >> num;\n\t\tif ( !x && !y && !num )\n\t\t\tbreak;\n\t\ta[x][y] = num;\n\t}\t\n\t//四重循环\n\tint i,j,k,l;\n\tfor ( i=1; i<=n; ++i )\n\t\tfor ( j=1; j<=n; ++j )\n\t\t\tfor ( k=1; k<=n; ++k )\n\t\t\t\tfor ( l=1; l<=n; ++l ){\n\t\t\t\t\tdp[i][j][k][l] = max ( max (max ( dp[i-1][j][k-1][l], dp[i-1][j][k][l-1] ), dp[i][j-1][k-1][l] ), dp[i][j-1][k][l-1] ) + a[i][j] + a[k][l];\n\t\t\t\t\t//注意相同去重\n\t\t\t\t\tif ( i==k && j== l )\n\t\t\t\t\t\tdp[i][j][k][l] -= a[k][l];\n\t\t\t\t}\n\tcout << dp[n][n][n][n] << endl;\n}\n```\n\n## 总结与讨论\n\n​\t\t本题难点在于理解两次局部最优解和全局最优解的不同之处。对于四维dp理解不到位也很难写出该算法。\n\n\n\n# P1006 [NOIP2008 提高组] 传纸条\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1006\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排坐成一个 $m$ 行 $n$ 列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标 $(1,1)$，小轩坐在矩阵的右下角，坐标 $(m,n)$。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。\n\n在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。\n\n还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用 $0$ 表示），可以用一个 $[0,100]$ 内的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。现在，请你帮助小渊和小轩找到这样的两条路径。\n\n### 输入格式\n\n第一行有两个用空格隔开的整数 $m$ 和 $n$，表示班里有 $m$ 行 $n$ 列。\n\n接下来的 $m$ 行是一个 $m \\times n$ 的矩阵，矩阵中第 $i$ 行 $j$ 列的整数表示坐在第 $i$ 行 $j$ 列的学生的好心程度。每行的 $n$ 个整数之间用空格隔开。\n\n### 输出格式\n\n输出文件共一行一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n3 3\n0 3 9\n2 8 5\n5 7 0\n```\n\n#### 样例输出 #1\n\n```\n34\n```\n\n#### 提示\n\n**【数据范围】**\n\n对于 $30\\%$ 的数据，满足 $1 \\le m,n \\le 10$。  \n对于 $100\\%$ 的数据，满足 $1 \\le m,n \\le 50$。\n\n**【题目来源】**\n\nNOIP 2008 提高组第三题。\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t最好想的做法是四维dp，设f[i][j][k] [l]为从小渊传到小轩的纸条到达(i,j)，从小轩传给小渊的纸条到达(k,l)的路径上取得的最大的好心程度和。完全可以换一个思路想，即求从给定的起点出发走到指定位置的两条最短严格不相交路线。那么特别显然，转移方程是 f[i] [j] [k] [l]=max( f[i][j-1][k-1] [l] , f[i-1] [j] [k] [l-1] , f[i] [j-1] [k] [l-1] , f[i-1] [j] [k-1] [l] )+a[i] [j]+a[k] [l]。要小心l的枚举范围，应该是从j+1到m，只有这样，在枚举第二条路的时候可以控制下标的l不会和j有相等的可能，这样可以保证两条路一定不相交。由于终点的值是0，所以目标状态就是f[n] [m-1] [n-1] [m]。如果你不想这样做，那就让l直接从1枚举，但需要加一个判断，判断当前的(i,j)和(k,l)是不是重合了，如果重合那就把f数组对应的这个地方在转移后减掉一个a[i] [j]或者a[k] [l]。\n\n### 算法代码\n\n```\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#define maxn 55\nusing namespace std;\nint f[2 * maxn][maxn][maxn];\nint a[maxn][maxn];\nint n,m;\n \nint max_ele(int a,int b,int c,int d){\n    if (b>a)\n        a = b;\n    if (c>a)\n        a = c;\n    if (d>a)\n        a = d;\n    return a;\n}\n \nint main(){\n    cin >> n >> m;\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=m;j++)\n            cin >> a[i][j];\n    for (int k=1;k<=n+m-1;k++)\n        for (int i=1;i<=n;i++)\n            for (int j=1;j<=n;j++){\n                if (k-i+1<1 || k-j+1<1) //这里是判断纵坐标的合法性，如果纵坐标不合法那就跳过去\n                    continue;\n                 f[k][i][j] = max_ele(f[k-1][i][j],f[k-1][i-1][j-1],f[k-1][i][j-1],f[k-1][i-1][j]) + a[i][k-i+1] + a[j][k-j+1];\n                if (i==j) //判断重合路径\n                    f[k][i][j]-=a[i][k-i+1];\n            }\n \n \n    cout << f[n+m-1][n][n] << endl;\n    return 0;\n}\n```\n\n## 总结与讨论\n\n​\t\t算法时间复杂度是O(n^2 * m^2)。\n\n\n\n# P1018 [NOIP2000 提高组] 乘积最大\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1018\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n今年是国际数学联盟确定的“ 2000 ――世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰 90 周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友 XZ 也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：\n\n\n设有一个长度为 $N$ 的数字串，要求选手使用 $K$ 个乘号将它分成 $K+1$ 个部分，找出一种分法，使得这 $K+1$ 个部分的乘积能够为最大。\n\n\n同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：\n\n\n有一个数字串：$312$， 当 $N=3,K=1$ 时会有以下两种分法：\n\n1. $3  \\times  12=36$ \n2. $31  \\times   2=62$  \n\n\n这时，符合题目要求的结果是: $31  \\times  2 = 62$\n\n\n现在，请你帮助你的好朋友 XZ 设计一个程序，求得正确的答案。\n\n### 输入格式\n\n程序的输入共有两行：\n\n第一行共有 $2$ 个自然数 $N,K$\n\n第二行是一个长度为 $N$ 的数字串。\n\n### 输出格式\n\n结果显示在屏幕上，相对于输入，应输出所求得的最大乘积（一个自然数）。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n4  2\n1231\n```\n\n#### 样例输出 #1\n\n```\n62\n```\n\n#### 提示\n\n**数据范围与约定**\n\n对于 $60\\%$ 的测试数据满足 $6≤N≤20$。  \n对于所有测试数据，$6≤N≤40,1≤K≤6$。\n\nNOIp2000 提高组第二题\n\n## 算法\n\n### 问题分析与算法设计\n\n首先，这道题是显而易见的区间DP，那么，做这道题时，可以分为以下几步：\n1.确定状态，一般是f[i] [j]之类的，一般题目问什么，就设什么，这道题的状态定义为：f[ i ] [ j ]表示在前i个数中放j个乘号所得到的最大值。把这个状态带回题目，发现f[n−1] [k]恰为所求。\n2.确定阶段，这道题很显然是以乘号为阶段的，乘号具有明显的顺序性，即：先放完一个乘号，记录在DP数组中，放两个乘号是才能顺利调用之前的计算结果。\n3.确定状态转移方程：f[i] [j] = max(f[i] [j],f[i−1] [k−1]∗num(k,j))。\n4.初始化，这道题肯定是要初始化的，即 f [i] [0]时（前i个数中放0个乘号所得到的最大值就是i本身）\n\n### 算法代码\n\n```\n#include<bits/stdc++.h>\n\n#define INF 0x3f3f3f3f\n#define ll long long\n\nusing namespace std;\n\nstring s;\nll n,m,f[50][10];//f[i][j]:前i个数字放j个乘号\n\nll js(ll x,ll y)//将字符串从x位到y位转换为一个数字\n{\n\tll sum = 0;\n\tfor(int i = x;i <= y;++i)\n\t{\n\t\tsum = sum * 10;\n\t\tsum += s[i] - 48;\n\t}\n\treturn sum;\n}\n\nint main()\n{\n\tcin >> n >> m;\n\tcin >> s;\n\tfor(int i = 0;i < n;++i)\n\t{\n\t\tf[i][0] = js(0,i);//初始化\n\t}\n\tfor(int i = 1;i <= m;++i)//放i个乘号\n\t{\n\t\tfor(int j = i;j < n;++j)//在第j个位置放乘号，j不能=n，因为乘号必须要放在数字之间\n\t\t{\n\t\t\tfor(int k = i;k <= j;++k)//分割线\n\t\t\t{\n\t\t\t\tf[j][i] = max(f[j][i],f[k - 1][i - 1] * js(k,j));\n\t\t\t}\n\t\t}\n\t} \n\tcout << f[n - 1][m] << endl; \n\treturn 0;\n} \n```\n\n## 总结与讨论\n\n​\t\t或许暴力算法也能解决？\n\n\n\n# P1016 [NOIP1999 提高组] 旅行家的预算\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1016\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n一个旅行家想驾驶汽车以最少的费用从一个城市到另一个城市（假设出发时油箱是空的）。给定两个城市之间的距离 $D_1$、汽车油箱的容量 $C$（以升为单位）、每升汽油能行驶的距离 $D_2$、出发点每升汽油价格$P$和沿途油站数 $N$（$N$ 可以为零），油站 $i$ 离出发点的距离 $D_i$、每升汽油价格 $P_i$（$i=1,2,…,N$）。计算结果四舍五入至小数点后两位。如果无法到达目的地，则输出 `No Solution`。\n\n### 输入格式\n\n第一行，$D_1$，$C$，$D_2$，$P$，$N$。\n\n接下来有 $N$ 行。\n\n第 $i+1$ 行，两个数字，油站 $i$ 离出发点的距离 $D_i$ 和每升汽油价格 $P_i$。\n\n### 输出格式\n\n所需最小费用，计算结果四舍五入至小数点后两位。如果无法到达目的地，则输出 `No Solution`。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n275.6 11.9 27.4 2.8 2\n102.0 2.9\n220.0 2.2\n```\n\n#### 样例输出 #1\n\n```\n26.95\n```\n\n#### 提示\n\n$N \\le 6$，其余数字$ \\le 500$。\n\n## 算法\n\n### 问题分析与算法设计\n\n首先做如下定义：加油站距离数组dis[n+2], 汽油价格数组pri[n+2], 两者一一对应。\n\n接着对这两个数组初始化，dis[0] = 0; pri[0] = p; // 将出发点的距离 0 和 油价p 放入数组\n\n　　　　　　　　　　　　　　dis[n+1] = d1; pri[n+1] = 0; // 终点的距离 d1, 油价 0 放入数组\n\n将之后输入的N行数据按照距离从小到大排列，需要注意的是，交换距离的时候需要将对应的价格也交换。\n\n那么只需要从距离最小的点开始出发，依次进行计算。\n\n### 算法代码\n\n```\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef struct\n{\n    double dis;\n    double price;\n}station;\nint wrong=99999;\nstation st[100000];\ndouble d1,c,d2,p;\nint n;\nint now;//当前所在位置\nint t;\ndouble maxn;//最远走到哪里\n\ndouble res;//剩余；\ndouble price_sum=0;//总价钱\nint cmp(station a,station b)\n{\n    return a.dis<b.dis;\n}\nint func(int now)\n{\n    int index=wrong;//next\n    for(int i=now+1;i<=n&&st[i].dis-st[now].dis<=maxn;i++)//找能到的加油站\n    {\n        if(st[i].price<st[now].price)//能到&&便宜\n        {\n            price_sum+=(st[i].dis-st[now].dis)/d2*st[now].price;\n            res=0;\n            return i;\n        }\n        if(index==wrong||st[i].price<st[index].price)\n            index=i;//能到，不便宜\n\n    }\n    if(d1-st[now].dis<=maxn)//没有更便宜的，且能到终点了\n    {\n        price_sum+=(d1-st[now].dis-res)/d2*st[now].price;\n        return wrong;\n    }\n    if(index==wrong)\n    {\n        //到不了下个站\n        cout<<\"No Solution\"<<endl;\n        return -1;\n    }\n\n    else//没有更便宜的，又不能一次到终点\n    {\n        price_sum+=c*st[now].price;\n        res+=(maxn-(st[index].dis-st[now].dis));\n        return index;\n    }\n}\nint main()\n{\n\n    cin>>d1>>c>>d2>>p>>n;\n\n    st[0].dis=0;\n    st[0].price=p;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>st[i].dis>>st[i].price;\n    }\n\n    sort(st,st+n+1,cmp);\n    now=0;\n    maxn=c*d2;\n\n    do\n    {\n        t=func(now);\n        now=t;\n        if(t==-1)\n            return 0;\n    }while(t!=wrong);\n\n    cout<<fixed<<setprecision(2)<<price_sum<<endl;\n    return 0;\n}\n```\n\n## 总结与讨论\n\n​\t\t需要注意的地方：1、每次都需要判断是否能够到达下一个加油站，如果无法到达，则直接退出。\n\n　　　　　　　　\t\t2、每次在当前能够走到的最远距离内进行判断，寻找是否有比当前油价更低的加油站。如果没有更低的，价格相等也可以。\n\n　　　　　　　　\t\t3、由于最后一点 pir[n+1]  的油价为0，所以要对其特殊处理。\n\n\n\n# P2434 [SDOI2005]区间\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P2434\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n现给定 $n$ 个闭区间 $[a_i, b_i]$（$1 \\le i \\le n$）。这些区间的并可以表示为一些不相交的闭区间的并。你的任务就是在这些表示方式中找出包含最少区间的方案。你的输出应该按照区间的升序排列。这里如果说两个区间 $[a, b]$ 和 $[c, d]$ 是按照升序排列的，那么我们有 $a \\le b < c \\le d$。\n\n请写一个程序：\n\n读入这些区间；\n\n计算满足给定条件的不相交闭区间；\n\n把这些区间按照升序输出。\n\n### 输入格式\n\n第一行包含一个整数 $n$（$3 \\le n \\le 50000$）为区间的数目。  \n以下 $n$ 行为对区间的描述，第 $i$ 行为对第 $i$ 个区间的描述，为两个整数 $a_i, b_i$（$1 \\le a _ i \\leq b _ i \\le 1000000$），表示一个区间 $[a_i, b_i]$。\n\n### 输出格式\n\n输出计算出来的不相交的区间。每一行都是对一个区间的描述，包括两个用空格分开的整数，为区间的上下界。你应该把区间按照升序排序。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n5\n5 6\n1 4\n10 10\n6 9\n8 10\n```\n\n#### 样例输出 #1\n\n```\n1 4\n5 10\n```\n\n#### 提示\n\n对于 $100 \\%$ 的数据，$3 \\le n \\le 50000$，$1 \\le a _ i \\leq b _ i \\le 1000000$。\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t将所有区间按左端点排序，然后将n个区间扫一遍，若能合并成一个大区间便合并， 并用l,r记录当前区间的左右端点，若不能合并（即q[i].l>r），输出，并重置l,r\n\n### 算法代码\n\n```\n#include <bits/stdc++.h>\n#define N 50005\nusing namespace std;\n \nint n; \n \nstruct node\n{\n    int l,r;\n}q[N];\nbool cmp(node x,node y) {return x.l<y.l;}\n \nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%d%d\",&q[i].l,&q[i].r);\n    sort(q+1,q+1+n,cmp);\n    int l=q[1].l,r=q[1].r;\n    for(int i=2;i<=n;i++)\n    {\n        if(q[i].l>r)\n        {\n            printf(\"%d %d\\n\",l,r);\n            l=q[i].l;r=q[i].r;\n        }\n        else r=max(r,q[i].r);\n    }\n    printf(\"%d %d\",l,r);\n    return 0;\n}\n```\n\n## 总结与讨论\n\n​\t\t这题也可用线段树完成，先将每一段区间插入线段树，然后用两个指针l=1,r=1扫[l,r]，若区间[l,r]被覆盖，r++,若不是，重置l,r，并在 l !=r时输出\n\n\n\n# P3842 [TJOI2007]线段\n\n## 题目描述\n\n在一个 $n \\times n$ 的平面上，在每一行中有一条线段，第 $i$ 行的线段的左端点是$(i, L_{i})$，右端点是$(i, R_{i})$。\n\n你从 $(1,1)$ 点出发，要求沿途走过所有的线段，最终到达 $(n,n)$ 点，且所走的路程长度要尽量短。\n\n更具体一些说，你在任何时候只能选择向下走一步（行数增加 $1$）、向左走一步（列数减少 $1$）或是向右走一步（列数增加 $1$）。当然，由于你不能向上行走，因此在从任何一行向下走到另一行的时候，你必须保证已经走完本行的那条线段。\n\n### 输入格式\n\n第一行有一个整数 $n$。\n\n以下 $n$ 行，在第 $i$ 行（总第 $(i+1)$ 行）的两个整数表示 $L_i$ 和 $R_i$。\n\n### 输出格式\n\n仅包含一个整数，你选择的最短路程的长度。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n6\n2 6\n3 4\n1 3\n1 2\n3 6\n4 5\n```\n\n#### 样例输出 #1\n\n```\n24\n```\n\n#### 提示\n\n我们选择的路线是\n\n```\n (1, 1) (1, 6)\n (2, 6) (2, 3)\n (3, 3) (3, 1)\n (4, 1) (4, 2)\n (5, 2) (5, 6)\n (6, 6) (6, 4) (6, 6)\n```\n不难计算得到，路程的总长度是 $24$。 \n\n对于 $100\\%$ 的数据中，$n \\le 2 \\times 10^4$，$1 \\le L_i \\le R_i \\le n$。\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t比较典型的DP，首先先想，每一层的最优肯定是由上一层限制的左端点或者右端点下来得到的，那么就可以有状态转移方程了。f[i] [0]表示走完第i行且停在第i行的左端点最少用的步数，f[i] [1]同理，停在右端点的最少步数。\n​\t\t那么转移就很简单了，走完当前行且停到左端点，那么一定是从右端点过来的，那么从上一行左端点转移的话就是f[i] [0]=abs(上一行左端点的坐标-本行右端点的坐标+本行线段长度)\n\n### 算法代码\n\n```\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,hang,ans=0;\nint l[20005];\nint r[20005];\nint f[29999][3];//F[X][0] left max \n\nint main(){\n scanf(\"%d\",&n);\n for(int i=1;i<=n;i++) scanf(\"%d%d\",&l[i],&r[i]);\n f[1][1]=r[1]-1;\n f[1][0]=r[1]-1+r[1]-l[1];\n for(int i=2;i<=n;i++){\n   if(l[i-1]>=r[i]){\n      f[i][1]=min(r[i]-l[i]+r[i]-l[i]+f[i-1][0]+1+l[i-1]-r[i],r[i]-l[i]+r[i]-l[i]+f[i-1][1]+1+r[i-1]-r[i]);\n      f[i][0]=min(f[i-1][0]+1+l[i-1]-l[i],f[i-1][1]+1+r[i-1]-l[i]); \n      }\n      else if(r[i-1]<=l[i]) {\n       f[i][0]=min(r[i]-l[i]+r[i]-l[i]+f[i-1][1]+1+l[i]-r[i-1],r[i]-l[i]+r[i]-l[i]+f[i-1][0]+1+l[i]-l[i-1]);\n       f[i][1]=min(f[i-1][1]+1+r[i]-r[i-1],f[i-1][0]+1+r[i]-l[i-1]);\n   }\n   else if(l[i]<=l[i-1]&&r[i]>=r[i-1]){\n    f[i][0]=min(r[i]-l[i]+f[i-1][1]+1+r[i]-r[i-1],r[i]-l[i]+r[i]-l[i]+f[i-1][0]+1+l[i-1]-l[i]);\n    f[i][1]=min(r[i]-l[i]+r[i]-l[i]+f[i-1][1]+1+r[i]-r[i-1],r[i]-l[i]+f[i-1][0]+1+l[i-1]-l[i]); \n   }\n   else if(l[i]>=l[i-1]&&r[i]<=r[i-1]){\n    f[i][0]=min(r[i]-l[i]+f[i-1][1]+1+r[i-1]-r[i],r[i]-l[i]+r[i]-l[i]+f[i-1][0]+1+l[i]-l[i-1]);\n    f[i][1]=min(r[i]-l[i]+r[i]-l[i]+f[i-1][1]+1+r[i-1]-r[i],r[i]-l[i]+f[i-1][0]+1+l[i]-l[i-1]);\n   }\n   else if(l[i]>=l[i-1]&&l[i]<=r[i-1]){\n    f[i][0]=min(r[i]-l[i]+f[i-1][1]+1+r[i]-r[i-1],r[i]-l[i]+r[i]-l[i]+f[i-1][0]+1+l[i]-l[i-1]);\n    f[i][1]=min(r[i-1]-l[i]+r[i]-l[i]+f[i-1][1]+1,f[i-1][0]+1+r[i]-l[i-1]); \n   }\n   else if(r[i]>=l[i-1]&&r[i]<=r[i-1]){\n    f[i][1]=min(r[i]-l[i]+r[i]-l[i]+f[i-1][1]+1+r[i-1]-r[i],r[i]-l[i]+l[i-1]-l[i]+f[i-1][0]+1);\n    f[i][0]=min(r[i]-l[i]+f[i-1][1]+1+r[i-1]-r[i],r[i]-l[i]+f[i-1][0]+1+r[i]-l[i-1]);\n   } \n }\n ans=min(f[n][0]+n-l[n],f[n][1]+n-r[n]);\n cout<<ans;\n return 0;\n} \n```\n\n## 总结与讨论\n\n​\t\t贪心算法基本不可解。\n\n\n\n# P5414 [YNOI2019] 排序\n\n## 题目描述\n\n对于一个数列 $\\{7, 1, 2, 3\\}$ 进行排序，我们可以把 $7$ 从头移动到尾。但是这个操作的成本是 $7$，并不是最佳的。最佳的排序方式是将连续的 $1,2,3$ 移动到 $7$ 的前面。这样的话，总的操作成本就是 $1+2+3=6$，比之前的成本 $7$ 要小。\n\n你的任务是，对于一个给定的数列，输出对这个数列进行排序的最小成本。\n\n### 输入格式\n\n输入文件名为sort.in。\n\n每个输入文件包含多组数据。\n\n输入文件的第一行，包含一个正整数 $T$，代表该输入文件中所含的数据组数。\n\n接下来是 $T$ 组数据，每组数据的格式如下：\n\n每组数据包含 $2$ 行；\n\n第一行包含一个正整数 $n$，代表数列中元素的个数，其中 $0 < n \\leq 10^2$；\n\n第二行包含 $n$ 个整数，两个数之间以一个空格隔开，代表数列中的元素 $k_i$，其中$-10^{7} \\leq k_i \\leq 10^{7}$。\n\n### 输出格式\n\n输出文件名为sort.out。\n\n输出文件包含 $T$ 行，分别对应 $T$ 组数据的答案，即对数列进行排序的最小成本。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n1\n4\n7 1 2 3\n```\n\n#### 样例输出 #1\n\n```\n6\n```\n\n#### 提示\n\n对于 $60\\%$ 的数据：$0 < n \\leq 60$，$-10^{7} \\leq k_i \\leq 10^{7}$\n\n对于 $80\\%$ 的数据：$0 < n \\leq 80$，$-10^{7} \\leq k_i \\leq 10^{7}$\n\n对于 $100\\%$ 的数据：$0 < n ≤ 10^2$，$-10^{7} \\leq k_i \\leq 10^{7}$\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t这道题就是移动几个数字使得数列单调上升，每次移动可以移动到任意位置，花费就是移动数字的大小。看到这个题之后，我们可以得到 ：最优解不可能把同一个数字移动2次及以上。既然我们可以一次把它移到正确的位置上，那么这个数字就可以理解为直接被移走了。那么问题就变成了：删除几个数字，使得数列单调递增，所求的是移走数字的最小和。 使得删除的和最小，就意味着留下的和最大。那么问题就变成了：保留几个单调递增的数字，使得和最大。\n\n### 算法代码\n\n```\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N=205;\nint a[N],dp[N];\n\nint read(){\n\tint x=0; \n\tchar c=getchar();\n\twhile(c<'0'||c>'9') \n\t\tc=getchar();\n\twhile('0'<=c&&c<='9'){ \n\t\tx=(x<<3)+(x<<1)+(c^48); \n\t\tc=getchar();\n\t}\n\treturn x;\n}\n\nint main(){\n\tint i,j,n;\n\tfor(int T=read(),sum=0,ans=0;T;T--,sum=0,ans=0){\n\t\tn=read(); \n\t\tfor(i=1;i<=n;i++){\n\t\t\ta[i]=read(),sum+=a[i];\n\t\t\tfor(j=1;j<i;j++)\n\t\t\t\tif(a[j]<=a[i]&&dp[i]<dp[j])\n\t\t\t\t\tdp[i]=dp[j];\n\t\t\tdp[i]+=a[i];\n\t\t}\n\t\tfor(i=1;i<=n;i++)\n\t\t\tans=max(ans,dp[i]);\n\t\tprintf(\"%d\\n\",sum-ans);\n\t}\n}\n```\n\n## 总结与讨论\n\n​\t\t将问题转化之后其实并不是太难。\n\n\n\n# P2023 [AHOI2009] 维护序列\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P2023\n- 登陆账号：SkyTravelar\n\n## 题目背景\n\n老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。\n\n## 题目描述\n\n有一个长为 $n$ 的数列 $\\{a_n\\}$，有如下三种操作形式：\n\n1. 格式 `1 t g c`，表示把所有满足 $t\\le i\\le g$ 的 $a_i$ 改为 $a_i\\times c$ ;\n2. 格式 `2 t g c` 表示把所有满足 $t\\le i\\le g$ 的 $a_i$ 改为 $a_i+c$ ;\n3. 格式 `3 t g` 询问所有满足 $t\\le i\\le g$ 的 $a_i$ 的和，由于答案可能很大，你只需输出这个数模 $p$ 的值。\n\n### 输入格式\n\n第一行两个整数 $n$ 和 $p$。\n\n第二行含有 $n$ 个非负整数，表示数列 $\\{a_i\\}$ 。\n\n第三行有一个整数 $m$，表示操作总数。\n\n从第四行开始每行描述一个操作，同一行相邻两数之间用一个空格隔开，每行开头和末尾没有多余空格。\n\n### 输出格式\n\n对每个操作 3，按照它在输入中出现的顺序，依次输出**一行一个整数**表示询问结果。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n7 43\n1 2 3 4 5 6 7\n5\n1 2 5 5\n3 2 4\n2 3 7 9\n3 1 3\n3 4 7\n```\n\n#### 样例输出 #1\n\n```\n2\n35\n8\n```\n\n#### 提示\n\n##### 样例输入输出 1 解释\n\n- 初始时数列为 $\\{1,2,3,4,5,6,7\\}$。\n- 经过第 $1$ 次操作后，数列为 $\\{1,10,15,20,25,6,7\\}$。\n- 对第 $2$ 次操作，和为 $10+15+20=45$，模 $43$ 的结果是 $2$。\n- 经过第 $3$ 次操作后，数列为 $\\{1,10,24,29,34,15,16\\}$。\n- 对第 $4$ 次操作，和为 $1+10+24=35$，模 $43$ 的结果是 $35$。\n- 对第 $5$ 次操作，和为 $29+34+15+16=94$，模 $43$ 的结果是$8$。\n\n\n##### 数据规模与约定\n\n测试数据规模如下表所示：\n\n| 数据点编号 |  1   |   2    |   3    |    4    |    5    |    6    |    7    |    8    |   9,10   |\n| :--------: | :--: | :----: | :----: | :-----: | :-----: | :-----: | :-----: | :-----: | :------: |\n|    $n=$    | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |\n|    $m=$    | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |\n\n对于全部的测试点，保证 $0 \\leq p, a_i, c \\leq 10^9$，$1 \\leq t \\leq g \\leq n$。\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t本题较之平常的线段树,会有一点不同.就是多了一个乘的操作.所以我们需要令一个优先级,即先乘后加.因为加无论什么时候加都没有关系,但是乘会对整个答案产生影响.于是乎,只要打两个标记.在乘的时候,加的标记也要乘上那个值.\n\n### 算法代码\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=2e5+1;\nstruct Node{\n\tll l;\n\tll r;\n\tll k;\n\tll add;\n\tll mul;\n}tree[N*4];\nll n,m,Mod,pos;\ninline ll build_tree(ll value,ll l,ll r){\n\ttree[value]=Node{l,r,0,0,1};\n\tif (l==r){\n\t\tll num;\n\t\tscanf(\"%lld\",&num);\n\t\treturn tree[value].k=num%Mod;\n\t}\n\tll mid=(l+r)>>1;\n\treturn tree[value].k=(build_tree(value*2,l,mid)+build_tree(value*2+1,mid+1,r))%Mod;\n}\ninline void pushdown(ll value){\n\ttree[value*2].add=(tree[value].add+tree[value*2].add*tree[value].mul)%Mod;\n\ttree[value*2+1].add=(tree[value].add+tree[value*2+1].add*tree[value].mul)%Mod;\n\ttree[value*2].mul=(tree[value].mul*tree[value*2].mul)%Mod;\n\ttree[value*2+1].mul=(tree[value].mul*tree[value*2+1].mul)%Mod;\n\ttree[value*2].k=(tree[value].mul*tree[value*2].k+tree[value].add*(tree[value*2].r-tree[value*2].l+1))%Mod;\n\ttree[value*2+1].k=(tree[value].mul*tree[value*2+1].k+tree[value].add*(tree[value*2+1].r-tree[value*2+1].l+1))%Mod;\n\ttree[value].add=0;\n\ttree[value].mul=1;\n}\ninline ll query(ll value,ll L,ll R){\n\tpushdown(value);\n\tif (tree[value].l>=L&&tree[value].r<=R)\n\t\treturn tree[value].k%Mod;\n\tll mid=(tree[value].l+tree[value].r)>>1;\n    return ((L<=mid?query(value*2,L,R):0)+(R>mid?query(value*2+1,L,R):0))%Mod;\n}\ninline void updata(ll value,ll x,ll pos,ll L,ll R){\n\tpushdown(value);\n\tif (pos==1&&tree[value].l>=L&&tree[value].r<=R){\n\t\ttree[value].mul=(tree[value].mul*x)%Mod;\n        tree[value].add=(tree[value].add*x)%Mod;\n        tree[value].k=(tree[value].k*tree[value].mul)%Mod;\n        return;\n\t}\n\tif(pos==2&&tree[value].l>=L&&tree[value].r<=R){\n        tree[value].add=(tree[value].add+x)%Mod;\n        tree[value].k=(tree[value].k+tree[value].add*(tree[value].r-tree[value].l+1))%Mod;\n        return;\n    }\n    ll mid=(tree[value].l+tree[value].r)/2;\n    if(L<=mid)\n        updata(value*2,x,pos,L,R);\n    if(R>mid)\n        updata((value*2)+1,x,pos,L,R);\n    tree[value].k=(tree[value*2].k+tree[value*2+1].k)%Mod;\n}\nint main(){\n\tscanf(\"%lld%lld\",&n,&Mod);\n\tbuild_tree(1,1,n);\n\tcin>>m;\n\tfor (ll i=1;i<=m;i++){\n\t\tcin>>pos;\n\t\tll x,y;\n\t\tcin>>x>>y; \n\t\tif (pos!=3){\n\t\t\tll k;\n\t\t\tcin>>k;\n\t\t\tupdata(1,k,pos,x,y);\n\t\t}\n\t\telse if (pos==3)\n\t\t\tprintf(\"%lld\\n\",query(1,x,y));\n\t}\n}\n```\n\n## 总结与讨论\n\n​\t\t难","tags":["算法分析与设计"]},{"title":"十六进制转二进制并输出","url":"/2023/04/26/12/","content":"\n要求如下:\n\n- 从键盘输入两个四位十六进制数。\n- 将这两个数以二进制形式输出，要求输出的0和1颜色交替变化。\n- 找出这两个数中的偶数，若有则以十进制输出，若无，输出“NO”。\n- 计算这两个数的平方和。\n- 数据的输入和结果的输出都要有必要的提示，且提示独占一行。\n- 要使用到子程序。\n\n实现如下：\n\n```\ndata segment\n  str1 db 0ah,0dh,'Input number1 :',0ah,0dh,'$'\n  str2 db 0ah,0dh,'Input number2 :',0ah,0dh,'$' \n  str3 db 0ah,0dh,'Output number1 bin :',0ah,0dh,'$'\n  str4 db 0ah,0dh,'Output number2 bin :',0ah,0dh,'$'\n  str5 db 0ah,0dh,'Judge number1 oushu :',0ah,0dh,'$'\n  str6 db 0ah,0dh,'Judge number2 oushu :',0ah,0dh,'$'\n  str7 db 0ah,0dh,'Output powsum :',0ah,0dh,'$'\n  str8 db 0ah,0dh,'Program End !!!',0ah,0dh,'$'\nnum dw 2 dup(?)\n  str db 5,?,5 dup(?)\n  a dw ?\n  d dw ?\n  f dw ?\ndata ends\ncode segment\n  assume cs:code,ds:data\n  main proc far             ;主函数\nstart:\n  mov ax,data\n  mov ds,ax\n  \n  lea dx,str1\n  mov ah,09h\n  int 21h\n  call input\n  mov ax,num                \n  mov num+2,ax              ;将输入的第一个16进制数存到num+2中\n\n  lea dx,str2\n  mov ah,09h\n  int 21h\n  call input                ;第二个输入的16进制数存到num中\n  \n  lea dx,str3\n  mov ah,09h\n  int 21h\n  mov bx,num+2\n  call bin                  ;将第一个数以2进制输出\n  \n  lea dx,str4\n  mov ah,09h\n  int 21h\n  mov bx,num\ncall bin                  ;将第二个数以2进制输出\n\n  lea dx,str5\n  mov ah,09h\n  int 21h\n  mov bx,num+2\n  call oushu                ;判断第一个数是否为偶数\n\n  lea dx,str6\n  mov ah,09h\n  int 21h\n  mov bx,num\n  call oushu                ;判断第二个数是否为偶数\n  \n  lea dx,str7\n  mov ah,09h\n  int 21h\n  call powsum               ;将两数平方相加并以16进制输出\n\n  lea dx,str8\n  mov ah,09h\n  int 21h\n\n  mov ax,4c00h\n  int 21h  \nmain endp\n\ninput proc near              ;子程序1：输入16进制数\n  lea dx,str\n  mov ah,0ah\n  int 21h\n  lea si,str+2\n  mov cx,4\n  mov dx,0\nA1:\n push cx                    ;保护cx防止被后面左移改变\n  mov al,[si]\n  cmp al,'0'                 ;判断与0的大小，小于则退出\n  jb A4\n  cmp al,'F'                 ;判断与F的大小，大于则退出\n  ja A4\n  cmp al,'9'                 ;判断与9的大小\njbe A2\n  sub al,07h\nA2: \n  sub al,30h\n  cbw                        ;扩大al为ax，用于存4位16进制数\n  add dx,ax                  ;加到dx，dx用来存每次变化后的结果\n  cmp cx,1                   ;防止在将第4位数加入后仍左移\n  jz A3\n  mov cl,4\n  shl dx,cl                  ;dx左移4位，便于下一位16进制数加入dx\nA3:\n  inc si\n  pop cx\n  loop A1\nA4: \n  mov num ,dx  \n  ret\ninput endp \n\nbin proc near                ;子程序2：输出2进制，颜色交替\n  mov cx,8                   ;循环8次，每次输出两位颜色交替2进制数\n  mov dx,0\nB1:\n  mov ax,0\n  shl bx,1\n  adc al,0                   ;循环左移1位，将cf表示位最高位2进制数\n  push cx                    ;保护cx避免后面重复输出1次时发生改变\n  push bx                    ;保护bx避免改变\n  add al,30h\n  mov cx,1\n  mov bl,04h                ;设置为红色\n  mov bh,0\n  mov ah,09h\n  int 10h\n  mov ah,03h                ;03号功能读取当前光标位置，确定dh的有坐标和dl的x坐标\n  int 10h\n  inc dl                    ;光标右移1位\n  mov ah,02h                ;02号功能设置光标位置\n  int 10h\n  pop bx\n  mov ax,0\n\n  shl bx,1\n  adc al,0\n  push bx\n  add al,30h\n  mov cx,1\n  mov bl,0ah               ;设置为浅绿色\n  mov bh,0\n  mov ah,09h\n  int 10h\n  mov ah,03h\n  int 10h\n  inc dl\n  mov ah,02h\n  int 10h\n  pop bx\n  pop cx\n  loop B1\n  \n  ret\nbin endp\noushu proc near            ;子程序3：判断偶数并输出\n  push bx                  ;保护bx\n  and bx,0001h             ;取2进制的末位\n  mov cx,8\nC1:\n  cmp bl,0h                ;判断2进制末位为0则偶数\n  jz C2\n  mov ah,02h               ;非偶数输出’NO’\n  mov dl,'N'\n  int 21h\n  mov ah,02h\n  mov dl,'O'\n  int 21h\n  pop bx\n  jmp C3\n\nC2:\n  pop bx\n  mov cx,5\n  mov ax,bx\n  mov bx,10\nC4:\n  mov dx,0\n  div bx                    ;除10，余数压栈\n  add dl,30h\n  push dx\n  loop C4\n  mov cx,5\nC5:\n  pop dx\n  mov ah,02h                ;10进制输出\n  int 21h\n  loop C5\nC3:\n  ret\noushu endp\n\npowsum proc near            ;子程序4：计算平方和\n\n  mov ax,num\n  mul num\n  mov a,ax\n  mov d,dx\n\t\n  mov ax,num+2\n  mul num+2\n  add a,ax                  \n  adc d,dx                  ;将ax相加的进位与dx相加\n  adc f,0                   ;dx相加可能产生进位，cf为最高位16进制数\n  mov dx,f\n  add dl,30h\n  mov ah,02h\n  int 21h\n\t\n  mov cx,4\n  mov dx,d\nD1:\t\n  push cx\t\n  mov cl,4\n  rol dx,cl\t               ;循环左移，\n  push dx\n  and dl,0fh                 ;dx最末位为所要输出的16进制数\n  cmp dl,9\n  jbe D2\n  add dl,7h\nD2:\n  add dl,30h\n  mov ah,02h\n  int 21h \n  pop dx\n  pop cx\n  loop D1\n\n  mov cx,4\n  mov dx,a\nD3:\n  push cx\t\n  mov cl,4\n  rol dx,cl\t               ;循环左移\n  push dx\n  and dl,0fh                 ;ax最末位为所要输出的16进制数\n  cmp dl,9\n  jbe D4\n  add dl,7h\nD4:\n  add dl,30h\n  mov ah,02h\n  int 21h \n  pop dx\n  pop cx\n  loop D3\n  ret\npowsum endp\ncode ends\nend main\n```\n\n","tags":["汇编"]},{"title":"对二十个数进行排序","url":"/2022/12/12/10/","content":"```\ndata segment\narray \tdw 40 dup(0)\nten \tdb 10 \nfuyi \tdw -1\t\nflag\tdb 0\ndata ends\n\nstack segment \n\tdw 40 dup(0)\nstack ends\n\nassume cs:code, ds:data, ss:stack\n\ncode segment\n\tstart:\t\t\n\t\tmov ax,data\n        mov ds,ax\n        mov ax,stack\n        mov ss,ax\n        mov sp,80\n        mov si,0 \n        mov cx,20\t\n        call scan\t\n        mov cx,20\n        call sort\n        mov si,0\n        mov cx,20\n        call to_char\n        mov ax,4c00h\n        int 21h\n\tscan:\t\t\n\t\tpush ax\n        push bx\n        push dx\n\tl1:\t\t\n\t\tmov dx,0\t\t\t\n\tll2:\t\n\t\tmov ah,1\n        int 21h\t\t\t\t\n        cmp al,' '\n        je continue\t\t\t\n        cmp al,'-'\n        je negtive\t\t\t\n        sub al,30h\n        mov bl,al \n        mov ax,array[si]\n        mul ten\n        mov bh,0\n        add ax,bx\n        mov array[si],ax\n        jmp ll2\t\t\nnegtive:\n        inc dx\t\n        jmp ll2\t\t\t\ncontinue:\t\t\t\t\t\t\t\n        cmp dx,0\t\t\t\n        je l\t\n        mov ax,array[si]\n        imul fuyi\n        mov array[si],ax\n\t\tl:\t\n        add si,2\n        loop l1\n        pop dx\n        pop bx\n        pop ax\n        ret\n\tsort:\t\t\n\t\tpush di\n        push bx\n        push ax\t\t\t\n\t\tdec cx\n\ts1:\t\t\n\t\tmov di,cx\n\t\tmov bx,0\n    s2:\t\t\n    \tmov ax,array[bx]\n        cmp ax,array[bx+2]\n        jle s3\n        xchg ax,array[bx+2]\n        mov array[bx],ax\n\ts3:\t\t\n\t\tadd bx,2\n        loop s2\t\t\t\n        mov cx,di\n        loop s1\t\t\t\n        pop ax\n        pop bx\n        pop di\n        ret\t\t\t\nto_char:\n    \tpush ax\n    \tpush bx\n    \tpush dx\n    \tpush di   \t\n    \tmov dl,0ah\t\n    \tmov ah,2\n    \tint 21h    \t\n\tl2:\t\t\n\t\tpush cx\n\t\tmov bx,0\n\t\tmov flag,0\n\tl3:\t\t\t\t\t\t\t\t\t\t\t\n\t\tmov ax,[si]\n\t\tand ah,10000000b\n\t\tcmp ah,0\n\t\tje b\t\t\t\t\n\t\tmov ax,[si]\t\t\t\n\t\timul fuyi\n\t\tmov [si],ax\n\t\tmov flag,1\t\t\t\t\t\n\tb:\t\n\t\tinc bx\t\n\t\tmov cx,10\n\t\tcall divtw\n    \tmov dh,7\n    \tadd dl,30h\n    \tpush dx\t\n    \tcmp word ptr [si],0\n    \tje j\n    \tloop l3    \t\n    j:\t\n    \tcmp flag,1\n    \tjne q\n    \tinc bx\n\t\tmov dh,7\n\t\tmov dl,'-'\n\t\tpush dx    \t\n    q:\t\n    \tmov cx,bx\n    k:\t\n    \tpop dx\n    \tmov ah,2\n    \tint 21h\n    \tloop k\n    \tmov dl,' '\n    \tmov ah,2\n    \tint 21h    \t\n    \tpop cx\n   \t\tadd si,2\n    \tloop l2    \t\n    \tpop di\n    \tpop dx\n    \tpop bx\n    \tpop ax\n    \tret    \t\n divtw:\n \t\tpush ax\t\t\n\t\tmov dx,0\n\t\tmov ax,[si]\n\t\tdiv cx\n\t\tmov [si],ax\t\t\n\t\tpop ax\n\t\tret\t\t\t\t\t\t\t\t\ncode ends\nend start\n```\n\n","tags":["汇编"]},{"title":"输出斐波拉契数列前20项","url":"/2022/12/12/9/","content":"```\nDATAS SEGMENT\n VAL    DW 20 DUP(0)\nDATAS ENDS\nSTACKS SEGMENT\n DW 30 DUP(0)\nSTACKS ENDS\nCODES SEGMENT\n    ASSUME CS:CODES,DS:DATAS,SS:DATAS\nSTART:\n    MOV AX,DATAS\n    MOV DS,AX\n    MOV AX,STACKS\n    MOV SS,AX\n    MOV DI,0\n    MOV AX,1\n    MOV DX,1\n    JMP FIBO\n    \nFIBO:   MOV VAL[DI],AX\n\t\tADD DI,2\n\t\tMOV VAL[DI],DX\n\t\tADD DI,2\n\t\tADD AX,DX\n\t\tADD DX,AX\n\t\tCMP DI,40\n\t\tJAE  BACK\n\t\tCALL FIBO\n\t\tRET\n\t  \nBACK:   \n  MOV DI,0\n   MOV CX,20\n   MOV DX,0\n   \nL1:    \n        MOV AX,VAL[DI]\n  ADD DI,2\n  CMP AX,1000\n  JNB P1\n  CMP AX,100\n  JNB P2\n  CMP AX,10\n  JNB P3\n  CMP AX,1\n  JNB P4\n\n  \nP1:  MOV BX,1000\n  DIV BX\n  PUSH DX\n  MOV DX,AX\n  ADD DL,30H\n  MOV AH,2H\n  INT 21H\n  POP AX\n  MOV DX,0\n  \nP2:  MOV BX,100\n  DIV BX\n  PUSH DX\n  MOV DX,AX\n  ADD DL,30H\n  MOV AH,2H\n  INT 21H\n  POP AX\n  MOV DX,0\n  \nP3:     MOV BX,10\n  DIV BX\n  PUSH DX\n  MOV DX,AX\n  ADD DL,30H\n  MOV AH,2H\n  INT 21H\n  POP AX\n  MOV DX,0\n  \nP4:    \n        MOV BX,1\n  DIV BX\n  PUSH DX\n  MOV DX,AX\n  ADD DL,30H\n  MOV AH,2H\n  INT 21H\n  POP AX\n  \n  MOV DL,32\n  MOV AH,2H\n  INT 21H\n  MOV DX,0\n  LOOP L1\n  \n  MOV AX,4C00H\n  INT 21H\nCODES ENDS\n    END START\n\n```\n\n","tags":["汇编"]},{"title":"输出斐波拉契数列前50项","url":"/2022/12/12/8/","content":"```\nDATAS SEGMENT\n\tDW 200 DUP(0)\n   \nDATAS ENDS\n\nSTACKS SEGMENT\n    DW 30 DUP(0)\nSTACKS ENDS\n\nCODES SEGMENT\n    ASSUME CS:CODES,DS:DATAS,SS:STACKS\nSTART:\n\t.386\n\tMOV AX,DATAS\n\tMOV DS,AX\n\tMOV AX,STACKS\n\tMOV SS,AX\n\tMOV SI,0\n\tMOV DI,0 \n\tMOV EAX,1\n\tMOV EDX,0\n\tJMP PRINT11\nA:\n\tCALL FIBO\n\nFIBO:\n\tCMP DI,392\n\tJE BACK\n\t\n\tCMP DI,0\t\n\tJE SET1\n\nSET1BACK:\n\tCMP DI,8\n\tJE SET2\n\nSET2BACK:\n\tADD DI,8\n\tMOV EAX,DS:[DI-8]\n\tMOV EDX,DS:[DI-4]\n\tMOV ECX,DS:[DI-12]\n\tMOV EBX,DS:[DI-16]\n\tADD EAX,EBX\n\tADC EDX,ECX\n\tMOV DS:[DI],EAX\n\tMOV DS:[DI+4],EDX\n\tCALL PRINT\n\nPRINTBACK:\t\n\tCALL FIBO\n\t\n;==================================================\nSET1:\n\tMOV DS:[0],EAX\n\tMOV DS:[4],EDX\n\tADD DI,8\n\tJMP SET1BACK\n;==================================================\nSET2:\n\tMOV DS:[8],EAX\n\tMOV DS:[12],EDX\n\tJMP SET2BACK\n;==================================================\t\n\n;PRINT EDX EAX\nPRINT:\n\tPUSH EAX\n\tPUSH EBX\n\tPUSH ECX\n\tPUSH EDX\n\tCMP EDX,10B\n\tJNB P1\n\tCMP EDX,0\n\tJA  P2\n\tCMP EAX,1000000000\n\tJNB P2\n\tCMP EAX,100000000\n\tJNB P3\n\tCMP EAX,10000000\n\tJNB P4\n\tCMP EAX,1000000\n\tJNB P5\n\tCMP EAX,100000\n\tJNB P6\n\tCMP EAX,10000\n\tJNB P7\n\tCMP EAX,1000\n\tJNB P8\n\tCMP EAX,100\n\tJNB P9\n\tCMP EAX,10\n\tJNB P10\n\tCMP EAX,1\n\tJNB P11\n\nP1:\n\tMOV DL,1\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tMOV EAX,10011010001001110101010101100001B\n\tMOV EDX,0\n\nP2:\n\tMOV EBX,1000000000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP3:\n\tMOV EBX,100000000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP4:\n\tMOV EBX,10000000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP5:\n\tMOV EBX,1000000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP6:\n\tMOV EBX,100000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP7:\n\tMOV EBX,10000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP8:\n\tMOV EBX,1000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP9:\n\tMOV EBX,100\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP10:\n\tMOV EBX,10\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\t\n\nP11:\n\tMOV EBX,1\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\tMOV DL,32\n\tMOV AH,2H\n\tINT 21H\n\t\n\tPOP EDX\n\tPOP ECX\n\tPOP EBX\n\tPOP EAX\n\tJMP PRINTBACK\n;PRINT END\n\n\n;PRINT11\nPRINT11:\n\tPUSH EDX\n\tPUSH EAX\n\t\n\tMOV DL,1\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tMOV DL,32\n\tMOV AH,2H\n\tINT 21H\n\t\n\tMOV DL,1\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tMOV DL,32\n\tMOV AH,2H\n\tINT 21H\n\t\n\tPOP EAX\n\tPOP EDX\n\t\n\tJMP A\n\nBACK:\n\tMOV AX,4C00H\n   \tINT 21H\nCODES ENDS\n    END START\n```\n\n","tags":["汇编"]},{"title":"航班信息管理系统","url":"/2022/12/12/7/","content":"```\n#include <iostream>\n#include <string>   \n#include <iomanip>   \n#include <fstream> \n#include <random> \n#include <ctime>   \n#include <windows.h> \n\nusing namespace std;\n\ntypedef struct flightnode\n{\n\tstring flight_num;       //航班号\n\tstring time;             //起飞时间\n\tint date = 0;            //起飞日期\n\tstring start_place;      //出发地\n\tstring end_place;        //目的地\n\tfloat discount = 0;      //折扣\n\tint left = 0;            //余票\n\tfloat price = 0;         //价格\n\tflightnode* next = NULL;\n}*flightlist;\n\nstruct ticket\n{\n\tstring flight_num;\t  //航班号\n\tstring time;\t\t  //起飞时间\n\tstring start_place;\t  //出发地\n\tstring end_place;     //目的地\n\tfloat price = 0;      //价格\n\tint date = 0;         //起飞日期\n\tstring order_num;\t  //订单编号\n};\n\ntypedef struct passengernode\n{\n\tstring name;        //名字\n\tstring ID_num;      //证件号\n\tticket ticket;      //票\n\tint full = 0;       //预约标志  1表示预约状态\n\tpassengernode* next = NULL;\n}*passengerlist;\n\n//航班类信息\nvoid Init_flight(flightlist& h);\t\t//初始化航班\nvoid Load_flight(flightlist& h);\t\t//载入航班\nvoid Add_flight(flightlist& h);\t\t\t//添加航班\nvoid Check_flight(flightlist& h);\t\t//查找航班\nvoid Check_flightnum(flightlist& h);\t//航班号查找\nvoid Check_seplace(flightlist& h);\t\t//起始地查找\nvoid Check_all(flightlist& h);\t\t\t//浏览全部航班\nvoid Revise_flight(flightlist& h);\t\t//修改航班信息\nvoid Delete_flight(flightlist& h);\t\t//删除航班\nvoid Revise_time(flightlist& h);\t\t//修改起飞抵达时间\nvoid Revise_price(flightlist& h);\t\t//修改价格\nvoid Save_flight(flightlist& h);\t\t//保存航班信息\n//用户信息\nvoid Init_passenger(passengerlist& c);\t\t\t//初始化用户\nvoid Load_passenger(passengerlist& c);\t\t\t//载入用户信息\nvoid Book(flightlist& h, passengerlist& c);\t\t//定票\nvoid Qbook(flightlist& h, passengerlist& c);\t//退票\nvoid Check_book(passengerlist& c);\t\t\t\t//查询订单\nvoid Save_passenger(passengerlist& c);\t\t\t//保存用户信息\n//管理操作\nvoid manage(flightlist& flight, passengerlist& passenger);\nvoid password();//密码管理\n//通用\nvoid wait();\n\n\n\n\nvoid manage(flightlist& flight, passengerlist& passenger)\n{\n\twhile (1) {\n\t\tcout << \"航班信息管理系统\" << endl << endl;\n\t\tcout << \"主菜单\" << endl;\n\t\tcout << \"1.录入航班信息\" << endl;\n\t\tcout << \"2.查询航班\" << endl;\n\t\tcout << \"3.订票\" << endl;\n\t\tcout << \"4.退票\" << endl;\n\t\tcout << \"5.查询订单\" << endl;\n\t\tcout << \"6.修改航班信息\" << endl;\n\t\tcout << \"0.退出系统 \" << endl;\n\t\tcout << \"请输入您想要进行的功能：\";\n\t\tint i;\n\t\tcin >> i;\n\t\tsystem(\"cls\");\n\t\tswitch (i) {\n\t\tcase 1:Add_flight(flight); Save_flight(flight); wait(); break;\n\t\tcase 2:Check_flight(flight); wait(); break;\n\t\tcase 3:Book(flight, passenger); Save_flight(flight); Save_passenger(passenger); wait(); break;\n\t\tcase 4:Qbook(flight, passenger); Save_flight(flight); Save_passenger(passenger); wait(); break;\n\t\tcase 5:Check_book(passenger); wait(); break;\n\t\tcase 6:Revise_flight(flight); Save_flight(flight); wait(); break;\n\t\tcase 0:exit(0); break;\n\t\tdefault:cout << \"请检查你的输入！\" << endl; break;\n\t\t}\n\t}\n}\n\nvoid Sort_flight(flightlist& h)\n{\n\tflightlist p = h->next;  //指向第一个结点\n\twhile (p != NULL) {\n\t\tflightlist q = h->next;   //指向p后一个结点\n\t\twhile (q) {\n\t\t\tif (q->date > p->date) {\n\t\t\t\tflightnode temp = *p;   //临时保存指针交换\n\t\t\t\ttemp.next = q->next;\n\t\t\t\tq->next = p->next;\n\t\t\t\t*p = *q;\n\t\t\t\t*q = temp;\n\t\t\t}\n\t\t\tq = q->next;   //指针移动\n\t\t}\n\t\tp = p->next;    //指针移动\n\t}\n\n}\n\nvoid Init_flight(flightlist& h)//初始化航班\n{\n\th = new flightnode;  //头指针\n\th->next = NULL;\n}\n\nvoid Load_flight(flightlist& h)//载入航班\n{\n\tflightlist f = h;\n\tflightlist newp = new flightnode;\n\tifstream ifs(\"FlightList.txt\");\n\tif (!ifs.is_open()) {\n\t\tcout << \"文件未被打开！\" << endl;\n\t\treturn;\n\t}\n\twhile (ifs >> newp->flight_num >> newp->date >> newp->time >> newp->start_place >> newp->end_place >> newp->price >> newp->discount >> newp->left) {\n\t\tf->next = newp;\n\t\tf = f->next;\n\t\tnewp = new flightnode;\n\t}\n\tf->next = NULL;\n\tdelete newp;\n}\n\nvoid Add_flight(flightlist& h)//添加航班\n{\n\tchar mark = 'y';\n\tflightlist s, rear;\n\tfor (rear = h; rear->next != NULL; rear = rear->next) {}  // rear移动结点尾\n\twhile (mark == 'y' || mark == 'Y') {\n\t\ts = new flightnode;\n\t\tcout << \"请输入航班号：\";\n\t\tcin >> s->flight_num;\n\t\tcout << \"请输入起飞日期：\";\n\t\tcin >> s->date;\n\t\tcout << \"请输入起飞时间：\";\n\t\tcin >> s->time;\n\t\tcout << \"请输入出发地：\";\n\t\tcin >> s->start_place;\n\t\tcout << \"请输入目的地：\";\n\t\tcin >> s->end_place;\n\t\tcout << \"请输入价格：\";\n\t\tcin >> s->price;\n\t\tcout << \"请输入折扣：\";\n\t\tcin >> s->discount;\n\t\tcout << \"请输入余票：\";\n\t\tcin >> s->left;\n\t\trear->next = s;\n\t\trear = s;\n\t\tcout << \"添加成功！\" << endl;\n\t\tcout << \"是否继续添加？（是“y”/否“n”）：\";\n\t\tcin >> mark;\n\t}\n\trear->next = NULL;\n}\n\nvoid Check_flight(flightlist& h)//查找航班\n{\n\tint i;\n\tcout << \"查找方式\" << endl;\n\tcout << \"1.航班查找\" << endl;\n\tcout << \"2.起始地查找\" << endl;\n\tcout << \"3.浏览全部航班\" << endl;\n\tcout << \"请输入查找方式：\";\n\tcin >> i;\n\tswitch (i) {\n\tcase 1:Check_flightnum(h); break;\n\tcase 2:Check_seplace(h); break;\n\tcase 3:Check_all(h); break;\n\tdefault:break;\n\t}\n}\n\nvoid Check_flightnum(flightlist& h)//航班号查找\n{\n\tstring flightnum;\n\tflightlist p = h->next;\n\tcout << \"请输入航班号：\";\n\tcin >> flightnum;\n\tcout << setw(6) << \"航班号\" << setw(17) << \"起飞日期\" << setw(15) << \"起飞时间\" << setw(15) << \"出发地\" << setw(15) << \"目的地\" << setw(15) << \"价格\" << setw(15) << \"折扣\" << setw(15) << \"余票\" << endl;\n\twhile (p != NULL) {\n\t\tif (p->flight_num == flightnum) {\n\t\t\tcout << setw(6) << p->flight_num << setw(15) << p->date << \"日\" << setw(15) << p->time << setw(15) << p->start_place << setw(15) << p->end_place << setw(15) << p->price << setw(15) << p->discount << setw(15) << p->left << endl;\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t\tp = p->next;\n\t}\n\tcout << setw(32) << \"未查到任何信息。\";\n\twait();\n}\n\nvoid Check_seplace(flightlist& h)//起始地查找\n{\n\tstring start_place, end_place;\n\tcout << \"请输入出发地：\";\n\tcin >> start_place;\n\tcout << \"请输入目的地：\";\n\tcin >> end_place;\n\tflightlist p = h->next;\n\tcout << setw(6) << \"航班号\" << setw(17) << \"起飞日期\" << setw(15) << \"起飞时间\" << setw(15) << \"出发地\" << setw(15) << \"目的地\" << setw(15) << \"价格\" << setw(15) << \"折扣\" << setw(15) << \"余票\" << endl;\n\twhile (p != NULL) {\n\t\tif (p->start_place == start_place && p->end_place == end_place) {\n\t\t\tcout << setw(6) << p->flight_num << setw(15) << p->date << \"号\" << setw(15) << p->time << setw(15) << p->start_place << setw(15) << p->end_place << setw(15) << p->price << setw(15) << p->discount << setw(15) << p->left << endl;\n\t\t\treturn;\n\t\t}\n\t\tp = p->next;        //移动\n\t}\n\tcout << \"未查到任何信息\" << endl;\n\twait();\n}\n\nvoid Check_all(flightlist& h)//浏览全部航班\n{\n\tSort_flight(h);  //日期排序\n\tflightlist p = h->next;\n\tcout << setw(6) << \"航班号\" << setw(17) << \"起飞日期\" << setw(15) << \"起飞时间\" << setw(15) << \"出发地\" << setw(15) << \"目的地\" << setw(15) << \"价格\" << setw(15) << \"折扣\" << setw(15) << \"余票\" << endl;\n\twhile (p != NULL)\n\t{\n\t\tcout << setw(6) << p->flight_num << setw(15) << p->date << \"号\" << setw(15) << p->time << setw(15) << p->start_place << setw(15) << p->end_place << setw(15) << p->price << setw(15) << p->discount << setw(15) << p->left << endl;\n\t\tp = p->next;   //移动\n\t}\n}\n\nvoid Revise_flight(flightlist& h)//修改航班信息\n{\n\tflightlist f = h->next;\n\tint i;\n\tcout << \"修改内容:\" << endl;\n\tcout << \"1.删除航班\" << endl;\n\tcout << \"2.修改起飞时间\" << endl;\n\tcout << \"3.修改航班价格\" << endl;\n\tcout << \"4.返回\" << endl;\n\tcout << \"请输入查找方式：\";\n\tcin >> i;\n\tCheck_all(h);     //浏览全部\n\tswitch (i) {\n\tcase 1:Delete_flight(h); break;\n\tcase 2:Revise_time(h); break;\n\tcase 3:Revise_price(h); break;\n\tcase 4:return; break;\n\tdefault:cout << \"请检查你的输入！\" << endl; break;\n\t}\n}\n\nvoid Delete_flight(flightlist& h)//删除航班\n{\n\tflightlist p = h->next, q = h;  //q是p的前驱\n\tstring flightnum;\n\tcout << \"请输入您想要修改的航班号：\";\n\tcin >> flightnum;\n\twhile (p != NULL) {\n\t\tif (p->flight_num == flightnum) {\n\t\t\tq->next = p->next;      //p是要删除的结点，q是前一个结点\n\t\t\tdelete p;\n\t\t\tcout << \"删除成功！\";\n\t\t\twait();\n\t\t\treturn;\n\t\t}\n\t\tq = q->next;\n\t\tp = q->next;\n\t}\n\tcout << \"未查找到相关航班！\";\n\twait();\n}\n\nvoid Revise_time(flightlist& h)//修改起飞抵达时间\n{\n\tstring flightnum;\n\tflightlist p = h->next;\n\tcout << \"请输入您想要修改的航班号：\";\n\tcin >> flightnum;\n\twhile (p != NULL) {\n\t\tif (p->flight_num == flightnum) {\n\t\t\tcout << \"请输入新的起飞日期：\";\n\t\t\tcin >> p->date;\n\t\t\tcout << \"请输入新的起飞时间：\";\n\t\t\tcin >> p->time;\n\t\t\tcout << \"修改成功！\";\n\t\t\twait();\n\t\t\treturn;\n\t\t}\n\t\tp = p->next;\n\t}\n\tcout << \"没有您想要修改的航班号!\";\n\twait();\n}\n\nvoid Revise_price(flightlist& h)//修改价格\n{\n\tstring flightnum;\n\tflightlist p = h->next;\n\tcout << \"请输入您想要修改的航班号：\";\n\tcin >> flightnum;\n\twhile (p != NULL) {\n\t\tif (p->flight_num == flightnum) {\n\t\t\tcout << \"请输入新的价格：\";\n\t\t\tcin >> p->price;\n\t\t\tcout << \"请输入新的折扣：\";\n\t\t\tcin >> p->discount;\n\t\t\tcout << \"修改成功！\t\";\n\t\t\twait();\n\t\t\treturn;\n\t\t}\n\t\tp = p->next;\n\t}\n\tcout << \"没有您想要修改的航班号!\";\n\twait();\n}\n\nvoid Save_flight(flightlist& h)//保存航班信息\n{\n\tflightlist f = h->next;\n\tSort_flight(h);\n\tofstream ofs(\"FlightList.txt\");\n\tif (!ofs)\n\t{\n\t\tcout << \"存储失败！\";\n\t\treturn;\n\t}\n\twhile (f != NULL)\n\t{\n\t\tofs << f->flight_num << \" \" << f->date << \" \" << f->time << \" \" << f->start_place << \" \" << f->end_place << \" \" << f->price << \" \" << f->discount << \" \" << f->left << endl;\n\t\tf = f->next;\n\t}\n\tofs.close();   //关闭文件\n}\n\nvoid Init_passenger(passengerlist& c)//初始化用户\n{\n\tc = new passengernode;   //头结点\n\tc->next = NULL;\n}\n\nvoid Load_passenger(passengerlist& c)\n{\n\tpassengerlist p = c;\n\tpassengerlist newp = new passengernode;\n\tifstream ifs(\"PassengerList.txt\");\n\tif (!ifs.is_open()) {\n\t\tcout << \"文件未被打开！\" << endl;\n\t\treturn;\n\t}\n\tcout << \"数据读取成功！\" << endl;\n\tsystem(\"cls\");\n\twhile (ifs >> newp->name >> newp->ID_num >> newp->ticket.flight_num >> newp->ticket.date >> newp->ticket.time >> newp->ticket.start_place >> newp->ticket.end_place >> newp->ticket.price >> newp->ticket.order_num)\n\t{\n\t\tp->next = newp;\n\t\tp = p->next;\n\t\tnewp = new passengernode;\n\t}\n\tp->next = NULL;\n\tdelete newp;\n}\n\nvoid Book(flightlist& h, passengerlist& c)//订票\n{\n\tstring start_place, end_place, flightnum;\n\tint date;//航班信息\n\tflightlist p = h->next, q = h->next;\n\tpassengerlist s, r = c;\n\tchar mark, check = '1';\n\tchar mark02 = '1';         //标志\n\tfor (; r->next != NULL; r = r->next) {}   //r移动到结点尾\n\ts = new passengernode;\n\tcout << \"请输入乘客的姓名：\";\n\tcin >> s->name;\n\tcout << \"请输入乘客的证件号：\";\n\tcin >> s->ID_num;\n\tcout << \"请输入出发地：\";\n\tcin >> start_place;\n\tcout << \"请输入目的地：\";\n\tcin >> end_place;\n\tcout << \"请选择出发日期：\";\n\tcin >> date;\n\tcout << setw(6) << \"航班号\" << setw(17) << \"起飞日期\" << setw(15) << \"起飞时间\" << setw(15) << \"出发地\" << setw(15) << \"目的地\" << setw(15) << \"价格\" << setw(15) << \"折扣\" << setw(15) << \"余票\" << endl;\n\twhile (p != NULL)\n\t{\n\t\tif (p->start_place == start_place && p->end_place == end_place && p->date == date)//匹配日期相符的航班\n\t\t{\n\t\t\tcout << setw(6) << p->flight_num << setw(15) << p->date << \"号\" << setw(15) << p->time << setw(15) << p->start_place << setw(15) << p->end_place << setw(15) << p->price << setw(15) << p->discount << setw(15) << p->left << endl;\n\t\t\tcheck = '0';\n\t\t}\n\t\tp = p->next;\n\t}\n\tif (check == '1') {\n\t\tp = h->next;\n\t\tcout << \"无\" << setw(15) << \"无\" << setw(17) << \"无\" << setw(15) << \"无\" << setw(15) << \"无\" << setw(15) << \"无\" << setw(15) << \"无\" << setw(15) << \"无\" << endl;\n\t\tcout << \"该天没相关的航班\" << endl;\n\t\tif (mark02 == '1')\n\t\t\treturn;//结束\n\t}\n\tcout << \"是否进行购买？（Y/N）\";\n\tcin >> mark;\n\tif (mark == 'y' || mark == 'Y') {\n\t\tcout << \"请输入您想要购买的航班号：\";\n\t\tcin >> flightnum;\n\t\twhile (q != NULL) {\n\t\t\tif (q->flight_num == flightnum && q->start_place == start_place && q->end_place == end_place) {\n\t\t\t\tif (q->left == 0) {\n\t\t\t\t\tcout << \"余票不足，请选择是否预约（Y/N）\";\n\t\t\t\t\tcin >> mark;\n\t\t\t\t\tif (mark == 'y' || mark == 'Y') {\n\t\t\t\t\t\ts->full = 1;  //修改预约标志\n\t\t\t\t\t\ts->ticket.flight_num = flightnum;\n\t\t\t\t\t\ts->ticket.start_place = start_place;\n\t\t\t\t\t\ts->ticket.end_place = end_place;\n\t\t\t\t\t\ts->ticket.time = \"预约\";\n\t\t\t\t\t\ts->ticket.price = 000;\n\t\t\t\t\t\ts->ticket.date = date;\n\t\t\t\t\t\ts->ticket.order_num = \"预约\";\n\t\t\t\t\t\tcout << \" 预约成功\";\n\t\t\t\t\t\tr->next = s;\n\t\t\t\t\t\tr = s;\n\t\t\t\t\t\tr->next = NULL;\n\t\t\t\t\t\twait();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\treturn;  //不预约直接结束\n\t\t\t\t}\n\t\t\t\ts->ticket.flight_num = flightnum;\n\t\t\t\ts->ticket.start_place = start_place;\n\t\t\t\ts->ticket.end_place = end_place;\n\t\t\t\ts->ticket.time = q->time;\n\t\t\t\ts->ticket.price = q->price;\n\t\t\t\ts->ticket.date = q->date;\n\t\t\t\tsrand((unsigned int)time(0));\n\t\t\t\ts->ticket.order_num = q->flight_num + to_string(rand()) + to_string(rand());//订单编号\n\t\t\t\tr->next = s;\n\t\t\t\tr = s;\n\t\t\t\tr->next = NULL;\n\t\t\t\tcout << \"购票成功！\" << \"订单号为\" + s->ticket.order_num << endl;\n\t\t\t\tq->left--;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t\tq = q->next;\n\t\t}\n\t\tcout << \"航班号填入错误！\" << endl;\n\t\twait();\n\t}\n\telse {\n\t\treturn;//不进行购买直接结束\n\t}\n}\n\nvoid Qbook(flightlist& h, passengerlist& c)//退票\n{\n\tstring name, ID_num;\n\tbool mark = false;\n\tflightlist f = h->next;\n\tpassengerlist p = c->next, q = c, t = c->next;\n\tcout << \"请输入乘客的姓名：\";\n\tcin >> name;\n\tcout << \"请输入乘客的证件号：\";\n\tcin >> ID_num;\n\twhile (p != NULL) {\n\t\tif (p->name == name && p->ID_num == ID_num) {\n\t\t\tmark = true;   //找到乘客\n\t\t\twhile (f != NULL) {\n\t\t\t\tif (p->ticket.flight_num == f->flight_num) {\n\t\t\t\t\tf->left++;  //票数更新\n\t\t\t\t\twhile (t != NULL) {\n\t\t\t\t\t\tif (t->ticket.flight_num == p->ticket.flight_num && t->full == 1) {\n\t\t\t\t\t\t\tt->ticket.start_place = p->ticket.start_place;\n\t\t\t\t\t\t\tt->ticket.end_place = p->ticket.end_place;\n\t\t\t\t\t\t\tt->ticket.time = p->ticket.time;\n\t\t\t\t\t\t\tt->ticket.price = p->ticket.price;\n\t\t\t\t\t\t\tt->ticket.date = p->ticket.date;\n\t\t\t\t\t\t\tsrand((unsigned int)time(0));\n\t\t\t\t\t\t\tt->ticket.order_num = p->ticket.flight_num.c_str() + to_string(rand()) + to_string(rand());\n\t\t\t\t\t\t\tf->left--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt = t->next;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tf = f->next;\n\t\t\t}\n\t\t\tq->next = p->next;\n\t\t\tdelete p;\n\t\t\tcout << \"退票成功！\";\n\t\t\treturn;\n\t\t}\n\t\tq = q->next;\n\t\tp = q->next;\n\t}\n\tif (!mark) {\n\t\tcout << \"未找到相关乘客的订单\";\n\t\twait();\n\t}\n}\n\nvoid Check_book(passengerlist& c)//查询订票\n{\n\tstring name, ID_num;\n\tpassengerlist p = c->next;\n\tcout << \"请输入乘客的姓名：\";\n\tcin >> name;\n\tcout << \"请输入乘客的证件号：\";\n\tcin >> ID_num;\n\tcout << setw(8) << \"姓名\" << setw(15) << \"航班号\" << setw(17) << \"起飞日期\" << setw(15) << \"起飞时间\" << setw(15) << \"出发地\" << setw(15) << \"目的地\" << setw(15) << \"价格\" << setw(18) << \"订单编号\" << endl;\n\twhile (p != NULL) {\n\t\tif (p->name == name && p->ID_num == ID_num) {\n\t\t\tcout << setw(8) << p->name << setw(15) << p->ticket.flight_num << setw(15) << p->ticket.date << \"号\" << setw(15) << p->ticket.time << setw(15) << p->ticket.start_place << setw(15) << p->ticket.end_place << setw(15) << p->ticket.price << setw(18) << p->ticket.order_num << endl;\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t\tp = p->next;\n\t}\n\tcout << setw(32) << \"未查到任何信息。\";\n\twait();\n\treturn;\n}\n\nvoid Save_passenger(passengerlist& c)\n{\n\tpassengerlist p = c->next;\n\tofstream ofs(\"PassengerList.txt\");\n\tif (!ofs) {\n\t\tcout << \"存储失败！\";\n\t\treturn;\n\t}\n\twhile (p != NULL) {\n\t\tofs << p->name << \" \" << p->ID_num << \" \" << p->ticket.flight_num << \" \" << p->ticket.date << \" \" << p->ticket.time << \" \" << p->ticket.start_place << \" \" << p->ticket.end_place << \" \" << p->ticket.price << \" \" << p->ticket.order_num << endl;\n\t\tp = p->next;\n\t}\n\tofs.close();\n}\n\nvoid wait() {\n\tint a = getchar();\n\ta = getchar();\n\tsystem(\"cls\");\n}\n\nint main()\n{\n\tflightlist flight;\n\tpassengerlist passenger;\n\tInit_passenger(passenger); //初始用户信息\n\tLoad_passenger(passenger); //载入用户信息\n\tInit_flight(flight);       //初始化航班\n\tLoad_flight(flight);       //载入航班\n\tmanage(flight, passenger); //封装管理函数\n\treturn 0;\n}\n\n```\n\n","tags":["C++"]},{"title":"面向对象编程","url":"/2022/12/11/6/","content":"\n# C++核心编程\n\n本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。\n\n\n\n## 1 内存分区模型\n\nC++程序在执行时，将内存大方向划分为**4个区域**\n\n- 代码区：存放函数体的二进制代码，由操作系统进行管理的\n- 全局区：存放全局变量和静态变量以及常量\n- 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等\n- 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收\n\n\n\n\n\n\n\n**内存四区意义：**\n\n不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程\n\n\n\n\n\n### 1.1 程序运行前\n\n\t在程序编译后，生成了exe可执行程序，**未执行该程序前**分为两个区域\n\t\n\t**代码区：**\n\t\n\t\t存放 CPU 执行的机器指令\n\t\n\t\t代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可\n\t\n\t\t代码区是**只读**的，使其只读的原因是防止程序意外地修改了它的指令\n\t\n\t**全局区：**\n\t\n\t\t全局变量和静态变量存放在此.\n\t\n\t\t全局区还包含了常量区, 字符串常量和其他常量也存放在此.\n\t\n\t\t==该区域的数据在程序结束后由操作系统释放==.\n\n\n\n\n\n\n\n\n\n\n\n\n\n**示例：**\n\n```c++\n//全局变量\nint g_a = 10;\nint g_b = 10;\n\n//全局常量\nconst int c_g_a = 10;\nconst int c_g_b = 10;\n\nint main() {\n\n\t//局部变量\n\tint a = 10;\n\tint b = 10;\n\n\t//打印地址\n\tcout << \"局部变量a地址为： \" << (int)&a << endl;\n\tcout << \"局部变量b地址为： \" << (int)&b << endl;\n\n\tcout << \"全局变量g_a地址为： \" <<  (int)&g_a << endl;\n\tcout << \"全局变量g_b地址为： \" <<  (int)&g_b << endl;\n\n\t//静态变量\n\tstatic int s_a = 10;\n\tstatic int s_b = 10;\n\n\tcout << \"静态变量s_a地址为： \" << (int)&s_a << endl;\n\tcout << \"静态变量s_b地址为： \" << (int)&s_b << endl;\n\n\tcout << \"字符串常量地址为： \" << (int)&\"hello world\" << endl;\n\tcout << \"字符串常量地址为： \" << (int)&\"hello world1\" << endl;\n\n\tcout << \"全局常量c_g_a地址为： \" << (int)&c_g_a << endl;\n\tcout << \"全局常量c_g_b地址为： \" << (int)&c_g_b << endl;\n\n\tconst int c_l_a = 10;\n\tconst int c_l_b = 10;\n\tcout << \"局部常量c_l_a地址为： \" << (int)&c_l_a << endl;\n\tcout << \"局部常量c_l_b地址为： \" << (int)&c_l_b << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n打印结果：\n\n![1545017602518](assets/1545017602518.png)\n\n\n\n总结：\n\n* C++中在程序运行前分为全局区和代码区\n* 代码区特点是共享和只读\n* 全局区中存放全局变量、静态变量、常量\n* 常量区中存放 const修饰的全局常量  和 字符串常量\n\n\n\n\n\n\n### 1.2 程序运行后\n\n\n\n\t**栈区：**\n\t\n\t\t由编译器自动分配释放, 存放函数的参数值,局部变量等\n\t\n\t\t注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放\n\n\n\n**示例：**\n\n```c++\nint * func()\n{\n\tint a = 10;\n\treturn &a;\n}\n\nint main() {\n\n\tint *p = func();\n\n\tcout << *p << endl;\n\tcout << *p << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\t**堆区：**\n\t\n\t\t由程序员分配释放,若程序员不释放,程序结束时由操作系统回收\n\t\n\t\t在C++中主要利用new在堆区开辟内存\n\n**示例：**\n\n```c++\nint* func()\n{\n\tint* a = new int(10);\n\treturn a;\n}\n\nint main() {\n\n\tint *p = func();\n\n\tcout << *p << endl;\n\tcout << *p << endl;\n    \n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n**总结：**\n\n堆区数据由程序员管理开辟和释放\n\n堆区数据利用new关键字进行开辟内存\n\n\n\n\n\n\n\n\n\n### 1.3 new操作符\n\n\n\n\tC++中利用==new==操作符在堆区开辟数据\n\t\n\t堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==\n\t\n\t语法：` new 数据类型`\n\t\n\t利用new创建的数据，会返回该数据对应的类型的指针\n\n\n\n**示例1： 基本语法**\n\n```c++\nint* func()\n{\n\tint* a = new int(10);\n\treturn a;\n}\n\nint main() {\n\n\tint *p = func();\n\n\tcout << *p << endl;\n\tcout << *p << endl;\n\n\t//利用delete释放堆区数据\n\tdelete p;\n\n\t//cout << *p << endl; //报错，释放的空间不可访问\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n**示例2：开辟数组**\n\n```c++\n//堆区开辟数组\nint main() {\n\n\tint* arr = new int[10];\n\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tarr[i] = i + 100;\n\t}\n\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tcout << arr[i] << endl;\n\t}\n\t//释放数组 delete 后加 []\n\tdelete[] arr;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n## 2 引用\n\n### 2.1 引用的基本使用\n\n**作用： **给变量起别名\n\n**语法：** `数据类型 &别名 = 原名`\n\n\n\n**示例：**\n\n```C++\nint main() {\n\n\tint a = 10;\n\tint &b = a;\n\n\tcout << \"a = \" << a << endl;\n\tcout << \"b = \" << b << endl;\n\n\tb = 100;\n\n\tcout << \"a = \" << a << endl;\n\tcout << \"b = \" << b << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n### 2.2 引用注意事项\n\n* 引用必须初始化\n* 引用在初始化后，不可以改变\n\n示例：\n\n```C++\nint main() {\n\n\tint a = 10;\n\tint b = 20;\n\t//int &c; //错误，引用必须初始化\n\tint &c = a; //一旦初始化后，就不可以更改\n\tc = b; //这是赋值操作，不是更改引用\n\n\tcout << \"a = \" << a << endl;\n\tcout << \"b = \" << b << endl;\n\tcout << \"c = \" << c << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n### 2.3 引用做函数参数\n\n**作用：**函数传参时，可以利用引用的技术让形参修饰实参\n\n**优点：**可以简化指针修改实参\n\n\n\n**示例：**\n\n```C++\n//1. 值传递\nvoid mySwap01(int a, int b) {\n\tint temp = a;\n\ta = b;\n\tb = temp;\n}\n\n//2. 地址传递\nvoid mySwap02(int* a, int* b) {\n\tint temp = *a;\n\t*a = *b;\n\t*b = temp;\n}\n\n//3. 引用传递\nvoid mySwap03(int& a, int& b) {\n\tint temp = a;\n\ta = b;\n\tb = temp;\n}\n\nint main() {\n\n\tint a = 10;\n\tint b = 20;\n\n\tmySwap01(a, b);\n\tcout << \"a:\" << a << \" b:\" << b << endl;\n\n\tmySwap02(&a, &b);\n\tcout << \"a:\" << a << \" b:\" << b << endl;\n\n\tmySwap03(a, b);\n\tcout << \"a:\" << a << \" b:\" << b << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n\n```\n\n\n\n> 总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 2.4 引用做函数返回值\n\n\n\n作用：引用是可以作为函数的返回值存在的\n\n\n\n注意：**不要返回局部变量引用**\n\n用法：函数调用作为左值\n\n\n\n**示例：**\n\n```C++\n//返回局部变量引用\nint& test01() {\n\tint a = 10; //局部变量\n\treturn a;\n}\n\n//返回静态变量引用\nint& test02() {\n\tstatic int a = 20;\n\treturn a;\n}\n\nint main() {\n\n\t//不能返回局部变量的引用\n\tint& ref = test01();\n\tcout << \"ref = \" << ref << endl;\n\tcout << \"ref = \" << ref << endl;\n\n\t//如果函数做左值，那么必须返回引用\n\tint& ref2 = test02();\n\tcout << \"ref2 = \" << ref2 << endl;\n\tcout << \"ref2 = \" << ref2 << endl;\n\n\ttest02() = 1000;\n\n\tcout << \"ref2 = \" << ref2 << endl;\n\tcout << \"ref2 = \" << ref2 << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n​\t\n\n\n\n\n\n\n\n\n\n### 2.5 引用的本质\n\n本质：**引用的本质在c++内部实现是一个指针常量.**\n\n讲解示例：\n\n```C++\n//发现是引用，转换为 int* const ref = &a;\nvoid func(int& ref){\n\tref = 100; // ref是引用，转换为*ref = 100\n}\nint main(){\n\tint a = 10;\n    \n    //自动转换为 int* const ref = &a; 指针常量是指针指向不可改，也说明为什么引用不可更改\n\tint& ref = a; \n\tref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20;\n    \n\tcout << \"a:\" << a << endl;\n\tcout << \"ref:\" << ref << endl;\n    \n\tfunc(a);\n\treturn 0;\n}\n```\n\n结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 2.6 常量引用\n\n\n\n**作用：**常量引用主要用来修饰形参，防止误操作\n\n\n\n在函数形参列表中，可以加==const修饰形参==，防止形参改变实参\n\n\n\n**示例：**\n\n\n\n```C++\n//引用使用的场景，通常用来修饰形参\nvoid showValue(const int& v) {\n\t//v += 10;\n\tcout << v << endl;\n}\n\nint main() {\n\n\t//int& ref = 10;  引用本身需要一个合法的内存空间，因此这行错误\n\t//加入const就可以了，编译器优化代码，int temp = 10; const int& ref = temp;\n\tconst int& ref = 10;\n\n\t//ref = 100;  //加入const后不可以修改变量\n\tcout << ref << endl;\n\n\t//函数中利用常量引用防止误操作修改实参\n\tint a = 10;\n\tshowValue(a);\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n## 3 函数提高\n\n### 3.1 函数默认参数\n\n\n\n在C++中，函数的形参列表中的形参是可以有默认值的。\n\n语法：` 返回值类型  函数名 （参数= 默认值）{}`\n\n\n\n**示例：**\n\n```C++\nint func(int a, int b = 10, int c = 10) {\n\treturn a + b + c;\n}\n\n//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值\n//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数\nint func2(int a = 10, int b = 10);\nint func2(int a, int b) {\n\treturn a + b;\n}\n\nint main() {\n\n\tcout << \"ret = \" << func(20, 20) << endl;\n\tcout << \"ret = \" << func(100) << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n### 3.2 函数占位参数\n\n\n\nC++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置\n\n\n\n**语法：** `返回值类型 函数名 (数据类型){}`\n\n\n\n在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术\n\n\n\n**示例：**\n\n```C++\n//函数占位参数 ，占位参数也可以有默认参数\nvoid func(int a, int) {\n\tcout << \"this is func\" << endl;\n}\n\nint main() {\n\n\tfunc(10,10); //占位参数必须填补\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n### 3.3 函数重载\n\n#### 3.3.1 函数重载概述\n\n\n\n**作用：**函数名可以相同，提高复用性\n\n\n\n**函数重载满足条件：**\n\n* 同一个作用域下\n* 函数名称相同\n* 函数参数**类型不同**  或者 **个数不同** 或者 **顺序不同**\n\n\n\n**注意:**  函数的返回值不可以作为函数重载的条件\n\n\n\n**示例：**\n\n```C++\n//函数重载需要函数都在同一个作用域下\nvoid func()\n{\n\tcout << \"func 的调用！\" << endl;\n}\nvoid func(int a)\n{\n\tcout << \"func (int a) 的调用！\" << endl;\n}\nvoid func(double a)\n{\n\tcout << \"func (double a)的调用！\" << endl;\n}\nvoid func(int a ,double b)\n{\n\tcout << \"func (int a ,double b) 的调用！\" << endl;\n}\nvoid func(double a ,int b)\n{\n\tcout << \"func (double a ,int b)的调用！\" << endl;\n}\n\n//函数返回值不可以作为函数重载条件\n//int func(double a, int b)\n//{\n//\tcout << \"func (double a ,int b)的调用！\" << endl;\n//}\n\n\nint main() {\n\n\tfunc();\n\tfunc(10);\n\tfunc(3.14);\n\tfunc(10,3.14);\n\tfunc(3.14 , 10);\n\t\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 3.3.2 函数重载注意事项\n\n\n\n* 引用作为重载条件\n* 函数重载碰到函数默认参数\n\n\n\n\n\n**示例：**\n\n```C++\n//函数重载注意事项\n//1、引用作为重载条件\n\nvoid func(int &a)\n{\n\tcout << \"func (int &a) 调用 \" << endl;\n}\n\nvoid func(const int &a)\n{\n\tcout << \"func (const int &a) 调用 \" << endl;\n}\n\n\n//2、函数重载碰到函数默认参数\n\nvoid func2(int a, int b = 10)\n{\n\tcout << \"func2(int a, int b = 10) 调用\" << endl;\n}\n\nvoid func2(int a)\n{\n\tcout << \"func2(int a) 调用\" << endl;\n}\n\nint main() {\n\t\n\tint a = 10;\n\tfunc(a); //调用无const\n\tfunc(10);//调用有const\n\n\n\t//func2(10); //碰到默认参数产生歧义，需要避免\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n## **4** 类和对象\n\n\n\nC++面向对象的三大特性为：==封装、继承、多态==\n\n\n\nC++认为==万事万物都皆为对象==，对象上有其属性和行为\n\n\n\n**例如：**\n\n\t人可以作为对象，属性有姓名、年龄、身高、体重...，行为有走、跑、跳、吃饭、唱歌...\n\t\n\t车也可以作为对象，属性有轮胎、方向盘、车灯...,行为有载人、放音乐、放空调...\n\t\n\t具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类\n\n### 4.1 封装\n\n#### 4.1.1  封装的意义\n\n封装是C++面向对象三大特性之一\n\n封装的意义：\n\n* 将属性和行为作为一个整体，表现生活中的事物\n* 将属性和行为加以权限控制\n\n\n\n**封装意义一：**\n\n\t在设计类的时候，属性和行为写在一起，表现事物\n\n**语法：** `class 类名{   访问权限： 属性  / 行为  };`\n\n\n\n**示例1：**设计一个圆类，求圆的周长\n\n**示例代码：**\n\n```C++\n//圆周率\nconst double PI = 3.14;\n\n//1、封装的意义\n//将属性和行为作为一个整体，用来表现生活中的事物\n\n//封装一个圆类，求圆的周长\n//class代表设计一个类，后面跟着的是类名\nclass Circle\n{\npublic:  //访问权限  公共的权限\n\n\t//属性\n\tint m_r;//半径\n\n\t//行为\n\t//获取到圆的周长\n\tdouble calculateZC()\n\t{\n\t\t//2 * pi  * r\n\t\t//获取圆的周长\n\t\treturn  2 * PI * m_r;\n\t}\n};\n\nint main() {\n\n\t//通过圆类，创建圆的对象\n\t// c1就是一个具体的圆\n\tCircle c1;\n\tc1.m_r = 10; //给圆对象的半径 进行赋值操作\n\n\t//2 * pi * 10 = = 62.8\n\tcout << \"圆的周长为： \" << c1.calculateZC() << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n**示例2：**设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号\n\n\n\n\n\n**示例2代码：**\n\n```C++\n//学生类\nclass Student {\npublic:\n\tvoid setName(string name) {\n\t\tm_name = name;\n\t}\n\tvoid setID(int id) {\n\t\tm_id = id;\n\t}\n\n\tvoid showStudent() {\n\t\tcout << \"name:\" << m_name << \" ID:\" << m_id << endl;\n\t}\npublic:\n\tstring m_name;\n\tint m_id;\n};\n\nint main() {\n\n\tStudent stu;\n\tstu.setName(\"德玛西亚\");\n\tstu.setID(250);\n\tstu.showStudent();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n\n```\n\n\n\n\n\n\n\n\n\n**封装意义二：**\n\n类在设计时，可以把属性和行为放在不同的权限下，加以控制\n\n访问权限有三种：\n\n\n\n1. public        公共权限  \n2. protected 保护权限\n3. private      私有权限\n\n\n\n\n\n\n\n**示例：**\n\n```C++\n//三种权限\n//公共权限  public     类内可以访问  类外可以访问\n//保护权限  protected  类内可以访问  类外不可以访问\n//私有权限  private    类内可以访问  类外不可以访问\n\nclass Person\n{\n\t//姓名  公共权限\npublic:\n\tstring m_Name;\n\n\t//汽车  保护权限\nprotected:\n\tstring m_Car;\n\n\t//银行卡密码  私有权限\nprivate:\n\tint m_Password;\n\npublic:\n\tvoid func()\n\t{\n\t\tm_Name = \"张三\";\n\t\tm_Car = \"拖拉机\";\n\t\tm_Password = 123456;\n\t}\n};\n\nint main() {\n\n\tPerson p;\n\tp.m_Name = \"李四\";\n\t//p.m_Car = \"奔驰\";  //保护权限类外访问不到\n\t//p.m_Password = 123; //私有权限类外访问不到\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n#### 4.1.2 struct和class区别\n\n\n\n在C++中 struct和class唯一的**区别**就在于 **默认的访问权限不同**\n\n区别：\n\n* struct 默认权限为公共\n* class   默认权限为私有\n\n\n\n```C++\nclass C1\n{\n\tint  m_A; //默认是私有权限\n};\n\nstruct C2\n{\n\tint m_A;  //默认是公共权限\n};\n\nint main() {\n\n\tC1 c1;\n\tc1.m_A = 10; //错误，访问权限是私有\n\n\tC2 c2;\n\tc2.m_A = 10; //正确，访问权限是公共\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.1.3 成员属性设置为私有\n\n\n\n**优点1：**将所有成员属性设置为私有，可以自己控制读写权限\n\n**优点2：**对于写权限，我们可以检测数据的有效性\n\n\n\n**示例：**\n\n```C++\nclass Person {\npublic:\n\n\t//姓名设置可读可写\n\tvoid setName(string name) {\n\t\tm_Name = name;\n\t}\n\tstring getName()\n\t{\n\t\treturn m_Name;\n\t}\n\n\n\t//获取年龄 \n\tint getAge() {\n\t\treturn m_Age;\n\t}\n\t//设置年龄\n\tvoid setAge(int age) {\n\t\tif (age < 0 || age > 150) {\n\t\t\tcout << \"你个老妖精!\" << endl;\n\t\t\treturn;\n\t\t}\n\t\tm_Age = age;\n\t}\n\n\t//情人设置为只写\n\tvoid setLover(string lover) {\n\t\tm_Lover = lover;\n\t}\n\nprivate:\n\tstring m_Name; //可读可写  姓名\n\t\n\tint m_Age; //只读  年龄\n\n\tstring m_Lover; //只写  情人\n};\n\n\nint main() {\n\n\tPerson p;\n\t//姓名设置\n\tp.setName(\"张三\");\n\tcout << \"姓名： \" << p.getName() << endl;\n\n\t//年龄设置\n\tp.setAge(50);\n\tcout << \"年龄： \" << p.getAge() << endl;\n\n\t//情人设置\n\tp.setLover(\"苍井\");\n\t//cout << \"情人： \" << p.m_Lover << endl;  //只写属性，不可以读取\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n**练习案例1：设计立方体类**\n\n设计立方体类(Cube)\n\n求出立方体的面积和体积\n\n分别用全局函数和成员函数判断两个立方体是否相等。\n\n\n\n![1545533548532](assets/1545533548532.png)\n\n\n\n\n\n\n\n\n\n\n\n**练习案例2：点和圆的关系**\n\n设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。\n\n\n\n![1545533829184](assets/1545533829184.png)\n\n\n\n\n\n\n\n### 4.2 对象的初始化和清理\n\n\n\n*  生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全\n*  C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。\n\n\n\n\n\n#### 4.2.1 构造函数和析构函数\n\n对象的**初始化和清理**也是两个非常重要的安全问题\n\n\t一个对象或者变量没有初始状态，对其使用后果是未知\n\t\n\t同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题\n\n\n\nc++利用了**构造函数**和**析构函数**解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。\n\n对象的初始化和清理工作是编译器强制要我们做的事情，因此如果**我们不提供构造和析构，编译器会提供**\n\n**编译器提供的构造函数和析构函数是空实现。**\n\n\n\n* 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。\n* 析构函数：主要作用在于对象**销毁前**系统自动调用，执行一些清理工作。\n\n\n\n\n\n**构造函数语法：**`类名(){}`\n\n1. 构造函数，没有返回值也不写void\n2. 函数名称与类名相同\n3. 构造函数可以有参数，因此可以发生重载\n4. 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次\n\n\n\n\n\n**析构函数语法：** `~类名(){}`\n\n1. 析构函数，没有返回值也不写void\n2. 函数名称与类名相同,在名称前加上符号  ~\n3. 析构函数不可以有参数，因此不可以发生重载\n4. 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次\n\n\n\n\n\n```C++\nclass Person\n{\npublic:\n\t//构造函数\n\tPerson()\n\t{\n\t\tcout << \"Person的构造函数调用\" << endl;\n\t}\n\t//析构函数\n\t~Person()\n\t{\n\t\tcout << \"Person的析构函数调用\" << endl;\n\t}\n\n};\n\nvoid test01()\n{\n\tPerson p;\n}\n\nint main() {\n\t\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n#### 4.2.2 构造函数的分类及调用\n\n两种分类方式：\n\n\t按参数分为： 有参构造和无参构造\n\t\n\t按类型分为： 普通构造和拷贝构造\n\n三种调用方式：\n\n\t括号法\n\t\n\t显示法\n\t\n\t隐式转换法\n\n\n\n**示例：**\n\n```C++\n//1、构造函数分类\n// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数\n// 按照类型分类分为 普通构造和拷贝构造\n\nclass Person {\npublic:\n\t//无参（默认）构造函数\n\tPerson() {\n\t\tcout << \"无参构造函数!\" << endl;\n\t}\n\t//有参构造函数\n\tPerson(int a) {\n\t\tage = a;\n\t\tcout << \"有参构造函数!\" << endl;\n\t}\n\t//拷贝构造函数\n\tPerson(const Person& p) {\n\t\tage = p.age;\n\t\tcout << \"拷贝构造函数!\" << endl;\n\t}\n\t//析构函数\n\t~Person() {\n\t\tcout << \"析构函数!\" << endl;\n\t}\npublic:\n\tint age;\n};\n\n//2、构造函数的调用\n//调用无参构造函数\nvoid test01() {\n\tPerson p; //调用无参构造函数\n}\n\n//调用有参的构造函数\nvoid test02() {\n\n\t//2.1  括号法，常用\n\tPerson p1(10);\n\t//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明\n\t//Person p2();\n\n\t//2.2 显式法\n\tPerson p2 = Person(10); \n\tPerson p3 = Person(p2);\n\t//Person(10)单独写就是匿名对象  当前行结束之后，马上析构\n\n\t//2.3 隐式转换法\n\tPerson p4 = 10; // Person p4 = Person(10); \n\tPerson p5 = p4; // Person p5 = Person(p4); \n\n\t//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明\n\t//Person p5(p4);\n}\n\nint main() {\n\n\ttest01();\n\t//test02();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n#### 4.2.3 拷贝构造函数调用时机\n\n\n\nC++中拷贝构造函数调用时机通常有三种情况\n\n* 使用一个已经创建完毕的对象来初始化一个新对象\n* 值传递的方式给函数参数传值\n* 以值方式返回局部对象\n\n\n\n**示例：**\n\n```C++\nclass Person {\npublic:\n\tPerson() {\n\t\tcout << \"无参构造函数!\" << endl;\n\t\tmAge = 0;\n\t}\n\tPerson(int age) {\n\t\tcout << \"有参构造函数!\" << endl;\n\t\tmAge = age;\n\t}\n\tPerson(const Person& p) {\n\t\tcout << \"拷贝构造函数!\" << endl;\n\t\tmAge = p.mAge;\n\t}\n\t//析构函数在释放内存之前调用\n\t~Person() {\n\t\tcout << \"析构函数!\" << endl;\n\t}\npublic:\n\tint mAge;\n};\n\n//1. 使用一个已经创建完毕的对象来初始化一个新对象\nvoid test01() {\n\n\tPerson man(100); //p对象已经创建完毕\n\tPerson newman(man); //调用拷贝构造函数\n\tPerson newman2 = man; //拷贝构造\n\n\t//Person newman3;\n\t//newman3 = man; //不是调用拷贝构造函数，赋值操作\n}\n\n//2. 值传递的方式给函数参数传值\n//相当于Person p1 = p;\nvoid doWork(Person p1) {}\nvoid test02() {\n\tPerson p; //无参构造函数\n\tdoWork(p);\n}\n\n//3. 以值方式返回局部对象\nPerson doWork2()\n{\n\tPerson p1;\n\tcout << (int *)&p1 << endl;\n\treturn p1;\n}\n\nvoid test03()\n{\n\tPerson p = doWork2();\n\tcout << (int *)&p << endl;\n}\n\n\nint main() {\n\n\t//test01();\n\t//test02();\n\ttest03();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n#### 4.2.4 构造函数调用规则\n\n默认情况下，c++编译器至少给一个类添加3个函数\n\n1．默认构造函数(无参，函数体为空)\n\n2．默认析构函数(无参，函数体为空)\n\n3．默认拷贝构造函数，对属性进行值拷贝\n\n\n\n构造函数调用规则如下：\n\n* 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造\n\n\n* 如果用户定义拷贝构造函数，c++不会再提供其他构造函数\n\n\n\n示例：\n\n```C++\nclass Person {\npublic:\n\t//无参（默认）构造函数\n\tPerson() {\n\t\tcout << \"无参构造函数!\" << endl;\n\t}\n\t//有参构造函数\n\tPerson(int a) {\n\t\tage = a;\n\t\tcout << \"有参构造函数!\" << endl;\n\t}\n\t//拷贝构造函数\n\tPerson(const Person& p) {\n\t\tage = p.age;\n\t\tcout << \"拷贝构造函数!\" << endl;\n\t}\n\t//析构函数\n\t~Person() {\n\t\tcout << \"析构函数!\" << endl;\n\t}\npublic:\n\tint age;\n};\n\nvoid test01()\n{\n\tPerson p1(18);\n\t//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作\n\tPerson p2(p1);\n\n\tcout << \"p2的年龄为： \" << p2.age << endl;\n}\n\nvoid test02()\n{\n\t//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造\n\tPerson p1; //此时如果用户自己没有提供默认构造，会出错\n\tPerson p2(10); //用户提供的有参\n\tPerson p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供\n\n\t//如果用户提供拷贝构造，编译器不会提供其他构造函数\n\tPerson p4; //此时如果用户自己没有提供默认构造，会出错\n\tPerson p5(10); //此时如果用户自己没有提供有参，会出错\n\tPerson p6(p5); //用户自己提供拷贝构造\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n#### 4.2.5 深拷贝与浅拷贝\n\n\n\n深浅拷贝是面试经典问题，也是常见的一个坑\n\n\n\n浅拷贝：简单的赋值拷贝操作\n\n\n\n深拷贝：在堆区重新申请空间，进行拷贝操作\n\n\n\n**示例：**\n\n```C++\nclass Person {\npublic:\n\t//无参（默认）构造函数\n\tPerson() {\n\t\tcout << \"无参构造函数!\" << endl;\n\t}\n\t//有参构造函数\n\tPerson(int age ,int height) {\n\t\t\n\t\tcout << \"有参构造函数!\" << endl;\n\n\t\tm_age = age;\n\t\tm_height = new int(height);\n\t\t\n\t}\n\t//拷贝构造函数  \n\tPerson(const Person& p) {\n\t\tcout << \"拷贝构造函数!\" << endl;\n\t\t//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题\n\t\tm_age = p.m_age;\n\t\tm_height = new int(*p.m_height);\n\t\t\n\t}\n\n\t//析构函数\n\t~Person() {\n\t\tcout << \"析构函数!\" << endl;\n\t\tif (m_height != NULL)\n\t\t{\n\t\t\tdelete m_height;\n\t\t}\n\t}\npublic:\n\tint m_age;\n\tint* m_height;\n};\n\nvoid test01()\n{\n\tPerson p1(18, 180);\n\n\tPerson p2(p1);\n\n\tcout << \"p1的年龄： \" << p1.m_age << \" 身高： \" << *p1.m_height << endl;\n\n\tcout << \"p2的年龄： \" << p2.m_age << \" 身高： \" << *p2.m_height << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n> 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题\n\n\n\n\n\n\n\n\n\n#### 4.2.6 初始化列表\n\n\n\n**作用：**\n\nC++提供了初始化列表语法，用来初始化属性\n\n\n\n**语法：**`构造函数()：属性1(值1),属性2（值2）... {}`\n\n\n\n**示例：**\n\n```C++\nclass Person {\npublic:\n\n\t////传统方式初始化\n\t//Person(int a, int b, int c) {\n\t//\tm_A = a;\n\t//\tm_B = b;\n\t//\tm_C = c;\n\t//}\n\n\t//初始化列表方式初始化\n\tPerson(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}\n\tvoid PrintPerson() {\n\t\tcout << \"mA:\" << m_A << endl;\n\t\tcout << \"mB:\" << m_B << endl;\n\t\tcout << \"mC:\" << m_C << endl;\n\t}\nprivate:\n\tint m_A;\n\tint m_B;\n\tint m_C;\n};\n\nint main() {\n\n\tPerson p(1, 2, 3);\n\tp.PrintPerson();\n\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n#### 4.2.7 类对象作为类成员\n\n\n\nC++类中的成员可以是另一个类的对象，我们称该成员为 对象成员\n\n\n\n例如：\n\n```C++\nclass A {}\nclass B\n{\n    A a；\n}\n```\n\n\n\nB类中有对象A作为成员，A为对象成员\n\n\n\n那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？\n\n\n\n**示例：**\n\n```C++\nclass Phone\n{\npublic:\n\tPhone(string name)\n\t{\n\t\tm_PhoneName = name;\n\t\tcout << \"Phone构造\" << endl;\n\t}\n\n\t~Phone()\n\t{\n\t\tcout << \"Phone析构\" << endl;\n\t}\n\n\tstring m_PhoneName;\n\n};\n\n\nclass Person\n{\npublic:\n\n\t//初始化列表可以告诉编译器调用哪一个构造函数\n\tPerson(string name, string pName) :m_Name(name), m_Phone(pName)\n\t{\n\t\tcout << \"Person构造\" << endl;\n\t}\n\n\t~Person()\n\t{\n\t\tcout << \"Person析构\" << endl;\n\t}\n\n\tvoid playGame()\n\t{\n\t\tcout << m_Name << \" 使用\" << m_Phone.m_PhoneName << \" 牌手机! \" << endl;\n\t}\n\n\tstring m_Name;\n\tPhone m_Phone;\n\n};\nvoid test01()\n{\n\t//当类中成员是其他类对象时，我们称该成员为 对象成员\n\t//构造的顺序是 ：先调用对象成员的构造，再调用本类构造\n\t//析构顺序与构造相反\n\tPerson p(\"张三\" , \"苹果X\");\n\tp.playGame();\n\n}\n\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n#### 4.2.8 静态成员\n\n静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员\n\n静态成员分为：\n\n\n\n*  静态成员变量\n   *  所有对象共享同一份数据\n   *  在编译阶段分配内存\n   *  类内声明，类外初始化\n*  静态成员函数\n   *  所有对象共享同一个函数\n   *  静态成员函数只能访问静态成员变量\n\n\n\n\n\n\n\n**示例1 ：**静态成员变量\n\n```C++\nclass Person\n{\n\t\npublic:\n\n\tstatic int m_A; //静态成员变量\n\n\t//静态成员变量特点：\n\t//1 在编译阶段分配内存\n\t//2 类内声明，类外初始化\n\t//3 所有对象共享同一份数据\n\nprivate:\n\tstatic int m_B; //静态成员变量也是有访问权限的\n};\nint Person::m_A = 10;\nint Person::m_B = 10;\n\nvoid test01()\n{\n\t//静态成员变量两种访问方式\n\n\t//1、通过对象\n\tPerson p1;\n\tp1.m_A = 100;\n\tcout << \"p1.m_A = \" << p1.m_A << endl;\n\n\tPerson p2;\n\tp2.m_A = 200;\n\tcout << \"p1.m_A = \" << p1.m_A << endl; //共享同一份数据\n\tcout << \"p2.m_A = \" << p2.m_A << endl;\n\n\t//2、通过类名\n\tcout << \"m_A = \" << Person::m_A << endl;\n\n\n\t//cout << \"m_B = \" << Person::m_B << endl; //私有权限访问不到\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n**示例2：**静态成员函数\n\n```C++\nclass Person\n{\n\npublic:\n\n\t//静态成员函数特点：\n\t//1 程序共享一个函数\n\t//2 静态成员函数只能访问静态成员变量\n\t\n\tstatic void func()\n\t{\n\t\tcout << \"func调用\" << endl;\n\t\tm_A = 100;\n\t\t//m_B = 100; //错误，不可以访问非静态成员变量\n\t}\n\n\tstatic int m_A; //静态成员变量\n\tint m_B; // \nprivate:\n\n\t//静态成员函数也是有访问权限的\n\tstatic void func2()\n\t{\n\t\tcout << \"func2调用\" << endl;\n\t}\n};\nint Person::m_A = 10;\n\n\nvoid test01()\n{\n\t//静态成员变量两种访问方式\n\n\t//1、通过对象\n\tPerson p1;\n\tp1.func();\n\n\t//2、通过类名\n\tPerson::func();\n\n\n\t//Person::func2(); //私有权限访问不到\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n### 4.3 C++对象模型和this指针\n\n\n\n#### 4.3.1 成员变量和成员函数分开存储\n\n\n\n在C++中，类内的成员变量和成员函数分开存储\n\n只有非静态成员变量才属于类的对象上\n\n\n\n```C++\nclass Person {\npublic:\n\tPerson() {\n\t\tmA = 0;\n\t}\n\t//非静态成员变量占对象空间\n\tint mA;\n\t//静态成员变量不占对象空间\n\tstatic int mB; \n\t//函数也不占对象空间，所有函数共享一个函数实例\n\tvoid func() {\n\t\tcout << \"mA:\" << this->mA << endl;\n\t}\n\t//静态成员函数也不占对象空间\n\tstatic void sfunc() {\n\t}\n};\n\nint main() {\n\n\tcout << sizeof(Person) << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n#### 4.3.2 this指针概念\n\n通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的\n\n每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码\n\n那么问题是：这一块代码是如何区分那个对象调用自己的呢？\n\n\n\nc++通过提供特殊的对象指针，this指针，解决上述问题。**this指针指向被调用的成员函数所属的对象**\n\n\n\nthis指针是隐含每一个非静态成员函数内的一种指针\n\nthis指针不需要定义，直接使用即可\n\n\n\nthis指针的用途：\n\n*  当形参和成员变量同名时，可用this指针来区分\n*  在类的非静态成员函数中返回对象本身，可使用return *this\n\n```C++\nclass Person\n{\npublic:\n\n\tPerson(int age)\n\t{\n\t\t//1、当形参和成员变量同名时，可用this指针来区分\n\t\tthis->age = age;\n\t}\n\n\tPerson& PersonAddPerson(Person p)\n\t{\n\t\tthis->age += p.age;\n\t\t//返回对象本身\n\t\treturn *this;\n\t}\n\n\tint age;\n};\n\nvoid test01()\n{\n\tPerson p1(10);\n\tcout << \"p1.age = \" << p1.age << endl;\n\n\tPerson p2(10);\n\tp2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);\n\tcout << \"p2.age = \" << p2.age << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n#### 4.3.3 空指针访问成员函数\n\n\n\nC++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针\n\n\n\n如果用到this指针，需要加以判断保证代码的健壮性\n\n\n\n**示例：**\n\n```C++\n//空指针访问成员函数\nclass Person {\npublic:\n\n\tvoid ShowClassName() {\n\t\tcout << \"我是Person类!\" << endl;\n\t}\n\n\tvoid ShowPerson() {\n\t\tif (this == NULL) {\n\t\t\treturn;\n\t\t}\n\t\tcout << mAge << endl;\n\t}\n\npublic:\n\tint mAge;\n};\n\nvoid test01()\n{\n\tPerson * p = NULL;\n\tp->ShowClassName(); //空指针，可以调用成员函数\n\tp->ShowPerson();  //但是如果成员函数中用到了this指针，就不可以了\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n#### 4.3.4 const修饰成员函数\n\n\n\n**常函数：**\n\n* 成员函数后加const后我们称为这个函数为**常函数**\n* 常函数内不可以修改成员属性\n* 成员属性声明时加关键字mutable后，在常函数中依然可以修改\n\n\n\n**常对象：**\n\n* 声明对象前加const称该对象为常对象\n* 常对象只能调用常函数\n\n\n\n\n\n\n\n**示例：**\n\n```C++\nclass Person {\npublic:\n\tPerson() {\n\t\tm_A = 0;\n\t\tm_B = 0;\n\t}\n\n\t//this指针的本质是一个指针常量，指针的指向不可修改\n\t//如果想让指针指向的值也不可以修改，需要声明常函数\n\tvoid ShowPerson() const {\n\t\t//const Type* const pointer;\n\t\t//this = NULL; //不能修改指针的指向 Person* const this;\n\t\t//this->mA = 100; //但是this指针指向的对象的数据是可以修改的\n\n\t\t//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量\n\t\tthis->m_B = 100;\n\t}\n\n\tvoid MyFunc() const {\n\t\t//mA = 10000;\n\t}\n\npublic:\n\tint m_A;\n\tmutable int m_B; //可修改 可变的\n};\n\n\n//const修饰对象  常对象\nvoid test01() {\n\n\tconst Person person; //常量对象  \n\tcout << person.m_A << endl;\n\t//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问\n\tperson.m_B = 100; //但是常对象可以修改mutable修饰成员变量\n\n\t//常对象访问成员函数\n\tperson.MyFunc(); //常对象不能调用const的函数\n\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n### 4.4 友元\n\n\n\n生活中你的家有客厅(Public)，有你的卧室(Private)\n\n客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去\n\n但是呢，你也可以允许你的好闺蜜好基友进去。\n\n\n\n在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术\n\n\n\n友元的目的就是让一个函数或者类 访问另一个类中私有成员\n\n\n\n友元的关键字为  ==friend==\n\n\n\n友元的三种实现\n\n* 全局函数做友元\n* 类做友元\n* 成员函数做友元\n\n\n\n\n\n#### 4.4.1 全局函数做友元\n\n```C++\nclass Building\n{\n\t//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容\n\tfriend void goodGay(Building * building);\n\npublic:\n\n\tBuilding()\n\t{\n\t\tthis->m_SittingRoom = \"客厅\";\n\t\tthis->m_BedRoom = \"卧室\";\n\t}\n\n\npublic:\n\tstring m_SittingRoom; //客厅\n\nprivate:\n\tstring m_BedRoom; //卧室\n};\n\n\nvoid goodGay(Building * building)\n{\n\tcout << \"好基友正在访问： \" << building->m_SittingRoom << endl;\n\tcout << \"好基友正在访问： \" << building->m_BedRoom << endl;\n}\n\n\nvoid test01()\n{\n\tBuilding b;\n\tgoodGay(&b);\n}\n\nint main(){\n\n\ttest01();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n\n#### 4.4.2 类做友元\n\n\n\n```C++\nclass Building;\nclass goodGay\n{\npublic:\n\n\tgoodGay();\n\tvoid visit();\n\nprivate:\n\tBuilding *building;\n};\n\n\nclass Building\n{\n\t//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容\n\tfriend class goodGay;\n\npublic:\n\tBuilding();\n\npublic:\n\tstring m_SittingRoom; //客厅\nprivate:\n\tstring m_BedRoom;//卧室\n};\n\nBuilding::Building()\n{\n\tthis->m_SittingRoom = \"客厅\";\n\tthis->m_BedRoom = \"卧室\";\n}\n\ngoodGay::goodGay()\n{\n\tbuilding = new Building;\n}\n\nvoid goodGay::visit()\n{\n\tcout << \"好基友正在访问\" << building->m_SittingRoom << endl;\n\tcout << \"好基友正在访问\" << building->m_BedRoom << endl;\n}\n\nvoid test01()\n{\n\tgoodGay gg;\n\tgg.visit();\n\n}\n\nint main(){\n\n\ttest01();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n\n\n\n#### 4.4.3 成员函数做友元\n\n\n\n```C++\nclass Building;\nclass goodGay\n{\npublic:\n\n\tgoodGay();\n\tvoid visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容\n\tvoid visit2(); \n\nprivate:\n\tBuilding *building;\n};\n\n\nclass Building\n{\n\t//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容\n\tfriend void goodGay::visit();\n\npublic:\n\tBuilding();\n\npublic:\n\tstring m_SittingRoom; //客厅\nprivate:\n\tstring m_BedRoom;//卧室\n};\n\nBuilding::Building()\n{\n\tthis->m_SittingRoom = \"客厅\";\n\tthis->m_BedRoom = \"卧室\";\n}\n\ngoodGay::goodGay()\n{\n\tbuilding = new Building;\n}\n\nvoid goodGay::visit()\n{\n\tcout << \"好基友正在访问\" << building->m_SittingRoom << endl;\n\tcout << \"好基友正在访问\" << building->m_BedRoom << endl;\n}\n\nvoid goodGay::visit2()\n{\n\tcout << \"好基友正在访问\" << building->m_SittingRoom << endl;\n\t//cout << \"好基友正在访问\" << building->m_BedRoom << endl;\n}\n\nvoid test01()\n{\n\tgoodGay  gg;\n\tgg.visit();\n\n}\n\nint main(){\n    \n\ttest01();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n### 4.5 运算符重载\n\n\n\n运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型\n\n\n\n#### 4.5.1 加号运算符重载\n\n\n\n作用：实现两个自定义数据类型相加的运算\n\n\n\n```C++\nclass Person {\npublic:\n\tPerson() {};\n\tPerson(int a, int b)\n\t{\n\t\tthis->m_A = a;\n\t\tthis->m_B = b;\n\t}\n\t//成员函数实现 + 号运算符重载\n\tPerson operator+(const Person& p) {\n\t\tPerson temp;\n\t\ttemp.m_A = this->m_A + p.m_A;\n\t\ttemp.m_B = this->m_B + p.m_B;\n\t\treturn temp;\n\t}\n\n\npublic:\n\tint m_A;\n\tint m_B;\n};\n\n//全局函数实现 + 号运算符重载\n//Person operator+(const Person& p1, const Person& p2) {\n//\tPerson temp(0, 0);\n//\ttemp.m_A = p1.m_A + p2.m_A;\n//\ttemp.m_B = p1.m_B + p2.m_B;\n//\treturn temp;\n//}\n\n//运算符重载 可以发生函数重载 \nPerson operator+(const Person& p2, int val)  \n{\n\tPerson temp;\n\ttemp.m_A = p2.m_A + val;\n\ttemp.m_B = p2.m_B + val;\n\treturn temp;\n}\n\nvoid test() {\n\n\tPerson p1(10, 10);\n\tPerson p2(20, 20);\n\n\t//成员函数方式\n\tPerson p3 = p2 + p1;  //相当于 p2.operaor+(p1)\n\tcout << \"mA:\" << p3.m_A << \" mB:\" << p3.m_B << endl;\n\n\n\tPerson p4 = p3 + 10; //相当于 operator+(p3,10)\n\tcout << \"mA:\" << p4.m_A << \" mB:\" << p4.m_B << endl;\n\n}\n\nint main() {\n\n\ttest();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n> 总结1：对于内置的数据类型的表达式的的运算符是不可能改变的\n\n> 总结2：不要滥用运算符重载\n\n\n\n\n\n\n\n#### 4.5.2 左移运算符重载\n\n\n\n作用：可以输出自定义数据类型\n\n\n\n```C++\nclass Person {\n\tfriend ostream& operator<<(ostream& out, Person& p);\n\npublic:\n\n\tPerson(int a, int b)\n\t{\n\t\tthis->m_A = a;\n\t\tthis->m_B = b;\n\t}\n\n\t//成员函数 实现不了  p << cout 不是我们想要的效果\n\t//void operator<<(Person& p){\n\t//}\n\nprivate:\n\tint m_A;\n\tint m_B;\n};\n\n//全局函数实现左移重载\n//ostream对象只能有一个\nostream& operator<<(ostream& out, Person& p) {\n\tout << \"a:\" << p.m_A << \" b:\" << p.m_B;\n\treturn out;\n}\n\nvoid test() {\n\n\tPerson p1(10, 20);\n\n\tcout << p1 << \"hello world\" << endl; //链式编程\n}\n\nint main() {\n\n\ttest();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n> 总结：重载左移运算符配合友元可以实现输出自定义数据类型\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.5.3 递增运算符重载\n\n\n\n作用： 通过重载递增运算符，实现自己的整型数据\n\n\n\n```C++\nclass MyInteger {\n\n\tfriend ostream& operator<<(ostream& out, MyInteger myint);\n\npublic:\n\tMyInteger() {\n\t\tm_Num = 0;\n\t}\n\t//前置++\n\tMyInteger& operator++() {\n\t\t//先++\n\t\tm_Num++;\n\t\t//再返回\n\t\treturn *this;\n\t}\n\n\t//后置++\n\tMyInteger operator++(int) {\n\t\t//先返回\n\t\tMyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；\n\t\tm_Num++;\n\t\treturn temp;\n\t}\n\nprivate:\n\tint m_Num;\n};\n\n\nostream& operator<<(ostream& out, MyInteger myint) {\n\tout << myint.m_Num;\n\treturn out;\n}\n\n\n//前置++ 先++ 再返回\nvoid test01() {\n\tMyInteger myInt;\n\tcout << ++myInt << endl;\n\tcout << myInt << endl;\n}\n\n//后置++ 先返回 再++\nvoid test02() {\n\n\tMyInteger myInt;\n\tcout << myInt++ << endl;\n\tcout << myInt << endl;\n}\n\nint main() {\n\n\ttest01();\n\t//test02();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n> 总结： 前置递增返回引用，后置递增返回值\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.5.4 赋值运算符重载\n\n\n\nc++编译器至少给一个类添加4个函数\n\n1. 默认构造函数(无参，函数体为空)\n2. 默认析构函数(无参，函数体为空)\n3. 默认拷贝构造函数，对属性进行值拷贝\n4. 赋值运算符 operator=, 对属性进行值拷贝\n\n\n\n\n\n如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题\n\n\n\n\n\n**示例：**\n\n```C++\nclass Person\n{\npublic:\n\n\tPerson(int age)\n\t{\n\t\t//将年龄数据开辟到堆区\n\t\tm_Age = new int(age);\n\t}\n\n\t//重载赋值运算符 \n\tPerson& operator=(Person &p)\n\t{\n\t\tif (m_Age != NULL)\n\t\t{\n\t\t\tdelete m_Age;\n\t\t\tm_Age = NULL;\n\t\t}\n\t\t//编译器提供的代码是浅拷贝\n\t\t//m_Age = p.m_Age;\n\n\t\t//提供深拷贝 解决浅拷贝的问题\n\t\tm_Age = new int(*p.m_Age);\n\n\t\t//返回自身\n\t\treturn *this;\n\t}\n\n\n\t~Person()\n\t{\n\t\tif (m_Age != NULL)\n\t\t{\n\t\t\tdelete m_Age;\n\t\t\tm_Age = NULL;\n\t\t}\n\t}\n\n\t//年龄的指针\n\tint *m_Age;\n\n};\n\n\nvoid test01()\n{\n\tPerson p1(18);\n\n\tPerson p2(20);\n\n\tPerson p3(30);\n\n\tp3 = p2 = p1; //赋值操作\n\n\tcout << \"p1的年龄为：\" << *p1.m_Age << endl;\n\n\tcout << \"p2的年龄为：\" << *p2.m_Age << endl;\n\n\tcout << \"p3的年龄为：\" << *p3.m_Age << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\t//int a = 10;\n\t//int b = 20;\n\t//int c = 30;\n\n\t//c = b = a;\n\t//cout << \"a = \" << a << endl;\n\t//cout << \"b = \" << b << endl;\n\t//cout << \"c = \" << c << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n#### 4.5.5 关系运算符重载\n\n\n\n**作用：**重载关系运算符，可以让两个自定义类型对象进行对比操作\n\n\n\n**示例：**\n\n```C++\nclass Person\n{\npublic:\n\tPerson(string name, int age)\n\t{\n\t\tthis->m_Name = name;\n\t\tthis->m_Age = age;\n\t};\n\n\tbool operator==(Person & p)\n\t{\n\t\tif (this->m_Name == p.m_Name && this->m_Age == p.m_Age)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tbool operator!=(Person & p)\n\t{\n\t\tif (this->m_Name == p.m_Name && this->m_Age == p.m_Age)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstring m_Name;\n\tint m_Age;\n};\n\nvoid test01()\n{\n\t//int a = 0;\n\t//int b = 0;\n\n\tPerson a(\"孙悟空\", 18);\n\tPerson b(\"孙悟空\", 18);\n\n\tif (a == b)\n\t{\n\t\tcout << \"a和b相等\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"a和b不相等\" << endl;\n\t}\n\n\tif (a != b)\n\t{\n\t\tcout << \"a和b不相等\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"a和b相等\" << endl;\n\t}\n}\n\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n#### 4.5.6 函数调用运算符重载\n\n\n\n* 函数调用运算符 ()  也可以重载\n* 由于重载后使用的方式非常像函数的调用，因此称为仿函数\n* 仿函数没有固定写法，非常灵活\n\n\n\n**示例：**\n\n```C++\nclass MyPrint\n{\npublic:\n\tvoid operator()(string text)\n\t{\n\t\tcout << text << endl;\n\t}\n\n};\nvoid test01()\n{\n\t//重载的（）操作符 也称为仿函数\n\tMyPrint myFunc;\n\tmyFunc(\"hello world\");\n}\n\n\nclass MyAdd\n{\npublic:\n\tint operator()(int v1, int v2)\n\t{\n\t\treturn v1 + v2;\n\t}\n};\n\nvoid test02()\n{\n\tMyAdd add;\n\tint ret = add(10, 10);\n\tcout << \"ret = \" << ret << endl;\n\n\t//匿名对象调用  \n\tcout << \"MyAdd()(100,100) = \" << MyAdd()(100, 100) << endl;\n}\n\nint main() {\n\n\ttest01();\n\ttest02();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n### 4.6  继承\n\n**继承是面向对象三大特性之一**\n\n有些类与类之间存在特殊的关系，例如下图中：\n\n![1544861202252](assets/1544861202252.png)\n\n我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。\n\n这个时候我们就可以考虑利用继承的技术，减少重复代码\n\n\n\n#### 4.6.1 继承的基本语法\n\n\n\n例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同\n\n接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处\n\n\n\n**普通实现：**\n\n```C++\n//Java页面\nclass Java \n{\npublic:\n\tvoid header()\n\t{\n\t\tcout << \"首页、公开课、登录、注册...（公共头部）\" << endl;\n\t}\n\tvoid footer()\n\t{\n\t\tcout << \"帮助中心、交流合作、站内地图...(公共底部)\" << endl;\n\t}\n\tvoid left()\n\t{\n\t\tcout << \"Java,Python,C++...(公共分类列表)\" << endl;\n\t}\n\tvoid content()\n\t{\n\t\tcout << \"JAVA学科视频\" << endl;\n\t}\n};\n//Python页面\nclass Python\n{\npublic:\n\tvoid header()\n\t{\n\t\tcout << \"首页、公开课、登录、注册...（公共头部）\" << endl;\n\t}\n\tvoid footer()\n\t{\n\t\tcout << \"帮助中心、交流合作、站内地图...(公共底部)\" << endl;\n\t}\n\tvoid left()\n\t{\n\t\tcout << \"Java,Python,C++...(公共分类列表)\" << endl;\n\t}\n\tvoid content()\n\t{\n\t\tcout << \"Python学科视频\" << endl;\n\t}\n};\n//C++页面\nclass CPP \n{\npublic:\n\tvoid header()\n\t{\n\t\tcout << \"首页、公开课、登录、注册...（公共头部）\" << endl;\n\t}\n\tvoid footer()\n\t{\n\t\tcout << \"帮助中心、交流合作、站内地图...(公共底部)\" << endl;\n\t}\n\tvoid left()\n\t{\n\t\tcout << \"Java,Python,C++...(公共分类列表)\" << endl;\n\t}\n\tvoid content()\n\t{\n\t\tcout << \"C++学科视频\" << endl;\n\t}\n};\n\nvoid test01()\n{\n\t//Java页面\n\tcout << \"Java下载视频页面如下： \" << endl;\n\tJava ja;\n\tja.header();\n\tja.footer();\n\tja.left();\n\tja.content();\n\tcout << \"--------------------\" << endl;\n\n\t//Python页面\n\tcout << \"Python下载视频页面如下： \" << endl;\n\tPython py;\n\tpy.header();\n\tpy.footer();\n\tpy.left();\n\tpy.content();\n\tcout << \"--------------------\" << endl;\n\n\t//C++页面\n\tcout << \"C++下载视频页面如下： \" << endl;\n\tCPP cp;\n\tcp.header();\n\tcp.footer();\n\tcp.left();\n\tcp.content();\n\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n**继承实现：**\n\n```C++\n//公共页面\nclass BasePage\n{\npublic:\n\tvoid header()\n\t{\n\t\tcout << \"首页、公开课、登录、注册...（公共头部）\" << endl;\n\t}\n\n\tvoid footer()\n\t{\n\t\tcout << \"帮助中心、交流合作、站内地图...(公共底部)\" << endl;\n\t}\n\tvoid left()\n\t{\n\t\tcout << \"Java,Python,C++...(公共分类列表)\" << endl;\n\t}\n\n};\n\n//Java页面\nclass Java : public BasePage\n{\npublic:\n\tvoid content()\n\t{\n\t\tcout << \"JAVA学科视频\" << endl;\n\t}\n};\n//Python页面\nclass Python : public BasePage\n{\npublic:\n\tvoid content()\n\t{\n\t\tcout << \"Python学科视频\" << endl;\n\t}\n};\n//C++页面\nclass CPP : public BasePage\n{\npublic:\n\tvoid content()\n\t{\n\t\tcout << \"C++学科视频\" << endl;\n\t}\n};\n\nvoid test01()\n{\n\t//Java页面\n\tcout << \"Java下载视频页面如下： \" << endl;\n\tJava ja;\n\tja.header();\n\tja.footer();\n\tja.left();\n\tja.content();\n\tcout << \"--------------------\" << endl;\n\n\t//Python页面\n\tcout << \"Python下载视频页面如下： \" << endl;\n\tPython py;\n\tpy.header();\n\tpy.footer();\n\tpy.left();\n\tpy.content();\n\tcout << \"--------------------\" << endl;\n\n\t//C++页面\n\tcout << \"C++下载视频页面如下： \" << endl;\n\tCPP cp;\n\tcp.header();\n\tcp.footer();\n\tcp.left();\n\tcp.content();\n\n\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n**总结：**\n\n继承的好处：==可以减少重复的代码==\n\nclass A : public B; \n\nA 类称为子类 或 派生类\n\nB 类称为父类 或 基类\n\n\n\n**派生类中的成员，包含两大部分**：\n\n一类是从基类继承过来的，一类是自己增加的成员。\n\n从基类继承过过来的表现其共性，而新增的成员体现了其个性。\n\n\n\n\n\n\n\n\n\n#### 4.6.2 继承方式\n\n\n\n继承的语法：`class 子类 : 继承方式  父类`\n\n\n\n**继承方式一共有三种：**\n\n* 公共继承\n* 保护继承\n* 私有继承\n\n\n\n\n\n![img](assets/clip_image002.png)\n\n\n\n\n\n**示例：**\n\n```C++\nclass Base1\n{\npublic: \n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C;\n};\n\n//公共继承\nclass Son1 :public Base1\n{\npublic:\n\tvoid func()\n\t{\n\t\tm_A; //可访问 public权限\n\t\tm_B; //可访问 protected权限\n\t\t//m_C; //不可访问\n\t}\n};\n\nvoid myClass()\n{\n\tSon1 s1;\n\ts1.m_A; //其他类只能访问到公共权限\n}\n\n//保护继承\nclass Base2\n{\npublic:\n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C;\n};\nclass Son2:protected Base2\n{\npublic:\n\tvoid func()\n\t{\n\t\tm_A; //可访问 protected权限\n\t\tm_B; //可访问 protected权限\n\t\t//m_C; //不可访问\n\t}\n};\nvoid myClass2()\n{\n\tSon2 s;\n\t//s.m_A; //不可访问\n}\n\n//私有继承\nclass Base3\n{\npublic:\n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C;\n};\nclass Son3:private Base3\n{\npublic:\n\tvoid func()\n\t{\n\t\tm_A; //可访问 private权限\n\t\tm_B; //可访问 private权限\n\t\t//m_C; //不可访问\n\t}\n};\nclass GrandSon3 :public Son3\n{\npublic:\n\tvoid func()\n\t{\n\t\t//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到\n\t\t//m_A;\n\t\t//m_B;\n\t\t//m_C;\n\t}\n};\n```\n\n\n\n\n\n\n\n\n\n#### 4.6.3 继承中的对象模型\n\n\n\n**问题：**从父类继承过来的成员，哪些属于子类对象中？\n\n\n\n**示例：**\n\n```C++\nclass Base\n{\npublic:\n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C; //私有成员只是被隐藏了，但是还是会继承下去\n};\n\n//公共继承\nclass Son :public Base\n{\npublic:\n\tint m_D;\n};\n\nvoid test01()\n{\n\tcout << \"sizeof Son = \" << sizeof(Son) << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n利用工具查看：\n\n\n\n![1545881904150](assets/1545881904150.png)\n\n\n\n打开工具窗口后，定位到当前CPP文件的盘符\n\n然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名\n\n\n\n效果如下图：\n\n\n\n![1545882158050](assets/1545882158050.png)\n\n\n\n> 结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.6.4 继承中构造和析构顺序\n\n\n\n子类继承父类后，当创建子类对象，也会调用父类的构造函数\n\n\n\n问题：父类和子类的构造和析构顺序是谁先谁后？\n\n\n\n**示例：**\n\n```C++\nclass Base \n{\npublic:\n\tBase()\n\t{\n\t\tcout << \"Base构造函数!\" << endl;\n\t}\n\t~Base()\n\t{\n\t\tcout << \"Base析构函数!\" << endl;\n\t}\n};\n\nclass Son : public Base\n{\npublic:\n\tSon()\n\t{\n\t\tcout << \"Son构造函数!\" << endl;\n\t}\n\t~Son()\n\t{\n\t\tcout << \"Son析构函数!\" << endl;\n\t}\n\n};\n\n\nvoid test01()\n{\n\t//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反\n\tSon s;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n> 总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反\n\n\n\n\n\n\n\n\n\n\n\n#### 4.6.5 继承同名成员处理方式\n\n\n\n问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？\n\n\n\n* 访问子类同名成员   直接访问即可\n* 访问父类同名成员   需要加作用域\n\n\n\n**示例：**\n\n```C++\nclass Base {\npublic:\n\tBase()\n\t{\n\t\tm_A = 100;\n\t}\n\n\tvoid func()\n\t{\n\t\tcout << \"Base - func()调用\" << endl;\n\t}\n\n\tvoid func(int a)\n\t{\n\t\tcout << \"Base - func(int a)调用\" << endl;\n\t}\n\npublic:\n\tint m_A;\n};\n\n\nclass Son : public Base {\npublic:\n\tSon()\n\t{\n\t\tm_A = 200;\n\t}\n\n\t//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数\n\t//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域\n\tvoid func()\n\t{\n\t\tcout << \"Son - func()调用\" << endl;\n\t}\npublic:\n\tint m_A;\n};\n\nvoid test01()\n{\n\tSon s;\n\n\tcout << \"Son下的m_A = \" << s.m_A << endl;\n\tcout << \"Base下的m_A = \" << s.Base::m_A << endl;\n\n\ts.func();\n\ts.Base::func();\n\ts.Base::func(10);\n\n}\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\treturn EXIT_SUCCESS;\n}\n```\n\n总结：\n\n1. 子类对象可以直接访问到子类中同名成员\n2. 子类对象加作用域可以访问到父类同名成员\n3. 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.6.6 继承同名静态成员处理方式\n\n\n\n问题：继承中同名的静态成员在子类对象上如何进行访问？\n\n\n\n静态成员和非静态成员出现同名，处理方式一致\n\n\n\n- 访问子类同名成员   直接访问即可\n- 访问父类同名成员   需要加作用域\n\n\n\n**示例：**\n\n```C++\nclass Base {\npublic:\n\tstatic void func()\n\t{\n\t\tcout << \"Base - static void func()\" << endl;\n\t}\n\tstatic void func(int a)\n\t{\n\t\tcout << \"Base - static void func(int a)\" << endl;\n\t}\n\n\tstatic int m_A;\n};\n\nint Base::m_A = 100;\n\nclass Son : public Base {\npublic:\n\tstatic void func()\n\t{\n\t\tcout << \"Son - static void func()\" << endl;\n\t}\n\tstatic int m_A;\n};\n\nint Son::m_A = 200;\n\n//同名成员属性\nvoid test01()\n{\n\t//通过对象访问\n\tcout << \"通过对象访问： \" << endl;\n\tSon s;\n\tcout << \"Son  下 m_A = \" << s.m_A << endl;\n\tcout << \"Base 下 m_A = \" << s.Base::m_A << endl;\n\n\t//通过类名访问\n\tcout << \"通过类名访问： \" << endl;\n\tcout << \"Son  下 m_A = \" << Son::m_A << endl;\n\tcout << \"Base 下 m_A = \" << Son::Base::m_A << endl;\n}\n\n//同名成员函数\nvoid test02()\n{\n\t//通过对象访问\n\tcout << \"通过对象访问： \" << endl;\n\tSon s;\n\ts.func();\n\ts.Base::func();\n\n\tcout << \"通过类名访问： \" << endl;\n\tSon::func();\n\tSon::Base::func();\n\t//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问\n\tSon::Base::func(100);\n}\nint main() {\n\n\t//test01();\n\ttest02();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n> 总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.6.7 多继承语法\n\n\n\nC++允许**一个类继承多个类**\n\n\n\n语法：` class 子类 ：继承方式 父类1 ， 继承方式 父类2...`\n\n\n\n多继承可能会引发父类中有同名成员出现，需要加作用域区分\n\n\n\n**C++实际开发中不建议用多继承**\n\n\n\n\n\n\n\n**示例：**\n\n```C++\nclass Base1 {\npublic:\n\tBase1()\n\t{\n\t\tm_A = 100;\n\t}\npublic:\n\tint m_A;\n};\n\nclass Base2 {\npublic:\n\tBase2()\n\t{\n\t\tm_A = 200;  //开始是m_B 不会出问题，但是改为mA就会出现不明确\n\t}\npublic:\n\tint m_A;\n};\n\n//语法：class 子类：继承方式 父类1 ，继承方式 父类2 \nclass Son : public Base2, public Base1 \n{\npublic:\n\tSon()\n\t{\n\t\tm_C = 300;\n\t\tm_D = 400;\n\t}\npublic:\n\tint m_C;\n\tint m_D;\n};\n\n\n//多继承容易产生成员同名的情况\n//通过使用类名作用域可以区分调用哪一个基类的成员\nvoid test01()\n{\n\tSon s;\n\tcout << \"sizeof Son = \" << sizeof(s) << endl;\n\tcout << s.Base1::m_A << endl;\n\tcout << s.Base2::m_A << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n> 总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域\n\n\n\n\n\n\n\n\n\n\n\n#### 4.6.8 菱形继承\n\n\n\n**菱形继承概念：**\n\n\t两个派生类继承同一个基类\n\t\n\t又有某个类同时继承者两个派生类\n\t\n\t这种继承被称为菱形继承，或者钻石继承\n\n\n\n**典型的菱形继承案例：**\n\n\n\n![IMG_256](assets/clip_image002.jpg)\n\n\n\n**菱形继承问题：**\n\n\n\n1.     羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。\n\n2.     草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。\n\n\n\n**示例：**\n\n```C++\nclass Animal\n{\npublic:\n\tint m_Age;\n};\n\n//继承前加virtual关键字后，变为虚继承\n//此时公共的父类Animal称为虚基类\nclass Sheep : virtual public Animal {};\nclass Tuo   : virtual public Animal {};\nclass SheepTuo : public Sheep, public Tuo {};\n\nvoid test01()\n{\n\tSheepTuo st;\n\tst.Sheep::m_Age = 100;\n\tst.Tuo::m_Age = 200;\n\n\tcout << \"st.Sheep::m_Age = \" << st.Sheep::m_Age << endl;\n\tcout << \"st.Tuo::m_Age = \" <<  st.Tuo::m_Age << endl;\n\tcout << \"st.m_Age = \" << st.m_Age << endl;\n}\n\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n总结：\n\n* 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义\n* 利用虚继承可以解决菱形继承问题\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 4.7  多态\n\n#### 4.7.1 多态的基本概念\n\n\n\n**多态是C++面向对象三大特性之一**\n\n多态分为两类\n\n* 静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名\n* 动态多态: 派生类和虚函数实现运行时多态\n\n\n\n静态多态和动态多态区别：\n\n* 静态多态的函数地址早绑定  -  编译阶段确定函数地址\n* 动态多态的函数地址晚绑定  -  运行阶段确定函数地址\n\n\n\n下面通过案例进行讲解多态\n\n\n\n```C++\nclass Animal\n{\npublic:\n\t//Speak函数就是虚函数\n\t//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。\n\tvirtual void speak()\n\t{\n\t\tcout << \"动物在说话\" << endl;\n\t}\n};\n\nclass Cat :public Animal\n{\npublic:\n\tvoid speak()\n\t{\n\t\tcout << \"小猫在说话\" << endl;\n\t}\n};\n\nclass Dog :public Animal\n{\npublic:\n\n\tvoid speak()\n\t{\n\t\tcout << \"小狗在说话\" << endl;\n\t}\n\n};\n//我们希望传入什么对象，那么就调用什么对象的函数\n//如果函数地址在编译阶段就能确定，那么静态联编\n//如果函数地址在运行阶段才能确定，就是动态联编\n\nvoid DoSpeak(Animal & animal)\n{\n\tanimal.speak();\n}\n//\n//多态满足条件： \n//1、有继承关系\n//2、子类重写父类中的虚函数\n//多态使用：\n//父类指针或引用指向子类对象\n\nvoid test01()\n{\n\tCat cat;\n\tDoSpeak(cat);\n\n\n\tDog dog;\n\tDoSpeak(dog);\n}\n\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n总结：\n\n多态满足条件\n\n* 有继承关系\n* 子类重写父类中的虚函数\n\n多态使用条件\n\n* 父类指针或引用指向子类对象\n\n重写：函数返回值类型  函数名 参数列表 完全一致称为重写\n\n\n\n\n\n\n\n\n\n#### 4.7.2 多态案例一-计算器类\n\n\n\n案例描述：\n\n分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类\n\n\n\n多态的优点：\n\n* 代码组织结构清晰\n* 可读性强\n* 利于前期和后期的扩展以及维护\n\n\n\n**示例：**\n\n```C++\n//普通实现\nclass Calculator {\npublic:\n\tint getResult(string oper)\n\t{\n\t\tif (oper == \"+\") {\n\t\t\treturn m_Num1 + m_Num2;\n\t\t}\n\t\telse if (oper == \"-\") {\n\t\t\treturn m_Num1 - m_Num2;\n\t\t}\n\t\telse if (oper == \"*\") {\n\t\t\treturn m_Num1 * m_Num2;\n\t\t}\n\t\t//如果要提供新的运算，需要修改源码\n\t}\npublic:\n\tint m_Num1;\n\tint m_Num2;\n};\n\nvoid test01()\n{\n\t//普通实现测试\n\tCalculator c;\n\tc.m_Num1 = 10;\n\tc.m_Num2 = 10;\n\tcout << c.m_Num1 << \" + \" << c.m_Num2 << \" = \" << c.getResult(\"+\") << endl;\n\n\tcout << c.m_Num1 << \" - \" << c.m_Num2 << \" = \" << c.getResult(\"-\") << endl;\n\n\tcout << c.m_Num1 << \" * \" << c.m_Num2 << \" = \" << c.getResult(\"*\") << endl;\n}\n\n\n\n//多态实现\n//抽象计算器类\n//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护\nclass AbstractCalculator\n{\npublic :\n\n\tvirtual int getResult()\n\t{\n\t\treturn 0;\n\t}\n\n\tint m_Num1;\n\tint m_Num2;\n};\n\n//加法计算器\nclass AddCalculator :public AbstractCalculator\n{\npublic:\n\tint getResult()\n\t{\n\t\treturn m_Num1 + m_Num2;\n\t}\n};\n\n//减法计算器\nclass SubCalculator :public AbstractCalculator\n{\npublic:\n\tint getResult()\n\t{\n\t\treturn m_Num1 - m_Num2;\n\t}\n};\n\n//乘法计算器\nclass MulCalculator :public AbstractCalculator\n{\npublic:\n\tint getResult()\n\t{\n\t\treturn m_Num1 * m_Num2;\n\t}\n};\n\n\nvoid test02()\n{\n\t//创建加法计算器\n\tAbstractCalculator *abc = new AddCalculator;\n\tabc->m_Num1 = 10;\n\tabc->m_Num2 = 10;\n\tcout << abc->m_Num1 << \" + \" << abc->m_Num2 << \" = \" << abc->getResult() << endl;\n\tdelete abc;  //用完了记得销毁\n\n\t//创建减法计算器\n\tabc = new SubCalculator;\n\tabc->m_Num1 = 10;\n\tabc->m_Num2 = 10;\n\tcout << abc->m_Num1 << \" - \" << abc->m_Num2 << \" = \" << abc->getResult() << endl;\n\tdelete abc;  \n\n\t//创建乘法计算器\n\tabc = new MulCalculator;\n\tabc->m_Num1 = 10;\n\tabc->m_Num2 = 10;\n\tcout << abc->m_Num1 << \" * \" << abc->m_Num2 << \" = \" << abc->getResult() << endl;\n\tdelete abc;\n}\n\nint main() {\n\n\t//test01();\n\n\ttest02();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n> 总结：C++开发提倡利用多态设计程序架构，因为多态优点很多\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.7.3 纯虚函数和抽象类\n\n\n\n在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容\n\n\n\n因此可以将虚函数改为**纯虚函数**\n\n\n\n纯虚函数语法：`virtual 返回值类型 函数名 （参数列表）= 0 ;`\n\n\n\n当类中有了纯虚函数，这个类也称为==抽象类==\n\n\n\n**抽象类特点**：\n\n * 无法实例化对象\n * 子类必须重写抽象类中的纯虚函数，否则也属于抽象类\n\n\n\n\n\n**示例：**\n\n```C++\nclass Base\n{\npublic:\n\t//纯虚函数\n\t//类中只要有一个纯虚函数就称为抽象类\n\t//抽象类无法实例化对象\n\t//子类必须重写父类中的纯虚函数，否则也属于抽象类\n\tvirtual void func() = 0;\n};\n\nclass Son :public Base\n{\npublic:\n\tvirtual void func() \n\t{\n\t\tcout << \"func调用\" << endl;\n\t};\n};\n\nvoid test01()\n{\n\tBase * base = NULL;\n\t//base = new Base; // 错误，抽象类无法实例化对象\n\tbase = new Son;\n\tbase->func();\n\tdelete base;//记得销毁\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.7.4 多态案例二-制作饮品\n\n**案例描述：**\n\n制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料\n\n\n\n利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶\n\n\n\n![1545985945198](assets/1545985945198.png)\n\n\n\n**示例：**\n\n```C++\n//抽象制作饮品\nclass AbstractDrinking {\npublic:\n\t//烧水\n\tvirtual void Boil() = 0;\n\t//冲泡\n\tvirtual void Brew() = 0;\n\t//倒入杯中\n\tvirtual void PourInCup() = 0;\n\t//加入辅料\n\tvirtual void PutSomething() = 0;\n\t//规定流程\n\tvoid MakeDrink() {\n\t\tBoil();\n\t\tBrew();\n\t\tPourInCup();\n\t\tPutSomething();\n\t}\n};\n\n//制作咖啡\nclass Coffee : public AbstractDrinking {\npublic:\n\t//烧水\n\tvirtual void Boil() {\n\t\tcout << \"煮农夫山泉!\" << endl;\n\t}\n\t//冲泡\n\tvirtual void Brew() {\n\t\tcout << \"冲泡咖啡!\" << endl;\n\t}\n\t//倒入杯中\n\tvirtual void PourInCup() {\n\t\tcout << \"将咖啡倒入杯中!\" << endl;\n\t}\n\t//加入辅料\n\tvirtual void PutSomething() {\n\t\tcout << \"加入牛奶!\" << endl;\n\t}\n};\n\n//制作茶水\nclass Tea : public AbstractDrinking {\npublic:\n\t//烧水\n\tvirtual void Boil() {\n\t\tcout << \"煮自来水!\" << endl;\n\t}\n\t//冲泡\n\tvirtual void Brew() {\n\t\tcout << \"冲泡茶叶!\" << endl;\n\t}\n\t//倒入杯中\n\tvirtual void PourInCup() {\n\t\tcout << \"将茶水倒入杯中!\" << endl;\n\t}\n\t//加入辅料\n\tvirtual void PutSomething() {\n\t\tcout << \"加入枸杞!\" << endl;\n\t}\n};\n\n//业务函数\nvoid DoWork(AbstractDrinking* drink) {\n\tdrink->MakeDrink();\n\tdelete drink;\n}\n\nvoid test01() {\n\tDoWork(new Coffee);\n\tcout << \"--------------\" << endl;\n\tDoWork(new Tea);\n}\n\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.7.5 虚析构和纯虚析构\n\n\n\n多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码\n\n\n\n解决方式：将父类中的析构函数改为**虚析构**或者**纯虚析构**\n\n\n\n虚析构和纯虚析构共性：\n\n* 可以解决父类指针释放子类对象\n* 都需要有具体的函数实现\n\n虚析构和纯虚析构区别：\n\n* 如果是纯虚析构，该类属于抽象类，无法实例化对象\n\n\n\n虚析构语法：\n\n`virtual ~类名(){}`\n\n纯虚析构语法：\n\n` virtual ~类名() = 0;`\n\n`类名::~类名(){}`\n\n\n\n**示例：**\n\n```C++\nclass Animal {\npublic:\n\n\tAnimal()\n\t{\n\t\tcout << \"Animal 构造函数调用！\" << endl;\n\t}\n\tvirtual void Speak() = 0;\n\n\t//析构函数加上virtual关键字，变成虚析构函数\n\t//virtual ~Animal()\n\t//{\n\t//\tcout << \"Animal虚析构函数调用！\" << endl;\n\t//}\n\n\n\tvirtual ~Animal() = 0;\n};\n\nAnimal::~Animal()\n{\n\tcout << \"Animal 纯虚析构函数调用！\" << endl;\n}\n\n//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。\n\nclass Cat : public Animal {\npublic:\n\tCat(string name)\n\t{\n\t\tcout << \"Cat构造函数调用！\" << endl;\n\t\tm_Name = new string(name);\n\t}\n\tvirtual void Speak()\n\t{\n\t\tcout << *m_Name <<  \"小猫在说话!\" << endl;\n\t}\n\t~Cat()\n\t{\n\t\tcout << \"Cat析构函数调用!\" << endl;\n\t\tif (this->m_Name != NULL) {\n\t\t\tdelete m_Name;\n\t\t\tm_Name = NULL;\n\t\t}\n\t}\n\npublic:\n\tstring *m_Name;\n};\n\nvoid test01()\n{\n\tAnimal *animal = new Cat(\"Tom\");\n\tanimal->Speak();\n\n\t//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏\n\t//怎么解决？给基类增加一个虚析构函数\n\t//虚析构函数就是用来解决通过父类指针释放子类对象\n\tdelete animal;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n总结：\n\n\t1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象\n\t\n\t2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构\n\t\n\t3. 拥有纯虚析构函数的类也属于抽象类\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.7.6 多态案例三-电脑组装\n\n\n\n**案例描述：**\n\n\n\n电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）\n\n将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商\n\n创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口\n\n测试时组装三台不同的电脑进行工作\n\n\n\n\n\n**示例：**\n\n```C++\n#include<iostream>\nusing namespace std;\n\n//抽象CPU类\nclass CPU\n{\npublic:\n\t//抽象的计算函数\n\tvirtual void calculate() = 0;\n};\n\n//抽象显卡类\nclass VideoCard\n{\npublic:\n\t//抽象的显示函数\n\tvirtual void display() = 0;\n};\n\n//抽象内存条类\nclass Memory\n{\npublic:\n\t//抽象的存储函数\n\tvirtual void storage() = 0;\n};\n\n//电脑类\nclass Computer\n{\npublic:\n\tComputer(CPU * cpu, VideoCard * vc, Memory * mem)\n\t{\n\t\tm_cpu = cpu;\n\t\tm_vc = vc;\n\t\tm_mem = mem;\n\t}\n\n\t//提供工作的函数\n\tvoid work()\n\t{\n\t\t//让零件工作起来，调用接口\n\t\tm_cpu->calculate();\n\n\t\tm_vc->display();\n\n\t\tm_mem->storage();\n\t}\n\n\t//提供析构函数 释放3个电脑零件\n\t~Computer()\n\t{\n\n\t\t//释放CPU零件\n\t\tif (m_cpu != NULL)\n\t\t{\n\t\t\tdelete m_cpu;\n\t\t\tm_cpu = NULL;\n\t\t}\n\n\t\t//释放显卡零件\n\t\tif (m_vc != NULL)\n\t\t{\n\t\t\tdelete m_vc;\n\t\t\tm_vc = NULL;\n\t\t}\n\n\t\t//释放内存条零件\n\t\tif (m_mem != NULL)\n\t\t{\n\t\t\tdelete m_mem;\n\t\t\tm_mem = NULL;\n\t\t}\n\t}\n\nprivate:\n\n\tCPU * m_cpu; //CPU的零件指针\n\tVideoCard * m_vc; //显卡零件指针\n\tMemory * m_mem; //内存条零件指针\n};\n\n//具体厂商\n//Intel厂商\nclass IntelCPU :public CPU\n{\npublic:\n\tvirtual void calculate()\n\t{\n\t\tcout << \"Intel的CPU开始计算了！\" << endl;\n\t}\n};\n\nclass IntelVideoCard :public VideoCard\n{\npublic:\n\tvirtual void display()\n\t{\n\t\tcout << \"Intel的显卡开始显示了！\" << endl;\n\t}\n};\n\nclass IntelMemory :public Memory\n{\npublic:\n\tvirtual void storage()\n\t{\n\t\tcout << \"Intel的内存条开始存储了！\" << endl;\n\t}\n};\n\n//Lenovo厂商\nclass LenovoCPU :public CPU\n{\npublic:\n\tvirtual void calculate()\n\t{\n\t\tcout << \"Lenovo的CPU开始计算了！\" << endl;\n\t}\n};\n\nclass LenovoVideoCard :public VideoCard\n{\npublic:\n\tvirtual void display()\n\t{\n\t\tcout << \"Lenovo的显卡开始显示了！\" << endl;\n\t}\n};\n\nclass LenovoMemory :public Memory\n{\npublic:\n\tvirtual void storage()\n\t{\n\t\tcout << \"Lenovo的内存条开始存储了！\" << endl;\n\t}\n};\n\n\nvoid test01()\n{\n\t//第一台电脑零件\n\tCPU * intelCpu = new IntelCPU;\n\tVideoCard * intelCard = new IntelVideoCard;\n\tMemory * intelMem = new IntelMemory;\n\n\tcout << \"第一台电脑开始工作：\" << endl;\n\t//创建第一台电脑\n\tComputer * computer1 = new Computer(intelCpu, intelCard, intelMem);\n\tcomputer1->work();\n\tdelete computer1;\n\n\tcout << \"-----------------------\" << endl;\n\tcout << \"第二台电脑开始工作：\" << endl;\n\t//第二台电脑组装\n\tComputer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);;\n\tcomputer2->work();\n\tdelete computer2;\n\n\tcout << \"-----------------------\" << endl;\n\tcout << \"第三台电脑开始工作：\" << endl;\n\t//第三台电脑组装\n\tComputer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;\n\tcomputer3->work();\n\tdelete computer3;\n\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 5 文件操作\n\n\n\n程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放\n\n通过**文件可以将数据持久化**\n\nC++中对文件操作需要包含头文件 ==&lt; fstream &gt;==\n\n\n\n文件类型分为两种：\n\n1. **文本文件**     -  文件以文本的**ASCII码**形式存储在计算机中\n2. **二进制文件** -  文件以文本的**二进制**形式存储在计算机中，用户一般不能直接读懂它们\n\n\n\n操作文件的三大类:\n\n1. ofstream：写操作\n2. ifstream： 读操作\n3. fstream ： 读写操作\n\n\n\n### 5.1文本文件\n\n#### 5.1.1写文件\n\n   写文件步骤如下：\n\n1. 包含头文件   \n\n   \\#include <fstream\\>\n\n2. 创建流对象  \n\n   ofstream ofs;\n\n3. 打开文件\n\n   ofs.open(\"文件路径\",打开方式);\n\n4. 写数据\n\n   ofs << \"写入的数据\";\n\n5. 关闭文件\n\n   ofs.close();\n\n   \n\n文件打开方式：\n\n| 打开方式    | 解释                       |\n| ----------- | -------------------------- |\n| ios::in     | 为读文件而打开文件         |\n| ios::out    | 为写文件而打开文件         |\n| ios::ate    | 初始位置：文件尾           |\n| ios::app    | 追加方式写文件             |\n| ios::trunc  | 如果文件存在先删除，再创建 |\n| ios::binary | 二进制方式                 |\n\n**注意：** 文件打开方式可以配合使用，利用|操作符\n\n**例如：**用二进制方式写文件 `ios::binary |  ios:: out`\n\n\n\n\n\n**示例：**\n\n```C++\n#include <fstream>\n\nvoid test01()\n{\n\tofstream ofs;\n\tofs.open(\"test.txt\", ios::out);\n\n\tofs << \"姓名：张三\" << endl;\n\tofs << \"性别：男\" << endl;\n\tofs << \"年龄：18\" << endl;\n\n\tofs.close();\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n总结：\n\n* 文件操作必须包含头文件 fstream\n* 读文件可以利用 ofstream  ，或者fstream类\n* 打开文件时候需要指定操作文件的路径，以及打开方式\n* 利用<<可以向文件中写数据\n* 操作完毕，要关闭文件\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 5.1.2读文件\n\n\n\n读文件与写文件步骤相似，但是读取方式相对于比较多\n\n\n\n读文件步骤如下：\n\n1. 包含头文件   \n\n   \\#include <fstream\\>\n\n2. 创建流对象  \n\n   ifstream ifs;\n\n3. 打开文件并判断文件是否打开成功\n\n   ifs.open(\"文件路径\",打开方式);\n\n4. 读数据\n\n   四种方式读取\n\n5. 关闭文件\n\n   ifs.close();\n\n\n\n**示例：**\n\n```C++\n#include <fstream>\n#include <string>\nvoid test01()\n{\n\tifstream ifs;\n\tifs.open(\"test.txt\", ios::in);\n\n\tif (!ifs.is_open())\n\t{\n\t\tcout << \"文件打开失败\" << endl;\n\t\treturn;\n\t}\n\n\t//第一种方式\n\t//char buf[1024] = { 0 };\n\t//while (ifs >> buf)\n\t//{\n\t//\tcout << buf << endl;\n\t//}\n\n\t//第二种\n\t//char buf[1024] = { 0 };\n\t//while (ifs.getline(buf,sizeof(buf)))\n\t//{\n\t//\tcout << buf << endl;\n\t//}\n\n\t//第三种\n\t//string buf;\n\t//while (getline(ifs, buf))\n\t//{\n\t//\tcout << buf << endl;\n\t//}\n\n\tchar c;\n\twhile ((c = ifs.get()) != EOF)\n\t{\n\t\tcout << c;\n\t}\n\n\tifs.close();\n\n\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n总结：\n\n- 读文件可以利用 ifstream  ，或者fstream类\n- 利用is_open函数可以判断文件是否打开成功\n- close 关闭文件 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 5.2 二进制文件\n\n以二进制的方式对文件进行读写操作\n\n打开方式要指定为 ==ios::binary==\n\n\n\n#### 5.2.1 写文件\n\n二进制方式写文件主要利用流对象调用成员函数write\n\n函数原型 ：`ostream& write(const char * buffer,int len);`\n\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n\n\n\n**示例：**\n\n```C++\n#include <fstream>\n#include <string>\n\nclass Person\n{\npublic:\n\tchar m_Name[64];\n\tint m_Age;\n};\n\n//二进制文件  写文件\nvoid test01()\n{\n\t//1、包含头文件\n\n\t//2、创建输出流对象\n\tofstream ofs(\"person.txt\", ios::out | ios::binary);\n\t\n\t//3、打开文件\n\t//ofs.open(\"person.txt\", ios::out | ios::binary);\n\n\tPerson p = {\"张三\"  , 18};\n\n\t//4、写文件\n\tofs.write((const char *)&p, sizeof(p));\n\n\t//5、关闭文件\n\tofs.close();\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n总结：\n\n* 文件输出流对象 可以通过write函数，以二进制方式写数据\n\n\n\n\n\n\n\n\n\n\n\n#### 5.2.2 读文件\n\n二进制方式读文件主要利用流对象调用成员函数read\n\n函数原型：`istream& read(char *buffer,int len);`\n\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n\n示例：\n\n```C++\n#include <fstream>\n#include <string>\n\nclass Person\n{\npublic:\n\tchar m_Name[64];\n\tint m_Age;\n};\n\nvoid test01()\n{\n\tifstream ifs(\"person.txt\", ios::in | ios::binary);\n\tif (!ifs.is_open())\n\t{\n\t\tcout << \"文件打开失败\" << endl;\n\t}\n\n\tPerson p;\n\tifs.read((char *)&p, sizeof(p));\n\n\tcout << \"姓名： \" << p.m_Name << \" 年龄： \" << p.m_Age << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n- 文件输入流对象 可以通过read函数，以二进制方式读数据\n","tags":["C++"]},{"title":"日期类","url":"/2022/12/11/5/","content":"```\n#include<iostream>\n\nusing namespace std;\n\nclass Date\n{\npublic:\n    void set(int year, int month, int day)\n    {\n        this->year = year;\n        this->month = month;\n        this->day = day;\n    }\n    //前置++\n    Date& operator++()\n    {\n        if (day < 28)\n        {\n            day++;\n            return *this;\n        }\n        else if (month == 2)\n        {\n            if (day == 28 && !(year % 400 == 0 || (year % 4 == 0 && year % 100 != 0)))\n            {\n                day++;\n                return *this;\n            }\n            month++, day = 1;\n            return *this;\n        }\n        else if (day == 29)\n        {\n            day++;\n            return *this;\n        }\n        else if (day == 30)\n        {\n            switch (month)\n            {\n            case 4:case 6:case 9:case 11:\n                day = 1;\n                month++;\n                return *this;\n                break;\n            }\n            day++;\n            return *this;\n        }\n        else if (month == 12)\n        {\n            year++, month = 1, day = 1;\n            return *this;\n        }\n        else\n        {\n            month++;\n            day = 1;\n            return *this;\n        }\n    }\n    //后置++\n    Date operator++(int)\n    {\n        Date* temp = this;\n        return *temp;\n        ++(*this);\n    }\n    //前置--\n    Date& operator--()\n    {\n        if (day == 1)\n        {\n            switch (month)\n            {\n            case 2:case4:case 6:case 8:case 9:case 11:\n                day = 31;\n                month--;\n                break;\n            case 5:case 7:case 10:case 12:\n                day = 30;\n                month--;\n                break;\n            case 1:\n                month = 12;\n                year--;\n                day = 31;\n            case 3:\n                if (year % 4 != 0)\n                    month--;\n                day = 28;\n                month--;\n                day = 29;\n                break;\n            default:\n                break;\n            }\n\n        }\n        else\n            day--;\n        return *this;\n    }\n    //后置--\n    Date operator--(int)\n    {\n        Date* temp = this;\n        return *temp;\n        --(*this);\n    }\npublic:\n    int year;\n    int month;\n    int day;\n};\n\nvoid show(Date data)\n{\n    cout << \"年：\" << data.year << \"月：\" << data.month << \"日：\" << data.day << endl;\n}\n\nint main()\n{\n    Date data;\n    data.set(2012, 4, 29);\n    show(data);\n    int a;\n    cout << \"选择：1、后置递增\\t 2、前置递增\\t 3、后置递减\\t 4、前置递减\" << endl;\n    cin >> a;\n    switch (a)\n    {\n    case 1:\n        show(data++);\n        break;\n    case 2:\n        show(++data);\n        break;\n    case 3:\n        show(data--);\n        break;\n    case 4:\n        show(--data);\n        break;\n    default:\n        break;\n    }\n    return 0;\n}\n```\n","tags":["C++"]},{"title":"学生信息管理系统","url":"/2022/12/11/4/","content":"\n```\n#include<iostream>\n#include<string>\n#include<vector>\n#include<windows.h>\n#include<algorithm>\n\nusing namespace std;\n\nclass student\n{\npublic:\n    string s_name;\n    int s_id = 0;\n    int y_score = 0;//语文成绩\n    int s_score = 0;//数学成绩\n    int e_score = 0;//英语成绩\n    int s_total = 0;\n};\n\nvector<student> v;\nvector<student>z;\n\nvoid showmenu()\n{\n    cout << \"*******************************\" << endl;\n    cout << \"欢迎来到学生管理系统\" << endl;\n    cout << \"请选择您的操作\" << endl;\n    cout << \"1.添加学生\" << endl;\n    cout << \"2.输出学生列表\" << endl;\n    cout << \"3.对成绩进行排序\" << endl;\n    cout << \"4.根据学号查找学生信息\" << endl;\n    cout << \"输入其他字符退出程序\" << endl;\n    cout << \"*******************************\" << endl;\n}\n\nvoid showstudent(vector<student>& a)\n{\n    for (vector<student>::iterator it = a.begin(); it != a.end(); it++)\n    {\n        cout << \"姓名：\" << (*it).s_name << \"\\t学号：\" << (*it).s_id << \"\\t语文成绩：\" << (*it).y_score << \"\\t数学成绩：\" << (*it).s_score << \"\\t英语成绩：\" << (*it).e_score << \"\\t总成绩：\" << (*it).s_total << endl;\n    }\n}\n\nvoid showstudent1(vector<student>& a)\n{\n    int i = 1;\n    for (vector<student>::iterator it = a.begin(); it != a.end(); it++, i++)\n    {\n        cout << \"第\" << i << \"名： 姓名：\" << (*it).s_name << \"\\t学号：\" << (*it).s_id << \"\\t语文成绩：\" << (*it).y_score << \"\\t数学成绩：\" << (*it).s_score << \"\\t英语成绩：\" << (*it).e_score << \"\\t总成绩：\" << (*it).s_total << endl;\n    }\n}\n\nbool comp(const student& a, const student& b)\n{\n    return a.s_total > b.s_total;\n}\n\nint main()\n{\n    while (true)\n    {\n    aaa:\n        showmenu();\n        int a;\n        cin >> a;\n        system(\"cls\");\n        switch (a)\n        {\n        case 1:\n        {\n            student stu;\n            cout << \"姓名：\" << endl;\n            cin >> stu.s_name;\n            cout << \"学生号：\" << endl;\n            cin >> stu.s_id;\n            cout << \"语文成绩\" << endl;\n            cin >> stu.y_score;\n            cout << \"数学成绩\" << endl;\n            cin >> stu.s_score;\n            cout << \"英语成绩\" << endl;\n            cin >> stu.e_score;\n            stu.s_total = stu.y_score + stu.s_score + stu.e_score;\n            v.push_back(stu);\n            cout << \"添加成功！\" << endl;\n            Sleep(1000);\n            system(\"cls\");\n            break;\n        }\n        case 2:\n        {\n            showstudent(v);\n            system(\"pause\");\n            system(\"cls\");\n            break;\n        }\n        case 3:\n        {\n            z = v;\n            sort(z.begin(), z.end(), comp);\n            showstudent1(z);\n            system(\"pause\");\n            system(\"cls\");\n            break;\n        }\n        case 4:\n        {\n            int id;\n            cout << \"请输入学生id号：\" << endl;\n            cin >> id;\n            for (vector<student>::iterator it = v.begin(); it != v.end(); it++)\n            {\n                if ((*it).s_id == id)\n                {\n                    cout << \"查找成功 学生信息如下：\" << endl;\n                    cout << \"姓名：\" << (*it).s_name << \"\\t学号：\" << (*it).s_id << \"\\t语文成绩：\" << (*it).y_score << \"\\t数学成绩：\" << (*it).s_score << \"\\t英语成绩：\" << (*it).e_score << \"\\t总成绩：\" << (*it).s_total << endl;\n                    system(\"pause\");\n                    system(\"cls\");\n                    goto aaa;\n                }\n            }\n            cout << \"查无此人！\" << endl;\n            system(\"pause\");\n            system(\"cls\");\n            break;\n        }\n        default:\n        {\n            goto bbb;\n        }\n        }\n\n    }\nbbb:\n    return 0;\n}\n```\n\n","tags":["C++"]},{"title":"糖果机","url":"/2022/12/11/3/","content":"\n```\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<windows.h>\n\nusing namespace std;\n\nclass Users {\nprivate:\n\tmap<string, string> m;\npublic:\n\tUsers()\n\t{\n\t\tm[\"Administrator\"] = string(\"114514\");\n\t}\n\n\tbool check(string username, string password)\n\t{\n\t\tauto it = m.find(username);\n\t\tif (it == m.end())\n\t\t\treturn false;\n\t\tif (it->second != password)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tbool login()\n\t{\n\t\tputs(\"输入用户名:\");\n\t\tstring uname;\n\t\tcin >> uname;\n\t\tputs(\"输入密码:\");\n\t\tstring passw;\n\t\tcin >> passw;\n\t\tif (!check(uname, passw))\n\t\t{\n\t\t\tputs(\"用户名或密码错误\");\n\t\t\tSleep(600);\n\t\t\treturn false;\n\t\t}\n\t\tputs(\"登录成功\");\n\t\tSleep(600);\n\t\tsystem(\"cls\");\n\t\treturn true;\n\t}\n}users;\n\nclass CandyList {\nprivate:\n\tmap<string, int> list;//名字到id的映射\n\tvector<string> nameList;\npublic:\n\tCandyList()\n\t{\n\t\tnameList.resize(1);\n\t}\n\n\tint queryId(string name)//传入名字，返回id，不存在返回0\n\t{\n\t\tauto it = list.find(name);\n\t\tif (it != list.end())\n\t\t\treturn it->second;\n\t\treturn 0;\n\t}\n\n\tstring queryName(int id)//传入ID 返回名字\n\t{\n\t\tif (id > nameList.size())\n\t\t\treturn string(\"\");\n\t\treturn nameList[id];\n\t}\n\n\tint addCandyKind(string name)//无论有没有，都返回id\n\t{\n\t\tint id = queryId(name);\n\t\tif (id)\n\t\t\treturn id;\n\t\tid = list.size() + 1;\n\t\tlist[name] = id;\n\t\tnameList.push_back(name);\n\t\treturn id;\n\t}\n}candyList;\n\nclass Store {//仓库\nprivate:\n\tvector<pair<int, int> > s; //数量、单价\n\tint sum;\npublic:\n\tStore()\n\t{\n\t\ts.clear();\n\t\ts.resize(100);\n\t\tsum = 0;\n\t}\n\tint getSum()\n\t{\n\t\treturn sum;\n\t}\n\n\tint getPrice(int id)\n\t{\n\t\treturn s[id].second;\n\t}\n\n\tvoid displayCandy()\n\t{\n\t\tcout << \"编号\\t品名\\t剩余数量 单价\" << endl;\n\t\tfor (int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\tif (s[i].first > 0)\n\t\t\t{\n\t\t\t\tcout << i << \"\\t\" << candyList.queryName(i) << \"\\t\" << s[i].first << \"\\t \" << s[i].second << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid addCandy(string name, int num, int price = -1)\n\t{\n\t\tbool ok = 1;\n\t\tif (num < 1)\n\t\t\tok = 0, puts(\"数量错误\");\n\t\tif (price < -1 || price == 0)\n\t\t\tok = 0, puts(\"价格错误\");\n\t\tif (!ok)\n\t\t\treturn;\n\t\tint id = candyList.addCandyKind(name);\n\t\ts[id].first += num;\n\t\tsum += num;\n\t\tif (~price)\n\t\t\ts[id].second = price;//更新价格\n\t}\n\n\tint rmCandy(int id, int num, int pay)//卖糖\n\t{\n\t\tif (!id)\n\t\t{\n\t\t\tputs(\"编号错误！\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (s[id].first < num)\n\t\t{\n\t\t\tputs(\"数量不足\");\n\t\t\treturn 0;\n\t\t}\n\t\tint totPrice = num * s[id].second;\n\t\tif (pay < totPrice)\n\t\t{\n\t\t\tputs(\"钱不够\");\n\t\t\treturn -1;\n\t\t}\n\t\ts[id].first -= num;\n\t\tsum -= num;\n\t\treturn pay - totPrice;\n\t}\n}store;\n\nclass Show {//前端\nprivate:\n\tinline void read(int& x)\n\t{\n\t\tint s = 0, w = 1;\n\t\tchar ch = getchar();\n\t\twhile (ch < '0' || ch > '9')\n\t\t{\n\t\t\tif (ch == '-')\n\t\t\t\tw = -1;\n\t\t\tch = getchar();\n\t\t}\n\t\twhile (ch >= '0' && ch <= '9')\n\t\t\ts = s * 10 + ch - '0', ch = getchar();\n\t\tx = s * w;\n\t}\n\npublic:\n\tShow()\n\t{\n\t\tstore.addCandy(string(\"白砂糖\"), 10, 10);\n\t}\n\tvoid run()\n\t{\n\t\tprintf(\"启动中\");\n\t\tfor (int i = 0; i < 5; i++)\n\t\t{\n\t\t\tSleep(100);\n\t\t\tprintf(\".\");\n\t\t}\n\t\twhile (1)\n\t\t{\n\t\taa:\n\t\t\tsystem(\"cls\");\n\t\t\tif (store.getSum())\n\t\t\t\tprintf(\"营业中!\\n买糖请输入1\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"缺货 暂停营业！\\n\");\n\t\t\tputs(\"加糖请输入2\\n退出系统输入3\");\n\t\t\tint type = 0;\n\t\t\t//read(type);//提高容错性\n\t\t\tcin >> type;\n\t\t\tswitch (type)\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t{\n\t\t\t\tcout << \"欢迎光临！\" << endl;\n\t\t\t\tstore.displayCandy();\n\t\t\t\tputs(\"输入编号：\");\n\t\t\t\tint id;\n\t\t\t\tread(id);\n\t\t\t\tputs(\"输入数量：\");\n\t\t\t\tint num;\n\t\t\t\tread(num);\n\t\t\t\tputs(\"请付款：\");\n\t\t\t\tint pay;\n\t\t\t\tread(pay);\n\t\t\t\tint temp = store.rmCandy(id, num, pay);\n\t\t\t\tif (temp > 0)\n\t\t\t\t\tcout << \"给你找零:\" << temp << endl << \"\\n欢迎下次光临！\";\n\t\t\t\telse if (temp == 0)\n\t\t\t\t\tcout << \"交易成功 欢迎下次光临！\" << endl;\n\t\t\t\tSleep(1000);\n\t\t\t\tsystem(\"cls\");\n\t\t\t\tgoto aa;\n\t\t\t}\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\tif (!users.login())\n\t\t\t\t\tcontinue;\n\t\t\t\tputs(\"请输入品名\");\n\t\t\t\tstring name;\n\t\t\t\tcin >> name;\n\t\t\t\tint id = candyList.queryId(name);//不存在这个糖 id==0\n\t\t\t\tputs(\"请输入数量\");\n\t\t\t\tint num, price;\n\t\t\t\tbool transPrice = 0;\n\t\t\t\tread(num);\n\t\t\t\tif (!id)\n\t\t\t\t\tputs(\"输入定价(分/个)\"), read(price), transPrice = 1;\n\t\t\t\tif (transPrice)\n\t\t\t\t\tstore.addCandy(name, num, price);\n\t\t\t\telse\n\t\t\t\t\tstore.addCandy(name, num);\n\t\t\t\tgoto aa;\n\t\t\t}\n\t\t\tcase 3:\n\t\t\t{\n\t\t\t\tgoto flag;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tcout << \"输入错误！请重新输入！\" << endl;\n\t\t\t\tSleep(1000);\n\t\t\t\tgoto aa;\n\t\t\t}\n\t\t\t}\n\t\tflag:\n\t\t\tcout << \"正在退出\";\n\t\t\tfor (int i = 0; i < 5; i++)\n\t\t\t{\n\t\t\t\tSleep(100);\n\t\t\t\tprintf(\".\");\n\t\t\t}\n\t\t\tcout << \"\\n已退出！再见！\" << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n};\n\nint main()\n{\n\tShow machine;\n\tmachine.run();\n\tsystem(\"pause\");\n}\n```\n\n","tags":["C++"]},{"title":"打印玫瑰花","url":"/2022/12/11/2/","content":"\n```\n#include <stdio.h>\n#include <math.h>\n\nconst int max_iterations = 128;\nconst float stop_threshold = 0.01f;\nconst float grad_step = 0.01f;\nconst float clip_far = 10.0f;\n\nconst float PI = 3.14159265359f;\nconst float PI2 = 6.28318530718f;\nconst float DEG_TO_RAD = PI / 180.0f;\n\ntypedef struct { float x, y; } vec2;\ntypedef struct { float x, y, z; } vec3;\ntypedef struct { float m[9]; } mat3;\n\nconst vec3 light_pos = { 20.0f, 50.0f, 20.0f };\n\nfloat min(float a, float b) { return a < b ? a : b; }\nfloat max(float a, float b) { return a > b ? a : b; }\nfloat clamp(float f, float a, float b) { return max(min(f, b), a); }\nvec2 make2(float x, float y) { vec2 r = { x, y }; return r; }\nvec2 add2(vec2 a, vec2 b) { vec2 r = { a.x + b.x, a.y + b.y }; return r; }\nvec2 sub2(vec2 a, vec2 b) { vec2 r = { a.x - b.x, a.y - b.y }; return r; }\nfloat dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat length2(vec2 v) { return sqrt(dot2(v, v)); }\nvec3 make3(float x, float y, float z) { vec3 r = { x, y, z }; return r; }\nvec3 add3(vec3 a, vec3 b) { vec3 r = { a.x + b.x, a.y + b.y, a.z + b.z }; return r; }\nvec3 sub3(vec3 a, vec3 b) { vec3 r = { a.x - b.x, a.y - b.y, a.z - b.z }; return r; }\nvec3 mul3(vec3 a, vec3 b) { vec3 r = { a.x * b.x, a.y * b.y, a.z * b.z }; return r; }\nvec3 scale3(vec3 v, float s) { vec3 r = { v.x * s, v.y * s, v.z * s }; return r; }\nfloat dot3(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat length3(vec3 v) { return sqrt(dot3(v, v)); }\nvec3 normalize3(vec3 v) { return scale3(v, 1.0f / length3(v)); }\nvec3 mul(mat3 m, vec3 v) {\n    return make3(\n        m.m[0] * v.x + m.m[3] * v.y + m.m[6] * v.z,\n        m.m[1] * v.x + m.m[4] * v.y + m.m[7] * v.z,\n        m.m[2] * v.x + m.m[5] * v.y + m.m[8] * v.z);\n}\n\nmat3 rotationXY(float x, float y) {\n    vec2 c = { cos(x), cos(y) }, s = { sin(x), sin(y) };\n    mat3 m = {\n        c.y      , 0.0f, -s.y,\n        s.y * s.x,  c.x,  c.y * s.x,\n        s.y * c.x, -s.x,  c.y * c.x\n    };\n    return m;\n}\n\nfloat opI(float d1, float d2) { return max(d1, d2); }\nfloat opU(float d1, float d2) { return min(d1, d2); }\nfloat opS(float d1, float d2) { return max(-d1, d2); }\n\nfloat sdPetal(vec3 p, float s) {\n    p = add3(mul3(p, make3(0.8f, 1.5f, 0.8f)), make3(0.1f, 0.0f, 0.0f));\n    vec2 q = make2(length2(make2(p.x, p.z)), p.y);\n\n    float lower = length2(q) - 1.0f;\n    lower = opS(length2(q) - 0.97f, lower);\n    lower = opI(lower, q.y);\n\n    float upper = length2(sub2(q, make2(s, 0.0f))) + 1.0f - s;\n    upper = opS(upper, length2(sub2(q, make2(s, 0.0f))) + 0.97f - s);\n    upper = opI(upper, -q.y);\n    upper = opI(upper, q.x - 2.0f);\n\n    float region = length3(sub3(p, make3(1.0f, 0.0f, 0.0f))) - 1.0f;\n    return opI(opU(upper, lower), region);\n}\n\nfloat map(vec3 p) {\n    float d = 1000.0f, s = 2.0f;\n    mat3 r = rotationXY(0.1f, PI2 * 0.618034f);\n    r.m[0] *= 1.08f;  r.m[1] *= 1.08f;  r.m[2] *= 1.08f;\n    r.m[3] *= 0.995f; r.m[4] *= 0.995f; r.m[5] *= 0.995f;\n    r.m[6] *= 1.08f;  r.m[7] *= 1.08f;  r.m[8] *= 1.08f;\n    for (int i = 0; i < 21; i++) {\n        d = opU(d, sdPetal(p, s));\n        p = mul(r, p);\n        p = add3(p, make3(0.0, -0.02, 0.0));\n        s *= 1.05f;\n    }\n    return d;\n}\n\nvec3 gradient(vec3 pos) {\n    const vec3 dx = { grad_step, 0.0, 0.0 };\n    const vec3 dy = { 0.0, grad_step, 0.0 };\n    const vec3 dz = { 0.0, 0.0, grad_step };\n    return normalize3(make3(\n        map(add3(pos, dx)) - map(sub3(pos, dx)),\n        map(add3(pos, dy)) - map(sub3(pos, dy)),\n        map(add3(pos, dz)) - map(sub3(pos, dz))));\n}\n\nfloat ray_marching(vec3 origin, vec3 dir, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < max_iterations; i++) {\n        float dist = map(add3(origin, scale3(dir, depth)));\n        if (dist < stop_threshold)\n            return depth;\n        depth += dist * 0.3;\n        if (depth >= end)\n            return end;\n    }\n    return end;\n}\n\nfloat shading(vec3 v, vec3 n, vec3 eye) {\n    vec3 ev = normalize3(sub3(v, eye));\n    vec3 vl = normalize3(sub3(light_pos, v));\n    float diffuse = dot3(vl, n) * 0.5f + 0.5f;\n    vec3 h = normalize3(sub3(vl, ev));\n    float rim = pow(1.0f - max(-dot3(n, ev), 0.0f), 2.0f) * 0.15f;\n    float ao = clamp(v.y * 0.5f + 0.5f, 0.0f, 1.0f);\n    return (diffuse + rim) * ao;\n}\n\nvec3 ray_dir(float fov, vec2 pos) {\n    vec3 r = { pos.x, pos.y, -tan((90.0f - fov * 0.5f) * DEG_TO_RAD) };\n    return normalize3(r);\n}\n\nfloat f(vec2 fragCoord) {\n    vec3 dir = ray_dir(45.0f, fragCoord);\n    vec3 eye = { 0.0f, 0.0f, 4.5f };\n    mat3 rot = rotationXY(-1.0f, 1.0f);\n\n    dir = mul(rot, dir);\n    eye = mul(rot, eye);\n\n    float depth = ray_marching(eye, dir, 0.0f, clip_far);\n    vec3 pos = add3(eye, scale3(dir, depth));\n    if (depth >= clip_far)\n        return 0.0f;\n    else\n        return shading(pos, gradient(pos), eye);\n}\n\nint main() {\n    puts(\"\\033[91m\");\n    for (int y = 0; y < 80; y++) {\n        for (int x = 0; x < 160; x++)\n            putchar(\"  .,-:;+=*#@\"[(int)(f(make2((x / 160.0f - 0.5f) * 2.0f, (y / 80.0f - 0.5f) * -2.0f)) * 12.0f)]);\n        putchar('\\n');\n    }\n}\n```\n\n","tags":["C++"]},{"title":"ATM机","url":"/2022/12/11/1/","content":"\n```\n#include <string>\n#include <iostream>\n#include <vector>\n#include <Windows.h>\n#include <stdlib.h>\n#include <fstream>\n#include <ctime>\n\nusing namespace std;\n\nclass Account\n{\npublic:\n    string name;//姓名\n    int accountNumber = 0;//账号\n    int pinNumber = 0;//密码\n    int balance = 0;//余额\npublic:\n    bool welcome();//初始界面\n    void show();//打印菜单\n    void deposit();//存款\n    void withdrawal();//取款\n    void tran();//转账\n    void change();//修改密码\n    void getbalance();//查询余额\n    void print();//打印账号信息\n};\n\nvector<Account> account;\nAccount ATM;\nvector<Account>::iterator atm;\n\nvoid wait() {\n    int a = getchar();\n    a = getchar();\n}\n\nvoid keep() {\n    ofstream ofs(\"ATM.txt\");\n    if (ofs.is_open()) {\n        vector<Account>::iterator it;\n        for (it = account.begin(); it != account.end(); it++) {\n            ofs << it->name << \"\\t\" << it->accountNumber << \"\\t\" << it->pinNumber << \"\\t\" << it->balance << \"\\t\" << endl;\n        }\n        ofs.close();\n    }\n}\n\nvoid open() {\n    ifstream ifs(\"ATM.txt\");\n    if (ifs.is_open()) {\n        cout << \"文件打开成功！\" << endl;\n        system(\"cls\");\n        Account a;\n        while (ifs >> a.name >> a.accountNumber >> a.pinNumber >> a.balance) {\n            account.push_back(a);\n        }\n        ifs.close();\n    }\n    else {\n        cout << \"文件不存在！\" << endl;\n    }\n}\n\nbool Account::welcome() {\n    Account temp;\n    cout << \"欢迎使用！\\n请选择操作：\\n 1、登录\\n 2、开户\\n 3、退出\" << endl;\n    int a;\n    cin >> a;\n    system(\"cls\");\n    switch (a)\n    {\n    case 1: {\n        if (account.begin() == account.end()) {\n            cout << \"没有账号，无法登录！\" << endl;\n            wait();\n            return false;\n        }\n        else {\n            cout << \"请输入账号：\" << endl;\n            cin >> temp.accountNumber;\n            for (vector<Account>::iterator it = account.begin(); it != account.end(); it++) {\n                if (it->accountNumber == temp.accountNumber) {\n                    cout << \"请输入密码：\" << endl;\n                    cin >> temp.pinNumber;\n                    if (it->pinNumber == temp.pinNumber) {\n                        atm = it;\n                        cout << \"登陆成功！\" << endl;\n                        wait();\n                        return true;\n                    }\n                    else {\n                        cout << \"密码错误，无法登录！\" << endl;\n                        wait();\n                        return false;\n                    }\n                }\n            }\n            cout << \"账号不存在！\" << endl;\n            return false;\n        }\n    }\n    case 2: {\n        cout << \"请输入姓名：\" << endl;\n        cin >> temp.name;\n        cout << \"请输入密码：\" << endl;\n        cin >> temp.pinNumber;\n        srand(unsigned int(time(0)));\n        srand(temp.pinNumber + rand());\n        temp.accountNumber = rand() * 10000000 % 10000000 + 60000000;\n        cout << \"开户成功，您的账号为：\" << temp.accountNumber << endl;\n        account.push_back(temp);\n        wait();\n        return false;\n        break;\n    }\n    case 3: {\n        keep();\n        cout << \"感谢使用，再见！\" << endl;\n        exit(0);\n    }\n    default:return false; break;\n    }\n}\n\nvoid Account::show() {\n    system(\"cls\");\n    cout << \"请选择你需要的服务\" << endl;\n    cout << \"1、存款\" << endl;\n    cout << \"2、取款\" << endl;\n    cout << \"3、转账\" << endl;\n    cout << \"4、查询余额\" << endl;\n    cout << \"5、修改密码\" << endl;\n    cout << \"6、显示账号信息\" << endl;\n    cout << \"7、退出\" << endl;\n}\n\nvoid Account::deposit() {\n    int temp;\n    cout << \"请输入存款金额：\" << endl;\n    cin >> temp;\n    atm->balance += temp;\n    cout << \"存款成功！\" << endl;\n}\n\nvoid Account::withdrawal() {\n    cout << \"请输入取款金额：\" << endl;\n    int temp;\n    cin >> temp;\n    if (temp > atm->balance)\n        cout << \"余额不足！\" << endl;\n    else\n        atm->balance -= temp;\n    cout << \"成功！\" << endl;\n}\n\nvoid Account::tran() {\n    Account temp;\n    cout << \"请输入对方账户：\" << endl;\n    cin >> temp.accountNumber;\n    for (vector<Account>::iterator it = account.begin(); it != account.end(); it++) {\n        if (temp.accountNumber == it->accountNumber)\n        {\n            int a;\n            cout << \"请输入转账金额：\" << endl;\n            cin >> a;\n            if (a < atm->balance && a > 0) {\n                atm->balance -= a;\n                it->balance += a;\n                cout << \"转账成功！\" << endl;\n                return;\n            }\n            else if (a > atm->balance) {\n                cout << \"余额不足！\" << endl;\n                return;\n            }\n            else {\n                cout << \"输入错误！\" << endl;\n                return;\n            }\n        }\n    }\n    cout << \"账户不存在！\" << endl;\n    return;\n}\n\nvoid Account::change() {\n    cout << \"请输入新密码\" << endl;\n    cin >> atm->pinNumber;\n    cout << \"修改成功！\" << endl;\n}\n\nvoid Account::getbalance() {\n    cout << \"余额为：\" << atm->balance << endl;\n}\n\nvoid Account::print() {\n    cout << \"姓名：\" << atm->name << endl;\n    cout << \"账户名：\" << atm->accountNumber << endl;\n    cout << \"余额：\" << atm->balance << endl;\n}\n\nint main() {\n    open();\naaa:\n    system(\"cls\");\n    bool b = ATM.welcome();\n    while (b) {\n        int a;\n        ATM.show();\n        cin >> a;\n        switch (a) {\n        case 1:system(\"cls\"); (*atm).deposit(); wait(); break;\n        case 2:system(\"cls\"); (*atm).withdrawal(); wait(); break;\n        case 3:system(\"cls\"); (*atm).tran(); wait(); break;\n        case 4:system(\"cls\"); (*atm).getbalance(); wait(); break;\n        case 5:system(\"cls\"); (*atm).change(); wait(); break;\n        case 6:system(\"cls\"); (*atm).print(); wait(); break;\n        case 7:system(\"cls\"); keep(); cout << \"感谢使用，再见！\" << endl; b = false; break;\n        default:break;\n        }\n    }\n    goto aaa;\n}\n```\n\n","tags":["C++"]}]