[{"title":"实验二","url":"/2023/05/06/24/","content":"\n# 实验二\n\n## 任务一\n\n- 定义一个视图，包括定单的编号、时间、金额以及收货人的姓名、国家代码和国家名称。\n\n  ```\n  CREATE VIEW OCS (orderNo, orderTime, orderCost, reciName, CountryID, CountryName)\n  AS SELECT Orders.cOrderNo, dOrderDate, mTotalCost, vFirstName+' '+vLastName, Country.cCountryID, cCountry\n  FROM Orders\n  LEFT OUTER JOIN Recipient\n  ON Orders.cOrderNo = Recipient.cOrderNo\n  LEFT OUTER JOIN Country\n  ON Recipient.cCountryId = Country.cCountryId;\n  ```\n\n- 基于（1）中定义的视图，查询所有国家代码为‘001’的收货人的姓名和他们所下定单的笔数及定单的总金额。\n\n  ```\n  SELECT reciName, CountryID, CountryName, count(*) TotalOrders, sum(orderCost) SumOrdercost\n  FROM OCS\n  GROUP BY reciName, CountryName, CountryID\n  HAVING CountryID = '001';\n  \n  ```\n\n- 视图定义如下：\n\n  ```\n  CREATE VIEW vwOrderWrapper\n     AS\n     SELECT cOrderNo, cToyId, siQty, vDescription, mWrapperRate\n     FROM OrderDetail JOIN Wrapper\n     ON OrderDetail.cWrapperId = Wrapper.cWrapperId\n  ```\n\n  执行以下更新命令并分析该命令的执行结果。\n\n  ```\n  UPDATE vwOrderWrapper\n     SET siQty = 2, mWrapperRate = mWrapperRate + 1 \n     WHERE cOrderNo = ‘000001’\n  ```\n\n​\t\t运行结果：视图或函数 'vwOrderWrapper' 不可更新，因为修改会影响多个基表。\n\n​\t\t原因：该视图与两个表相关联\n\n## 任务二\n\n- 在OrderDetail上定义一个触发器，当向OrderDetail表中新增一条记录时，自动修改Toys表中玩具的库存数量（siToyQoh）。\n\n  ```\n  CREATE TRIGGER UpdateSiToyQoh ON OrderDetail\n      AFTER INSERT\n      AS\n          UPDATE Toys\n          SET siToyQoh = siToyQoh - 1\n          WHERE cToyId IN (SELECT cToyId FROM inserted);\n  ```\n\n  测试语句\n\n  ```\n  INSERT INTO OrderDetail VALUES ('000001', '000009', 2, 'N', NULL, NULL, 38.8800);\n  DELETE OrderDetail WHERE cOrderNo = '000001' AND cToyId = '000009';\n  ```\n\n- Orders表是GlobalToyz数据库里的一张核心的表，对这张表上做的任何更新动作（增、删、改）都需要记录下来，这是数据库审计（Audit）的基本思想。要求设计一张表存储对Orders表的更新操作，包括操作者、操作时间、操作类型、更新前的数据、更新后的数据。设计触发器实现对Orders表的审计。\n\n  ```\n  CREATE TABLE Audit(\n      Operator VARCHAR(10),\n      OperateTime DATETIME,\n      OperateWay CHAR(6),\n      OldData VARCHAR(100),\n      NewData VARCHAR(100)\n  )\n  \n  CREATE TRIGGER AuditOrders ON Orders\n      FOR INSERT, DELETE, UPDATE\n      AS BEGIN\n              DECLARE @oper VARCHAR(30) = SYSTEM_USER\n              DECLARE @operTime DATETIME = GETDATE()\n              DECLARE @opway CHAR(6) \n              DECLARE @del INT = (SELECT COUNT(*) FROM deleted)\n              DECLARE @ins INT = (SELECT COUNT(*) FROM inserted)\n              IF @del != 0\n                  IF @ins != 0\n                      SELECT @opway = 'UPDATE'\n                  ELSE\n                      SELECT @opway = 'DELETE'\n              ELSE\n                  SELECT @opway = 'INSERT'\n              DECLARE @olddata VARCHAR(100);\n              DECLARE @newdata VARCHAR(100);\n              SELECT @olddata = (SELECT cOrderNo + CAST(dOrderDate AS VARCHAR(23)) + cCartId +\n                                 cShopperId + cShippingModeId + str(mShippingCharges) +\n                                 str(mGiftWrapCharges) + cOrderProcessed +\n                                 str(mTotalCost) + CAST(dExpDelDate AS VARCHAR(23))\n                          FROM deleted) \n              SELECT @newdata = (SELECT cOrderNo + CAST(dOrderDate AS VARCHAR(23)) + cCartId +\n                                 cShopperId + cShippingModeId + str(mShippingCharges) +\n                                 str(mGiftWrapCharges) + cOrderProcessed +\n                                 str(mTotalCost) + CAST(dExpDelDate AS VARCHAR(23))\n                          FROM inserted) \n              INSERT INTO Audit values (@oper, @operTime, @opway, @olddata, @newdata);\n      END\n  --测试语句\n  INSERT INTO Orders VALUES ('000011', GETDATE(), '000005', '000007', '03', 21, 2, 'Y', 59, GETDATE());\n  UPDATE Orders\n      SET cCartId = '000008'\n      WHERE cOrderNo = '000011'\n  DELETE Orders WHERE cOrderNo = '000011';\n  ```\n\n## 任务三\n\n- 修改表ShoppingCart的结构，在表中新增一个字段‘Status’。该字段取值为1，表示该玩具为本次下订单时要购买的玩具。在表ShoppingCart中生成一些模拟数据。\n\n  ```\n  ALTER TABLE ShoppingCart\n  ADD\n      Status INT CHECK (Status = 0 OR Status = 1) DEFAULT 0;\n      \n  UPDATE ShoppingCart\n  SET Status = (SELECT CAST(FLOOR(RAND(convert(varbinary, newid())) * 2) AS INT))\n  ```\n\n- 当购物者确认定单时，应该包含下面的步骤：\n\n  > 产生新的定单号。\n  >\n  > 定单号，当前日期，购物车ID，和购物者ID加到Orders表中。\n  >\n  > 定单号，玩具ID和数量加到OrderDetail表中。\n  >\n  > 在OrderDetail表中更新玩具成本。（提示：Toy cost = Quantity * Toy Rate）。\n  >\n  > 从ShoppingCart表中将本次已购买的玩具删除。\n\n​\t\t将上述步骤定义为一个事务。编写一个存储过程以购物车ID（cCartId）和购物者ID(cShopperId)为参数，实现这个事务。用在第\t\t（1）题中生成的模拟数据测试存储过程。\n\n```\nCREATE PROCEDURE P\n(\n    @cCartID CHAR(6),\n    @cShopperID CHAR(6)\n)\nAS\n    BEGIN\n        BEGIN TRANSACTION\n            DECLARE @ret INT = 0;\n            DECLARE @ordno CHAR(6) = RIGHT('000000'+CONVERT(CHAR(2),(SELECT max(CAST(cOrderNo AS INT)) FROM Orders) + 1), 6);\n            DECLARE @orddate DATETIME = GETDATE()\n            DECLARE @shipmod CHAR(2) = RIGHT('00'+CONVERT(VARCHAR, CEILING(RAND(convert(varbinary, newid())) * 3)), 2);\n            DECLARE @shipcharge money = CAST(CEILING(RAND(convert(varbinary, newid())) * 90) AS MONEY)\n            DECLARE @num INT = (SELECT COUNT(*) FROM ShoppingCart WHERE cCartId = @cCartID AND Status = 1)\n            IF @num != 0\n                BEGIN\n                    INSERT INTO Orders VALUES\n                    (@ordno, @orddate, @cCartID, @cShopperID, @shipmod, @shipcharge, NULL, 'Y', NULL, @orddate)\n                    DECLARE @ctoyID CHAR(6), @siqty SMALLINT;\n                    DECLARE cursor_temp CURSOR LOCAL SCROLL FOR\n                    (SELECT cToyId, siQty FROM ShoppingCart WHERE cCartId = @cCartID AND Status = 1)\n                    OPEN cursor_temp\n                    FETCH FIRST FROM cursor_temp INTO @ctoyID, @siqty;\n                    WHILE(@@fetch_status = 0)\n                        BEGIN\n                            INSERT INTO OrderDetail VALUES\n                            (@ordno, @ctoyID, @siqty, 'N', NULL, NULL, NULL)\n                            UPDATE OrderDetail\n                            SET mToyCost = siQty * (SELECT mToyRate FROM Toys WHERE Toys.cToyId = @ctoyID)\n                            WHERE cOrderNo = @ordno;\n                            DELETE FROM ShoppingCart\n                            WHERE cToyId = @ctoyID AND cCartId = @cCartID;\n                            FETCH NEXT FROM cursor_temp INTO @ctoyID, @siqty;\n                        END\n                    CLOSE cursor_temp\n                    DEALLOCATE cursor_temp;\n                END\n        IF @ret = 0\n            BEGIN\n                COMMIT TRANSACTION\n                PRINT N'成功更新--finished'\n            END\n        ELSE\n            BEGIN\n                ROLLBACK TRANSACTION\n                PRINT N'Status为0--rollback'\n            END\n    END\ngo\n--测试样例\nEXEC P @cCartID = '000001', @cShopperID = '000015';\nEXEC P @cCartID = '000002', @cShopperID = '000024';\n```\n\n## 任务四\n\n- 基于表Orders和Shopper，以下列格式生成报表：（要求用游标实现）\n\n  >       购货人ID   XXX    购货人姓名   XXX    \n  >       购货人地址  XXXXXX \n  >       定单号XXX  定单时间XXX  定单金额XXX\n  >       定单号XXX  定单时间XXX  定单金额XXX\n\n  ```\n  BEGIN\n      DECLARE @sid CHAR(6), @sname VARCHAR(40), @sAddress VARCHAR(40), @ordno CHAR(6), @ordtime VARCHAR(100), @ordmoney MONEY\n      DECLARE cursor_1 CURSOR LOCAL SCROLL FOR\n      (SELECT Orders.cShopperId, vFirstName + vLastName AS Name, vAddress, cOrderNo, CONVERT(VARCHAR(100), dOrderDate, 120), mTotalCost\n       FROM Orders\n       LEFT OUTER JOIN Shopper\n       ON Orders.cShopperId = Shopper.cShopperId)\n      OPEN cursor_1\n      FETCH FIRST FROM cursor_1 INTO @sid, @sname, @sAddress, @ordno, @ordtime, @ordmoney;\n      PRINT N'订单报表如下:'\n      WHILE (@@fetch_status = 0)\n          BEGIN\n              PRINT N'购货人ID： ' + @sid + CHAR(9) + N'购货人姓名： ' + @sname;\n              PRINT N'购货人地址： ' + @sAddress;\n              PRINT N'订单号： ' + @ordno + N'  订单时间：' + @ordtime + N'  订单金额：' + convert(varchar(10),@ordmoney);\n              FETCH NEXT FROM cursor_1 INTO @sid, @sname, @sAddress, @ordno, @ordtime, @ordmoney;\n          END\n      CLOSE cursor_1\n      DEALLOCATE cursor_1;\n  END\n  ```\n\n- 编写代码，分析玩具和地域的关系，例如哪个城市的购买者对哪一种、哪一类或哪一个品牌的玩具更有兴趣。这道题是个开放的题目，同学们可以按照自己的理解从不同的角度进行分析。实验报告中需给出代码、结果截图和对分析结果的文字描述。\n\n  ```\n  SELECT cCity, cToyId INTO ##T1 FROM Orders\n  LEFT OUTER JOIN OrderDetail\n  ON Orders.cOrderNo = OrderDetail.cOrderNo\n  LEFT OUTER JOIN Shopper\n  ON Orders.cShopperId = Shopper.cShopperId\n  \n  SELECT cCity, ##T1.cToyId, cBrandId, cCategoryId  INTO ##T2 FROM ##T1\n  LEFT OUTER JOIN Toys\n  ON ##T1.cToyId = Toys.cToyId\n  WHERE vToyName IS NOT NULL;\n  \n  SELECT cCity AS N'城市', cBrandName AS N'品牌', COUNT(cBrandName) AS N'总计'\n  INTO ##T3\n  FROM ##T2\n  LEFT OUTER JOIN ToyBrand ON\n  ##T2.cBrandId = ToyBrand.cBrandId\n  GROUP BY cBrandName, cCity\n  \n  --测试案例\n  SELECT TOP 3 城市, 品牌, 总计 FROM ##T3 WHERE 总计 > 1;\n  ```\n","tags":["SQL Server"]},{"title":"实验一","url":"/2023/05/06/23/","content":"\n# 实验一\n\n## 任务一\n\n- 创建一张表Orders_Jan，表的结构与Orders相同，将Orders表中month为‘Jan’的订单记录复制到表Orders_Jan中。\n\n  ```\n  SELECT * \n  INTO Orders_Jan \n  FROM ORDERS \n  WHERE month = 'Jan';\n  ```\n\n- 将Orders表中month为‘Jan’的订单记录全部删掉。\n\n  ```\n  DELETE FROM ORDERS WHERE month = 'Jan';\n  ```\n\n- 对曾经下过金额（dollars）大于500的订单的客户，将其discnt值增加2个百分点（+2）。\n\n  ```\n  UPDATE CUSTOMERS \n  SET discnt = discnt + 2\n  WHERE cid \n  IN (SELECT cid FROM ORDERS WHERE dollars > 500);\n  ```\n\n- 写一段TSQL程序，向表Orders中增加5000条记录，要求订单尽可能均匀地分布在12个月中。\n\n  ```\n  DECLARE @i INT = 1\n  DECLARE @maxm INT;\n  SELECT @maxm = max(ordno) FROM ORDERS /*获取表单中最大值*/\n  WHILE @i <= 5000\n  BEGIN\n      DECLARE @newno INT = @maxm + @i;\n      DECLARE @newmon INT;\n      SELECT @newmon = (SELECT CAST(CEILING(RAND() * 12) AS INT))\n      DECLARE @strnewmon VARCHAR(4);\n      SELECT @strnewmon =\n             CASE\n                 WHEN @newmon = 1 THEN 'Jan'\n                 WHEN @newmon = 2 THEN 'Feb'\n                 WHEN @newmon = 3 THEN 'Mar'\n                 WHEN @newmon = 4 THEN 'Apr'\n                 WHEN @newmon = 5 THEN 'May'\n                 WHEN @newmon = 6 THEN 'Jun'\n                 WHEN @newmon = 7 THEN 'Jul'\n                 WHEN @newmon = 8 THEN 'Aug'\n                 WHEN @newmon = 9 THEN 'Sep'\n                 WHEN @newmon = 10 THEN 'Oct'\n                 WHEN @newmon = 11 THEN 'Nov'\n                 WHEN @newmon = 12 THEN 'Dec'\n              END\n      DECLARE @newcid VARCHAR(4);\n      SELECT @newcid = 'C' + (SELECT CAST(CEILING(RAND() * 500) AS VARCHAR(3)))\n      DECLARE @newqty INT;\n      SELECT @newqty = (SELECT CAST(floor(RAND() * 1000) AS INT))\n      DECLARE @newdollars DECIMAL(10, 2);\n      SELECT @newdollars = (SELECT CAST(ceiling(RAND() * 1000) AS DECIMAL(10,2)))\n      INSERT INTO ORDERS (ordno, month, cid, qty, dollars)\n      values (@newno, @strnewmon, @newcid, @newqty, @newdollars);\n      SELECT @i = @i + 1;\n  END\n  ```\n\n- 在表Orders的’month’字段上建立索引。\n\n  ```\n  CREATE INDEX MONTH_INDEX ON ORDERS(month(50));\n  ```\n\n- 创建一个视图order_month_summary，视图中的字段包括月份、该月的订单总量和该月的订单总金额。基于视图order_month_summary，查询第一季度各个月份的订单总量和订单总金额。\n\n  ```\n  CREATE VIEW order_month__summary (month, countorders, sumdollars)\n  AS SELECT month, count(*), sum(dollars)\n     FROM ORDERS\n     GROUP BY month\n     HAVING month = 'Jan' or month = 'Feb' or month = 'Jun'\n     COLLATE Chinese_PRC_CI_AI;\n  ```\n\n## 任务二\n\n- 查找属于California和Florida州的顾客的名、姓和emailID。\n\n  ```\n  SELECT vFirstName, vLastName, vEmailId\n  FROM Shopper\n  WHERE cShopperId IN (SELECT cShopperId FROM Orders) \n    AND (cState = 'California' or cState = 'Florida');\n  ```\n\n- 查找定单号码、顾客ID，定单的总价值，并以定单的总价值的升序排列。\n\n  ```\n  SELECT cOrderNo, cShopperId, mTotalCost \n  FROM Orders \n  ORDER BY mTotalCost;\n  ```\n\n- 查找在orderDetail表中vMessage为空值的行。\n\n  ```\n  SELECT * \n  FROM OrderDetail \n  WHERE vMessage IS NULL ;\n  ```\n\n- 查找玩具名字中有“Racer”字样的所有玩具的基本资料。\n\n  ```\n  SELECT * \n  FROM Toys \n  WHERE vToyName LIKE '%Racer%';\n  ```\n\n- 根据2016年的玩具销售总数，查找“Pick of the Month”玩具的前五名玩具的ID。\n\n  ```\n  SELECT cToyId \n  FROM PickOfMonth \n  GROUP BY cToyId \n  ORDER BY sum(iTotalSold)\n  LIMIT 5;\n  ```\n\n- 根据OrderDetail表，查找玩具总价值大于￥50的定单的号码和玩具总价值。\n\n  ```\n  SELECT cOrderNo, mToyCost \n  FROM OrderDetail \n  WHERE mToyCost > 50;\n  ```\n\n- 查找一份包含所有装运信息的报表，包括：Order Number, Shipment Date, Actual Delivery Date, Days in Transit. (提示：Days in Transit = Actual Delivery Date – Shipment Date) \n\n  ```\n  SELECT cOrderNo, dShipmentDate, dActualDeliveryDate, DATEDIFF( dActualDeliveryDate , dShipmentDate ) AS DaysInTransit\n  FROM Shipment;\n  ```\n\n- 查找所有玩具的名称、商标和种类（Toy Name, Brand, Category）。\n\n  ```\n  SELECT Toys.vToyName ToyName, ToyBrand.cBrandName Brand, Category.cCategory Category\n  FROM Toys\n  LEFT OUTER JOIN ToyBrand\n  ON Toys.cBrandId = ToyBrand.cBrandId\n  LEFT OUTER JOIN Category\n  ON Toys.cCategoryId = Category.cCategoryId;\n  ```\n\n- 查找玩具的名称和所有玩具的购物车ID。如果玩具不在购物车中，也需在结果中出现。\n\n  ```\n  SELECT Toys.vToyName, ShoppingCart.cCartId\n  FROM Toys\n  LEFT OUTER JOIN ShoppingCart\n  ON Toys.cToyId = ShoppingCart.cToyId;\n  ```\n\n- 以下列格式查找所有购物者的名字和他们的简称：（Initials, vFirstName, vLastName）,例如Angela Smith的Initials为A.S。\n\n  ```\n  SELECT concat(substring(vFirstName,1,1),'.',substring(vLastName,1,1)) Initials,vFirstName,vLastName \n  FROM shopper;\n  ```\n\n- 查找所有玩具的平均价格，并舍入到整数。\n\n  ```\n  SELECT ROUND(avg(mtoyrate),0) averagerate \n  FROM toys;\n  ```\n\n- 查找所有购买者和收货人的名、姓、地址和所在城市，要求保留结果中的重复记录。\n\n  ```\n  SELECT Shopper.vFirstName BuyerFisrtName , Shopper.vLastName BuyerLastName , Shopper.vAddress BuyerAddress, Shopper.cCity BuyerCity,\n      Recipient.vFirstName ReciFirstName ,Recipient.vLastName ReciLastName,Recipient.vAddress ReciAdress, Recipient.cCity ReciCity\n  FROM Orders\n  LEFT OUTER JOIN Shopper\n  ON Orders.cShopperId = Shopper.cShopperId\n  LEFT OUTER JOIN Recipient\n  ON Orders.cOrderNo = Recipient.cOrderNo;\n  ```\n\n- 查找没有包装的所有玩具的名称。（要求用子查询实现）\n\n  ```\n  SELECT vToyName\n  FROM Toys\n  WHERE cToyId IN (SELECT cToyId\n                   FROM OrderDetail\n                   WHERE cWrapperId IS NULL);\n  ```\n\n- 查找已收货定单的定单号码以及下定单的时间。（要求用子查询实现）\n\n  ```\n  SELECT cOrderNo, dOrderDate\n  FROM Orders\n  WHERE cOrderNo IN (SELECT cOrderNo\n                     FROM Shipment\n                     WHERE dActualDeliveryDate IS NULL);\n  ```\n\n- 查找从来没有下过订单的顾客。\n\n  ```\n  SELECT *\n  FROM Shopper\n  WHERE Shopper.cShopperId NOT IN (SELECT Orders.cShopperId FROM Orders);\n  ```\n\n- 删除“Largo”牌的所有玩具。\n\n  ```\n  DELETE FROM Toys WHERE cBrandId IN\n  (SELECT cBrandId FROM ToyBrand WHERE cBrandName = 'Largo');\n  /*存在外键约束，无法删除*/\n  ```\n\n","tags":["MySQL"]},{"title":"拾","url":"/2023/04/27/22/","content":"\n# 问题一\n\n## 问题分析\n\n调研学习并给出矩阵的LU分解方法。\n\n## 调研\n\nLU分解是一种线性代数的基本算法，它将一个矩阵分解为一个下三角矩阵L和一个上三角矩阵U的乘积，即A=LU。\n\nLU分解有很多种方法，其中常用的是高斯消元法和Doolittle分解法。\n\n高斯消元法是最基本的LU分解方法之一，其主要思想是利用初等行变换将原矩阵A化为一个上三角矩阵U，然后通过反向代入得到下三角矩阵L。具体步骤如下：\n\n1. 将原矩阵A的第一列作为主元素，通过初等行变换将第一列下面的所有元素都变为0，得到第一行和新的矩阵B；\n2. 对新矩阵B的子矩阵（除去第一行和第一列）重复步骤1，直到得到上三角矩阵U；\n3. 设置下三角矩阵L的对角线为1，其他元素为对应位置上未被消元的矩阵A的元素的相反数。\n\nDoolittle分解法也是常用的LU分解方法之一，它与高斯消元法类似，但是将计算过程中的主元素选为1，使得计算更加简单。具体步骤如下：\n\n1. 将对角线元素设置为1，并将矩阵A分解为一个下三角矩阵L和一个上三角矩阵U；\n2. 对于每一行i（i=1,2,...,n），消去矩阵A的第i列下面的所有元素，得到新矩阵A'；\n3. 根据公式A'=LU计算出L和U。\n\n以上是LU分解的两种常用方法，它们都可以通过数值计算软件来实现。\n\n# 问题二\n\n## 问题分析\n\n给出方案计算可逆矩阵的逆。\n\n## 算法思路\n\n​\t\t计算可逆矩阵的逆可以使用高斯-约旦消元法。该方法是在矩阵后面连接一个单位矩阵，然后利用行变换将左边的矩阵化为单位矩阵，右边的矩阵就是原矩阵的逆矩阵。\n\n## 算法代码与分析\n\n```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// 交换两个数\nvoid swap(double& a, double& b) {\n    double temp = a;\n    a = b;\n    b = temp;\n}\n\n// 高斯-约旦消元法求解逆矩阵\nvector<vector<double>> inverse(vector<vector<double>>& A) {\n    int n = A.size();\n    // 构造增广矩阵\n    vector<vector<double>> aug(n, vector<double>(2 * n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            aug[i][j] = A[i][j];\n        }\n        aug[i][n + i] = 1.0;\n    }\n    // 消元过程\n    for (int k = 0; k < n; ++k) {\n        // 将主元素缩放为1\n        double pivot = aug[k][k];\n        for (int j = k; j < 2 * n; ++j) {\n            aug[k][j] /= pivot;\n        }\n        // 将消元时用到的行变换应用到右边的矩阵上\n        for (int i = 0; i < n; ++i) {\n            if (i != k) {\n                double factor = aug[i][k];\n                for (int j = k; j < 2 * n; ++j) {\n                    aug[i][j] -= factor * aug[k][j];\n                }\n            }\n        }\n    }\n    // 获取逆矩阵\n    vector<vector<double>> inv(n, vector<double>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            inv[i][j] = aug[i][n + j];\n        }\n    }\n    return inv;\n}\n\nint main() {\n    vector<vector<double>> A {{1.0, 2.0}, {3.0, 4.0}}; // 待求逆矩阵\n    vector<vector<double>> invA = inverse(A);\n    cout << \"Inverse of A:\" << endl;\n    for (int i = 0; i < invA.size(); ++i) {\n        for (int j = 0; j < invA[0].size(); ++j) {\n            cout << invA[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}\n```\n\n","tags":["算法分析与设计"]},{"title":"玖","url":"/2023/04/27/21/","content":"\n# 问题1\n\n## 问题分析\n\n对比分析折半查找与斐波那契查找的性能与应用场景。\n\n## 性能分析\n\n折半查找的时间复杂度是O(log n)，它通过不断缩小查找范围来快速定位目标元素。但是，折半查找要求数据集必须是有序的，因此如果需要频繁进行插入或删除操作，就需要重新排序数据集，这会带来一定的性能损失。\n\n斐波那契查找的时间复杂度也是O(log n)，但是相较于折半查找，它对数据集的有序性要求更低。此外，斐波那契查找还利用了黄金分割比例优化了查找跳跃点的选择，因此在某些情况下会比折半查找更快。\n\n## 应用场景\n\n折半查找适用于静态数据集、频繁读取、很少插入或删除的情况。例如，在一个电话簿或字典中查找单词或者在一个数组中查找元素。\n\n斐波那契查找适用于数据集动态变化的情况，例如有序表随时可能插入或删除元素的情况。此外，斐波那契查找还适用于分布式计算环境中，可以将数据集分成若干个块，每个块交给不同的节点处理，可以提高查找效率。\n\n# 问题2\n\n## 问题分析\n\n调研学习Bloom过滤器的原理。\n\n## 原理\n\nBloom过滤器是一种基于概率的数据结构，它可以用于快速检索某个元素是否属于一个集合中。Bloom过滤器的主要原理是利用多个Hash函数将元素映射到不同的二进制位上，从而实现快速的查找操作。\n\n具体来说，Bloom过滤器的构造过程包括以下几个步骤：\n\n- 初始化：首先需要定义一个长度为m的比特位数组，初始值都为0，表示该集合中没有任何元素。\n- 添加元素：当一个元素加入集合时，需要利用k个独立的Hash函数将该元素映射到m个不同的位置上，并将这些位置的比特位设置为1。\n- 检索元素：当需要检索一个元素是否在集合中时，需要再次将该元素利用相同的k个Hash函数映射到m个位置上，然后判断这些位置的比特位是否都为1。如果有任意一个比特位为0，就可以确定该元素不在集合中；如果所有比特位都为1，说明该元素有可能在集合中，但也有可能是误判，需要进行进一步的判断。\n\nBloom过滤器的优点是空间效率和查询速度非常高，因为它只需要使用一个比特位数组和若干个Hash函数，就可以快速判断一个元素是否在集合中。而且Bloom过滤器可以处理大规模数据集，即使数据量很大，查询速度也能保持在常数级别。\n\n但是Bloom过滤器也存在一定的缺点。它的误判率是无法避免的，即有可能把不属于集合的元素误判为属于集合的元素。另外，Bloom过滤器不支持删除操作，因为一旦比特位被置为1，就无法准确地反映该位置是否被其它元素使用。因此，如果需要频繁地添加或删除元素，或者要求较高的检索准确性，就需要考虑其它更适合的数据结构了。\n","tags":["算法分析与设计"]},{"title":"捌","url":"/2023/04/27/20/","content":"\n# 问题1\n\n## 问题分析\n\n给出策略打印旋转矩阵。以及如何实现“之”字形打印矩阵\n\n## 算法思路\n\n先将矩阵逆时针旋转90度，然后按行打印。定义变量flag用来标记遍历的方向，如果为true表示向右上方走，如果为false表示向左下方走。在循环中根据flag的值判断应该向哪个方向遍历，同时也需要考虑边界问题。\n\n## 算法代码与分析\n\n### 打印旋转矩阵\n\n```\nvoid printRotateMatrix(vector<vector<int>>& matrix) {\n\tint m = matrix.size();\n\tif (m == 0) \n\t\treturn;\n\tint n = matrix[0].size();// 逆时针旋转90度\n\tfor (int i = 0; i < m / 2; ++i) {\n\t\tfor (int j = i; j < n - i - 1; ++j) {\n\t\t\tint temp = matrix[i][j];            \n\t\t\tmatrix[i][j] = matrix[j][n - i - 1];            \n\t\t\tmatrix[j][n - i - 1] = matrix[m - i - 1][n - j - 1];            \n\t\t\tmatrix[m - i - 1][n - j - 1] = matrix[n - j - 1][i];            \n\t\t\tmatrix[n - j - 1][i] = temp;        \n\t\t}    \n\t}\n    // 按行打印\n    for (int i = 0; i < m; ++i) {\n    \tfor (int j = 0; j < n; ++j) {            \n    \t\tcout << matrix[i][j] << \" \";        \n    \t}        \n    \tcout << endl;    \n    }\n}\n```\n\n### 之字形打印矩阵\n\n```\nvoid printZigzagMatrix(vector<vector<int>>& matrix) {\n    int m = matrix.size();\n    if (m == 0) return;\n    int n = matrix[0].size();\n\n    int i = 0, j = 0;\n    bool flag = true; // 标记方向\n    for (int k = 0; k < m + n - 1; ++k) {\n        if (flag) {\n            while (i >= 0 && j < n) {\n                cout << matrix[i][j] << \" \";\n                --i;\n                ++j;\n            }\n            if (j < n) {\n                i = 0;\n            } else {\n                i += 2;\n                --j;\n            }\n        } else {\n            while (i < m && j >= 0) {\n                cout << matrix[i][j] << \" \";\n                ++i;\n                --j;\n            }\n            if (i < m) {\n                j = 0;\n            } else {\n                j += 2;\n                --i;\n            }\n        }\n        flag = !flag;\n    }\n}\n```\n\n# 问题2\n\n## 问题分析\n\n给出策略返回一个m*n矩阵中从[1,1]到[m,n]的和最小的一条路径。\n\n## 算法思路\n\n从起点开始，依次计算到达每个格子的最小路径和，最后得到终点的最小路径和。计算的过程中，我们可以利用一个二维数组dp来记录到达每个格子的最小路径和。初始化dp[1][1]为grid[1][1]，然后按照以下公式递推：\n若i>1且j>1，则dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] \n若i=1且j>1，则dp[1][j] = dp[1][j-1] + grid[1][j] \n若i>1且j=1，则dp[i][1] = dp[i-1][1] + grid[i][1]。\n其中grid[i][j]表示矩阵中第i行第j列格子中的数字。\n最后，得到的dp[m][n]就是从起点到终点的最小路径和。回溯一下dp数组，就可以得到一条满足题目要求的最小路径。\n\n## 算法分析与设计\n\n```\nclass Solution {public:\n    int minPathSum(vector<vector<int>>& grid) {\n        int m = grid.size();\n        int n = grid[0].size();\n        vector<vector<int>> dp(m, vector<int>(n, 0));\n        dp[0][0] = grid[0][0];\n        for (int i = 1; i < m; i++) {\n            dp[i][0] = dp[i-1][0] + grid[i][0];\n        }\n        for (int j = 1; j < n; j++) {\n            dp[0][j] = dp[0][j-1] + grid[0][j];\n        }\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n            }\n        }\n        return dp[m-1][n-1];\n    }\n};\n```\n\n","tags":["算法分析与设计"]},{"title":"柒","url":"/2023/04/27/19/","content":"\n# 问题1\n\n## 问题分析\n\n调研学习Voronoi图及相关算法，并给出至少一个应用。\n\n## Voronoi图\n\nVoronoi 图，又叫狄利克雷镶嵌（Dirichlet tessellation）或者泰森多边形（Thiessen polygon），是一种将平面或表面划分为称为 Voronoi 单元的区域的方法，使得每个像元包含来自一组给定点（称为站点）的一个点，并且单元格中的所有点都比任何其他站点更靠近该站点。您可以将 Voronoi 图视为每个站点最近邻居的地图。Voronoi 图可以通过绘制连接每对站点的线段的垂直平分线或使用从左到右扫描平面的扫描算法来构建。\n\n​\t而Voronoi图常常与Delaunay三角测量相联系，Delaunay三角测量是一种将平面或曲面中的一组点连接成三角形的方法，这样任何三角形的圆周内都没有点。Delaunay 三角测量可视为最大化三角形最小角度的网格。Delaunay 三角测量可以通过翻转任意三角测量的边直到它们满足圆周条件来构造，或者通过使用一次添加一个点的增量或分而治之算法来构造。\n\n​\t而Voronoi图和Delaunay三角测量是双重结构，这意味着它们可以通过简单的变换相互推导。\n\n在计算几何中，它们可用于解决最近邻搜索、最近对、凸包、最小生成树和插值等问题。在空间分析中，它们可用于对自然模式、细胞结构、领土行为和资源分配进行建模。在计算机图形学中，它们可以生成逼真的纹理、地形、网格和照明效果。在计算机视觉中，它们可以分割图像、提取特征和重建表面。在机器学习中，它们可以对数据进行聚类、对模式进行分类和近似函数。\n\n## 应用\n\nVoronoi图被广泛应用于神经科学、气象学、信息科学等诸多领域。比如在生物学中，他可以用于描述流行病学中的传染源，生物细胞的结构等生理模型。在计算机科学中，Voronoi图可以用于地图分区，机器人导航、规划路径等实际问题。\n\n# 问题2\n\n## 问题分析\n\n在一个二维矩阵中查找某元素。矩阵中行列均为升序排列，请给出相关的查找算法并进行分析。\n\n## 算法思路\n\n### 暴力算法\n\n暴力算法是最简单直接的做法，即遍历整个矩阵，逐个比较每个元素与目标值是否相同。时间复杂度为 O(mn)，空间复杂度为 O(1)。由于题目已经保证了矩阵的行列均为升序排列，因此该方法显然不是最优解。\n\n### 二分查找算法\n\n对于一个按升序排列的数组，我们可以利用二分查找算法进行快速查找。对于这道题目，我们可以将矩阵转化成一个有序的数组，从而应用二分查找算法。首先将二维矩阵转化为一维有序数组（可以使用行优先或列优先的方式），对一维数组进行二分查找，找到目标值对应的下标，根据下标计算出目标值在二维矩阵中的位置。时间复杂度为O(log(mn))，空间复杂度为 O(1)。\n\n## 算法代码与分析\n\n### 暴力算法\n\n```\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\n    if (matrix.empty() || matrix[0].empty()) {\n        return false;\n}\n    int m = matrix.size(), n = matrix[0].size();\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (matrix[i][j] == target) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n\n### 二分查找算法\n\n```\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\n    if (matrix.empty() || matrix[0].empty()) {\n        return false;\n    }    \n    int m = matrix.size(), n = matrix[0].size();\n    int left = 0, right = m * n - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        int row = mid / n, col = mid % n;\n        if (matrix[row][col] == target) {\n            return true;\n        } else if (matrix[row][col] > target) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }    \n    return false;\n}\n```\n\n","tags":["算法分析与设计"]},{"title":"陆","url":"/2023/04/27/18/","content":"\n# 问题1\n\n## 问题分析\n\n给出不同策略返回一系列数中的众数（出现次数不小于序列长度的一半），并分析。\n\n## 算法思路\n\n- 暴力法： 遍历数组中的每个元素，然后计算它在数组中出现的次数。 如果它出现的次数大于或等于整个数组长度的一半，则它是众数。 时间复杂度为O(n^2)。\n- 排序法： 对数组进行排序，然后统计相邻元素的出现次数。 时间复杂度为O(nlogn)。\n- 投票法： 遍历数组中的每个元素，并使用一个计数器来记录当前元素出现的次数。 如果下一个元素与当前元素相同，则增加计数器；否则减少计数器。 当计数器变为零时，将当前元素更改为下一个元素，并将计数器重置为1。 最终留下的元素是众数。 时间复杂度为O(n)。\n\n## 算法代码与分析\n\n### 暴力法\n\n```\nint majorityElement(vector<int>& nums) {\n    int n = nums.size();\n    for (int i = 0; i < n; i++) {\n        int count = 0;\n        for (int j = 0; j < n; j++) {\n            if (nums[j] == nums[i]) {\n                count++;\n            }\n        }\n        if (count > n/2) {\n            return nums[i];\n        }\n    }\n    return -1; // 如果没有众数则返回-1\n}\n```\n\n### 排序法\n\n```\nint majorityElement(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    int count = 1, maxCount = 1, n = nums.size(), result = nums[0];\n    for (int i = 1; i < n; i++) {\n        if (nums[i] == nums[i-1]) {\n            count++;\n        } else {\n            if (count > maxCount) {\n                maxCount = count;\n                result = nums[i-1];\n            }\n            count = 1;\n        }\n    }\n    if (count > maxCount) { // 处理最后一个元素\n        result = nums[n-1];\n    }\n    return result;\n}\n```\n\n### 投票法\n\n```\nint majorityElement(vector<int>& nums) {\n    int count = 0, candidate = -1, n = nums.size();\n    for (int i = 0; i < n; i++) {\n        if (count == 0) {\n            candidate = nums[i];\n        }\n        count += (nums[i] == candidate) ? 1 : -1;\n    }\n    return candidate;\n}\n```\n\n## 性能分析\n\n投票法是最优解。因为它具有线性时间复杂度，并且不需要额外的空间。在实际应用中，投票法常用于在线性时间内找到众数。\n\n# 问题2\n\n## 问题分析\n\n给出不同策略将偶数个元素形成的序列分成两个等规模子序列S1,S2，要求s1，s2的和差值最大。\n\n## 算法思路\n\n一种常见的策略是动态规划。令dp[i][j]表示前i个数中选出若干个数，它们的和不超过j的最大值，则有状态转移方程：dp[i][j]=max(dp[i-1][j], dp[i-1][j-nums[i]]+nums[i])。其中，nums[i]表示第i个数的值。最后，s1和s2的差值即为(sum-dp[n][sum/2])-dp[n][sum/2]，其中sum为序列总和，n为序列长度。\n\n贪心的思路是将序列从大到小排序，然后依次将每个数分配给两个子序列中较小的那个。具体实现中，可以使用两个指针分别指向两个子序列当前的末尾位置，每次加入一个数时选择较小的末尾位置进行加入。\n\n搜索算法也可以解决此问题，具体实现中可以用深度优先搜索（DFS）枚举每个数属于哪一个子序列，并计算它们的和差值。由于数据范围较小，因此搜索算法在此问题中也是可行的。\n\n## 算法代码与分析\n\n### 动态规划\n\n```\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nconst int MAXN = 105;\nint nums[MAXN];\nint dp[MAXN][MAXN*MAXN/2];\n\nint main() {\n    int n, sum = 0;\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> nums[i];\n        sum += nums[i];\n    }\n    memset(dp, 0, sizeof(dp));\n    for (int i = 1; i <= n; i++) {\n        for (int j = sum/2; j >= nums[i]; j--) {\n            dp[i][j] = max(dp[i-1][j], dp[i-1][j-nums[i]]+nums[i]);\n        }\n    }\n    cout << sum - dp[n][sum/2] - dp[n][sum/2] << endl;\n    return 0;\n}\n```\n\n### 贪心算法\n\n```\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 105;\nint nums[MAXN];\n\nint main() {\n    int n, sum = 0;\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> nums[i];\n        sum += nums[i];\n    }\n    sort(nums + 1, nums + n + 1, greater<int>());\n    int s1 = 0, s2 = 0;\n    for (int i = 1; i <= n; i++) {\n        if (s1 < s2) {\n            s1 += nums[i];\n        } else {\n            s2 += nums[i];\n        }\n    }\n    cout << sum - 2 * min(s1, s2) << endl;\n    return 0;\n}\n```\n\n### 搜索算法\n\n```\n#include <iostream>\nusing namespace std;\n\nconst int MAXN = 105;\nint nums[MAXN];\nbool vis[MAXN];\nint ans = -1;\n\nvoid dfs(int cur, int s1, int s2) {\n    if (cur == 0) {\n        ans = max(ans, abs(s1 - s2));\n        return;\n    }\n    vis[cur] = true;\n    dfs(cur - 1, s1 + nums[cur], s2);\n    vis[cur] = false;\n    dfs(cur - 1, s1, s2 + nums[cur]);\n}\n\nint main() {\n    int n, sum = 0;\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> nums[i];\n        sum += nums[i];\n    }\n    dfs(n, 0, 0);\n    cout << ans << endl;\n    return 0;\n}\n```\n\n","tags":["算法分析与设计"]},{"title":"伍","url":"/2023/04/27/17/","content":"\n# 问题1\n\n## 问题分析\n\n在计算机科学与社会生活中，经常涉及到要求前K个元素即top-k的问题，请给出不同策解决这一问题，并对比分析。\n\n## 算法思路\n\n前K个元素即top-k问题是计算机科学中的常见问题，在很多场景下都有应用，如推荐系统、排名系统、搜索引擎等。以下是一些解决top-k问题的不同策略：\n\n- 排序法：将要求前K个元素的数据进行排序，然后取前K个即可。时间复杂度为O(nlogn)，适用于数据规模较小的情况。\n- 堆排序法：使用堆数据结构，维护一个大小为K的最小堆或最大堆，遍历整个数据集，将每个元素与堆顶比较，如果比堆顶大或小，则替换堆顶元素，重新调整堆。时间复杂度为O(nlogk)，适用于大规模数据。\n- 快速选择法：快速选择法是基于快速排序算法实现的，通过分治、随机化等技术，不需要完全排序，即可找到前K个元素。时间复杂度为O(n)，适用于K比较小的情况。\n- 分治法：将数据集分为若干部分，每部分找出前K个元素，然后合并这些部分的前K个元素，再找出合并后的前K个元素。时间复杂度取决于每部分处理时间和合并时间。\n\n## 算法代码与分析\n\n### 排序法\n\n```\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> topKSort(std::vector<int> nums, int k) {\n    std::sort(nums.begin(), nums.end());\n    return std::vector<int>(nums.end() - k, nums.end());\n}\n```\n\n### 堆排序法\n\n```\n#include <queue>\n#include <vector>\n\nstd::vector<int> topKHeap(std::vector<int> nums, int k) {\n    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;\n    for (int num : nums) {\n        minHeap.push(num);\n        if (minHeap.size() > k) {\n            minHeap.pop();\n        }\n    }\n    std::vector<int> res;\n    while (!minHeap.empty()) {\n        res.push_back(minHeap.top());\n        minHeap.pop();\n    }\n    std::reverse(res.begin(), res.end());\n    return res;\n}\n```\n\n### 快速选择法\n\n```\n#include <cstdlib>\n#include <ctime>\n#include <vector>\n\nint partition(std::vector<int>& nums, int left, int right) {\n    srand(time(nullptr));\n    int pivotIndex = left + rand() % (right - left + 1);\n    int pivotValue = nums[pivotIndex];\n    std::swap(nums[pivotIndex], nums[right]);\n    int storeIndex = left;\n    for (int i = left; i < right; ++i) {\n        if (nums[i] < pivotValue) {\n            std::swap(nums[storeIndex], nums[i]);\n            ++storeIndex;\n        }\n    }\n    std::swap(nums[right], nums[storeIndex]);\n    return storeIndex;\n}\n\nint quickSelect(std::vector<int>& nums, int left, int right, int k) {\n    if (left == right) {\n        return nums[left];\n    }\n    int pivotIndex = partition(nums, left, right);\n    if (k == pivotIndex) {\n        return nums[k];\n    } else if (k < pivotIndex) {\n        return quickSelect(nums, left, pivotIndex - 1, k);\n    } else {\n        return quickSelect(nums, pivotIndex + 1, right, k);\n    }\n}\n\nstd::vector<int> topKQuickSelect(std::vector<int>& nums, int k) {\n    int n = nums.size();\n    int kthLargest = quickSelect(nums, 0, n - 1, n - k);\n    std::vector<int> res;\n    for (int num : nums) {\n        if (num >= kthLargest) {\n            res.push_back(num);\n        }\n    }\n    return res;\n}\n```\n\n### 分治法\n\n```\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> merge(std::vector<int> v1, std::vector<int> v2, int k) {\n    std::vector<int> res;\n    int i = 0, j = 0;\n    while (i < v1.size() && j < v2.size() && res.size() < k) {\n        if (v1[i] > v2[j]) {\n            res.push_back(v1[i++]);\n        } else {\n            res.push_back(v2[j++]);\n        }\n    }\n    while (i < v1.size() && res.size() < k) {\n        res.push_back(v1[i++]);\n    }\n    while (j < v2.size() && res.size() < k) {\n        res.push_back(v2[j++]);\n    }\n    return res;\n}\n\nstd::vector<int> topKDivideConquer(std::vector<int>& nums, int k) {\n    if (nums.size() == 1) {\n        return nums;\n    }\n    int mid = nums.size() / 2;\n    std::vector<int> left(nums.begin(), nums.begin() + mid);\n    std::vector<int> right(nums.begin() + mid, nums.end());\n    std::vector<int> leftTopK = topKDivideConquer(left, k);\n    std::vector<int> rightTopK = topKDivideConquer(right, k);\n    std::vector<int> merged = merge(leftTopK, rightTopK, k);\n    return merged;\n}\n```\n\n## 性能分析\n\n综合来看，对于数据规模较小，K值也不大的情况，排序法和快速选择法是两种较为简单有效的策略；对于大规模数据和K值较大的情况，堆排序法是一种更加高效的方法。如果可以进行数据划分，则可以考虑使用分治法。需要根据具体场景和需求选择合适的算法。\n\n# 问题2\n\n## 问题分析\n\n请用递归方式实现堆排序，并进行性能分析。\n\n## 算法思路\n\n堆排序的思想是利用堆这种数据结构进行排序。在堆中定义如下两种操作：\n\n- 弹出堆顶元素：将堆顶（即堆的最大元素）弹出，然后将堆底元素移到堆顶，并通过“下沉”操作，将新的堆顶元素恢复成大根堆。\n- 插入新元素：将新元素插入堆尾，并通过“上浮”操作，将新元素恢复成大根堆。\n\n堆排序的具体步骤如下：\n\n- 建堆：将无序序列构建成一个大根堆。\n- 弹出堆顶元素，并将其与堆底元素交换，缩小堆的大小，重新对堆顶元素进行“下沉”操作。\n- 重复执行第2步，直到堆的大小为1。\n\n## 算法代码与分析\n\n```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n// 将元素向下调整\nvoid adjustHeap(vector<int>& nums, int i, int n) {\n    int temp = nums[i];\n    int j = i * 2 + 1;\n    while (j < n) {\n        if (j + 1 < n && nums[j] < nums[j + 1]) j++;\n        if (nums[j] > temp) {\n            nums[i] = nums[j];\n            i = j;\n            j = i * 2 + 1;\n        } else {\n            break;    \n        }\n    }\n    nums[i] = temp;\n}\n\n// 堆排序\nvoid heapSort(vector<int>& nums) {\n    int n = nums.size();\n    // 构建初始堆，从最后一个非叶子节点开始向下调整\n    for (int i = (n - 2) / 2; i >= 0; i--) {\n        adjustHeap(nums, i, n);\n    }\n    // 依次将堆顶元素与堆底元素交换，缩小堆的大小，并重新调整堆\n    for (int i = n - 1; i > 0; i--) {\n        swap(nums[0], nums[i]);\n        adjustHeap(nums, 0, i);\n    }\n}\n\nint main() {\n    vector<int> nums = {3, 5, 1, 4, 2};\n    heapSort(nums);\n    for (auto x : nums) {\n        cout << x << \" \";\n    }\n    cout << endl;\n    return 0;\n}\n```\n\n## 性能分析\n\n堆排序的时间复杂度为O(nlogn)，与快速排序相当。但是堆排序的常数较大，不如快排，因此实际应用中很少使用堆排序。另外，堆排序是一种不稳定排序，因为在构建初始堆和每次交换堆顶元素与堆底元素时都有可能破坏相同元素的相对位置。\n","tags":["算法分析与设计"]},{"title":"肆","url":"/2023/04/27/16/","content":"\n# 问题1\n\n## 问题分析\n\n对于一个序列可以采用二分查找或顺序查找，请结合实施查找的次数，确定在什么情况下使用二分查找效率更高\n\n## 算法思路\n\n在有序序列中查找目标元素时，二分查找的效率通常要高于顺序查找。这是因为二分查找每次可以将待查区间减半，而顺序查找则需要遍历整个序列，所以当数据规模较大时，二分查找的查找次数比顺序查找更少，时间复杂度更低。\n\n具体来说，在以下情况下使用二分查找效率更高：\n\n1. 序列较大且有序：如果序列规模较大，并且已经有序，那么使用二分查找可以显著降低查找次数，提高效率。\n\n2. 多次查找：如果需要对同一个序列进行多次查找，将序列排序后再使用二分查找可以加快查找速度。虽然排序本身也需要时间，但这种方法适用于需要多次查找的情况，因为排序只需要进行一次。\n\n​\t结果的精确性。\n\n总之，二分查找适用于有序序列、需要多次查找或需要精确查找的情况。在其他情况下，顺序查找可能更合适。\n\n## 算法代码与分析：\n\n```\nint search_rotated_array(vector<int>& arr, int target) {\n    // 定义二分查找函数\n    auto binary_search = [&](int left, int right) -> int {\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            if (arr[mid] == target)\n                return mid;\n            else if (arr[mid] < target)\n                left = mid + 1;\n            else\n                right = mid - 1;\n        }\n        return -1;\n    };\n    // 特判\n    if (arr.empty())\n        return -1;\n    // 初始化左右端点\n    int left = 0, right = arr.size() - 1;\n    // 二分查找寻找旋转点\n    while (left < right) {\n        int mid = (left + right) / 2;\n        if (arr[mid] > arr[right])\n            left = mid + 1;\n        else\n            right = mid;\n    }\n    // 根据旋转点在哪个半部分执行二分查找\n    if (target <= arr.back())\n        return binary_search(left, arr.size() - 1);\n    else\n        return binary_search(0, left - 1);\n}\n```\n\n# 问题2\n\n## 问题分析\n\n现有一个序列，它是由一个有序系列绕着某个元素旋转得到的。请给出一个在此序列实施查找的有效算法，并对你的算法进行分析。\n\n## 算法思路\n\n由于该序列是由一个有序系列旋转得到的，因此可以考虑采用二分查找的方法进行查找。具体来说，可以先找出旋转点，即最小值所在的位置，然后根据要查找的元素和旋转点的大小关系，在左半段或右半段中进行二分查找。查找过程中，需要注意边界情况的处理，如数组为空、只有一个元素等情况。\n\n时间复杂度分析：查找旋转点的时间复杂度为 O(log n)；在左半段或右半段中进行二分查找的时间复杂度也为 O(log n)，因此总的时间复杂度为 O(log n)。\n\n空间复杂度分析：该算法只使用了常数个临时变量，因此空间复杂度为 O(1)。\n\n## 算法代码与分析\n\n```\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int n = nums.size();\n        if (n == 0) return -1;  // 特判：数组为空\n        // 查找旋转点（最小值所在位置）\n        int left = 0, right = n - 1;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] > nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        int rotate = left;\n        // 在左半段或右半段中进行二分查找\n        left = 0, right = n - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            int realmid = (mid + rotate) % n;  // 实际中间位置\n            if (nums[realmid] == target) {\n                return realmid;\n            } else if (nums[realmid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return -1;  // 未找到目标元素\n    }\n};\n```\n\n","tags":["算法分析与设计"]},{"title":"叁","url":"/2023/04/26/15/","content":"\n# 问题1\n\n## 问题分析\n\n给出策略列举出包含n元素的集合的所有子集，并进行分析。\n\n## 算法思路\n\n可以使用回溯法得到包含 n 个元素的集合的所有子集。\n\n具体地，从空集出发，每次选择一个元素加入当前子集中，然后递归下去继续选择，直到没有更多元素可选为止。在递归结束后，需要将当前选定的元素移除，返回上一层递归，以便尝试其它选择。\n\n## 算法代码与分析\n\n```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// 输出当前子集\nvoid print_subset(const vector<int>& subset) {\n    cout << \"{ \";\n    for (int i = 0; i < subset.size(); i++) {\n        cout << subset[i] << \" \";\n    }\n    cout << \"}\" << endl;\n}\n\n// 递归函数\nvoid backtrack(vector<int>& nums, vector<int>& subset, int start) {    \n    print_subset(subset);// 先输出当前子集\n    // 从start开始枚举未选择的元素\n    for (int i = start; i < nums.size(); i++) {\n        subset.push_back(nums[i]);// 将nums[i]加入到当前子集中，并进入下一层递归\n        backtrack(nums, subset, i+1);       \n        subset.pop_back();// 将nums[i]移除出当前子集，返回上一层递归\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> nums(n);\n    for (int i = 0; i < n; i++) {\n        nums[i] = i+1;\n    }\n    vector<int> subset; // 当前子集\n    backtrack(nums, subset, 0);\n    return 0;\n}\n```\n\n# 问题2\n\n## 问题分析\n\n在机器学习、文本处理、推荐系统等应用领域，经常使用相似度指标，调研学习当前业界经常使用的相似度指标。\n\n## 结论\n\n- 余弦相似度（Cosine Similarity）：用于对两个向量的相似性进行度量，计算方法是两个向量的点积除以它们的模长之积。余弦相似度的值范围在 [−1,1](#) 之间，值越大表示相似度越高。\n- 欧几里得距离（Euclidean Distance）：用于比较两个样本之间的相似性或距离。计算方法是将两个样本看成向量，计算两个向量之间的欧几里得距离。欧几里得距离的值越小表示相似度越高。\n- 曼哈顿距离（Manhattan Distance）：也称为城市街区距离，用于比较两个样本之间的相似性或距离。计算方法是将两个样本看成向量，计算两个向量之间的曼哈顿距离。曼哈顿距离的值越小表示相似度越高。\n- Jaccard 相似系数（Jaccard Similarity Coefficient）：用于比较两个集合之间的相似性。计算方法是将两个集合的交集除以它们的并集。Jaccard 相似系数的值在 [0,1](#) 之间，值越大表示相似度越高。\n- 皮尔逊相关系数（Pearson Correlation Coefficient）：用于度量两个变量之间的线性关系程度。计算方法是将两个变量的协方差除以它们的标准差之积。皮尔逊相关系数的值在 [−1,1](#) 之间，值越大表示相关性越强。\n- 斯皮尔曼等级相关系数（Spearman Rank Correlation Coefficient）：用于度量两个变量之间的等级关系程度。计算方法是将两个变量转化为等级，然后计算它们之间的皮尔逊相关系数。斯皮尔曼等级相关系数的值在 [−1,1](#) 之间，值越大表示相关性越强。\n","tags":["算法分析与设计"]},{"title":"贰","url":"/2023/04/26/14/","content":"\n# 问题1\n\n## 问题分析\n\n给出不同策略求两个整数的最大公约数GCD(m,n)，并进行分析。\n\n## 算法思路\n\n暴力枚举\n\n欧几里得算法\n\n更相减损法\n\n## 算法代码与分析\n\n### 暴力枚举\n\n```\nint gcd(int m,int n){\n\tint i=m>n?n:m;\n\tfor(int j=i;j>0;j--){\n\t\tif(m%j==0&&n%j==0){\n\t\t\treturn j;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n```\n\n### 欧几里得算法\n\n```\nint gcd(int m, int n) {\n    while (n != 0) {\n        int temp = m % n;\n        m = n;\n        n = temp;\n    }\n    return m;\n}\n```\n\n### 更相减损法\n\n```\nint gcd(int m, int n) {\n    while (m != n) {\n        if (m > n) m -= n;\n        else n -= m;\n    }\n    return m;\n}\n```\n\n# 问题2\n\n## 问题分析\n\n给出方案返回一可以动态变化的序列（可增可减）中的最大值，并对你的方案进行分析。\n\n## 算法思路\n\n采取从最大堆获取最大值的方法\n\n## 算法代码及分析\n\n```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n); // 存储原始序列\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    priority_queue<int> pq(a.begin(), a.end()); // 使用最大堆初始化\n    int ans = pq.top(); // 获取当前最大值\n    cout << ans << endl;\n    // 模拟动态变化\n    a[2] = 20;\n    pq.push(20);\n    ans = pq.top();\n    cout << ans << endl; \n    a[0] = 10;\n    pq.push(10);\n    ans = pq.top();\n    cout << ans << endl;\n    return 0;\n}\n```\n\n","tags":["算法分析与设计"]},{"title":"壹","url":"/2023/04/26/13/","content":"\n# 问题1\n\n## 问题分析\n\n设计一栈结构，使得出栈、入栈以及求栈的最小值均能在O(1)时间内完成。\n\n## 算法思路\n\n创建两个栈，其中一个栈存储全部数据，另一个栈存放这组数据中的最小值。\n\n## 算法代码与分析\n\n```\n#include<iostream>\n#include<stack>\n\nusing namespace std;\n\ntemplate<class T>\n\nclass Stack{\nprivate:\n\tstack<T> s1;//存储全部数据\n\tstack<T> s2;//存储最小值\npublic:\n\tvoid push(const T& x){\n\t\ts1.push(x);\n\t\tif (s1.size() == 1)\n\t\t\ts2.push(s1.top());\n\t\telse{\n\t\t\tif (s1.top() <= s2.top()){\n\t\t\t\ts2.push(s1.top());\n\t\t\t}\n\t\t}\n\t}//入栈\n\n\tvoid Pop(){\n\t\tif (!s1.empty()){\n\t\t\tif (s1.top() == s2.top())\n\t\t\t\ts2.pop();\n\t\t\ts1.pop();\n\t\t}\n\t}//出栈\n\n\tT& Min(){\n\t\treturn s2.top();\n\t}//返回最小值\n\n\tsize_t Size(){\n\t\treturn s1.size();\n\t}//返回栈中元素个数\n\n\tbool Empty(){\n\t\treturn s1.empty();\n\t}//判断栈是否为空\n\n\tT& Top(){\n\t\treturn s1.top();\n\t}//返回栈顶元素\n};\n\nint main(){\n\tStack<int> s;\n\ts.push(6);\n\ts.push(7);\n\ts.push(2);\n\ts.push(1);\n\ts.push(9);\n\tcout << s.Size() << endl;\n\tcout << s.Min() << endl;\n\tcout << s.Top() << endl;\n\n}\n```\n\n# 问题2\n\n## 问题分析\n\n改进冒泡排序使得在最好情况下可以在线性时间内完成。\n\n## 算法思路\n\n在外层循环中加入一个bool变量用来判断在循环中是否发生了交换，如果没有交换，那么就可以说明数组的顺序已经排好了，直接结束循环，此时的复杂度即为O(n)。\n\n## 算法代码及分析\n\n```\n#include<iostream>\n\nusing namespace std;\n\nint main()\n{\n\tint m=0,n;//m存储排序次数 n存储需要排序的元素的个数\n\tcin>>n;\n\tint a[n];\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t}\n\tbool flag=false;//标志位 倘若未改动则表示元素有序 直接停止循环\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n-i-1;j++){\n\t\t\tif(a[j]>a[j+1]){\n\t\t\t\tint temp =a[j];\n\t\t\t\ta[j]=a[j+1];\n\t\t\t\ta[j+1]=a[j];\n\t\t\t\tflag = true;\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\t\tif(flag==false){\n\t\t\tbreak;\n\t\t}\n\t}\n\tcout<<m<<endl;\n}\n```\n\n","tags":["算法分析与设计"]},{"title":"算法分析与设计实践","url":"/2023/04/26/11/","content":"\n# P1302 可见矩形\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1302\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n给定平面上 n 个互不相交（指公共面积为零）的正方形，它们的顶点坐标均为整数。设坐标原点为 O(0,0)。对于任一正方形 R，如果可以找到 R 的边上 2 个不同的点 A 和 B，使  三角形OAB 的内部与其他正方形无公共点，则称正方形 R 是从 O 点可见的正方形。\n\n对于给定的 n 个互不相交的正方形，计算从坐标原点 O 可见的正方形个数。\n\n### 输入格式\n\n输入文件的第一行是正方形个数n（1≤n≤10001≤n≤1000）\n\n接下来n行中，每行有三个表示正方形的整数 X,Y,L。其中，X 和 Y 表示正方形的左下角顶点坐标，L表示边长，1≤X,Y,Z≤10000。\n\n### 输出格式\n\n输出文件仅有一行包含一个整数，表示从坐标原点 O 可见的正方形个数。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n3\n2 6 4\n1 4 1\n2 4 1\n```\n\n#### 样例输出 #1\n\n```\n3\n```\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t设正方形的左下端点（aa，bb），边长为cc，参数cmp=aa+bb+cc。不难发现，cmp较小的正方形可以遮挡cmp较大的正方形，于是记录每个正方形的斜率范围。即最小斜率bb/(aa+cc)和最大斜率(bb+cc)/aa，并针对cmp参数进行递增排序\n\n​\t\t建立二维数组a负责储存不可用的斜率范围，a数组奇数编号储存起始斜率，偶数编号储存截止斜率。于是便可用数组a表示所有不可用范围。初始的斜率范围即为k[1].s到k[1].l，下面依次使各正方形的斜率进入数组。\n\n​\t\t第i号正方形进入数组：比k[i].s还小的元素直接照抄，不需更改，直到找到第一个大于等于k[i].s的元素。若该元素编号为奇数，即为一个范围的起始位置，说明k[i].s的进入产生了一个新的不可用范围，直接使k[i].s进入数组。若该元素编号为偶数，即为一个范围的结束位置，说明k[i].s处在某个范围内部，不需要产生新的起始点，不进行操作，继续向下查找元素。处在k[i].s和k[i].l之间的元素无需理会，直到找到第一个大于等于k[i].l的元素，对k[i].l的操作跟k[i].s基本相同。\n\n### 算法代码\n\n```\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n;\nint ans;\nstruct node{\n\tdouble l,s,cmp;\n}k[100100];\nbool cmp(node x,node y){\n\treturn x.cmp<y.cmp;\n}\ndouble a[10001][10001];\nint cnt[10001];\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c>'9'||c<'0'){\n\t\tif(c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<3)+(x<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint main(){\n\tn=read();\n\tint aa,bb,cc;\n\tfor(int i=1;i<=n;i++){\n\t\taa=read();\n\t\tbb=read();\n\t\tcc=read();\n\t\tk[i].l=(bb+cc)*1.0/aa;\n\t\tk[i].s=bb*1.0/(aa+cc);\n\t\tk[i].cmp=aa+bb+cc;\n\t}\n\tsort(k+1,k+1+n,cmp);\n\ta[1][1]=k[1].s;\n\ta[1][2]=k[1].l;\n\tcnt[1]=2;\n\tfor(int i=2;i<=n;i++){\n\t\tint t=1;\n\t\twhile(a[i-1][t]<k[i].s&&t<=cnt[i-1]){\n\t\t\ta[i][t]=a[i-1][t];\n\t\t\tt++;\n\t\t}\n\t\tint l=t;\n\t\tcnt[i]=t-1;\n\t\tif(t%2==1){\n\t\t\ta[i][++cnt[i]]=k[i].s;\n\t\t\tif(a[i-1][t]==a[i][t]) l=t+1;\n\t\t} \n\t\twhile(a[i-1][t]<=k[i].l&&t<=cnt[i-1]){\n\t\t\tt++;\n\t\t}\n\t\tint r=t;\n\t\tif(t%2==1){\n\t\t\ta[i][++cnt[i]]=k[i].l;\n\t\t\tif(a[i-1][t-1]==a[i][cnt[i]]) r--;\n\t\t} \n\t\twhile(t<=cnt[i-1]){\n\t\t\ta[i][++cnt[i]]=a[i-1][t]; \n\t\t\tt++;\n\t\t}\n\t\tif(r-l>=1) ans++;\n\t\telse{\n\t\t\tif(r%2==1) ans++;\n\t\t}\n\t}\n\tcout<<ans+1;\n\treturn 0;\n}\n```\n\n## 总结与讨论\n\n算法的时间复杂度比较高。\n\n\n\n# P1784 数独\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1784\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n数独是根据 $9 \\times 9$ 盘面上的已知数字，推理出所有剩余空格的数字，并满足每一行、每一列、每一个粗线宫内的数字均含 $1 - 9$ ，不重复。每一道合格的数独谜题都有且仅有唯一答案，推理方法也以此为基础，任何无解或多解的题目都是不合格的。\n\n芬兰一位数学家号称设计出全球最难的“数独游戏”，并刊登在报纸上，让大家去挑战。\n\n这位数学家说，他相信只有“智慧最顶尖”的人才有可能破解这个“数独之谜”。\n\n据介绍，目前数独游戏的难度的等级有一到五级，一是入门等级，五则比较难。不过这位数学家说，他所设计的数独游戏难度等级是十一，可以说是所以数独游戏中，难度最高的等级。他还表示，他目前还没遇到解不出来的数独游戏，因此他认为“最具挑战性”的数独游戏并没有出现。\n\n### 输入格式\n\n一个未填的数独。\n\n### 输出格式\n\n填好的数独。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n8 0 0 0 0 0 0 0 0 \n0 0 3 6 0 0 0 0 0 \n0 7 0 0 9 0 2 0 0 \n0 5 0 0 0 7 0 0 0 \n0 0 0 0 4 5 7 0 0 \n0 0 0 1 0 0 0 3 0 \n0 0 1 0 0 0 0 6 8 \n0 0 8 5 0 0 0 1 0 \n0 9 0 0 0 0 4 0 0\n```\n\n#### 样例输出 #1\n\n```\n8 1 2 7 5 3 6 4 9 \n9 4 3 6 8 2 1 7 5 \n6 7 5 4 9 1 2 8 3 \n1 5 4 2 3 7 8 9 6 \n3 6 9 8 4 5 7 2 1 \n2 8 7 1 6 9 5 3 4 \n5 2 1 9 7 4 3 6 8 \n4 3 8 5 2 6 9 1 7 \n7 9 6 3 1 8 4 5 2\n```\n\n### 样例 #2\n\n#### 样例输入 #2\n\n```\n9 0 0 8 0 0 0 0 0\n0 0 0 0 0 0 5 0 0 \n0 0 0 0 0 0 0 0 0 \n0 2 0 0 1 0 0 0 3\n0 1 0 0 0 0 0 6 0\n0 0 0 4 0 0 0 7 0\n7 0 8 6 0 0 0 0 0 \n0 0 0 0 3 0 1 0 0 \n4 0 0 0 0 0 2 0 0 \n```\n\n#### 样例输出 #2\n\n```\n9 7 2 8 5 3 6 1 4 \n1 4 6 2 7 9 5 3 8 \n5 8 3 1 4 6 7 2 9 \n6 2 4 7 1 8 9 5 3 \n8 1 7 3 9 5 4 6 2 \n3 5 9 4 6 2 8 7 1 \n7 9 8 6 2 1 3 4 5 \n2 6 5 9 3 4 1 8 7 \n4 3 1 5 8 7 2 9 6 \n```\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t数独是源自18世纪瑞士的一种数学游戏。是一种运用纸、笔进行演算的逻辑游戏。玩家需要根据9×9盘面上的已知数字，推理出所有剩余空格的数字，并满足每一行、每一列、每一个粗线宫（3×3）内的数字均含1-9，不重复。\n\n​\t\t数独要求每一行、每一列、每一个3×3方阵内的数字，不重复。行和列重复判断是相当简单的。我们可以定义两个bool型二维数组，当此行（或列）填充数字时，我们可以直接把这行的这个数字打上true表示有数字了。\n\n### 算法代码\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint sd[11][11];//数独方阵定义 \nbool p[11][11],l[11][11],fz[11][11];//行，列，方阵。 \n\nvoid _out()\n{\n    cout<<endl;\n\tfor(int i=1;i<=9;i++)\n\t{\t\n  \t\tfor(int j=1;j<=9;j++)\n\t\t\tcout<<sd[i][j]<<\" \";\n\t\tcout<<endl;\n\t}\n\texit(0); \n}\nvoid dfs(int x,int y)\n{\n\tif(sd[x][y]!=0)//如果原来这个位置有数字，跳过。 \n\t\tif(x==9&&y==9)_out();//当行列都为9，填充完成，输出\n\t\telse if(y==9)dfs(x+1,1);//当列数为9，搜索下一排。 \n\t\telse dfs(x,y+1);//搜下一列 \n\telse//原来的地方没有数字，准备填充！ \n\t\tfor(int i=1;i<=9;i++)\n\t\t\tif((!p[x][i])&&(!l[y][i])&&(!fz[(x-1)/3*3+(y-1)/3+1][i]))\n\t\t\t//判断是不是重复了。\n\t\t\t{\n\t\t\t\tsd[x][y]=i;//填充！ \n\t\t\t\tp[x][i]=l[y][i]=fz[(x-1)/3*3+(y-1)/3+1][i]=true;//打上标记。 \n\t\t\t\tif(x==9&&y==9)_out();//全部填完！输出\n\t\t\t\telse if(y==9)dfs(x+1,1);//同上！搜下一行。\n\t\t\t\telse dfs(x,y+1);//搜下一列！ \n\t\t\t\tsd[x][y]=0; //恢复标记。 \n\t\t\t\tp[x][i]=l[y][i]=fz[(x-1)/3*3+(y-1)/3+1][i]=false;//恢复标记。 \n\t\t\t}\n}\nint main()\n{\n\tfor(int i=1;i<=9;i++)\n\t\tfor(int j=1;j<=9;j++)\n\t\t{\n\t\t\tint t;//定义tmp（防止下面代码太长？） \n\t\t\tcin>>t;//输入 \n\t\t\tif(t!=0)\n\t\t\t\tp[i][t]=l[j][t]=fz[(i-1)/3*3+(j-1)/3+1][t]=true;\n\t\t\t//填充的不是0的话，表示原来有数字了。打上标记。\t\n\t\t\tsd[i][j]=t;//填充进数独。 \n\t\t}\t\n\tdfs(1,1);//搜索\n\treturn 0;//结束 \n}\n```\n\n## 总结与讨论\n\n​\t\t算法的难点在于判断数字的重复。\n\n\n\n# P1229 遍历问题\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1229\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n我们都很熟悉二叉树的前序、中序、后序遍历，在数据结构中常提出这样的问题：已知一棵二叉树的前序和中序遍历，求它的后序遍历，相应的，已知一棵二叉树的后序遍历和中序遍历序列你也能求出它的前序遍历。然而给定一棵二叉树的前序和后序遍历，你却不能确定其中序遍历序列，考虑如下图中的几棵二叉树：\n\n ![](https://cdn.luogu.com.cn/upload/pic/73.png) \n\n所有这些二叉树都有着相同的前序遍历和后序遍历，但中序遍历却不相同。\n\n### 输入格式\n\n输A数据共两行，第一行表示该二叉树的前序遍历结果s1，第二行表示该二叉树的后序遍历结果s2。\n\n### 输出格式\n\n输出可能的中序遍历序列的总数，结果不超过长整型数。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\nabc                           \ncba\n```\n\n#### 样例输出 #1\n\n```\n4\n```\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t给定中能确定树的具体结构，是因为可以确定是左子树还是右子树，而之给定前和后，则不能确定，这就是会出现不同树结构的原因。只有前和后那么主要问题就是没有办法处理只有一个子树的情况，因为这种情况不知道子树究竟是这个节点的左子树还是右子树，也就是说其实这道题要判断遍历中存在着多少个只有一棵子树的情况。对于前，如果一个结点的下个结点等于后中对应结点的前一个结点的话，那么这个结点就是根节点且其只有一个子树。sum初始化为1，出现一个只有一棵子树的情况，就把sum*2。\n\n```\n#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int i;\n    long long c=1;\n    string s1,s2,s3;\n    cin >> s1 >> s2;\n    for (i=0; i<s1.length()-1; i++) {\n        s3 = s1.substr(i,2); // 截取相邻的两个字符串\n        reverse(s3.begin(),s3.end()); // 反转\n        if (s2.find(s3) != string::npos) c *= 2; // 匹配成功则总数*2\n    }\n    cout << c << endl;\n}\n```\n\n## 总结与讨论\n\n​\t\t乍一看很难，实则找规律。\n\n\n\n# P1387 最大正方形\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1387\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n在一个 n×mn×m的只包含 0和1的矩阵里找出一个不包含 0的最大正方形，输出边长。\n\n### 输入格式\n\n输入文件第一行为两个整数n,m(1≤n,m≤100)，接下来 n 行，每行 m 个数字，用空格隔开，0 或 1。\n\n### 输出格式\n\n一个整数，最大正方形的边长。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n4 4\n0 1 1 1\n1 1 1 0\n0 1 1 0\n1 1 0 1\n```\n\n#### 样例输出 #1\n\n```\n2\n```\n\n## 算法\n\n### 问题分析与算法设计\n\n暴力算法：枚举每一个点作为所选正方形的左上角的点，然后枚举正方形边长，逐一判断。\n\n### 算法代码\n\n```\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool f[202][202]={0},p;\nint n,m,i,j,k,x,y,ans=0;\n\nint main()\n{\n  cin>>m;\n  cin>>n;\n  for (int i=0; i<n; i++)\n    for (int j=0; j<m; j++)\n      cin>>f[i][j];          \n  for (int i=0; i<n; i++)\n    for (int j=0; j<m; j++)\n      for (int k=min(n,m); k>ans; k--){\n          p=1;\n          for (int x=i; x<i+k; x++){\n              for (int y=j; y<j+k; y++){\n                  if (!f[x][y])      \n                      {\n                        p=0; \n                        break;   \n                      }\n              }\n              if (!p){\n              \tbreak;\n              }     \n            }\n          if (p){\n              ans=k; \n              break;       \n            }\n        }\n  cout<<ans<<endl;                \n  return 0;\n}\n```\n\n## 总结与讨论\n\n​\t\t时间复杂度略高，还需要改进。\n\n\n\n# P1123 取数游戏\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1123\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n一个$N \\times M$的由非负整数构成的数字矩阵，你需要在其中取出若干个数字，使得取出的任意两个数字不相邻（若一个数字在另外一个数字相邻$8$个格子中的一个即认为这两个数字相邻），求取出数字和最大是多少。\n\n### 输入格式\n\n第1行有一个正整数$T$，表示了有$T$组数据。\n\n对于每一组数据，第一行有两个正整数$N$和$M$，表示了数字矩阵为$N$行$M$列。\n\n接下来$N$行，每行$M$个非负整数，描述了这个数字矩阵。\n\n### 输出格式\n\n$T$行，每行一个非负整数，输出所求得的答案。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n3\n4 4\n67 75 63 10\n29 29 92 14\n21 68 71 56\n8 67 91 25\n2 3\n87 70 85\n10 3 17\n3 3\n1 1 1\n1 99 1\n1 1 1\n```\n\n#### 样例输出 #1\n\n```\n271\n172\n99\n```\n\n#### 提示\n\n对于第1组数据，取数方式如下：\n\n[67] 75 63 10\n\n29 29 [92] 14\n\n[21] 68 71 56\n\n8 67 [91] 25\n\n对于$20\\%$的数据，$N, M≤3$；\n\n对于$40\\%$的数据，$N,M≤4$；\n\n对于$60\\%$的数据，$N, M≤5$；\n\n对于$100\\%$的数据，$N, M≤6,T≤20$。\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t对于本题，如果使用贪心法，每次去最大值，那么可以发现有问题。因为每取一个数，相邻的数就不能再取，那么每次决策就会影响下次结果，从而导致贪心决策不能最优化。动态规划也是如此，在动态规划中，每一个分步决策不能影响后续结果，所以此算法也排除。\n\n​\t\t根据数据范围，所以可以考虑暴力枚举，而对于一个图，以及一个变化的状态，深度优先搜索（dfs） 应该是一个比较适合的算法。\n再考虑每个数的状态。显然，对于一个数，有取与不取两种状态，状态改变取决于周围取数的变化。我们用 mark[ i ][ j ] 记录点 ( i , j ) 附近有几个数，若 mark[i] [j] ! = 0 就代表不能取这个数。\n\n### 算法代码\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int d[8][2]={1,0,-1,0,0,1,0,-1,1,1,-1,1,1,-1,-1,-1};//方向数组用来控制搜索时的方向 \nint t,n,m,s[8][8],mark[8][8],ans,mx;\n\nvoid dfs(int x,int y){//搜索函数，表示搜索点(x,y) \n\tif(y==m+1){//当y到边界时，搜索下一行 \n\t\tdfs(x+1,1);\n\t\treturn;\n\t}\n\tif(x==n+1){//当x到边界时，搜索结束，刷新最大值 \n\t\tmx=max(ans,mx);\n\t\treturn;\n\t}\n\t\n\tdfs(x,y+1);// 不取此数的情况 \n\t\n\tif(mark[x][y]==0){ //取此数的情况（需保证此数周围没有取其他数，即mark[i][j]==0）\n\t\tans+=s[x][y];\n\t\tfor(int fx=0;fx<8;++fx){ //标记周围的数 \n\t\t\t++mark[x+d[fx][0]][y+d[fx][1]];\n\t\t}\n\t\tdfs(x,y+1);\n\t\tfor(int fx=0;fx<8;++fx){ //回溯 \n\t\t\t--mark[x+d[fx][0]][y+d[fx][1]];\n\t\t}\n\t\tans-=s[x][y];\n\t}\n\t\n}\nint main(){\n\tcin>>t; \n\twhile(t--){\n\t\tmemset(s,0,sizeof(s));\n\t\tmemset(mark,0,sizeof(mark));//在做每个数据前都要初始化数组 \n\t\tcin>>n>>m;\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tfor(int j=1;j<=m;++j){\n\t\t\t\tcin>>s[i][j];\n\t\t\t}\n\t\t}\n\t\tmx=0;\n\t\tdfs(1,1);//从点(1,1)开始搜索 \n\t\tcout<<mx<<endl;\n\t}\n\treturn 0;\n}\n```\n\n## 总结与讨论\n\n​\t\t主要需要确定算法和考虑标记状态。\n\n\n\n# P1576 最小花费\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1576\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n在 $n$ 个人中，某些人的银行账号之间可以互相转账。这些人之间转账的手续费各不相同。给定这些人之间转账时需要从转账金额里扣除百分之几的手续费，请问 $A$ 最少需要多少钱使得转账后 $B$ 收到 $100$ 元。\n\n### 输入格式\n\n第一行输入两个正整数 $n,m$，分别表示总人数和可以互相转账的人的对数。\n\n以下 $m$ 行每行输入三个正整数 $x,y,z$，表示标号为 $x$ 的人和标号为 $y$ 的人之间互相转账需要扣除 $z\\%$ 的手续费 $(z<100)$。\n\n最后一行输入两个正整数 $A,B$。数据保证 $A$ 与 $B$ 之间可以直接或间接地转账。\n\n### 输出格式\n\n输出 $A$ 使得 $B$ 到账 $100$ 元最少需要的总费用。精确到小数点后 $8$ 位。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n3 3                                     \n1 2 1\n2 3 2\n1 3 3\n1 3\n```\n\n#### 样例输出 #1\n\n```\n103.07153164\n```\n\n#### 提示\n\n$1\\le n \\le 2000,m\\le 100000$。\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t将本题抽象化之后不难发现本题就是最短路径问题，可采用Dijkstra算法解决。最小花费就是把每个人看做一个点，每次转账看做一个边，把花费看做边权，并且要建双向边。 i，j互相转账就相当于节点i和j之间有一条权值为（1-z%）的边，求一条路径使路径上各边权值乘积最大。结果就是100/max。 \n\n### 算法代码\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n,m,a,b;//意思如题意\nbool mark[2005];//记下该点有无被遍历过\ndouble d[2005];//B点到该点的费用\nvector < pair <int,int> > s[2005];//用可变数组来记两点之间能否到达和费用如何，相较于普通数组更加方便\nmultiset <pair <int,int> > f;//multiset里用pair 是按前面的数排序\n\nvoid dij() {\n\tfor(int i=1; i<=n; i++) d[i]=1e9;//若B到达不了，则费用无限大\n\td[b]=100;//B到B，100元\n\tf.insert(make_pair(d[b],b));\n\tfor(int i=1; i<=n; i++) {\n\t\twhile(!f.empty()&&mark[(*f.begin()).second]) f.erase(f.begin());//如果该点被遍历过则不要\n\t\tint p=(*f.begin()).second;//遍历点\n\t\tmark[p]=1;\n\t\tfor(int j=0; j<s[p].size(); j++) {\n\t\t\tint h=s[p][j].second,z=s[p][j].first;//h为加入点\n\t\t\tdouble mon=d[p]/(100-z)*100;//费用\n\t\t\tif(mon<d[h]) {\n\t\t\t\td[h]=mon;\n\t\t\t\tf.insert(make_pair(d[h],h));\n\t\t\t}//取最小，加入。\n\t\t}\n\t}\n}\nint main() {\n\tcin>>m>>n;\n\tfor(int i=0; i<m; i++) {\n\t\tint u,v,w;//u、v为点，w为费用\n\t\tcin>>u>>v>>w;\n\t\ts[u].push_back(make_pair(w,v));\n\t\ts[v].push_back(make_pair(w,u));\n\t}\n\tcin>>a>>b;\n\tdij();\n\tprintf(\"%.8f\",d[a]);\n\treturn 0;\n}\n```\n\n## 总结与讨论\n\n​\t\t本题可以借助数据结构，更加方便，如堆，优先队列，multiset。\n\n\n\n# P2141 [NOIP2014 普及组] 珠心算测验\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P2141\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n珠心算是一种通过在脑中模拟算盘变化来完成快速运算的一种计算技术。珠心算训练，既能够开发智力，又能够为日常生活带来很多便利，因而在很多学校得到普及。\n\n\n某学校的珠心算老师采用一种快速考察珠心算加法能力的测验方法。他随机生成一个正整数集合，集合中的数各不相同，然后要求学生回答：其中有多少个数，恰好等于集合中另外两个（不同的）数之和？\n\n\n最近老师出了一些测验题，请你帮忙求出答案。\n\n\n(本题目为 2014NOIP 普及 T1)\n\n### 输入格式\n\n共两行，第一行包含一个整数 $n$，表示测试题中给出的正整数个数。\n\n\n第二行有 $n$ 个正整数，每两个正整数之间用一个空格隔开，表示测试题中给出的正整数。\n\n### 输出格式\n\n一个整数，表示测验题答案。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n4\n1 2 3 4\n```\n\n#### 样例输出 #1\n\n```\n2\n```\n\n#### 提示\n\n【样例说明】\n\n\n由 $1+2=3,1+3=4$，故满足测试要求的答案为 $2$。  \n\n注意，加数和被加数必须是集合中的两个不同的数。\n\n\n【数据说明】\n\n\n对于 $100\\%$ 的数据，$3 \\leq n \\leq 100$，测验题给出的正整数大小不超过 $10,000$。\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t采用三个数组，一个存储数值，另外两个标记数值状态。其中一个存储输入数值的状态，另一个存储数值相加之和的状态。最后遍历两个数组即可。\n\n### 算法代码\n\n```\n#include<iostream>\n#include<cstdio>\nusing namespace std;\nint t[200005],g[200005];\nint n,a[105],ans;\nint main(){\n    cin>>n;\n    for (int i=1;i<=n;i++){\n        cin>>a[i];//读入\n        g[a[i]]=1;//在集合中赋值为1\n    }\n    for (int i=1;i<n;i++){//枚举\n        for (int j=i+1;j<=n;j++){\n            t[a[i]+a[j]]++;//被加出来了\n        }\n    }\n    for (int i=1;i<=200002;i++){\n        if (t[i]>0&&g[i]) ans++;//判断是否满足，满足ans++\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n```\n\n## 总结与讨论\n\n​\t\t此题算法简单，暴力算法即可求解，倘若数据范围未给出或者指明很大，则另当别论。\n\n\n\n# P1004 [NOIP2000 提高组] 方格取数\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1004\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n设有 $N \\times N$ 的方格图 $(N \\le 9)$，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 $0$。如下图所示（见样例）:\n\n```plain\nA\n 0  0  0  0  0  0  0  0\n 0  0 13  0  0  6  0  0\n 0  0  0  0  7  0  0  0\n 0  0  0 14  0  0  0  0\n 0 21  0  0  0  4  0  0\n 0  0 15  0  0  0  0  0\n 0 14  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0\n                         B\n```\n某人从图的左上角的 $A$ 点出发，可以向下行走，也可以向右走，直到到达右下角的 $B$ 点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 $0$）。  \n此人从 $A$ 点到 $B$ 点共走两次，试找出 $2$ 条这样的路径，使得取得的数之和为最大。\n\n### 输入格式\n\n输入的第一行为一个整数 $N$（表示 $N \\times N$ 的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的 $0$ 表示输入结束。\n\n### 输出格式\n\n只需输出一个整数，表示 $2$ 条路径上取得的最大的和。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n8\n2 3 13\n2 6  6\n3 5  7\n4 4 14\n5 2 21\n5 6  4\n6 3 15\n7 2 14\n0 0  0\n```\n\n#### 样例输出 #1\n\n```\n67\n```\n\n#### 提示\n\nNOIP 2000 提高组第四题\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t本题采用深度优先算法解决，并且采用四维dp。之所以不用二维dp，原因在于，局部最优解不是全局最优解。\n\n​\t\t设dp[i] [j] [k] [l] 存放的是两个人同时分别走到i,j和k,l点时的最大路径和。易知，两个同时走的人均需遵守只能向下或向右的规则，那么两个人的选择2 x 2就一共有四种可能，即1.都往下走。2.一个往下，一个往右。3.一个往右，一个往下。4.都往右走。\n\n​\t\t倘若某格子有人走过了，另一个人倘若也需要经过那个格子，只需在原算法基础上减掉那个格子的值即可，而无需考虑将其数值置零的问题。\n\n### 算法代码\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\n\nint a[10][10];\nint dp[10][10][10][10];\n\nint main()\n{\n\tint n;\n\tcin >> n;\t\n\t//输入数据\n\tint x,y,num;\n\twhile (1){\n\t\tcin >> x >> y >> num;\n\t\tif ( !x && !y && !num )\n\t\t\tbreak;\n\t\ta[x][y] = num;\n\t}\t\n\t//四重循环\n\tint i,j,k,l;\n\tfor ( i=1; i<=n; ++i )\n\t\tfor ( j=1; j<=n; ++j )\n\t\t\tfor ( k=1; k<=n; ++k )\n\t\t\t\tfor ( l=1; l<=n; ++l ){\n\t\t\t\t\tdp[i][j][k][l] = max ( max (max ( dp[i-1][j][k-1][l], dp[i-1][j][k][l-1] ), dp[i][j-1][k-1][l] ), dp[i][j-1][k][l-1] ) + a[i][j] + a[k][l];\n\t\t\t\t\t//注意相同去重\n\t\t\t\t\tif ( i==k && j== l )\n\t\t\t\t\t\tdp[i][j][k][l] -= a[k][l];\n\t\t\t\t}\n\tcout << dp[n][n][n][n] << endl;\n}\n```\n\n## 总结与讨论\n\n​\t\t本题难点在于理解两次局部最优解和全局最优解的不同之处。对于四维dp理解不到位也很难写出该算法。\n\n\n\n# P1006 [NOIP2008 提高组] 传纸条\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1006\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排坐成一个 $m$ 行 $n$ 列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标 $(1,1)$，小轩坐在矩阵的右下角，坐标 $(m,n)$。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。\n\n在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。\n\n还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用 $0$ 表示），可以用一个 $[0,100]$ 内的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。现在，请你帮助小渊和小轩找到这样的两条路径。\n\n### 输入格式\n\n第一行有两个用空格隔开的整数 $m$ 和 $n$，表示班里有 $m$ 行 $n$ 列。\n\n接下来的 $m$ 行是一个 $m \\times n$ 的矩阵，矩阵中第 $i$ 行 $j$ 列的整数表示坐在第 $i$ 行 $j$ 列的学生的好心程度。每行的 $n$ 个整数之间用空格隔开。\n\n### 输出格式\n\n输出文件共一行一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n3 3\n0 3 9\n2 8 5\n5 7 0\n```\n\n#### 样例输出 #1\n\n```\n34\n```\n\n#### 提示\n\n**【数据范围】**\n\n对于 $30\\%$ 的数据，满足 $1 \\le m,n \\le 10$。  \n对于 $100\\%$ 的数据，满足 $1 \\le m,n \\le 50$。\n\n**【题目来源】**\n\nNOIP 2008 提高组第三题。\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t最好想的做法是四维dp，设f[i][j][k] [l]为从小渊传到小轩的纸条到达(i,j)，从小轩传给小渊的纸条到达(k,l)的路径上取得的最大的好心程度和。完全可以换一个思路想，即求从给定的起点出发走到指定位置的两条最短严格不相交路线。那么特别显然，转移方程是 f[i] [j] [k] [l]=max( f[i][j-1][k-1] [l] , f[i-1] [j] [k] [l-1] , f[i] [j-1] [k] [l-1] , f[i-1] [j] [k-1] [l] )+a[i] [j]+a[k] [l]。要小心l的枚举范围，应该是从j+1到m，只有这样，在枚举第二条路的时候可以控制下标的l不会和j有相等的可能，这样可以保证两条路一定不相交。由于终点的值是0，所以目标状态就是f[n] [m-1] [n-1] [m]。如果你不想这样做，那就让l直接从1枚举，但需要加一个判断，判断当前的(i,j)和(k,l)是不是重合了，如果重合那就把f数组对应的这个地方在转移后减掉一个a[i] [j]或者a[k] [l]。\n\n### 算法代码\n\n```\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#define maxn 55\nusing namespace std;\nint f[2 * maxn][maxn][maxn];\nint a[maxn][maxn];\nint n,m;\n \nint max_ele(int a,int b,int c,int d){\n    if (b>a)\n        a = b;\n    if (c>a)\n        a = c;\n    if (d>a)\n        a = d;\n    return a;\n}\n \nint main(){\n    cin >> n >> m;\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=m;j++)\n            cin >> a[i][j];\n    for (int k=1;k<=n+m-1;k++)\n        for (int i=1;i<=n;i++)\n            for (int j=1;j<=n;j++){\n                if (k-i+1<1 || k-j+1<1) //这里是判断纵坐标的合法性，如果纵坐标不合法那就跳过去\n                    continue;\n                 f[k][i][j] = max_ele(f[k-1][i][j],f[k-1][i-1][j-1],f[k-1][i][j-1],f[k-1][i-1][j]) + a[i][k-i+1] + a[j][k-j+1];\n                if (i==j) //判断重合路径\n                    f[k][i][j]-=a[i][k-i+1];\n            }\n \n \n    cout << f[n+m-1][n][n] << endl;\n    return 0;\n}\n```\n\n## 总结与讨论\n\n​\t\t算法时间复杂度是O(n^2 * m^2)。\n\n\n\n# P1018 [NOIP2000 提高组] 乘积最大\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1018\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n今年是国际数学联盟确定的“ 2000 ――世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰 90 周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友 XZ 也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：\n\n\n设有一个长度为 $N$ 的数字串，要求选手使用 $K$ 个乘号将它分成 $K+1$ 个部分，找出一种分法，使得这 $K+1$ 个部分的乘积能够为最大。\n\n\n同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：\n\n\n有一个数字串：$312$， 当 $N=3,K=1$ 时会有以下两种分法：\n\n1. $3  \\times  12=36$ \n2. $31  \\times   2=62$  \n\n\n这时，符合题目要求的结果是: $31  \\times  2 = 62$\n\n\n现在，请你帮助你的好朋友 XZ 设计一个程序，求得正确的答案。\n\n### 输入格式\n\n程序的输入共有两行：\n\n第一行共有 $2$ 个自然数 $N,K$\n\n第二行是一个长度为 $N$ 的数字串。\n\n### 输出格式\n\n结果显示在屏幕上，相对于输入，应输出所求得的最大乘积（一个自然数）。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n4  2\n1231\n```\n\n#### 样例输出 #1\n\n```\n62\n```\n\n#### 提示\n\n**数据范围与约定**\n\n对于 $60\\%$ 的测试数据满足 $6≤N≤20$。  \n对于所有测试数据，$6≤N≤40,1≤K≤6$。\n\nNOIp2000 提高组第二题\n\n## 算法\n\n### 问题分析与算法设计\n\n首先，这道题是显而易见的区间DP，那么，做这道题时，可以分为以下几步：\n1.确定状态，一般是f[i] [j]之类的，一般题目问什么，就设什么，这道题的状态定义为：f[ i ] [ j ]表示在前i个数中放j个乘号所得到的最大值。把这个状态带回题目，发现f[n−1] [k]恰为所求。\n2.确定阶段，这道题很显然是以乘号为阶段的，乘号具有明显的顺序性，即：先放完一个乘号，记录在DP数组中，放两个乘号是才能顺利调用之前的计算结果。\n3.确定状态转移方程：f[i] [j] = max(f[i] [j],f[i−1] [k−1]∗num(k,j))。\n4.初始化，这道题肯定是要初始化的，即 f [i] [0]时（前i个数中放0个乘号所得到的最大值就是i本身）\n\n### 算法代码\n\n```\n#include<bits/stdc++.h>\n\n#define INF 0x3f3f3f3f\n#define ll long long\n\nusing namespace std;\n\nstring s;\nll n,m,f[50][10];//f[i][j]:前i个数字放j个乘号\n\nll js(ll x,ll y)//将字符串从x位到y位转换为一个数字\n{\n\tll sum = 0;\n\tfor(int i = x;i <= y;++i)\n\t{\n\t\tsum = sum * 10;\n\t\tsum += s[i] - 48;\n\t}\n\treturn sum;\n}\n\nint main()\n{\n\tcin >> n >> m;\n\tcin >> s;\n\tfor(int i = 0;i < n;++i)\n\t{\n\t\tf[i][0] = js(0,i);//初始化\n\t}\n\tfor(int i = 1;i <= m;++i)//放i个乘号\n\t{\n\t\tfor(int j = i;j < n;++j)//在第j个位置放乘号，j不能=n，因为乘号必须要放在数字之间\n\t\t{\n\t\t\tfor(int k = i;k <= j;++k)//分割线\n\t\t\t{\n\t\t\t\tf[j][i] = max(f[j][i],f[k - 1][i - 1] * js(k,j));\n\t\t\t}\n\t\t}\n\t} \n\tcout << f[n - 1][m] << endl; \n\treturn 0;\n} \n```\n\n## 总结与讨论\n\n​\t\t或许暴力算法也能解决？\n\n\n\n# P1016 [NOIP1999 提高组] 旅行家的预算\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P1016\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n一个旅行家想驾驶汽车以最少的费用从一个城市到另一个城市（假设出发时油箱是空的）。给定两个城市之间的距离 $D_1$、汽车油箱的容量 $C$（以升为单位）、每升汽油能行驶的距离 $D_2$、出发点每升汽油价格$P$和沿途油站数 $N$（$N$ 可以为零），油站 $i$ 离出发点的距离 $D_i$、每升汽油价格 $P_i$（$i=1,2,…,N$）。计算结果四舍五入至小数点后两位。如果无法到达目的地，则输出 `No Solution`。\n\n### 输入格式\n\n第一行，$D_1$，$C$，$D_2$，$P$，$N$。\n\n接下来有 $N$ 行。\n\n第 $i+1$ 行，两个数字，油站 $i$ 离出发点的距离 $D_i$ 和每升汽油价格 $P_i$。\n\n### 输出格式\n\n所需最小费用，计算结果四舍五入至小数点后两位。如果无法到达目的地，则输出 `No Solution`。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n275.6 11.9 27.4 2.8 2\n102.0 2.9\n220.0 2.2\n```\n\n#### 样例输出 #1\n\n```\n26.95\n```\n\n#### 提示\n\n$N \\le 6$，其余数字$ \\le 500$。\n\n## 算法\n\n### 问题分析与算法设计\n\n首先做如下定义：加油站距离数组dis[n+2], 汽油价格数组pri[n+2], 两者一一对应。\n\n接着对这两个数组初始化，dis[0] = 0; pri[0] = p; // 将出发点的距离 0 和 油价p 放入数组\n\n　　　　　　　　　　　　　　dis[n+1] = d1; pri[n+1] = 0; // 终点的距离 d1, 油价 0 放入数组\n\n将之后输入的N行数据按照距离从小到大排列，需要注意的是，交换距离的时候需要将对应的价格也交换。\n\n那么只需要从距离最小的点开始出发，依次进行计算。\n\n### 算法代码\n\n```\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef struct\n{\n    double dis;\n    double price;\n}station;\nint wrong=99999;\nstation st[100000];\ndouble d1,c,d2,p;\nint n;\nint now;//当前所在位置\nint t;\ndouble maxn;//最远走到哪里\n\ndouble res;//剩余；\ndouble price_sum=0;//总价钱\nint cmp(station a,station b)\n{\n    return a.dis<b.dis;\n}\nint func(int now)\n{\n    int index=wrong;//next\n    for(int i=now+1;i<=n&&st[i].dis-st[now].dis<=maxn;i++)//找能到的加油站\n    {\n        if(st[i].price<st[now].price)//能到&&便宜\n        {\n            price_sum+=(st[i].dis-st[now].dis)/d2*st[now].price;\n            res=0;\n            return i;\n        }\n        if(index==wrong||st[i].price<st[index].price)\n            index=i;//能到，不便宜\n\n    }\n    if(d1-st[now].dis<=maxn)//没有更便宜的，且能到终点了\n    {\n        price_sum+=(d1-st[now].dis-res)/d2*st[now].price;\n        return wrong;\n    }\n    if(index==wrong)\n    {\n        //到不了下个站\n        cout<<\"No Solution\"<<endl;\n        return -1;\n    }\n\n    else//没有更便宜的，又不能一次到终点\n    {\n        price_sum+=c*st[now].price;\n        res+=(maxn-(st[index].dis-st[now].dis));\n        return index;\n    }\n}\nint main()\n{\n\n    cin>>d1>>c>>d2>>p>>n;\n\n    st[0].dis=0;\n    st[0].price=p;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>st[i].dis>>st[i].price;\n    }\n\n    sort(st,st+n+1,cmp);\n    now=0;\n    maxn=c*d2;\n\n    do\n    {\n        t=func(now);\n        now=t;\n        if(t==-1)\n            return 0;\n    }while(t!=wrong);\n\n    cout<<fixed<<setprecision(2)<<price_sum<<endl;\n    return 0;\n}\n```\n\n## 总结与讨论\n\n​\t\t需要注意的地方：1、每次都需要判断是否能够到达下一个加油站，如果无法到达，则直接退出。\n\n　　　　　　　　\t\t2、每次在当前能够走到的最远距离内进行判断，寻找是否有比当前油价更低的加油站。如果没有更低的，价格相等也可以。\n\n　　　　　　　　\t\t3、由于最后一点 pir[n+1]  的油价为0，所以要对其特殊处理。\n\n\n\n# P2434 [SDOI2005]区间\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P2434\n- 登陆账号：SkyTravelar\n\n## 题目描述\n\n现给定 $n$ 个闭区间 $[a_i, b_i]$（$1 \\le i \\le n$）。这些区间的并可以表示为一些不相交的闭区间的并。你的任务就是在这些表示方式中找出包含最少区间的方案。你的输出应该按照区间的升序排列。这里如果说两个区间 $[a, b]$ 和 $[c, d]$ 是按照升序排列的，那么我们有 $a \\le b < c \\le d$。\n\n请写一个程序：\n\n读入这些区间；\n\n计算满足给定条件的不相交闭区间；\n\n把这些区间按照升序输出。\n\n### 输入格式\n\n第一行包含一个整数 $n$（$3 \\le n \\le 50000$）为区间的数目。  \n以下 $n$ 行为对区间的描述，第 $i$ 行为对第 $i$ 个区间的描述，为两个整数 $a_i, b_i$（$1 \\le a _ i \\leq b _ i \\le 1000000$），表示一个区间 $[a_i, b_i]$。\n\n### 输出格式\n\n输出计算出来的不相交的区间。每一行都是对一个区间的描述，包括两个用空格分开的整数，为区间的上下界。你应该把区间按照升序排序。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n5\n5 6\n1 4\n10 10\n6 9\n8 10\n```\n\n#### 样例输出 #1\n\n```\n1 4\n5 10\n```\n\n#### 提示\n\n对于 $100 \\%$ 的数据，$3 \\le n \\le 50000$，$1 \\le a _ i \\leq b _ i \\le 1000000$。\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t将所有区间按左端点排序，然后将n个区间扫一遍，若能合并成一个大区间便合并， 并用l,r记录当前区间的左右端点，若不能合并（即q[i].l>r），输出，并重置l,r\n\n### 算法代码\n\n```\n#include <bits/stdc++.h>\n#define N 50005\nusing namespace std;\n \nint n; \n \nstruct node\n{\n    int l,r;\n}q[N];\nbool cmp(node x,node y) {return x.l<y.l;}\n \nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%d%d\",&q[i].l,&q[i].r);\n    sort(q+1,q+1+n,cmp);\n    int l=q[1].l,r=q[1].r;\n    for(int i=2;i<=n;i++)\n    {\n        if(q[i].l>r)\n        {\n            printf(\"%d %d\\n\",l,r);\n            l=q[i].l;r=q[i].r;\n        }\n        else r=max(r,q[i].r);\n    }\n    printf(\"%d %d\",l,r);\n    return 0;\n}\n```\n\n## 总结与讨论\n\n​\t\t这题也可用线段树完成，先将每一段区间插入线段树，然后用两个指针l=1,r=1扫[l,r]，若区间[l,r]被覆盖，r++,若不是，重置l,r，并在 l !=r时输出\n\n\n\n# P3842 [TJOI2007]线段\n\n## 题目描述\n\n在一个 $n \\times n$ 的平面上，在每一行中有一条线段，第 $i$ 行的线段的左端点是$(i, L_{i})$，右端点是$(i, R_{i})$。\n\n你从 $(1,1)$ 点出发，要求沿途走过所有的线段，最终到达 $(n,n)$ 点，且所走的路程长度要尽量短。\n\n更具体一些说，你在任何时候只能选择向下走一步（行数增加 $1$）、向左走一步（列数减少 $1$）或是向右走一步（列数增加 $1$）。当然，由于你不能向上行走，因此在从任何一行向下走到另一行的时候，你必须保证已经走完本行的那条线段。\n\n### 输入格式\n\n第一行有一个整数 $n$。\n\n以下 $n$ 行，在第 $i$ 行（总第 $(i+1)$ 行）的两个整数表示 $L_i$ 和 $R_i$。\n\n### 输出格式\n\n仅包含一个整数，你选择的最短路程的长度。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n6\n2 6\n3 4\n1 3\n1 2\n3 6\n4 5\n```\n\n#### 样例输出 #1\n\n```\n24\n```\n\n#### 提示\n\n我们选择的路线是\n\n```\n (1, 1) (1, 6)\n (2, 6) (2, 3)\n (3, 3) (3, 1)\n (4, 1) (4, 2)\n (5, 2) (5, 6)\n (6, 6) (6, 4) (6, 6)\n```\n不难计算得到，路程的总长度是 $24$。 \n\n对于 $100\\%$ 的数据中，$n \\le 2 \\times 10^4$，$1 \\le L_i \\le R_i \\le n$。\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t比较典型的DP，首先先想，每一层的最优肯定是由上一层限制的左端点或者右端点下来得到的，那么就可以有状态转移方程了。f[i] [0]表示走完第i行且停在第i行的左端点最少用的步数，f[i] [1]同理，停在右端点的最少步数。\n​\t\t那么转移就很简单了，走完当前行且停到左端点，那么一定是从右端点过来的，那么从上一行左端点转移的话就是f[i] [0]=abs(上一行左端点的坐标-本行右端点的坐标+本行线段长度)\n\n### 算法代码\n\n```\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,hang,ans=0;\nint l[20005];\nint r[20005];\nint f[29999][3];//F[X][0] left max \n\nint main(){\n scanf(\"%d\",&n);\n for(int i=1;i<=n;i++) scanf(\"%d%d\",&l[i],&r[i]);\n f[1][1]=r[1]-1;\n f[1][0]=r[1]-1+r[1]-l[1];\n for(int i=2;i<=n;i++){\n   if(l[i-1]>=r[i]){\n      f[i][1]=min(r[i]-l[i]+r[i]-l[i]+f[i-1][0]+1+l[i-1]-r[i],r[i]-l[i]+r[i]-l[i]+f[i-1][1]+1+r[i-1]-r[i]);\n      f[i][0]=min(f[i-1][0]+1+l[i-1]-l[i],f[i-1][1]+1+r[i-1]-l[i]); \n      }\n      else if(r[i-1]<=l[i]) {\n       f[i][0]=min(r[i]-l[i]+r[i]-l[i]+f[i-1][1]+1+l[i]-r[i-1],r[i]-l[i]+r[i]-l[i]+f[i-1][0]+1+l[i]-l[i-1]);\n       f[i][1]=min(f[i-1][1]+1+r[i]-r[i-1],f[i-1][0]+1+r[i]-l[i-1]);\n   }\n   else if(l[i]<=l[i-1]&&r[i]>=r[i-1]){\n    f[i][0]=min(r[i]-l[i]+f[i-1][1]+1+r[i]-r[i-1],r[i]-l[i]+r[i]-l[i]+f[i-1][0]+1+l[i-1]-l[i]);\n    f[i][1]=min(r[i]-l[i]+r[i]-l[i]+f[i-1][1]+1+r[i]-r[i-1],r[i]-l[i]+f[i-1][0]+1+l[i-1]-l[i]); \n   }\n   else if(l[i]>=l[i-1]&&r[i]<=r[i-1]){\n    f[i][0]=min(r[i]-l[i]+f[i-1][1]+1+r[i-1]-r[i],r[i]-l[i]+r[i]-l[i]+f[i-1][0]+1+l[i]-l[i-1]);\n    f[i][1]=min(r[i]-l[i]+r[i]-l[i]+f[i-1][1]+1+r[i-1]-r[i],r[i]-l[i]+f[i-1][0]+1+l[i]-l[i-1]);\n   }\n   else if(l[i]>=l[i-1]&&l[i]<=r[i-1]){\n    f[i][0]=min(r[i]-l[i]+f[i-1][1]+1+r[i]-r[i-1],r[i]-l[i]+r[i]-l[i]+f[i-1][0]+1+l[i]-l[i-1]);\n    f[i][1]=min(r[i-1]-l[i]+r[i]-l[i]+f[i-1][1]+1,f[i-1][0]+1+r[i]-l[i-1]); \n   }\n   else if(r[i]>=l[i-1]&&r[i]<=r[i-1]){\n    f[i][1]=min(r[i]-l[i]+r[i]-l[i]+f[i-1][1]+1+r[i-1]-r[i],r[i]-l[i]+l[i-1]-l[i]+f[i-1][0]+1);\n    f[i][0]=min(r[i]-l[i]+f[i-1][1]+1+r[i-1]-r[i],r[i]-l[i]+f[i-1][0]+1+r[i]-l[i-1]);\n   } \n }\n ans=min(f[n][0]+n-l[n],f[n][1]+n-r[n]);\n cout<<ans;\n return 0;\n} \n```\n\n## 总结与讨论\n\n​\t\t贪心算法基本不可解。\n\n\n\n# P5414 [YNOI2019] 排序\n\n## 题目描述\n\n对于一个数列 $\\{7, 1, 2, 3\\}$ 进行排序，我们可以把 $7$ 从头移动到尾。但是这个操作的成本是 $7$，并不是最佳的。最佳的排序方式是将连续的 $1,2,3$ 移动到 $7$ 的前面。这样的话，总的操作成本就是 $1+2+3=6$，比之前的成本 $7$ 要小。\n\n你的任务是，对于一个给定的数列，输出对这个数列进行排序的最小成本。\n\n### 输入格式\n\n输入文件名为sort.in。\n\n每个输入文件包含多组数据。\n\n输入文件的第一行，包含一个正整数 $T$，代表该输入文件中所含的数据组数。\n\n接下来是 $T$ 组数据，每组数据的格式如下：\n\n每组数据包含 $2$ 行；\n\n第一行包含一个正整数 $n$，代表数列中元素的个数，其中 $0 < n \\leq 10^2$；\n\n第二行包含 $n$ 个整数，两个数之间以一个空格隔开，代表数列中的元素 $k_i$，其中$-10^{7} \\leq k_i \\leq 10^{7}$。\n\n### 输出格式\n\n输出文件名为sort.out。\n\n输出文件包含 $T$ 行，分别对应 $T$ 组数据的答案，即对数列进行排序的最小成本。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n1\n4\n7 1 2 3\n```\n\n#### 样例输出 #1\n\n```\n6\n```\n\n#### 提示\n\n对于 $60\\%$ 的数据：$0 < n \\leq 60$，$-10^{7} \\leq k_i \\leq 10^{7}$\n\n对于 $80\\%$ 的数据：$0 < n \\leq 80$，$-10^{7} \\leq k_i \\leq 10^{7}$\n\n对于 $100\\%$ 的数据：$0 < n ≤ 10^2$，$-10^{7} \\leq k_i \\leq 10^{7}$\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t这道题就是移动几个数字使得数列单调上升，每次移动可以移动到任意位置，花费就是移动数字的大小。看到这个题之后，我们可以得到 ：最优解不可能把同一个数字移动2次及以上。既然我们可以一次把它移到正确的位置上，那么这个数字就可以理解为直接被移走了。那么问题就变成了：删除几个数字，使得数列单调递增，所求的是移走数字的最小和。 使得删除的和最小，就意味着留下的和最大。那么问题就变成了：保留几个单调递增的数字，使得和最大。\n\n### 算法代码\n\n```\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N=205;\nint a[N],dp[N];\n\nint read(){\n\tint x=0; \n\tchar c=getchar();\n\twhile(c<'0'||c>'9') \n\t\tc=getchar();\n\twhile('0'<=c&&c<='9'){ \n\t\tx=(x<<3)+(x<<1)+(c^48); \n\t\tc=getchar();\n\t}\n\treturn x;\n}\n\nint main(){\n\tint i,j,n;\n\tfor(int T=read(),sum=0,ans=0;T;T--,sum=0,ans=0){\n\t\tn=read(); \n\t\tfor(i=1;i<=n;i++){\n\t\t\ta[i]=read(),sum+=a[i];\n\t\t\tfor(j=1;j<i;j++)\n\t\t\t\tif(a[j]<=a[i]&&dp[i]<dp[j])\n\t\t\t\t\tdp[i]=dp[j];\n\t\t\tdp[i]+=a[i];\n\t\t}\n\t\tfor(i=1;i<=n;i++)\n\t\t\tans=max(ans,dp[i]);\n\t\tprintf(\"%d\\n\",sum-ans);\n\t}\n}\n```\n\n## 总结与讨论\n\n​\t\t将问题转化之后其实并不是太难。\n\n\n\n# P2023 [AHOI2009] 维护序列\n\n## 问题来源及登录账号\n\n- 问题来源：洛谷\n- 问题号：P2023\n- 登陆账号：SkyTravelar\n\n## 题目背景\n\n老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。\n\n## 题目描述\n\n有一个长为 $n$ 的数列 $\\{a_n\\}$，有如下三种操作形式：\n\n1. 格式 `1 t g c`，表示把所有满足 $t\\le i\\le g$ 的 $a_i$ 改为 $a_i\\times c$ ;\n2. 格式 `2 t g c` 表示把所有满足 $t\\le i\\le g$ 的 $a_i$ 改为 $a_i+c$ ;\n3. 格式 `3 t g` 询问所有满足 $t\\le i\\le g$ 的 $a_i$ 的和，由于答案可能很大，你只需输出这个数模 $p$ 的值。\n\n### 输入格式\n\n第一行两个整数 $n$ 和 $p$。\n\n第二行含有 $n$ 个非负整数，表示数列 $\\{a_i\\}$ 。\n\n第三行有一个整数 $m$，表示操作总数。\n\n从第四行开始每行描述一个操作，同一行相邻两数之间用一个空格隔开，每行开头和末尾没有多余空格。\n\n### 输出格式\n\n对每个操作 3，按照它在输入中出现的顺序，依次输出**一行一个整数**表示询问结果。\n\n### 样例 #1\n\n#### 样例输入 #1\n\n```\n7 43\n1 2 3 4 5 6 7\n5\n1 2 5 5\n3 2 4\n2 3 7 9\n3 1 3\n3 4 7\n```\n\n#### 样例输出 #1\n\n```\n2\n35\n8\n```\n\n#### 提示\n\n##### 样例输入输出 1 解释\n\n- 初始时数列为 $\\{1,2,3,4,5,6,7\\}$。\n- 经过第 $1$ 次操作后，数列为 $\\{1,10,15,20,25,6,7\\}$。\n- 对第 $2$ 次操作，和为 $10+15+20=45$，模 $43$ 的结果是 $2$。\n- 经过第 $3$ 次操作后，数列为 $\\{1,10,24,29,34,15,16\\}$。\n- 对第 $4$ 次操作，和为 $1+10+24=35$，模 $43$ 的结果是 $35$。\n- 对第 $5$ 次操作，和为 $29+34+15+16=94$，模 $43$ 的结果是$8$。\n\n\n##### 数据规模与约定\n\n测试数据规模如下表所示：\n\n| 数据点编号 |  1   |   2    |   3    |    4    |    5    |    6    |    7    |    8    |   9,10   |\n| :--------: | :--: | :----: | :----: | :-----: | :-----: | :-----: | :-----: | :-----: | :------: |\n|    $n=$    | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |\n|    $m=$    | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |\n\n对于全部的测试点，保证 $0 \\leq p, a_i, c \\leq 10^9$，$1 \\leq t \\leq g \\leq n$。\n\n## 算法\n\n### 问题分析与算法设计\n\n​\t\t本题较之平常的线段树,会有一点不同.就是多了一个乘的操作.所以我们需要令一个优先级,即先乘后加.因为加无论什么时候加都没有关系,但是乘会对整个答案产生影响.于是乎,只要打两个标记.在乘的时候,加的标记也要乘上那个值.\n\n### 算法代码\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=2e5+1;\nstruct Node{\n\tll l;\n\tll r;\n\tll k;\n\tll add;\n\tll mul;\n}tree[N*4];\nll n,m,Mod,pos;\ninline ll build_tree(ll value,ll l,ll r){\n\ttree[value]=Node{l,r,0,0,1};\n\tif (l==r){\n\t\tll num;\n\t\tscanf(\"%lld\",&num);\n\t\treturn tree[value].k=num%Mod;\n\t}\n\tll mid=(l+r)>>1;\n\treturn tree[value].k=(build_tree(value*2,l,mid)+build_tree(value*2+1,mid+1,r))%Mod;\n}\ninline void pushdown(ll value){\n\ttree[value*2].add=(tree[value].add+tree[value*2].add*tree[value].mul)%Mod;\n\ttree[value*2+1].add=(tree[value].add+tree[value*2+1].add*tree[value].mul)%Mod;\n\ttree[value*2].mul=(tree[value].mul*tree[value*2].mul)%Mod;\n\ttree[value*2+1].mul=(tree[value].mul*tree[value*2+1].mul)%Mod;\n\ttree[value*2].k=(tree[value].mul*tree[value*2].k+tree[value].add*(tree[value*2].r-tree[value*2].l+1))%Mod;\n\ttree[value*2+1].k=(tree[value].mul*tree[value*2+1].k+tree[value].add*(tree[value*2+1].r-tree[value*2+1].l+1))%Mod;\n\ttree[value].add=0;\n\ttree[value].mul=1;\n}\ninline ll query(ll value,ll L,ll R){\n\tpushdown(value);\n\tif (tree[value].l>=L&&tree[value].r<=R)\n\t\treturn tree[value].k%Mod;\n\tll mid=(tree[value].l+tree[value].r)>>1;\n    return ((L<=mid?query(value*2,L,R):0)+(R>mid?query(value*2+1,L,R):0))%Mod;\n}\ninline void updata(ll value,ll x,ll pos,ll L,ll R){\n\tpushdown(value);\n\tif (pos==1&&tree[value].l>=L&&tree[value].r<=R){\n\t\ttree[value].mul=(tree[value].mul*x)%Mod;\n        tree[value].add=(tree[value].add*x)%Mod;\n        tree[value].k=(tree[value].k*tree[value].mul)%Mod;\n        return;\n\t}\n\tif(pos==2&&tree[value].l>=L&&tree[value].r<=R){\n        tree[value].add=(tree[value].add+x)%Mod;\n        tree[value].k=(tree[value].k+tree[value].add*(tree[value].r-tree[value].l+1))%Mod;\n        return;\n    }\n    ll mid=(tree[value].l+tree[value].r)/2;\n    if(L<=mid)\n        updata(value*2,x,pos,L,R);\n    if(R>mid)\n        updata((value*2)+1,x,pos,L,R);\n    tree[value].k=(tree[value*2].k+tree[value*2+1].k)%Mod;\n}\nint main(){\n\tscanf(\"%lld%lld\",&n,&Mod);\n\tbuild_tree(1,1,n);\n\tcin>>m;\n\tfor (ll i=1;i<=m;i++){\n\t\tcin>>pos;\n\t\tll x,y;\n\t\tcin>>x>>y; \n\t\tif (pos!=3){\n\t\t\tll k;\n\t\t\tcin>>k;\n\t\t\tupdata(1,k,pos,x,y);\n\t\t}\n\t\telse if (pos==3)\n\t\t\tprintf(\"%lld\\n\",query(1,x,y));\n\t}\n}\n```\n\n## 总结与讨论\n\n​\t\t难","tags":["算法分析与设计"]},{"title":"十六进制转二进制并输出","url":"/2023/04/26/12/","content":"\n要求如下:\n\n- 从键盘输入两个四位十六进制数。\n- 将这两个数以二进制形式输出，要求输出的0和1颜色交替变化。\n- 找出这两个数中的偶数，若有则以十进制输出，若无，输出“NO”。\n- 计算这两个数的平方和。\n- 数据的输入和结果的输出都要有必要的提示，且提示独占一行。\n- 要使用到子程序。\n\n实现如下：\n\n```\ndata segment\n  str1 db 0ah,0dh,'Input number1 :',0ah,0dh,'$'\n  str2 db 0ah,0dh,'Input number2 :',0ah,0dh,'$' \n  str3 db 0ah,0dh,'Output number1 bin :',0ah,0dh,'$'\n  str4 db 0ah,0dh,'Output number2 bin :',0ah,0dh,'$'\n  str5 db 0ah,0dh,'Judge number1 oushu :',0ah,0dh,'$'\n  str6 db 0ah,0dh,'Judge number2 oushu :',0ah,0dh,'$'\n  str7 db 0ah,0dh,'Output powsum :',0ah,0dh,'$'\n  str8 db 0ah,0dh,'Program End !!!',0ah,0dh,'$'\nnum dw 2 dup(?)\n  str db 5,?,5 dup(?)\n  a dw ?\n  d dw ?\n  f dw ?\ndata ends\ncode segment\n  assume cs:code,ds:data\n  main proc far             ;主函数\nstart:\n  mov ax,data\n  mov ds,ax\n  \n  lea dx,str1\n  mov ah,09h\n  int 21h\n  call input\n  mov ax,num                \n  mov num+2,ax              ;将输入的第一个16进制数存到num+2中\n\n  lea dx,str2\n  mov ah,09h\n  int 21h\n  call input                ;第二个输入的16进制数存到num中\n  \n  lea dx,str3\n  mov ah,09h\n  int 21h\n  mov bx,num+2\n  call bin                  ;将第一个数以2进制输出\n  \n  lea dx,str4\n  mov ah,09h\n  int 21h\n  mov bx,num\ncall bin                  ;将第二个数以2进制输出\n\n  lea dx,str5\n  mov ah,09h\n  int 21h\n  mov bx,num+2\n  call oushu                ;判断第一个数是否为偶数\n\n  lea dx,str6\n  mov ah,09h\n  int 21h\n  mov bx,num\n  call oushu                ;判断第二个数是否为偶数\n  \n  lea dx,str7\n  mov ah,09h\n  int 21h\n  call powsum               ;将两数平方相加并以16进制输出\n\n  lea dx,str8\n  mov ah,09h\n  int 21h\n\n  mov ax,4c00h\n  int 21h  \nmain endp\n\ninput proc near              ;子程序1：输入16进制数\n  lea dx,str\n  mov ah,0ah\n  int 21h\n  lea si,str+2\n  mov cx,4\n  mov dx,0\nA1:\n push cx                    ;保护cx防止被后面左移改变\n  mov al,[si]\n  cmp al,'0'                 ;判断与0的大小，小于则退出\n  jb A4\n  cmp al,'F'                 ;判断与F的大小，大于则退出\n  ja A4\n  cmp al,'9'                 ;判断与9的大小\njbe A2\n  sub al,07h\nA2: \n  sub al,30h\n  cbw                        ;扩大al为ax，用于存4位16进制数\n  add dx,ax                  ;加到dx，dx用来存每次变化后的结果\n  cmp cx,1                   ;防止在将第4位数加入后仍左移\n  jz A3\n  mov cl,4\n  shl dx,cl                  ;dx左移4位，便于下一位16进制数加入dx\nA3:\n  inc si\n  pop cx\n  loop A1\nA4: \n  mov num ,dx  \n  ret\ninput endp \n\nbin proc near                ;子程序2：输出2进制，颜色交替\n  mov cx,8                   ;循环8次，每次输出两位颜色交替2进制数\n  mov dx,0\nB1:\n  mov ax,0\n  shl bx,1\n  adc al,0                   ;循环左移1位，将cf表示位最高位2进制数\n  push cx                    ;保护cx避免后面重复输出1次时发生改变\n  push bx                    ;保护bx避免改变\n  add al,30h\n  mov cx,1\n  mov bl,04h                ;设置为红色\n  mov bh,0\n  mov ah,09h\n  int 10h\n  mov ah,03h                ;03号功能读取当前光标位置，确定dh的有坐标和dl的x坐标\n  int 10h\n  inc dl                    ;光标右移1位\n  mov ah,02h                ;02号功能设置光标位置\n  int 10h\n  pop bx\n  mov ax,0\n\n  shl bx,1\n  adc al,0\n  push bx\n  add al,30h\n  mov cx,1\n  mov bl,0ah               ;设置为浅绿色\n  mov bh,0\n  mov ah,09h\n  int 10h\n  mov ah,03h\n  int 10h\n  inc dl\n  mov ah,02h\n  int 10h\n  pop bx\n  pop cx\n  loop B1\n  \n  ret\nbin endp\noushu proc near            ;子程序3：判断偶数并输出\n  push bx                  ;保护bx\n  and bx,0001h             ;取2进制的末位\n  mov cx,8\nC1:\n  cmp bl,0h                ;判断2进制末位为0则偶数\n  jz C2\n  mov ah,02h               ;非偶数输出’NO’\n  mov dl,'N'\n  int 21h\n  mov ah,02h\n  mov dl,'O'\n  int 21h\n  pop bx\n  jmp C3\n\nC2:\n  pop bx\n  mov cx,5\n  mov ax,bx\n  mov bx,10\nC4:\n  mov dx,0\n  div bx                    ;除10，余数压栈\n  add dl,30h\n  push dx\n  loop C4\n  mov cx,5\nC5:\n  pop dx\n  mov ah,02h                ;10进制输出\n  int 21h\n  loop C5\nC3:\n  ret\noushu endp\n\npowsum proc near            ;子程序4：计算平方和\n\n  mov ax,num\n  mul num\n  mov a,ax\n  mov d,dx\n\t\n  mov ax,num+2\n  mul num+2\n  add a,ax                  \n  adc d,dx                  ;将ax相加的进位与dx相加\n  adc f,0                   ;dx相加可能产生进位，cf为最高位16进制数\n  mov dx,f\n  add dl,30h\n  mov ah,02h\n  int 21h\n\t\n  mov cx,4\n  mov dx,d\nD1:\t\n  push cx\t\n  mov cl,4\n  rol dx,cl\t               ;循环左移，\n  push dx\n  and dl,0fh                 ;dx最末位为所要输出的16进制数\n  cmp dl,9\n  jbe D2\n  add dl,7h\nD2:\n  add dl,30h\n  mov ah,02h\n  int 21h \n  pop dx\n  pop cx\n  loop D1\n\n  mov cx,4\n  mov dx,a\nD3:\n  push cx\t\n  mov cl,4\n  rol dx,cl\t               ;循环左移\n  push dx\n  and dl,0fh                 ;ax最末位为所要输出的16进制数\n  cmp dl,9\n  jbe D4\n  add dl,7h\nD4:\n  add dl,30h\n  mov ah,02h\n  int 21h \n  pop dx\n  pop cx\n  loop D3\n  ret\npowsum endp\ncode ends\nend main\n```\n\n","tags":["汇编"]},{"title":"对二十个数进行排序","url":"/2022/12/12/10/","content":"```\ndata segment\narray \tdw 40 dup(0)\nten \tdb 10 \nfuyi \tdw -1\t\nflag\tdb 0\ndata ends\n\nstack segment \n\tdw 40 dup(0)\nstack ends\n\nassume cs:code, ds:data, ss:stack\n\ncode segment\n\tstart:\t\t\n\t\tmov ax,data\n        mov ds,ax\n        mov ax,stack\n        mov ss,ax\n        mov sp,80\n        mov si,0 \n        mov cx,20\t\n        call scan\t\n        mov cx,20\n        call sort\n        mov si,0\n        mov cx,20\n        call to_char\n        mov ax,4c00h\n        int 21h\n\tscan:\t\t\n\t\tpush ax\n        push bx\n        push dx\n\tl1:\t\t\n\t\tmov dx,0\t\t\t\n\tll2:\t\n\t\tmov ah,1\n        int 21h\t\t\t\t\n        cmp al,' '\n        je continue\t\t\t\n        cmp al,'-'\n        je negtive\t\t\t\n        sub al,30h\n        mov bl,al \n        mov ax,array[si]\n        mul ten\n        mov bh,0\n        add ax,bx\n        mov array[si],ax\n        jmp ll2\t\t\nnegtive:\n        inc dx\t\n        jmp ll2\t\t\t\ncontinue:\t\t\t\t\t\t\t\n        cmp dx,0\t\t\t\n        je l\t\n        mov ax,array[si]\n        imul fuyi\n        mov array[si],ax\n\t\tl:\t\n        add si,2\n        loop l1\n        pop dx\n        pop bx\n        pop ax\n        ret\n\tsort:\t\t\n\t\tpush di\n        push bx\n        push ax\t\t\t\n\t\tdec cx\n\ts1:\t\t\n\t\tmov di,cx\n\t\tmov bx,0\n    s2:\t\t\n    \tmov ax,array[bx]\n        cmp ax,array[bx+2]\n        jle s3\n        xchg ax,array[bx+2]\n        mov array[bx],ax\n\ts3:\t\t\n\t\tadd bx,2\n        loop s2\t\t\t\n        mov cx,di\n        loop s1\t\t\t\n        pop ax\n        pop bx\n        pop di\n        ret\t\t\t\nto_char:\n    \tpush ax\n    \tpush bx\n    \tpush dx\n    \tpush di   \t\n    \tmov dl,0ah\t\n    \tmov ah,2\n    \tint 21h    \t\n\tl2:\t\t\n\t\tpush cx\n\t\tmov bx,0\n\t\tmov flag,0\n\tl3:\t\t\t\t\t\t\t\t\t\t\t\n\t\tmov ax,[si]\n\t\tand ah,10000000b\n\t\tcmp ah,0\n\t\tje b\t\t\t\t\n\t\tmov ax,[si]\t\t\t\n\t\timul fuyi\n\t\tmov [si],ax\n\t\tmov flag,1\t\t\t\t\t\n\tb:\t\n\t\tinc bx\t\n\t\tmov cx,10\n\t\tcall divtw\n    \tmov dh,7\n    \tadd dl,30h\n    \tpush dx\t\n    \tcmp word ptr [si],0\n    \tje j\n    \tloop l3    \t\n    j:\t\n    \tcmp flag,1\n    \tjne q\n    \tinc bx\n\t\tmov dh,7\n\t\tmov dl,'-'\n\t\tpush dx    \t\n    q:\t\n    \tmov cx,bx\n    k:\t\n    \tpop dx\n    \tmov ah,2\n    \tint 21h\n    \tloop k\n    \tmov dl,' '\n    \tmov ah,2\n    \tint 21h    \t\n    \tpop cx\n   \t\tadd si,2\n    \tloop l2    \t\n    \tpop di\n    \tpop dx\n    \tpop bx\n    \tpop ax\n    \tret    \t\n divtw:\n \t\tpush ax\t\t\n\t\tmov dx,0\n\t\tmov ax,[si]\n\t\tdiv cx\n\t\tmov [si],ax\t\t\n\t\tpop ax\n\t\tret\t\t\t\t\t\t\t\t\ncode ends\nend start\n```\n\n","tags":["汇编"]},{"title":"输出斐波拉契数列前20项","url":"/2022/12/12/9/","content":"```\nDATAS SEGMENT\n VAL    DW 20 DUP(0)\nDATAS ENDS\nSTACKS SEGMENT\n DW 30 DUP(0)\nSTACKS ENDS\nCODES SEGMENT\n    ASSUME CS:CODES,DS:DATAS,SS:DATAS\nSTART:\n    MOV AX,DATAS\n    MOV DS,AX\n    MOV AX,STACKS\n    MOV SS,AX\n    MOV DI,0\n    MOV AX,1\n    MOV DX,1\n    JMP FIBO\n    \nFIBO:   MOV VAL[DI],AX\n\t\tADD DI,2\n\t\tMOV VAL[DI],DX\n\t\tADD DI,2\n\t\tADD AX,DX\n\t\tADD DX,AX\n\t\tCMP DI,40\n\t\tJAE  BACK\n\t\tCALL FIBO\n\t\tRET\n\t  \nBACK:   \n  MOV DI,0\n   MOV CX,20\n   MOV DX,0\n   \nL1:    \n        MOV AX,VAL[DI]\n  ADD DI,2\n  CMP AX,1000\n  JNB P1\n  CMP AX,100\n  JNB P2\n  CMP AX,10\n  JNB P3\n  CMP AX,1\n  JNB P4\n\n  \nP1:  MOV BX,1000\n  DIV BX\n  PUSH DX\n  MOV DX,AX\n  ADD DL,30H\n  MOV AH,2H\n  INT 21H\n  POP AX\n  MOV DX,0\n  \nP2:  MOV BX,100\n  DIV BX\n  PUSH DX\n  MOV DX,AX\n  ADD DL,30H\n  MOV AH,2H\n  INT 21H\n  POP AX\n  MOV DX,0\n  \nP3:     MOV BX,10\n  DIV BX\n  PUSH DX\n  MOV DX,AX\n  ADD DL,30H\n  MOV AH,2H\n  INT 21H\n  POP AX\n  MOV DX,0\n  \nP4:    \n        MOV BX,1\n  DIV BX\n  PUSH DX\n  MOV DX,AX\n  ADD DL,30H\n  MOV AH,2H\n  INT 21H\n  POP AX\n  \n  MOV DL,32\n  MOV AH,2H\n  INT 21H\n  MOV DX,0\n  LOOP L1\n  \n  MOV AX,4C00H\n  INT 21H\nCODES ENDS\n    END START\n\n```\n\n","tags":["汇编"]},{"title":"输出斐波拉契数列前50项","url":"/2022/12/12/8/","content":"```\nDATAS SEGMENT\n\tDW 200 DUP(0)\n   \nDATAS ENDS\n\nSTACKS SEGMENT\n    DW 30 DUP(0)\nSTACKS ENDS\n\nCODES SEGMENT\n    ASSUME CS:CODES,DS:DATAS,SS:STACKS\nSTART:\n\t.386\n\tMOV AX,DATAS\n\tMOV DS,AX\n\tMOV AX,STACKS\n\tMOV SS,AX\n\tMOV SI,0\n\tMOV DI,0 \n\tMOV EAX,1\n\tMOV EDX,0\n\tJMP PRINT11\nA:\n\tCALL FIBO\n\nFIBO:\n\tCMP DI,392\n\tJE BACK\n\t\n\tCMP DI,0\t\n\tJE SET1\n\nSET1BACK:\n\tCMP DI,8\n\tJE SET2\n\nSET2BACK:\n\tADD DI,8\n\tMOV EAX,DS:[DI-8]\n\tMOV EDX,DS:[DI-4]\n\tMOV ECX,DS:[DI-12]\n\tMOV EBX,DS:[DI-16]\n\tADD EAX,EBX\n\tADC EDX,ECX\n\tMOV DS:[DI],EAX\n\tMOV DS:[DI+4],EDX\n\tCALL PRINT\n\nPRINTBACK:\t\n\tCALL FIBO\n\t\n;==================================================\nSET1:\n\tMOV DS:[0],EAX\n\tMOV DS:[4],EDX\n\tADD DI,8\n\tJMP SET1BACK\n;==================================================\nSET2:\n\tMOV DS:[8],EAX\n\tMOV DS:[12],EDX\n\tJMP SET2BACK\n;==================================================\t\n\n;PRINT EDX EAX\nPRINT:\n\tPUSH EAX\n\tPUSH EBX\n\tPUSH ECX\n\tPUSH EDX\n\tCMP EDX,10B\n\tJNB P1\n\tCMP EDX,0\n\tJA  P2\n\tCMP EAX,1000000000\n\tJNB P2\n\tCMP EAX,100000000\n\tJNB P3\n\tCMP EAX,10000000\n\tJNB P4\n\tCMP EAX,1000000\n\tJNB P5\n\tCMP EAX,100000\n\tJNB P6\n\tCMP EAX,10000\n\tJNB P7\n\tCMP EAX,1000\n\tJNB P8\n\tCMP EAX,100\n\tJNB P9\n\tCMP EAX,10\n\tJNB P10\n\tCMP EAX,1\n\tJNB P11\n\nP1:\n\tMOV DL,1\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tMOV EAX,10011010001001110101010101100001B\n\tMOV EDX,0\n\nP2:\n\tMOV EBX,1000000000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP3:\n\tMOV EBX,100000000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP4:\n\tMOV EBX,10000000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP5:\n\tMOV EBX,1000000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP6:\n\tMOV EBX,100000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP7:\n\tMOV EBX,10000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP8:\n\tMOV EBX,1000\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP9:\n\tMOV EBX,100\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\nP10:\n\tMOV EBX,10\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\t\n\nP11:\n\tMOV EBX,1\n\tDIV EBX\n\tPUSH EDX\n\tMOV EDX,EAX\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tPOP EAX\n\tMOV EDX,0\n\tMOV DL,32\n\tMOV AH,2H\n\tINT 21H\n\t\n\tPOP EDX\n\tPOP ECX\n\tPOP EBX\n\tPOP EAX\n\tJMP PRINTBACK\n;PRINT END\n\n\n;PRINT11\nPRINT11:\n\tPUSH EDX\n\tPUSH EAX\n\t\n\tMOV DL,1\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tMOV DL,32\n\tMOV AH,2H\n\tINT 21H\n\t\n\tMOV DL,1\n\tADD DL,30H\n\tMOV AH,2H\n\tINT 21H\n\tMOV DL,32\n\tMOV AH,2H\n\tINT 21H\n\t\n\tPOP EAX\n\tPOP EDX\n\t\n\tJMP A\n\nBACK:\n\tMOV AX,4C00H\n   \tINT 21H\nCODES ENDS\n    END START\n```\n\n","tags":["汇编"]},{"title":"航班信息管理系统","url":"/2022/12/12/7/","content":"```\n#include <iostream>\n#include <string>   \n#include <iomanip>   \n#include <fstream> \n#include <random> \n#include <ctime>   \n#include <windows.h> \n\nusing namespace std;\n\ntypedef struct flightnode\n{\n\tstring flight_num;       //航班号\n\tstring time;             //起飞时间\n\tint date = 0;            //起飞日期\n\tstring start_place;      //出发地\n\tstring end_place;        //目的地\n\tfloat discount = 0;      //折扣\n\tint left = 0;            //余票\n\tfloat price = 0;         //价格\n\tflightnode* next = NULL;\n}*flightlist;\n\nstruct ticket\n{\n\tstring flight_num;\t  //航班号\n\tstring time;\t\t  //起飞时间\n\tstring start_place;\t  //出发地\n\tstring end_place;     //目的地\n\tfloat price = 0;      //价格\n\tint date = 0;         //起飞日期\n\tstring order_num;\t  //订单编号\n};\n\ntypedef struct passengernode\n{\n\tstring name;        //名字\n\tstring ID_num;      //证件号\n\tticket ticket;      //票\n\tint full = 0;       //预约标志  1表示预约状态\n\tpassengernode* next = NULL;\n}*passengerlist;\n\n//航班类信息\nvoid Init_flight(flightlist& h);\t\t//初始化航班\nvoid Load_flight(flightlist& h);\t\t//载入航班\nvoid Add_flight(flightlist& h);\t\t\t//添加航班\nvoid Check_flight(flightlist& h);\t\t//查找航班\nvoid Check_flightnum(flightlist& h);\t//航班号查找\nvoid Check_seplace(flightlist& h);\t\t//起始地查找\nvoid Check_all(flightlist& h);\t\t\t//浏览全部航班\nvoid Revise_flight(flightlist& h);\t\t//修改航班信息\nvoid Delete_flight(flightlist& h);\t\t//删除航班\nvoid Revise_time(flightlist& h);\t\t//修改起飞抵达时间\nvoid Revise_price(flightlist& h);\t\t//修改价格\nvoid Save_flight(flightlist& h);\t\t//保存航班信息\n//用户信息\nvoid Init_passenger(passengerlist& c);\t\t\t//初始化用户\nvoid Load_passenger(passengerlist& c);\t\t\t//载入用户信息\nvoid Book(flightlist& h, passengerlist& c);\t\t//定票\nvoid Qbook(flightlist& h, passengerlist& c);\t//退票\nvoid Check_book(passengerlist& c);\t\t\t\t//查询订单\nvoid Save_passenger(passengerlist& c);\t\t\t//保存用户信息\n//管理操作\nvoid manage(flightlist& flight, passengerlist& passenger);\nvoid password();//密码管理\n//通用\nvoid wait();\n\n\n\n\nvoid manage(flightlist& flight, passengerlist& passenger)\n{\n\twhile (1) {\n\t\tcout << \"航班信息管理系统\" << endl << endl;\n\t\tcout << \"主菜单\" << endl;\n\t\tcout << \"1.录入航班信息\" << endl;\n\t\tcout << \"2.查询航班\" << endl;\n\t\tcout << \"3.订票\" << endl;\n\t\tcout << \"4.退票\" << endl;\n\t\tcout << \"5.查询订单\" << endl;\n\t\tcout << \"6.修改航班信息\" << endl;\n\t\tcout << \"0.退出系统 \" << endl;\n\t\tcout << \"请输入您想要进行的功能：\";\n\t\tint i;\n\t\tcin >> i;\n\t\tsystem(\"cls\");\n\t\tswitch (i) {\n\t\tcase 1:Add_flight(flight); Save_flight(flight); wait(); break;\n\t\tcase 2:Check_flight(flight); wait(); break;\n\t\tcase 3:Book(flight, passenger); Save_flight(flight); Save_passenger(passenger); wait(); break;\n\t\tcase 4:Qbook(flight, passenger); Save_flight(flight); Save_passenger(passenger); wait(); break;\n\t\tcase 5:Check_book(passenger); wait(); break;\n\t\tcase 6:Revise_flight(flight); Save_flight(flight); wait(); break;\n\t\tcase 0:exit(0); break;\n\t\tdefault:cout << \"请检查你的输入！\" << endl; break;\n\t\t}\n\t}\n}\n\nvoid Sort_flight(flightlist& h)\n{\n\tflightlist p = h->next;  //指向第一个结点\n\twhile (p != NULL) {\n\t\tflightlist q = h->next;   //指向p后一个结点\n\t\twhile (q) {\n\t\t\tif (q->date > p->date) {\n\t\t\t\tflightnode temp = *p;   //临时保存指针交换\n\t\t\t\ttemp.next = q->next;\n\t\t\t\tq->next = p->next;\n\t\t\t\t*p = *q;\n\t\t\t\t*q = temp;\n\t\t\t}\n\t\t\tq = q->next;   //指针移动\n\t\t}\n\t\tp = p->next;    //指针移动\n\t}\n\n}\n\nvoid Init_flight(flightlist& h)//初始化航班\n{\n\th = new flightnode;  //头指针\n\th->next = NULL;\n}\n\nvoid Load_flight(flightlist& h)//载入航班\n{\n\tflightlist f = h;\n\tflightlist newp = new flightnode;\n\tifstream ifs(\"FlightList.txt\");\n\tif (!ifs.is_open()) {\n\t\tcout << \"文件未被打开！\" << endl;\n\t\treturn;\n\t}\n\twhile (ifs >> newp->flight_num >> newp->date >> newp->time >> newp->start_place >> newp->end_place >> newp->price >> newp->discount >> newp->left) {\n\t\tf->next = newp;\n\t\tf = f->next;\n\t\tnewp = new flightnode;\n\t}\n\tf->next = NULL;\n\tdelete newp;\n}\n\nvoid Add_flight(flightlist& h)//添加航班\n{\n\tchar mark = 'y';\n\tflightlist s, rear;\n\tfor (rear = h; rear->next != NULL; rear = rear->next) {}  // rear移动结点尾\n\twhile (mark == 'y' || mark == 'Y') {\n\t\ts = new flightnode;\n\t\tcout << \"请输入航班号：\";\n\t\tcin >> s->flight_num;\n\t\tcout << \"请输入起飞日期：\";\n\t\tcin >> s->date;\n\t\tcout << \"请输入起飞时间：\";\n\t\tcin >> s->time;\n\t\tcout << \"请输入出发地：\";\n\t\tcin >> s->start_place;\n\t\tcout << \"请输入目的地：\";\n\t\tcin >> s->end_place;\n\t\tcout << \"请输入价格：\";\n\t\tcin >> s->price;\n\t\tcout << \"请输入折扣：\";\n\t\tcin >> s->discount;\n\t\tcout << \"请输入余票：\";\n\t\tcin >> s->left;\n\t\trear->next = s;\n\t\trear = s;\n\t\tcout << \"添加成功！\" << endl;\n\t\tcout << \"是否继续添加？（是“y”/否“n”）：\";\n\t\tcin >> mark;\n\t}\n\trear->next = NULL;\n}\n\nvoid Check_flight(flightlist& h)//查找航班\n{\n\tint i;\n\tcout << \"查找方式\" << endl;\n\tcout << \"1.航班查找\" << endl;\n\tcout << \"2.起始地查找\" << endl;\n\tcout << \"3.浏览全部航班\" << endl;\n\tcout << \"请输入查找方式：\";\n\tcin >> i;\n\tswitch (i) {\n\tcase 1:Check_flightnum(h); break;\n\tcase 2:Check_seplace(h); break;\n\tcase 3:Check_all(h); break;\n\tdefault:break;\n\t}\n}\n\nvoid Check_flightnum(flightlist& h)//航班号查找\n{\n\tstring flightnum;\n\tflightlist p = h->next;\n\tcout << \"请输入航班号：\";\n\tcin >> flightnum;\n\tcout << setw(6) << \"航班号\" << setw(17) << \"起飞日期\" << setw(15) << \"起飞时间\" << setw(15) << \"出发地\" << setw(15) << \"目的地\" << setw(15) << \"价格\" << setw(15) << \"折扣\" << setw(15) << \"余票\" << endl;\n\twhile (p != NULL) {\n\t\tif (p->flight_num == flightnum) {\n\t\t\tcout << setw(6) << p->flight_num << setw(15) << p->date << \"日\" << setw(15) << p->time << setw(15) << p->start_place << setw(15) << p->end_place << setw(15) << p->price << setw(15) << p->discount << setw(15) << p->left << endl;\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t\tp = p->next;\n\t}\n\tcout << setw(32) << \"未查到任何信息。\";\n\twait();\n}\n\nvoid Check_seplace(flightlist& h)//起始地查找\n{\n\tstring start_place, end_place;\n\tcout << \"请输入出发地：\";\n\tcin >> start_place;\n\tcout << \"请输入目的地：\";\n\tcin >> end_place;\n\tflightlist p = h->next;\n\tcout << setw(6) << \"航班号\" << setw(17) << \"起飞日期\" << setw(15) << \"起飞时间\" << setw(15) << \"出发地\" << setw(15) << \"目的地\" << setw(15) << \"价格\" << setw(15) << \"折扣\" << setw(15) << \"余票\" << endl;\n\twhile (p != NULL) {\n\t\tif (p->start_place == start_place && p->end_place == end_place) {\n\t\t\tcout << setw(6) << p->flight_num << setw(15) << p->date << \"号\" << setw(15) << p->time << setw(15) << p->start_place << setw(15) << p->end_place << setw(15) << p->price << setw(15) << p->discount << setw(15) << p->left << endl;\n\t\t\treturn;\n\t\t}\n\t\tp = p->next;        //移动\n\t}\n\tcout << \"未查到任何信息\" << endl;\n\twait();\n}\n\nvoid Check_all(flightlist& h)//浏览全部航班\n{\n\tSort_flight(h);  //日期排序\n\tflightlist p = h->next;\n\tcout << setw(6) << \"航班号\" << setw(17) << \"起飞日期\" << setw(15) << \"起飞时间\" << setw(15) << \"出发地\" << setw(15) << \"目的地\" << setw(15) << \"价格\" << setw(15) << \"折扣\" << setw(15) << \"余票\" << endl;\n\twhile (p != NULL)\n\t{\n\t\tcout << setw(6) << p->flight_num << setw(15) << p->date << \"号\" << setw(15) << p->time << setw(15) << p->start_place << setw(15) << p->end_place << setw(15) << p->price << setw(15) << p->discount << setw(15) << p->left << endl;\n\t\tp = p->next;   //移动\n\t}\n}\n\nvoid Revise_flight(flightlist& h)//修改航班信息\n{\n\tflightlist f = h->next;\n\tint i;\n\tcout << \"修改内容:\" << endl;\n\tcout << \"1.删除航班\" << endl;\n\tcout << \"2.修改起飞时间\" << endl;\n\tcout << \"3.修改航班价格\" << endl;\n\tcout << \"4.返回\" << endl;\n\tcout << \"请输入查找方式：\";\n\tcin >> i;\n\tCheck_all(h);     //浏览全部\n\tswitch (i) {\n\tcase 1:Delete_flight(h); break;\n\tcase 2:Revise_time(h); break;\n\tcase 3:Revise_price(h); break;\n\tcase 4:return; break;\n\tdefault:cout << \"请检查你的输入！\" << endl; break;\n\t}\n}\n\nvoid Delete_flight(flightlist& h)//删除航班\n{\n\tflightlist p = h->next, q = h;  //q是p的前驱\n\tstring flightnum;\n\tcout << \"请输入您想要修改的航班号：\";\n\tcin >> flightnum;\n\twhile (p != NULL) {\n\t\tif (p->flight_num == flightnum) {\n\t\t\tq->next = p->next;      //p是要删除的结点，q是前一个结点\n\t\t\tdelete p;\n\t\t\tcout << \"删除成功！\";\n\t\t\twait();\n\t\t\treturn;\n\t\t}\n\t\tq = q->next;\n\t\tp = q->next;\n\t}\n\tcout << \"未查找到相关航班！\";\n\twait();\n}\n\nvoid Revise_time(flightlist& h)//修改起飞抵达时间\n{\n\tstring flightnum;\n\tflightlist p = h->next;\n\tcout << \"请输入您想要修改的航班号：\";\n\tcin >> flightnum;\n\twhile (p != NULL) {\n\t\tif (p->flight_num == flightnum) {\n\t\t\tcout << \"请输入新的起飞日期：\";\n\t\t\tcin >> p->date;\n\t\t\tcout << \"请输入新的起飞时间：\";\n\t\t\tcin >> p->time;\n\t\t\tcout << \"修改成功！\";\n\t\t\twait();\n\t\t\treturn;\n\t\t}\n\t\tp = p->next;\n\t}\n\tcout << \"没有您想要修改的航班号!\";\n\twait();\n}\n\nvoid Revise_price(flightlist& h)//修改价格\n{\n\tstring flightnum;\n\tflightlist p = h->next;\n\tcout << \"请输入您想要修改的航班号：\";\n\tcin >> flightnum;\n\twhile (p != NULL) {\n\t\tif (p->flight_num == flightnum) {\n\t\t\tcout << \"请输入新的价格：\";\n\t\t\tcin >> p->price;\n\t\t\tcout << \"请输入新的折扣：\";\n\t\t\tcin >> p->discount;\n\t\t\tcout << \"修改成功！\t\";\n\t\t\twait();\n\t\t\treturn;\n\t\t}\n\t\tp = p->next;\n\t}\n\tcout << \"没有您想要修改的航班号!\";\n\twait();\n}\n\nvoid Save_flight(flightlist& h)//保存航班信息\n{\n\tflightlist f = h->next;\n\tSort_flight(h);\n\tofstream ofs(\"FlightList.txt\");\n\tif (!ofs)\n\t{\n\t\tcout << \"存储失败！\";\n\t\treturn;\n\t}\n\twhile (f != NULL)\n\t{\n\t\tofs << f->flight_num << \" \" << f->date << \" \" << f->time << \" \" << f->start_place << \" \" << f->end_place << \" \" << f->price << \" \" << f->discount << \" \" << f->left << endl;\n\t\tf = f->next;\n\t}\n\tofs.close();   //关闭文件\n}\n\nvoid Init_passenger(passengerlist& c)//初始化用户\n{\n\tc = new passengernode;   //头结点\n\tc->next = NULL;\n}\n\nvoid Load_passenger(passengerlist& c)\n{\n\tpassengerlist p = c;\n\tpassengerlist newp = new passengernode;\n\tifstream ifs(\"PassengerList.txt\");\n\tif (!ifs.is_open()) {\n\t\tcout << \"文件未被打开！\" << endl;\n\t\treturn;\n\t}\n\tcout << \"数据读取成功！\" << endl;\n\tsystem(\"cls\");\n\twhile (ifs >> newp->name >> newp->ID_num >> newp->ticket.flight_num >> newp->ticket.date >> newp->ticket.time >> newp->ticket.start_place >> newp->ticket.end_place >> newp->ticket.price >> newp->ticket.order_num)\n\t{\n\t\tp->next = newp;\n\t\tp = p->next;\n\t\tnewp = new passengernode;\n\t}\n\tp->next = NULL;\n\tdelete newp;\n}\n\nvoid Book(flightlist& h, passengerlist& c)//订票\n{\n\tstring start_place, end_place, flightnum;\n\tint date;//航班信息\n\tflightlist p = h->next, q = h->next;\n\tpassengerlist s, r = c;\n\tchar mark, check = '1';\n\tchar mark02 = '1';         //标志\n\tfor (; r->next != NULL; r = r->next) {}   //r移动到结点尾\n\ts = new passengernode;\n\tcout << \"请输入乘客的姓名：\";\n\tcin >> s->name;\n\tcout << \"请输入乘客的证件号：\";\n\tcin >> s->ID_num;\n\tcout << \"请输入出发地：\";\n\tcin >> start_place;\n\tcout << \"请输入目的地：\";\n\tcin >> end_place;\n\tcout << \"请选择出发日期：\";\n\tcin >> date;\n\tcout << setw(6) << \"航班号\" << setw(17) << \"起飞日期\" << setw(15) << \"起飞时间\" << setw(15) << \"出发地\" << setw(15) << \"目的地\" << setw(15) << \"价格\" << setw(15) << \"折扣\" << setw(15) << \"余票\" << endl;\n\twhile (p != NULL)\n\t{\n\t\tif (p->start_place == start_place && p->end_place == end_place && p->date == date)//匹配日期相符的航班\n\t\t{\n\t\t\tcout << setw(6) << p->flight_num << setw(15) << p->date << \"号\" << setw(15) << p->time << setw(15) << p->start_place << setw(15) << p->end_place << setw(15) << p->price << setw(15) << p->discount << setw(15) << p->left << endl;\n\t\t\tcheck = '0';\n\t\t}\n\t\tp = p->next;\n\t}\n\tif (check == '1') {\n\t\tp = h->next;\n\t\tcout << \"无\" << setw(15) << \"无\" << setw(17) << \"无\" << setw(15) << \"无\" << setw(15) << \"无\" << setw(15) << \"无\" << setw(15) << \"无\" << setw(15) << \"无\" << endl;\n\t\tcout << \"该天没相关的航班\" << endl;\n\t\tif (mark02 == '1')\n\t\t\treturn;//结束\n\t}\n\tcout << \"是否进行购买？（Y/N）\";\n\tcin >> mark;\n\tif (mark == 'y' || mark == 'Y') {\n\t\tcout << \"请输入您想要购买的航班号：\";\n\t\tcin >> flightnum;\n\t\twhile (q != NULL) {\n\t\t\tif (q->flight_num == flightnum && q->start_place == start_place && q->end_place == end_place) {\n\t\t\t\tif (q->left == 0) {\n\t\t\t\t\tcout << \"余票不足，请选择是否预约（Y/N）\";\n\t\t\t\t\tcin >> mark;\n\t\t\t\t\tif (mark == 'y' || mark == 'Y') {\n\t\t\t\t\t\ts->full = 1;  //修改预约标志\n\t\t\t\t\t\ts->ticket.flight_num = flightnum;\n\t\t\t\t\t\ts->ticket.start_place = start_place;\n\t\t\t\t\t\ts->ticket.end_place = end_place;\n\t\t\t\t\t\ts->ticket.time = \"预约\";\n\t\t\t\t\t\ts->ticket.price = 000;\n\t\t\t\t\t\ts->ticket.date = date;\n\t\t\t\t\t\ts->ticket.order_num = \"预约\";\n\t\t\t\t\t\tcout << \" 预约成功\";\n\t\t\t\t\t\tr->next = s;\n\t\t\t\t\t\tr = s;\n\t\t\t\t\t\tr->next = NULL;\n\t\t\t\t\t\twait();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\treturn;  //不预约直接结束\n\t\t\t\t}\n\t\t\t\ts->ticket.flight_num = flightnum;\n\t\t\t\ts->ticket.start_place = start_place;\n\t\t\t\ts->ticket.end_place = end_place;\n\t\t\t\ts->ticket.time = q->time;\n\t\t\t\ts->ticket.price = q->price;\n\t\t\t\ts->ticket.date = q->date;\n\t\t\t\tsrand((unsigned int)time(0));\n\t\t\t\ts->ticket.order_num = q->flight_num + to_string(rand()) + to_string(rand());//订单编号\n\t\t\t\tr->next = s;\n\t\t\t\tr = s;\n\t\t\t\tr->next = NULL;\n\t\t\t\tcout << \"购票成功！\" << \"订单号为\" + s->ticket.order_num << endl;\n\t\t\t\tq->left--;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse\n\t\t\t\tq = q->next;\n\t\t}\n\t\tcout << \"航班号填入错误！\" << endl;\n\t\twait();\n\t}\n\telse {\n\t\treturn;//不进行购买直接结束\n\t}\n}\n\nvoid Qbook(flightlist& h, passengerlist& c)//退票\n{\n\tstring name, ID_num;\n\tbool mark = false;\n\tflightlist f = h->next;\n\tpassengerlist p = c->next, q = c, t = c->next;\n\tcout << \"请输入乘客的姓名：\";\n\tcin >> name;\n\tcout << \"请输入乘客的证件号：\";\n\tcin >> ID_num;\n\twhile (p != NULL) {\n\t\tif (p->name == name && p->ID_num == ID_num) {\n\t\t\tmark = true;   //找到乘客\n\t\t\twhile (f != NULL) {\n\t\t\t\tif (p->ticket.flight_num == f->flight_num) {\n\t\t\t\t\tf->left++;  //票数更新\n\t\t\t\t\twhile (t != NULL) {\n\t\t\t\t\t\tif (t->ticket.flight_num == p->ticket.flight_num && t->full == 1) {\n\t\t\t\t\t\t\tt->ticket.start_place = p->ticket.start_place;\n\t\t\t\t\t\t\tt->ticket.end_place = p->ticket.end_place;\n\t\t\t\t\t\t\tt->ticket.time = p->ticket.time;\n\t\t\t\t\t\t\tt->ticket.price = p->ticket.price;\n\t\t\t\t\t\t\tt->ticket.date = p->ticket.date;\n\t\t\t\t\t\t\tsrand((unsigned int)time(0));\n\t\t\t\t\t\t\tt->ticket.order_num = p->ticket.flight_num.c_str() + to_string(rand()) + to_string(rand());\n\t\t\t\t\t\t\tf->left--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt = t->next;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tf = f->next;\n\t\t\t}\n\t\t\tq->next = p->next;\n\t\t\tdelete p;\n\t\t\tcout << \"退票成功！\";\n\t\t\treturn;\n\t\t}\n\t\tq = q->next;\n\t\tp = q->next;\n\t}\n\tif (!mark) {\n\t\tcout << \"未找到相关乘客的订单\";\n\t\twait();\n\t}\n}\n\nvoid Check_book(passengerlist& c)//查询订票\n{\n\tstring name, ID_num;\n\tpassengerlist p = c->next;\n\tcout << \"请输入乘客的姓名：\";\n\tcin >> name;\n\tcout << \"请输入乘客的证件号：\";\n\tcin >> ID_num;\n\tcout << setw(8) << \"姓名\" << setw(15) << \"航班号\" << setw(17) << \"起飞日期\" << setw(15) << \"起飞时间\" << setw(15) << \"出发地\" << setw(15) << \"目的地\" << setw(15) << \"价格\" << setw(18) << \"订单编号\" << endl;\n\twhile (p != NULL) {\n\t\tif (p->name == name && p->ID_num == ID_num) {\n\t\t\tcout << setw(8) << p->name << setw(15) << p->ticket.flight_num << setw(15) << p->ticket.date << \"号\" << setw(15) << p->ticket.time << setw(15) << p->ticket.start_place << setw(15) << p->ticket.end_place << setw(15) << p->ticket.price << setw(18) << p->ticket.order_num << endl;\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t\tp = p->next;\n\t}\n\tcout << setw(32) << \"未查到任何信息。\";\n\twait();\n\treturn;\n}\n\nvoid Save_passenger(passengerlist& c)\n{\n\tpassengerlist p = c->next;\n\tofstream ofs(\"PassengerList.txt\");\n\tif (!ofs) {\n\t\tcout << \"存储失败！\";\n\t\treturn;\n\t}\n\twhile (p != NULL) {\n\t\tofs << p->name << \" \" << p->ID_num << \" \" << p->ticket.flight_num << \" \" << p->ticket.date << \" \" << p->ticket.time << \" \" << p->ticket.start_place << \" \" << p->ticket.end_place << \" \" << p->ticket.price << \" \" << p->ticket.order_num << endl;\n\t\tp = p->next;\n\t}\n\tofs.close();\n}\n\nvoid wait() {\n\tint a = getchar();\n\ta = getchar();\n\tsystem(\"cls\");\n}\n\nint main()\n{\n\tflightlist flight;\n\tpassengerlist passenger;\n\tInit_passenger(passenger); //初始用户信息\n\tLoad_passenger(passenger); //载入用户信息\n\tInit_flight(flight);       //初始化航班\n\tLoad_flight(flight);       //载入航班\n\tmanage(flight, passenger); //封装管理函数\n\treturn 0;\n}\n\n```\n\n","tags":["C++"]},{"title":"面向对象编程","url":"/2022/12/11/6/","content":"\n# C++核心编程\n\n本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。\n\n\n\n## 1 内存分区模型\n\nC++程序在执行时，将内存大方向划分为**4个区域**\n\n- 代码区：存放函数体的二进制代码，由操作系统进行管理的\n- 全局区：存放全局变量和静态变量以及常量\n- 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等\n- 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收\n\n\n\n\n\n\n\n**内存四区意义：**\n\n不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程\n\n\n\n\n\n### 1.1 程序运行前\n\n\t在程序编译后，生成了exe可执行程序，**未执行该程序前**分为两个区域\n\t\n\t**代码区：**\n\t\n\t\t存放 CPU 执行的机器指令\n\t\n\t\t代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可\n\t\n\t\t代码区是**只读**的，使其只读的原因是防止程序意外地修改了它的指令\n\t\n\t**全局区：**\n\t\n\t\t全局变量和静态变量存放在此.\n\t\n\t\t全局区还包含了常量区, 字符串常量和其他常量也存放在此.\n\t\n\t\t==该区域的数据在程序结束后由操作系统释放==.\n\n\n\n\n\n\n\n\n\n\n\n\n\n**示例：**\n\n```c++\n//全局变量\nint g_a = 10;\nint g_b = 10;\n\n//全局常量\nconst int c_g_a = 10;\nconst int c_g_b = 10;\n\nint main() {\n\n\t//局部变量\n\tint a = 10;\n\tint b = 10;\n\n\t//打印地址\n\tcout << \"局部变量a地址为： \" << (int)&a << endl;\n\tcout << \"局部变量b地址为： \" << (int)&b << endl;\n\n\tcout << \"全局变量g_a地址为： \" <<  (int)&g_a << endl;\n\tcout << \"全局变量g_b地址为： \" <<  (int)&g_b << endl;\n\n\t//静态变量\n\tstatic int s_a = 10;\n\tstatic int s_b = 10;\n\n\tcout << \"静态变量s_a地址为： \" << (int)&s_a << endl;\n\tcout << \"静态变量s_b地址为： \" << (int)&s_b << endl;\n\n\tcout << \"字符串常量地址为： \" << (int)&\"hello world\" << endl;\n\tcout << \"字符串常量地址为： \" << (int)&\"hello world1\" << endl;\n\n\tcout << \"全局常量c_g_a地址为： \" << (int)&c_g_a << endl;\n\tcout << \"全局常量c_g_b地址为： \" << (int)&c_g_b << endl;\n\n\tconst int c_l_a = 10;\n\tconst int c_l_b = 10;\n\tcout << \"局部常量c_l_a地址为： \" << (int)&c_l_a << endl;\n\tcout << \"局部常量c_l_b地址为： \" << (int)&c_l_b << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n打印结果：\n\n![1545017602518](assets/1545017602518.png)\n\n\n\n总结：\n\n* C++中在程序运行前分为全局区和代码区\n* 代码区特点是共享和只读\n* 全局区中存放全局变量、静态变量、常量\n* 常量区中存放 const修饰的全局常量  和 字符串常量\n\n\n\n\n\n\n### 1.2 程序运行后\n\n\n\n\t**栈区：**\n\t\n\t\t由编译器自动分配释放, 存放函数的参数值,局部变量等\n\t\n\t\t注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放\n\n\n\n**示例：**\n\n```c++\nint * func()\n{\n\tint a = 10;\n\treturn &a;\n}\n\nint main() {\n\n\tint *p = func();\n\n\tcout << *p << endl;\n\tcout << *p << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\t**堆区：**\n\t\n\t\t由程序员分配释放,若程序员不释放,程序结束时由操作系统回收\n\t\n\t\t在C++中主要利用new在堆区开辟内存\n\n**示例：**\n\n```c++\nint* func()\n{\n\tint* a = new int(10);\n\treturn a;\n}\n\nint main() {\n\n\tint *p = func();\n\n\tcout << *p << endl;\n\tcout << *p << endl;\n    \n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n**总结：**\n\n堆区数据由程序员管理开辟和释放\n\n堆区数据利用new关键字进行开辟内存\n\n\n\n\n\n\n\n\n\n### 1.3 new操作符\n\n\n\n\tC++中利用==new==操作符在堆区开辟数据\n\t\n\t堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==\n\t\n\t语法：` new 数据类型`\n\t\n\t利用new创建的数据，会返回该数据对应的类型的指针\n\n\n\n**示例1： 基本语法**\n\n```c++\nint* func()\n{\n\tint* a = new int(10);\n\treturn a;\n}\n\nint main() {\n\n\tint *p = func();\n\n\tcout << *p << endl;\n\tcout << *p << endl;\n\n\t//利用delete释放堆区数据\n\tdelete p;\n\n\t//cout << *p << endl; //报错，释放的空间不可访问\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n**示例2：开辟数组**\n\n```c++\n//堆区开辟数组\nint main() {\n\n\tint* arr = new int[10];\n\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tarr[i] = i + 100;\n\t}\n\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tcout << arr[i] << endl;\n\t}\n\t//释放数组 delete 后加 []\n\tdelete[] arr;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n## 2 引用\n\n### 2.1 引用的基本使用\n\n**作用： **给变量起别名\n\n**语法：** `数据类型 &别名 = 原名`\n\n\n\n**示例：**\n\n```C++\nint main() {\n\n\tint a = 10;\n\tint &b = a;\n\n\tcout << \"a = \" << a << endl;\n\tcout << \"b = \" << b << endl;\n\n\tb = 100;\n\n\tcout << \"a = \" << a << endl;\n\tcout << \"b = \" << b << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n### 2.2 引用注意事项\n\n* 引用必须初始化\n* 引用在初始化后，不可以改变\n\n示例：\n\n```C++\nint main() {\n\n\tint a = 10;\n\tint b = 20;\n\t//int &c; //错误，引用必须初始化\n\tint &c = a; //一旦初始化后，就不可以更改\n\tc = b; //这是赋值操作，不是更改引用\n\n\tcout << \"a = \" << a << endl;\n\tcout << \"b = \" << b << endl;\n\tcout << \"c = \" << c << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n### 2.3 引用做函数参数\n\n**作用：**函数传参时，可以利用引用的技术让形参修饰实参\n\n**优点：**可以简化指针修改实参\n\n\n\n**示例：**\n\n```C++\n//1. 值传递\nvoid mySwap01(int a, int b) {\n\tint temp = a;\n\ta = b;\n\tb = temp;\n}\n\n//2. 地址传递\nvoid mySwap02(int* a, int* b) {\n\tint temp = *a;\n\t*a = *b;\n\t*b = temp;\n}\n\n//3. 引用传递\nvoid mySwap03(int& a, int& b) {\n\tint temp = a;\n\ta = b;\n\tb = temp;\n}\n\nint main() {\n\n\tint a = 10;\n\tint b = 20;\n\n\tmySwap01(a, b);\n\tcout << \"a:\" << a << \" b:\" << b << endl;\n\n\tmySwap02(&a, &b);\n\tcout << \"a:\" << a << \" b:\" << b << endl;\n\n\tmySwap03(a, b);\n\tcout << \"a:\" << a << \" b:\" << b << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n\n```\n\n\n\n> 总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 2.4 引用做函数返回值\n\n\n\n作用：引用是可以作为函数的返回值存在的\n\n\n\n注意：**不要返回局部变量引用**\n\n用法：函数调用作为左值\n\n\n\n**示例：**\n\n```C++\n//返回局部变量引用\nint& test01() {\n\tint a = 10; //局部变量\n\treturn a;\n}\n\n//返回静态变量引用\nint& test02() {\n\tstatic int a = 20;\n\treturn a;\n}\n\nint main() {\n\n\t//不能返回局部变量的引用\n\tint& ref = test01();\n\tcout << \"ref = \" << ref << endl;\n\tcout << \"ref = \" << ref << endl;\n\n\t//如果函数做左值，那么必须返回引用\n\tint& ref2 = test02();\n\tcout << \"ref2 = \" << ref2 << endl;\n\tcout << \"ref2 = \" << ref2 << endl;\n\n\ttest02() = 1000;\n\n\tcout << \"ref2 = \" << ref2 << endl;\n\tcout << \"ref2 = \" << ref2 << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n​\t\n\n\n\n\n\n\n\n\n\n### 2.5 引用的本质\n\n本质：**引用的本质在c++内部实现是一个指针常量.**\n\n讲解示例：\n\n```C++\n//发现是引用，转换为 int* const ref = &a;\nvoid func(int& ref){\n\tref = 100; // ref是引用，转换为*ref = 100\n}\nint main(){\n\tint a = 10;\n    \n    //自动转换为 int* const ref = &a; 指针常量是指针指向不可改，也说明为什么引用不可更改\n\tint& ref = a; \n\tref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20;\n    \n\tcout << \"a:\" << a << endl;\n\tcout << \"ref:\" << ref << endl;\n    \n\tfunc(a);\n\treturn 0;\n}\n```\n\n结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 2.6 常量引用\n\n\n\n**作用：**常量引用主要用来修饰形参，防止误操作\n\n\n\n在函数形参列表中，可以加==const修饰形参==，防止形参改变实参\n\n\n\n**示例：**\n\n\n\n```C++\n//引用使用的场景，通常用来修饰形参\nvoid showValue(const int& v) {\n\t//v += 10;\n\tcout << v << endl;\n}\n\nint main() {\n\n\t//int& ref = 10;  引用本身需要一个合法的内存空间，因此这行错误\n\t//加入const就可以了，编译器优化代码，int temp = 10; const int& ref = temp;\n\tconst int& ref = 10;\n\n\t//ref = 100;  //加入const后不可以修改变量\n\tcout << ref << endl;\n\n\t//函数中利用常量引用防止误操作修改实参\n\tint a = 10;\n\tshowValue(a);\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n## 3 函数提高\n\n### 3.1 函数默认参数\n\n\n\n在C++中，函数的形参列表中的形参是可以有默认值的。\n\n语法：` 返回值类型  函数名 （参数= 默认值）{}`\n\n\n\n**示例：**\n\n```C++\nint func(int a, int b = 10, int c = 10) {\n\treturn a + b + c;\n}\n\n//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值\n//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数\nint func2(int a = 10, int b = 10);\nint func2(int a, int b) {\n\treturn a + b;\n}\n\nint main() {\n\n\tcout << \"ret = \" << func(20, 20) << endl;\n\tcout << \"ret = \" << func(100) << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n### 3.2 函数占位参数\n\n\n\nC++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置\n\n\n\n**语法：** `返回值类型 函数名 (数据类型){}`\n\n\n\n在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术\n\n\n\n**示例：**\n\n```C++\n//函数占位参数 ，占位参数也可以有默认参数\nvoid func(int a, int) {\n\tcout << \"this is func\" << endl;\n}\n\nint main() {\n\n\tfunc(10,10); //占位参数必须填补\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n### 3.3 函数重载\n\n#### 3.3.1 函数重载概述\n\n\n\n**作用：**函数名可以相同，提高复用性\n\n\n\n**函数重载满足条件：**\n\n* 同一个作用域下\n* 函数名称相同\n* 函数参数**类型不同**  或者 **个数不同** 或者 **顺序不同**\n\n\n\n**注意:**  函数的返回值不可以作为函数重载的条件\n\n\n\n**示例：**\n\n```C++\n//函数重载需要函数都在同一个作用域下\nvoid func()\n{\n\tcout << \"func 的调用！\" << endl;\n}\nvoid func(int a)\n{\n\tcout << \"func (int a) 的调用！\" << endl;\n}\nvoid func(double a)\n{\n\tcout << \"func (double a)的调用！\" << endl;\n}\nvoid func(int a ,double b)\n{\n\tcout << \"func (int a ,double b) 的调用！\" << endl;\n}\nvoid func(double a ,int b)\n{\n\tcout << \"func (double a ,int b)的调用！\" << endl;\n}\n\n//函数返回值不可以作为函数重载条件\n//int func(double a, int b)\n//{\n//\tcout << \"func (double a ,int b)的调用！\" << endl;\n//}\n\n\nint main() {\n\n\tfunc();\n\tfunc(10);\n\tfunc(3.14);\n\tfunc(10,3.14);\n\tfunc(3.14 , 10);\n\t\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 3.3.2 函数重载注意事项\n\n\n\n* 引用作为重载条件\n* 函数重载碰到函数默认参数\n\n\n\n\n\n**示例：**\n\n```C++\n//函数重载注意事项\n//1、引用作为重载条件\n\nvoid func(int &a)\n{\n\tcout << \"func (int &a) 调用 \" << endl;\n}\n\nvoid func(const int &a)\n{\n\tcout << \"func (const int &a) 调用 \" << endl;\n}\n\n\n//2、函数重载碰到函数默认参数\n\nvoid func2(int a, int b = 10)\n{\n\tcout << \"func2(int a, int b = 10) 调用\" << endl;\n}\n\nvoid func2(int a)\n{\n\tcout << \"func2(int a) 调用\" << endl;\n}\n\nint main() {\n\t\n\tint a = 10;\n\tfunc(a); //调用无const\n\tfunc(10);//调用有const\n\n\n\t//func2(10); //碰到默认参数产生歧义，需要避免\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n## **4** 类和对象\n\n\n\nC++面向对象的三大特性为：==封装、继承、多态==\n\n\n\nC++认为==万事万物都皆为对象==，对象上有其属性和行为\n\n\n\n**例如：**\n\n\t人可以作为对象，属性有姓名、年龄、身高、体重...，行为有走、跑、跳、吃饭、唱歌...\n\t\n\t车也可以作为对象，属性有轮胎、方向盘、车灯...,行为有载人、放音乐、放空调...\n\t\n\t具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类\n\n### 4.1 封装\n\n#### 4.1.1  封装的意义\n\n封装是C++面向对象三大特性之一\n\n封装的意义：\n\n* 将属性和行为作为一个整体，表现生活中的事物\n* 将属性和行为加以权限控制\n\n\n\n**封装意义一：**\n\n\t在设计类的时候，属性和行为写在一起，表现事物\n\n**语法：** `class 类名{   访问权限： 属性  / 行为  };`\n\n\n\n**示例1：**设计一个圆类，求圆的周长\n\n**示例代码：**\n\n```C++\n//圆周率\nconst double PI = 3.14;\n\n//1、封装的意义\n//将属性和行为作为一个整体，用来表现生活中的事物\n\n//封装一个圆类，求圆的周长\n//class代表设计一个类，后面跟着的是类名\nclass Circle\n{\npublic:  //访问权限  公共的权限\n\n\t//属性\n\tint m_r;//半径\n\n\t//行为\n\t//获取到圆的周长\n\tdouble calculateZC()\n\t{\n\t\t//2 * pi  * r\n\t\t//获取圆的周长\n\t\treturn  2 * PI * m_r;\n\t}\n};\n\nint main() {\n\n\t//通过圆类，创建圆的对象\n\t// c1就是一个具体的圆\n\tCircle c1;\n\tc1.m_r = 10; //给圆对象的半径 进行赋值操作\n\n\t//2 * pi * 10 = = 62.8\n\tcout << \"圆的周长为： \" << c1.calculateZC() << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n**示例2：**设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号\n\n\n\n\n\n**示例2代码：**\n\n```C++\n//学生类\nclass Student {\npublic:\n\tvoid setName(string name) {\n\t\tm_name = name;\n\t}\n\tvoid setID(int id) {\n\t\tm_id = id;\n\t}\n\n\tvoid showStudent() {\n\t\tcout << \"name:\" << m_name << \" ID:\" << m_id << endl;\n\t}\npublic:\n\tstring m_name;\n\tint m_id;\n};\n\nint main() {\n\n\tStudent stu;\n\tstu.setName(\"德玛西亚\");\n\tstu.setID(250);\n\tstu.showStudent();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n\n```\n\n\n\n\n\n\n\n\n\n**封装意义二：**\n\n类在设计时，可以把属性和行为放在不同的权限下，加以控制\n\n访问权限有三种：\n\n\n\n1. public        公共权限  \n2. protected 保护权限\n3. private      私有权限\n\n\n\n\n\n\n\n**示例：**\n\n```C++\n//三种权限\n//公共权限  public     类内可以访问  类外可以访问\n//保护权限  protected  类内可以访问  类外不可以访问\n//私有权限  private    类内可以访问  类外不可以访问\n\nclass Person\n{\n\t//姓名  公共权限\npublic:\n\tstring m_Name;\n\n\t//汽车  保护权限\nprotected:\n\tstring m_Car;\n\n\t//银行卡密码  私有权限\nprivate:\n\tint m_Password;\n\npublic:\n\tvoid func()\n\t{\n\t\tm_Name = \"张三\";\n\t\tm_Car = \"拖拉机\";\n\t\tm_Password = 123456;\n\t}\n};\n\nint main() {\n\n\tPerson p;\n\tp.m_Name = \"李四\";\n\t//p.m_Car = \"奔驰\";  //保护权限类外访问不到\n\t//p.m_Password = 123; //私有权限类外访问不到\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n#### 4.1.2 struct和class区别\n\n\n\n在C++中 struct和class唯一的**区别**就在于 **默认的访问权限不同**\n\n区别：\n\n* struct 默认权限为公共\n* class   默认权限为私有\n\n\n\n```C++\nclass C1\n{\n\tint  m_A; //默认是私有权限\n};\n\nstruct C2\n{\n\tint m_A;  //默认是公共权限\n};\n\nint main() {\n\n\tC1 c1;\n\tc1.m_A = 10; //错误，访问权限是私有\n\n\tC2 c2;\n\tc2.m_A = 10; //正确，访问权限是公共\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.1.3 成员属性设置为私有\n\n\n\n**优点1：**将所有成员属性设置为私有，可以自己控制读写权限\n\n**优点2：**对于写权限，我们可以检测数据的有效性\n\n\n\n**示例：**\n\n```C++\nclass Person {\npublic:\n\n\t//姓名设置可读可写\n\tvoid setName(string name) {\n\t\tm_Name = name;\n\t}\n\tstring getName()\n\t{\n\t\treturn m_Name;\n\t}\n\n\n\t//获取年龄 \n\tint getAge() {\n\t\treturn m_Age;\n\t}\n\t//设置年龄\n\tvoid setAge(int age) {\n\t\tif (age < 0 || age > 150) {\n\t\t\tcout << \"你个老妖精!\" << endl;\n\t\t\treturn;\n\t\t}\n\t\tm_Age = age;\n\t}\n\n\t//情人设置为只写\n\tvoid setLover(string lover) {\n\t\tm_Lover = lover;\n\t}\n\nprivate:\n\tstring m_Name; //可读可写  姓名\n\t\n\tint m_Age; //只读  年龄\n\n\tstring m_Lover; //只写  情人\n};\n\n\nint main() {\n\n\tPerson p;\n\t//姓名设置\n\tp.setName(\"张三\");\n\tcout << \"姓名： \" << p.getName() << endl;\n\n\t//年龄设置\n\tp.setAge(50);\n\tcout << \"年龄： \" << p.getAge() << endl;\n\n\t//情人设置\n\tp.setLover(\"苍井\");\n\t//cout << \"情人： \" << p.m_Lover << endl;  //只写属性，不可以读取\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n**练习案例1：设计立方体类**\n\n设计立方体类(Cube)\n\n求出立方体的面积和体积\n\n分别用全局函数和成员函数判断两个立方体是否相等。\n\n\n\n![1545533548532](assets/1545533548532.png)\n\n\n\n\n\n\n\n\n\n\n\n**练习案例2：点和圆的关系**\n\n设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。\n\n\n\n![1545533829184](assets/1545533829184.png)\n\n\n\n\n\n\n\n### 4.2 对象的初始化和清理\n\n\n\n*  生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全\n*  C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。\n\n\n\n\n\n#### 4.2.1 构造函数和析构函数\n\n对象的**初始化和清理**也是两个非常重要的安全问题\n\n\t一个对象或者变量没有初始状态，对其使用后果是未知\n\t\n\t同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题\n\n\n\nc++利用了**构造函数**和**析构函数**解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。\n\n对象的初始化和清理工作是编译器强制要我们做的事情，因此如果**我们不提供构造和析构，编译器会提供**\n\n**编译器提供的构造函数和析构函数是空实现。**\n\n\n\n* 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。\n* 析构函数：主要作用在于对象**销毁前**系统自动调用，执行一些清理工作。\n\n\n\n\n\n**构造函数语法：**`类名(){}`\n\n1. 构造函数，没有返回值也不写void\n2. 函数名称与类名相同\n3. 构造函数可以有参数，因此可以发生重载\n4. 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次\n\n\n\n\n\n**析构函数语法：** `~类名(){}`\n\n1. 析构函数，没有返回值也不写void\n2. 函数名称与类名相同,在名称前加上符号  ~\n3. 析构函数不可以有参数，因此不可以发生重载\n4. 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次\n\n\n\n\n\n```C++\nclass Person\n{\npublic:\n\t//构造函数\n\tPerson()\n\t{\n\t\tcout << \"Person的构造函数调用\" << endl;\n\t}\n\t//析构函数\n\t~Person()\n\t{\n\t\tcout << \"Person的析构函数调用\" << endl;\n\t}\n\n};\n\nvoid test01()\n{\n\tPerson p;\n}\n\nint main() {\n\t\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n#### 4.2.2 构造函数的分类及调用\n\n两种分类方式：\n\n\t按参数分为： 有参构造和无参构造\n\t\n\t按类型分为： 普通构造和拷贝构造\n\n三种调用方式：\n\n\t括号法\n\t\n\t显示法\n\t\n\t隐式转换法\n\n\n\n**示例：**\n\n```C++\n//1、构造函数分类\n// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数\n// 按照类型分类分为 普通构造和拷贝构造\n\nclass Person {\npublic:\n\t//无参（默认）构造函数\n\tPerson() {\n\t\tcout << \"无参构造函数!\" << endl;\n\t}\n\t//有参构造函数\n\tPerson(int a) {\n\t\tage = a;\n\t\tcout << \"有参构造函数!\" << endl;\n\t}\n\t//拷贝构造函数\n\tPerson(const Person& p) {\n\t\tage = p.age;\n\t\tcout << \"拷贝构造函数!\" << endl;\n\t}\n\t//析构函数\n\t~Person() {\n\t\tcout << \"析构函数!\" << endl;\n\t}\npublic:\n\tint age;\n};\n\n//2、构造函数的调用\n//调用无参构造函数\nvoid test01() {\n\tPerson p; //调用无参构造函数\n}\n\n//调用有参的构造函数\nvoid test02() {\n\n\t//2.1  括号法，常用\n\tPerson p1(10);\n\t//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明\n\t//Person p2();\n\n\t//2.2 显式法\n\tPerson p2 = Person(10); \n\tPerson p3 = Person(p2);\n\t//Person(10)单独写就是匿名对象  当前行结束之后，马上析构\n\n\t//2.3 隐式转换法\n\tPerson p4 = 10; // Person p4 = Person(10); \n\tPerson p5 = p4; // Person p5 = Person(p4); \n\n\t//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明\n\t//Person p5(p4);\n}\n\nint main() {\n\n\ttest01();\n\t//test02();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n#### 4.2.3 拷贝构造函数调用时机\n\n\n\nC++中拷贝构造函数调用时机通常有三种情况\n\n* 使用一个已经创建完毕的对象来初始化一个新对象\n* 值传递的方式给函数参数传值\n* 以值方式返回局部对象\n\n\n\n**示例：**\n\n```C++\nclass Person {\npublic:\n\tPerson() {\n\t\tcout << \"无参构造函数!\" << endl;\n\t\tmAge = 0;\n\t}\n\tPerson(int age) {\n\t\tcout << \"有参构造函数!\" << endl;\n\t\tmAge = age;\n\t}\n\tPerson(const Person& p) {\n\t\tcout << \"拷贝构造函数!\" << endl;\n\t\tmAge = p.mAge;\n\t}\n\t//析构函数在释放内存之前调用\n\t~Person() {\n\t\tcout << \"析构函数!\" << endl;\n\t}\npublic:\n\tint mAge;\n};\n\n//1. 使用一个已经创建完毕的对象来初始化一个新对象\nvoid test01() {\n\n\tPerson man(100); //p对象已经创建完毕\n\tPerson newman(man); //调用拷贝构造函数\n\tPerson newman2 = man; //拷贝构造\n\n\t//Person newman3;\n\t//newman3 = man; //不是调用拷贝构造函数，赋值操作\n}\n\n//2. 值传递的方式给函数参数传值\n//相当于Person p1 = p;\nvoid doWork(Person p1) {}\nvoid test02() {\n\tPerson p; //无参构造函数\n\tdoWork(p);\n}\n\n//3. 以值方式返回局部对象\nPerson doWork2()\n{\n\tPerson p1;\n\tcout << (int *)&p1 << endl;\n\treturn p1;\n}\n\nvoid test03()\n{\n\tPerson p = doWork2();\n\tcout << (int *)&p << endl;\n}\n\n\nint main() {\n\n\t//test01();\n\t//test02();\n\ttest03();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n#### 4.2.4 构造函数调用规则\n\n默认情况下，c++编译器至少给一个类添加3个函数\n\n1．默认构造函数(无参，函数体为空)\n\n2．默认析构函数(无参，函数体为空)\n\n3．默认拷贝构造函数，对属性进行值拷贝\n\n\n\n构造函数调用规则如下：\n\n* 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造\n\n\n* 如果用户定义拷贝构造函数，c++不会再提供其他构造函数\n\n\n\n示例：\n\n```C++\nclass Person {\npublic:\n\t//无参（默认）构造函数\n\tPerson() {\n\t\tcout << \"无参构造函数!\" << endl;\n\t}\n\t//有参构造函数\n\tPerson(int a) {\n\t\tage = a;\n\t\tcout << \"有参构造函数!\" << endl;\n\t}\n\t//拷贝构造函数\n\tPerson(const Person& p) {\n\t\tage = p.age;\n\t\tcout << \"拷贝构造函数!\" << endl;\n\t}\n\t//析构函数\n\t~Person() {\n\t\tcout << \"析构函数!\" << endl;\n\t}\npublic:\n\tint age;\n};\n\nvoid test01()\n{\n\tPerson p1(18);\n\t//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作\n\tPerson p2(p1);\n\n\tcout << \"p2的年龄为： \" << p2.age << endl;\n}\n\nvoid test02()\n{\n\t//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造\n\tPerson p1; //此时如果用户自己没有提供默认构造，会出错\n\tPerson p2(10); //用户提供的有参\n\tPerson p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供\n\n\t//如果用户提供拷贝构造，编译器不会提供其他构造函数\n\tPerson p4; //此时如果用户自己没有提供默认构造，会出错\n\tPerson p5(10); //此时如果用户自己没有提供有参，会出错\n\tPerson p6(p5); //用户自己提供拷贝构造\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n#### 4.2.5 深拷贝与浅拷贝\n\n\n\n深浅拷贝是面试经典问题，也是常见的一个坑\n\n\n\n浅拷贝：简单的赋值拷贝操作\n\n\n\n深拷贝：在堆区重新申请空间，进行拷贝操作\n\n\n\n**示例：**\n\n```C++\nclass Person {\npublic:\n\t//无参（默认）构造函数\n\tPerson() {\n\t\tcout << \"无参构造函数!\" << endl;\n\t}\n\t//有参构造函数\n\tPerson(int age ,int height) {\n\t\t\n\t\tcout << \"有参构造函数!\" << endl;\n\n\t\tm_age = age;\n\t\tm_height = new int(height);\n\t\t\n\t}\n\t//拷贝构造函数  \n\tPerson(const Person& p) {\n\t\tcout << \"拷贝构造函数!\" << endl;\n\t\t//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题\n\t\tm_age = p.m_age;\n\t\tm_height = new int(*p.m_height);\n\t\t\n\t}\n\n\t//析构函数\n\t~Person() {\n\t\tcout << \"析构函数!\" << endl;\n\t\tif (m_height != NULL)\n\t\t{\n\t\t\tdelete m_height;\n\t\t}\n\t}\npublic:\n\tint m_age;\n\tint* m_height;\n};\n\nvoid test01()\n{\n\tPerson p1(18, 180);\n\n\tPerson p2(p1);\n\n\tcout << \"p1的年龄： \" << p1.m_age << \" 身高： \" << *p1.m_height << endl;\n\n\tcout << \"p2的年龄： \" << p2.m_age << \" 身高： \" << *p2.m_height << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n> 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题\n\n\n\n\n\n\n\n\n\n#### 4.2.6 初始化列表\n\n\n\n**作用：**\n\nC++提供了初始化列表语法，用来初始化属性\n\n\n\n**语法：**`构造函数()：属性1(值1),属性2（值2）... {}`\n\n\n\n**示例：**\n\n```C++\nclass Person {\npublic:\n\n\t////传统方式初始化\n\t//Person(int a, int b, int c) {\n\t//\tm_A = a;\n\t//\tm_B = b;\n\t//\tm_C = c;\n\t//}\n\n\t//初始化列表方式初始化\n\tPerson(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}\n\tvoid PrintPerson() {\n\t\tcout << \"mA:\" << m_A << endl;\n\t\tcout << \"mB:\" << m_B << endl;\n\t\tcout << \"mC:\" << m_C << endl;\n\t}\nprivate:\n\tint m_A;\n\tint m_B;\n\tint m_C;\n};\n\nint main() {\n\n\tPerson p(1, 2, 3);\n\tp.PrintPerson();\n\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n#### 4.2.7 类对象作为类成员\n\n\n\nC++类中的成员可以是另一个类的对象，我们称该成员为 对象成员\n\n\n\n例如：\n\n```C++\nclass A {}\nclass B\n{\n    A a；\n}\n```\n\n\n\nB类中有对象A作为成员，A为对象成员\n\n\n\n那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？\n\n\n\n**示例：**\n\n```C++\nclass Phone\n{\npublic:\n\tPhone(string name)\n\t{\n\t\tm_PhoneName = name;\n\t\tcout << \"Phone构造\" << endl;\n\t}\n\n\t~Phone()\n\t{\n\t\tcout << \"Phone析构\" << endl;\n\t}\n\n\tstring m_PhoneName;\n\n};\n\n\nclass Person\n{\npublic:\n\n\t//初始化列表可以告诉编译器调用哪一个构造函数\n\tPerson(string name, string pName) :m_Name(name), m_Phone(pName)\n\t{\n\t\tcout << \"Person构造\" << endl;\n\t}\n\n\t~Person()\n\t{\n\t\tcout << \"Person析构\" << endl;\n\t}\n\n\tvoid playGame()\n\t{\n\t\tcout << m_Name << \" 使用\" << m_Phone.m_PhoneName << \" 牌手机! \" << endl;\n\t}\n\n\tstring m_Name;\n\tPhone m_Phone;\n\n};\nvoid test01()\n{\n\t//当类中成员是其他类对象时，我们称该成员为 对象成员\n\t//构造的顺序是 ：先调用对象成员的构造，再调用本类构造\n\t//析构顺序与构造相反\n\tPerson p(\"张三\" , \"苹果X\");\n\tp.playGame();\n\n}\n\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n#### 4.2.8 静态成员\n\n静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员\n\n静态成员分为：\n\n\n\n*  静态成员变量\n   *  所有对象共享同一份数据\n   *  在编译阶段分配内存\n   *  类内声明，类外初始化\n*  静态成员函数\n   *  所有对象共享同一个函数\n   *  静态成员函数只能访问静态成员变量\n\n\n\n\n\n\n\n**示例1 ：**静态成员变量\n\n```C++\nclass Person\n{\n\t\npublic:\n\n\tstatic int m_A; //静态成员变量\n\n\t//静态成员变量特点：\n\t//1 在编译阶段分配内存\n\t//2 类内声明，类外初始化\n\t//3 所有对象共享同一份数据\n\nprivate:\n\tstatic int m_B; //静态成员变量也是有访问权限的\n};\nint Person::m_A = 10;\nint Person::m_B = 10;\n\nvoid test01()\n{\n\t//静态成员变量两种访问方式\n\n\t//1、通过对象\n\tPerson p1;\n\tp1.m_A = 100;\n\tcout << \"p1.m_A = \" << p1.m_A << endl;\n\n\tPerson p2;\n\tp2.m_A = 200;\n\tcout << \"p1.m_A = \" << p1.m_A << endl; //共享同一份数据\n\tcout << \"p2.m_A = \" << p2.m_A << endl;\n\n\t//2、通过类名\n\tcout << \"m_A = \" << Person::m_A << endl;\n\n\n\t//cout << \"m_B = \" << Person::m_B << endl; //私有权限访问不到\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n**示例2：**静态成员函数\n\n```C++\nclass Person\n{\n\npublic:\n\n\t//静态成员函数特点：\n\t//1 程序共享一个函数\n\t//2 静态成员函数只能访问静态成员变量\n\t\n\tstatic void func()\n\t{\n\t\tcout << \"func调用\" << endl;\n\t\tm_A = 100;\n\t\t//m_B = 100; //错误，不可以访问非静态成员变量\n\t}\n\n\tstatic int m_A; //静态成员变量\n\tint m_B; // \nprivate:\n\n\t//静态成员函数也是有访问权限的\n\tstatic void func2()\n\t{\n\t\tcout << \"func2调用\" << endl;\n\t}\n};\nint Person::m_A = 10;\n\n\nvoid test01()\n{\n\t//静态成员变量两种访问方式\n\n\t//1、通过对象\n\tPerson p1;\n\tp1.func();\n\n\t//2、通过类名\n\tPerson::func();\n\n\n\t//Person::func2(); //私有权限访问不到\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n### 4.3 C++对象模型和this指针\n\n\n\n#### 4.3.1 成员变量和成员函数分开存储\n\n\n\n在C++中，类内的成员变量和成员函数分开存储\n\n只有非静态成员变量才属于类的对象上\n\n\n\n```C++\nclass Person {\npublic:\n\tPerson() {\n\t\tmA = 0;\n\t}\n\t//非静态成员变量占对象空间\n\tint mA;\n\t//静态成员变量不占对象空间\n\tstatic int mB; \n\t//函数也不占对象空间，所有函数共享一个函数实例\n\tvoid func() {\n\t\tcout << \"mA:\" << this->mA << endl;\n\t}\n\t//静态成员函数也不占对象空间\n\tstatic void sfunc() {\n\t}\n};\n\nint main() {\n\n\tcout << sizeof(Person) << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n#### 4.3.2 this指针概念\n\n通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的\n\n每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码\n\n那么问题是：这一块代码是如何区分那个对象调用自己的呢？\n\n\n\nc++通过提供特殊的对象指针，this指针，解决上述问题。**this指针指向被调用的成员函数所属的对象**\n\n\n\nthis指针是隐含每一个非静态成员函数内的一种指针\n\nthis指针不需要定义，直接使用即可\n\n\n\nthis指针的用途：\n\n*  当形参和成员变量同名时，可用this指针来区分\n*  在类的非静态成员函数中返回对象本身，可使用return *this\n\n```C++\nclass Person\n{\npublic:\n\n\tPerson(int age)\n\t{\n\t\t//1、当形参和成员变量同名时，可用this指针来区分\n\t\tthis->age = age;\n\t}\n\n\tPerson& PersonAddPerson(Person p)\n\t{\n\t\tthis->age += p.age;\n\t\t//返回对象本身\n\t\treturn *this;\n\t}\n\n\tint age;\n};\n\nvoid test01()\n{\n\tPerson p1(10);\n\tcout << \"p1.age = \" << p1.age << endl;\n\n\tPerson p2(10);\n\tp2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);\n\tcout << \"p2.age = \" << p2.age << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n#### 4.3.3 空指针访问成员函数\n\n\n\nC++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针\n\n\n\n如果用到this指针，需要加以判断保证代码的健壮性\n\n\n\n**示例：**\n\n```C++\n//空指针访问成员函数\nclass Person {\npublic:\n\n\tvoid ShowClassName() {\n\t\tcout << \"我是Person类!\" << endl;\n\t}\n\n\tvoid ShowPerson() {\n\t\tif (this == NULL) {\n\t\t\treturn;\n\t\t}\n\t\tcout << mAge << endl;\n\t}\n\npublic:\n\tint mAge;\n};\n\nvoid test01()\n{\n\tPerson * p = NULL;\n\tp->ShowClassName(); //空指针，可以调用成员函数\n\tp->ShowPerson();  //但是如果成员函数中用到了this指针，就不可以了\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n#### 4.3.4 const修饰成员函数\n\n\n\n**常函数：**\n\n* 成员函数后加const后我们称为这个函数为**常函数**\n* 常函数内不可以修改成员属性\n* 成员属性声明时加关键字mutable后，在常函数中依然可以修改\n\n\n\n**常对象：**\n\n* 声明对象前加const称该对象为常对象\n* 常对象只能调用常函数\n\n\n\n\n\n\n\n**示例：**\n\n```C++\nclass Person {\npublic:\n\tPerson() {\n\t\tm_A = 0;\n\t\tm_B = 0;\n\t}\n\n\t//this指针的本质是一个指针常量，指针的指向不可修改\n\t//如果想让指针指向的值也不可以修改，需要声明常函数\n\tvoid ShowPerson() const {\n\t\t//const Type* const pointer;\n\t\t//this = NULL; //不能修改指针的指向 Person* const this;\n\t\t//this->mA = 100; //但是this指针指向的对象的数据是可以修改的\n\n\t\t//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量\n\t\tthis->m_B = 100;\n\t}\n\n\tvoid MyFunc() const {\n\t\t//mA = 10000;\n\t}\n\npublic:\n\tint m_A;\n\tmutable int m_B; //可修改 可变的\n};\n\n\n//const修饰对象  常对象\nvoid test01() {\n\n\tconst Person person; //常量对象  \n\tcout << person.m_A << endl;\n\t//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问\n\tperson.m_B = 100; //但是常对象可以修改mutable修饰成员变量\n\n\t//常对象访问成员函数\n\tperson.MyFunc(); //常对象不能调用const的函数\n\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n### 4.4 友元\n\n\n\n生活中你的家有客厅(Public)，有你的卧室(Private)\n\n客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去\n\n但是呢，你也可以允许你的好闺蜜好基友进去。\n\n\n\n在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术\n\n\n\n友元的目的就是让一个函数或者类 访问另一个类中私有成员\n\n\n\n友元的关键字为  ==friend==\n\n\n\n友元的三种实现\n\n* 全局函数做友元\n* 类做友元\n* 成员函数做友元\n\n\n\n\n\n#### 4.4.1 全局函数做友元\n\n```C++\nclass Building\n{\n\t//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容\n\tfriend void goodGay(Building * building);\n\npublic:\n\n\tBuilding()\n\t{\n\t\tthis->m_SittingRoom = \"客厅\";\n\t\tthis->m_BedRoom = \"卧室\";\n\t}\n\n\npublic:\n\tstring m_SittingRoom; //客厅\n\nprivate:\n\tstring m_BedRoom; //卧室\n};\n\n\nvoid goodGay(Building * building)\n{\n\tcout << \"好基友正在访问： \" << building->m_SittingRoom << endl;\n\tcout << \"好基友正在访问： \" << building->m_BedRoom << endl;\n}\n\n\nvoid test01()\n{\n\tBuilding b;\n\tgoodGay(&b);\n}\n\nint main(){\n\n\ttest01();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n\n#### 4.4.2 类做友元\n\n\n\n```C++\nclass Building;\nclass goodGay\n{\npublic:\n\n\tgoodGay();\n\tvoid visit();\n\nprivate:\n\tBuilding *building;\n};\n\n\nclass Building\n{\n\t//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容\n\tfriend class goodGay;\n\npublic:\n\tBuilding();\n\npublic:\n\tstring m_SittingRoom; //客厅\nprivate:\n\tstring m_BedRoom;//卧室\n};\n\nBuilding::Building()\n{\n\tthis->m_SittingRoom = \"客厅\";\n\tthis->m_BedRoom = \"卧室\";\n}\n\ngoodGay::goodGay()\n{\n\tbuilding = new Building;\n}\n\nvoid goodGay::visit()\n{\n\tcout << \"好基友正在访问\" << building->m_SittingRoom << endl;\n\tcout << \"好基友正在访问\" << building->m_BedRoom << endl;\n}\n\nvoid test01()\n{\n\tgoodGay gg;\n\tgg.visit();\n\n}\n\nint main(){\n\n\ttest01();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n\n\n\n#### 4.4.3 成员函数做友元\n\n\n\n```C++\nclass Building;\nclass goodGay\n{\npublic:\n\n\tgoodGay();\n\tvoid visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容\n\tvoid visit2(); \n\nprivate:\n\tBuilding *building;\n};\n\n\nclass Building\n{\n\t//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容\n\tfriend void goodGay::visit();\n\npublic:\n\tBuilding();\n\npublic:\n\tstring m_SittingRoom; //客厅\nprivate:\n\tstring m_BedRoom;//卧室\n};\n\nBuilding::Building()\n{\n\tthis->m_SittingRoom = \"客厅\";\n\tthis->m_BedRoom = \"卧室\";\n}\n\ngoodGay::goodGay()\n{\n\tbuilding = new Building;\n}\n\nvoid goodGay::visit()\n{\n\tcout << \"好基友正在访问\" << building->m_SittingRoom << endl;\n\tcout << \"好基友正在访问\" << building->m_BedRoom << endl;\n}\n\nvoid goodGay::visit2()\n{\n\tcout << \"好基友正在访问\" << building->m_SittingRoom << endl;\n\t//cout << \"好基友正在访问\" << building->m_BedRoom << endl;\n}\n\nvoid test01()\n{\n\tgoodGay  gg;\n\tgg.visit();\n\n}\n\nint main(){\n    \n\ttest01();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n### 4.5 运算符重载\n\n\n\n运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型\n\n\n\n#### 4.5.1 加号运算符重载\n\n\n\n作用：实现两个自定义数据类型相加的运算\n\n\n\n```C++\nclass Person {\npublic:\n\tPerson() {};\n\tPerson(int a, int b)\n\t{\n\t\tthis->m_A = a;\n\t\tthis->m_B = b;\n\t}\n\t//成员函数实现 + 号运算符重载\n\tPerson operator+(const Person& p) {\n\t\tPerson temp;\n\t\ttemp.m_A = this->m_A + p.m_A;\n\t\ttemp.m_B = this->m_B + p.m_B;\n\t\treturn temp;\n\t}\n\n\npublic:\n\tint m_A;\n\tint m_B;\n};\n\n//全局函数实现 + 号运算符重载\n//Person operator+(const Person& p1, const Person& p2) {\n//\tPerson temp(0, 0);\n//\ttemp.m_A = p1.m_A + p2.m_A;\n//\ttemp.m_B = p1.m_B + p2.m_B;\n//\treturn temp;\n//}\n\n//运算符重载 可以发生函数重载 \nPerson operator+(const Person& p2, int val)  \n{\n\tPerson temp;\n\ttemp.m_A = p2.m_A + val;\n\ttemp.m_B = p2.m_B + val;\n\treturn temp;\n}\n\nvoid test() {\n\n\tPerson p1(10, 10);\n\tPerson p2(20, 20);\n\n\t//成员函数方式\n\tPerson p3 = p2 + p1;  //相当于 p2.operaor+(p1)\n\tcout << \"mA:\" << p3.m_A << \" mB:\" << p3.m_B << endl;\n\n\n\tPerson p4 = p3 + 10; //相当于 operator+(p3,10)\n\tcout << \"mA:\" << p4.m_A << \" mB:\" << p4.m_B << endl;\n\n}\n\nint main() {\n\n\ttest();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n> 总结1：对于内置的数据类型的表达式的的运算符是不可能改变的\n\n> 总结2：不要滥用运算符重载\n\n\n\n\n\n\n\n#### 4.5.2 左移运算符重载\n\n\n\n作用：可以输出自定义数据类型\n\n\n\n```C++\nclass Person {\n\tfriend ostream& operator<<(ostream& out, Person& p);\n\npublic:\n\n\tPerson(int a, int b)\n\t{\n\t\tthis->m_A = a;\n\t\tthis->m_B = b;\n\t}\n\n\t//成员函数 实现不了  p << cout 不是我们想要的效果\n\t//void operator<<(Person& p){\n\t//}\n\nprivate:\n\tint m_A;\n\tint m_B;\n};\n\n//全局函数实现左移重载\n//ostream对象只能有一个\nostream& operator<<(ostream& out, Person& p) {\n\tout << \"a:\" << p.m_A << \" b:\" << p.m_B;\n\treturn out;\n}\n\nvoid test() {\n\n\tPerson p1(10, 20);\n\n\tcout << p1 << \"hello world\" << endl; //链式编程\n}\n\nint main() {\n\n\ttest();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n> 总结：重载左移运算符配合友元可以实现输出自定义数据类型\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.5.3 递增运算符重载\n\n\n\n作用： 通过重载递增运算符，实现自己的整型数据\n\n\n\n```C++\nclass MyInteger {\n\n\tfriend ostream& operator<<(ostream& out, MyInteger myint);\n\npublic:\n\tMyInteger() {\n\t\tm_Num = 0;\n\t}\n\t//前置++\n\tMyInteger& operator++() {\n\t\t//先++\n\t\tm_Num++;\n\t\t//再返回\n\t\treturn *this;\n\t}\n\n\t//后置++\n\tMyInteger operator++(int) {\n\t\t//先返回\n\t\tMyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；\n\t\tm_Num++;\n\t\treturn temp;\n\t}\n\nprivate:\n\tint m_Num;\n};\n\n\nostream& operator<<(ostream& out, MyInteger myint) {\n\tout << myint.m_Num;\n\treturn out;\n}\n\n\n//前置++ 先++ 再返回\nvoid test01() {\n\tMyInteger myInt;\n\tcout << ++myInt << endl;\n\tcout << myInt << endl;\n}\n\n//后置++ 先返回 再++\nvoid test02() {\n\n\tMyInteger myInt;\n\tcout << myInt++ << endl;\n\tcout << myInt << endl;\n}\n\nint main() {\n\n\ttest01();\n\t//test02();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n> 总结： 前置递增返回引用，后置递增返回值\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.5.4 赋值运算符重载\n\n\n\nc++编译器至少给一个类添加4个函数\n\n1. 默认构造函数(无参，函数体为空)\n2. 默认析构函数(无参，函数体为空)\n3. 默认拷贝构造函数，对属性进行值拷贝\n4. 赋值运算符 operator=, 对属性进行值拷贝\n\n\n\n\n\n如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题\n\n\n\n\n\n**示例：**\n\n```C++\nclass Person\n{\npublic:\n\n\tPerson(int age)\n\t{\n\t\t//将年龄数据开辟到堆区\n\t\tm_Age = new int(age);\n\t}\n\n\t//重载赋值运算符 \n\tPerson& operator=(Person &p)\n\t{\n\t\tif (m_Age != NULL)\n\t\t{\n\t\t\tdelete m_Age;\n\t\t\tm_Age = NULL;\n\t\t}\n\t\t//编译器提供的代码是浅拷贝\n\t\t//m_Age = p.m_Age;\n\n\t\t//提供深拷贝 解决浅拷贝的问题\n\t\tm_Age = new int(*p.m_Age);\n\n\t\t//返回自身\n\t\treturn *this;\n\t}\n\n\n\t~Person()\n\t{\n\t\tif (m_Age != NULL)\n\t\t{\n\t\t\tdelete m_Age;\n\t\t\tm_Age = NULL;\n\t\t}\n\t}\n\n\t//年龄的指针\n\tint *m_Age;\n\n};\n\n\nvoid test01()\n{\n\tPerson p1(18);\n\n\tPerson p2(20);\n\n\tPerson p3(30);\n\n\tp3 = p2 = p1; //赋值操作\n\n\tcout << \"p1的年龄为：\" << *p1.m_Age << endl;\n\n\tcout << \"p2的年龄为：\" << *p2.m_Age << endl;\n\n\tcout << \"p3的年龄为：\" << *p3.m_Age << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\t//int a = 10;\n\t//int b = 20;\n\t//int c = 30;\n\n\t//c = b = a;\n\t//cout << \"a = \" << a << endl;\n\t//cout << \"b = \" << b << endl;\n\t//cout << \"c = \" << c << endl;\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n#### 4.5.5 关系运算符重载\n\n\n\n**作用：**重载关系运算符，可以让两个自定义类型对象进行对比操作\n\n\n\n**示例：**\n\n```C++\nclass Person\n{\npublic:\n\tPerson(string name, int age)\n\t{\n\t\tthis->m_Name = name;\n\t\tthis->m_Age = age;\n\t};\n\n\tbool operator==(Person & p)\n\t{\n\t\tif (this->m_Name == p.m_Name && this->m_Age == p.m_Age)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tbool operator!=(Person & p)\n\t{\n\t\tif (this->m_Name == p.m_Name && this->m_Age == p.m_Age)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstring m_Name;\n\tint m_Age;\n};\n\nvoid test01()\n{\n\t//int a = 0;\n\t//int b = 0;\n\n\tPerson a(\"孙悟空\", 18);\n\tPerson b(\"孙悟空\", 18);\n\n\tif (a == b)\n\t{\n\t\tcout << \"a和b相等\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"a和b不相等\" << endl;\n\t}\n\n\tif (a != b)\n\t{\n\t\tcout << \"a和b不相等\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"a和b相等\" << endl;\n\t}\n}\n\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n#### 4.5.6 函数调用运算符重载\n\n\n\n* 函数调用运算符 ()  也可以重载\n* 由于重载后使用的方式非常像函数的调用，因此称为仿函数\n* 仿函数没有固定写法，非常灵活\n\n\n\n**示例：**\n\n```C++\nclass MyPrint\n{\npublic:\n\tvoid operator()(string text)\n\t{\n\t\tcout << text << endl;\n\t}\n\n};\nvoid test01()\n{\n\t//重载的（）操作符 也称为仿函数\n\tMyPrint myFunc;\n\tmyFunc(\"hello world\");\n}\n\n\nclass MyAdd\n{\npublic:\n\tint operator()(int v1, int v2)\n\t{\n\t\treturn v1 + v2;\n\t}\n};\n\nvoid test02()\n{\n\tMyAdd add;\n\tint ret = add(10, 10);\n\tcout << \"ret = \" << ret << endl;\n\n\t//匿名对象调用  \n\tcout << \"MyAdd()(100,100) = \" << MyAdd()(100, 100) << endl;\n}\n\nint main() {\n\n\ttest01();\n\ttest02();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n### 4.6  继承\n\n**继承是面向对象三大特性之一**\n\n有些类与类之间存在特殊的关系，例如下图中：\n\n![1544861202252](assets/1544861202252.png)\n\n我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。\n\n这个时候我们就可以考虑利用继承的技术，减少重复代码\n\n\n\n#### 4.6.1 继承的基本语法\n\n\n\n例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同\n\n接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处\n\n\n\n**普通实现：**\n\n```C++\n//Java页面\nclass Java \n{\npublic:\n\tvoid header()\n\t{\n\t\tcout << \"首页、公开课、登录、注册...（公共头部）\" << endl;\n\t}\n\tvoid footer()\n\t{\n\t\tcout << \"帮助中心、交流合作、站内地图...(公共底部)\" << endl;\n\t}\n\tvoid left()\n\t{\n\t\tcout << \"Java,Python,C++...(公共分类列表)\" << endl;\n\t}\n\tvoid content()\n\t{\n\t\tcout << \"JAVA学科视频\" << endl;\n\t}\n};\n//Python页面\nclass Python\n{\npublic:\n\tvoid header()\n\t{\n\t\tcout << \"首页、公开课、登录、注册...（公共头部）\" << endl;\n\t}\n\tvoid footer()\n\t{\n\t\tcout << \"帮助中心、交流合作、站内地图...(公共底部)\" << endl;\n\t}\n\tvoid left()\n\t{\n\t\tcout << \"Java,Python,C++...(公共分类列表)\" << endl;\n\t}\n\tvoid content()\n\t{\n\t\tcout << \"Python学科视频\" << endl;\n\t}\n};\n//C++页面\nclass CPP \n{\npublic:\n\tvoid header()\n\t{\n\t\tcout << \"首页、公开课、登录、注册...（公共头部）\" << endl;\n\t}\n\tvoid footer()\n\t{\n\t\tcout << \"帮助中心、交流合作、站内地图...(公共底部)\" << endl;\n\t}\n\tvoid left()\n\t{\n\t\tcout << \"Java,Python,C++...(公共分类列表)\" << endl;\n\t}\n\tvoid content()\n\t{\n\t\tcout << \"C++学科视频\" << endl;\n\t}\n};\n\nvoid test01()\n{\n\t//Java页面\n\tcout << \"Java下载视频页面如下： \" << endl;\n\tJava ja;\n\tja.header();\n\tja.footer();\n\tja.left();\n\tja.content();\n\tcout << \"--------------------\" << endl;\n\n\t//Python页面\n\tcout << \"Python下载视频页面如下： \" << endl;\n\tPython py;\n\tpy.header();\n\tpy.footer();\n\tpy.left();\n\tpy.content();\n\tcout << \"--------------------\" << endl;\n\n\t//C++页面\n\tcout << \"C++下载视频页面如下： \" << endl;\n\tCPP cp;\n\tcp.header();\n\tcp.footer();\n\tcp.left();\n\tcp.content();\n\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n**继承实现：**\n\n```C++\n//公共页面\nclass BasePage\n{\npublic:\n\tvoid header()\n\t{\n\t\tcout << \"首页、公开课、登录、注册...（公共头部）\" << endl;\n\t}\n\n\tvoid footer()\n\t{\n\t\tcout << \"帮助中心、交流合作、站内地图...(公共底部)\" << endl;\n\t}\n\tvoid left()\n\t{\n\t\tcout << \"Java,Python,C++...(公共分类列表)\" << endl;\n\t}\n\n};\n\n//Java页面\nclass Java : public BasePage\n{\npublic:\n\tvoid content()\n\t{\n\t\tcout << \"JAVA学科视频\" << endl;\n\t}\n};\n//Python页面\nclass Python : public BasePage\n{\npublic:\n\tvoid content()\n\t{\n\t\tcout << \"Python学科视频\" << endl;\n\t}\n};\n//C++页面\nclass CPP : public BasePage\n{\npublic:\n\tvoid content()\n\t{\n\t\tcout << \"C++学科视频\" << endl;\n\t}\n};\n\nvoid test01()\n{\n\t//Java页面\n\tcout << \"Java下载视频页面如下： \" << endl;\n\tJava ja;\n\tja.header();\n\tja.footer();\n\tja.left();\n\tja.content();\n\tcout << \"--------------------\" << endl;\n\n\t//Python页面\n\tcout << \"Python下载视频页面如下： \" << endl;\n\tPython py;\n\tpy.header();\n\tpy.footer();\n\tpy.left();\n\tpy.content();\n\tcout << \"--------------------\" << endl;\n\n\t//C++页面\n\tcout << \"C++下载视频页面如下： \" << endl;\n\tCPP cp;\n\tcp.header();\n\tcp.footer();\n\tcp.left();\n\tcp.content();\n\n\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n**总结：**\n\n继承的好处：==可以减少重复的代码==\n\nclass A : public B; \n\nA 类称为子类 或 派生类\n\nB 类称为父类 或 基类\n\n\n\n**派生类中的成员，包含两大部分**：\n\n一类是从基类继承过来的，一类是自己增加的成员。\n\n从基类继承过过来的表现其共性，而新增的成员体现了其个性。\n\n\n\n\n\n\n\n\n\n#### 4.6.2 继承方式\n\n\n\n继承的语法：`class 子类 : 继承方式  父类`\n\n\n\n**继承方式一共有三种：**\n\n* 公共继承\n* 保护继承\n* 私有继承\n\n\n\n\n\n![img](assets/clip_image002.png)\n\n\n\n\n\n**示例：**\n\n```C++\nclass Base1\n{\npublic: \n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C;\n};\n\n//公共继承\nclass Son1 :public Base1\n{\npublic:\n\tvoid func()\n\t{\n\t\tm_A; //可访问 public权限\n\t\tm_B; //可访问 protected权限\n\t\t//m_C; //不可访问\n\t}\n};\n\nvoid myClass()\n{\n\tSon1 s1;\n\ts1.m_A; //其他类只能访问到公共权限\n}\n\n//保护继承\nclass Base2\n{\npublic:\n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C;\n};\nclass Son2:protected Base2\n{\npublic:\n\tvoid func()\n\t{\n\t\tm_A; //可访问 protected权限\n\t\tm_B; //可访问 protected权限\n\t\t//m_C; //不可访问\n\t}\n};\nvoid myClass2()\n{\n\tSon2 s;\n\t//s.m_A; //不可访问\n}\n\n//私有继承\nclass Base3\n{\npublic:\n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C;\n};\nclass Son3:private Base3\n{\npublic:\n\tvoid func()\n\t{\n\t\tm_A; //可访问 private权限\n\t\tm_B; //可访问 private权限\n\t\t//m_C; //不可访问\n\t}\n};\nclass GrandSon3 :public Son3\n{\npublic:\n\tvoid func()\n\t{\n\t\t//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到\n\t\t//m_A;\n\t\t//m_B;\n\t\t//m_C;\n\t}\n};\n```\n\n\n\n\n\n\n\n\n\n#### 4.6.3 继承中的对象模型\n\n\n\n**问题：**从父类继承过来的成员，哪些属于子类对象中？\n\n\n\n**示例：**\n\n```C++\nclass Base\n{\npublic:\n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C; //私有成员只是被隐藏了，但是还是会继承下去\n};\n\n//公共继承\nclass Son :public Base\n{\npublic:\n\tint m_D;\n};\n\nvoid test01()\n{\n\tcout << \"sizeof Son = \" << sizeof(Son) << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n利用工具查看：\n\n\n\n![1545881904150](assets/1545881904150.png)\n\n\n\n打开工具窗口后，定位到当前CPP文件的盘符\n\n然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名\n\n\n\n效果如下图：\n\n\n\n![1545882158050](assets/1545882158050.png)\n\n\n\n> 结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.6.4 继承中构造和析构顺序\n\n\n\n子类继承父类后，当创建子类对象，也会调用父类的构造函数\n\n\n\n问题：父类和子类的构造和析构顺序是谁先谁后？\n\n\n\n**示例：**\n\n```C++\nclass Base \n{\npublic:\n\tBase()\n\t{\n\t\tcout << \"Base构造函数!\" << endl;\n\t}\n\t~Base()\n\t{\n\t\tcout << \"Base析构函数!\" << endl;\n\t}\n};\n\nclass Son : public Base\n{\npublic:\n\tSon()\n\t{\n\t\tcout << \"Son构造函数!\" << endl;\n\t}\n\t~Son()\n\t{\n\t\tcout << \"Son析构函数!\" << endl;\n\t}\n\n};\n\n\nvoid test01()\n{\n\t//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反\n\tSon s;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n> 总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反\n\n\n\n\n\n\n\n\n\n\n\n#### 4.6.5 继承同名成员处理方式\n\n\n\n问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？\n\n\n\n* 访问子类同名成员   直接访问即可\n* 访问父类同名成员   需要加作用域\n\n\n\n**示例：**\n\n```C++\nclass Base {\npublic:\n\tBase()\n\t{\n\t\tm_A = 100;\n\t}\n\n\tvoid func()\n\t{\n\t\tcout << \"Base - func()调用\" << endl;\n\t}\n\n\tvoid func(int a)\n\t{\n\t\tcout << \"Base - func(int a)调用\" << endl;\n\t}\n\npublic:\n\tint m_A;\n};\n\n\nclass Son : public Base {\npublic:\n\tSon()\n\t{\n\t\tm_A = 200;\n\t}\n\n\t//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数\n\t//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域\n\tvoid func()\n\t{\n\t\tcout << \"Son - func()调用\" << endl;\n\t}\npublic:\n\tint m_A;\n};\n\nvoid test01()\n{\n\tSon s;\n\n\tcout << \"Son下的m_A = \" << s.m_A << endl;\n\tcout << \"Base下的m_A = \" << s.Base::m_A << endl;\n\n\ts.func();\n\ts.Base::func();\n\ts.Base::func(10);\n\n}\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\treturn EXIT_SUCCESS;\n}\n```\n\n总结：\n\n1. 子类对象可以直接访问到子类中同名成员\n2. 子类对象加作用域可以访问到父类同名成员\n3. 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.6.6 继承同名静态成员处理方式\n\n\n\n问题：继承中同名的静态成员在子类对象上如何进行访问？\n\n\n\n静态成员和非静态成员出现同名，处理方式一致\n\n\n\n- 访问子类同名成员   直接访问即可\n- 访问父类同名成员   需要加作用域\n\n\n\n**示例：**\n\n```C++\nclass Base {\npublic:\n\tstatic void func()\n\t{\n\t\tcout << \"Base - static void func()\" << endl;\n\t}\n\tstatic void func(int a)\n\t{\n\t\tcout << \"Base - static void func(int a)\" << endl;\n\t}\n\n\tstatic int m_A;\n};\n\nint Base::m_A = 100;\n\nclass Son : public Base {\npublic:\n\tstatic void func()\n\t{\n\t\tcout << \"Son - static void func()\" << endl;\n\t}\n\tstatic int m_A;\n};\n\nint Son::m_A = 200;\n\n//同名成员属性\nvoid test01()\n{\n\t//通过对象访问\n\tcout << \"通过对象访问： \" << endl;\n\tSon s;\n\tcout << \"Son  下 m_A = \" << s.m_A << endl;\n\tcout << \"Base 下 m_A = \" << s.Base::m_A << endl;\n\n\t//通过类名访问\n\tcout << \"通过类名访问： \" << endl;\n\tcout << \"Son  下 m_A = \" << Son::m_A << endl;\n\tcout << \"Base 下 m_A = \" << Son::Base::m_A << endl;\n}\n\n//同名成员函数\nvoid test02()\n{\n\t//通过对象访问\n\tcout << \"通过对象访问： \" << endl;\n\tSon s;\n\ts.func();\n\ts.Base::func();\n\n\tcout << \"通过类名访问： \" << endl;\n\tSon::func();\n\tSon::Base::func();\n\t//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问\n\tSon::Base::func(100);\n}\nint main() {\n\n\t//test01();\n\ttest02();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n> 总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.6.7 多继承语法\n\n\n\nC++允许**一个类继承多个类**\n\n\n\n语法：` class 子类 ：继承方式 父类1 ， 继承方式 父类2...`\n\n\n\n多继承可能会引发父类中有同名成员出现，需要加作用域区分\n\n\n\n**C++实际开发中不建议用多继承**\n\n\n\n\n\n\n\n**示例：**\n\n```C++\nclass Base1 {\npublic:\n\tBase1()\n\t{\n\t\tm_A = 100;\n\t}\npublic:\n\tint m_A;\n};\n\nclass Base2 {\npublic:\n\tBase2()\n\t{\n\t\tm_A = 200;  //开始是m_B 不会出问题，但是改为mA就会出现不明确\n\t}\npublic:\n\tint m_A;\n};\n\n//语法：class 子类：继承方式 父类1 ，继承方式 父类2 \nclass Son : public Base2, public Base1 \n{\npublic:\n\tSon()\n\t{\n\t\tm_C = 300;\n\t\tm_D = 400;\n\t}\npublic:\n\tint m_C;\n\tint m_D;\n};\n\n\n//多继承容易产生成员同名的情况\n//通过使用类名作用域可以区分调用哪一个基类的成员\nvoid test01()\n{\n\tSon s;\n\tcout << \"sizeof Son = \" << sizeof(s) << endl;\n\tcout << s.Base1::m_A << endl;\n\tcout << s.Base2::m_A << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n> 总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域\n\n\n\n\n\n\n\n\n\n\n\n#### 4.6.8 菱形继承\n\n\n\n**菱形继承概念：**\n\n\t两个派生类继承同一个基类\n\t\n\t又有某个类同时继承者两个派生类\n\t\n\t这种继承被称为菱形继承，或者钻石继承\n\n\n\n**典型的菱形继承案例：**\n\n\n\n![IMG_256](assets/clip_image002.jpg)\n\n\n\n**菱形继承问题：**\n\n\n\n1.     羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。\n\n2.     草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。\n\n\n\n**示例：**\n\n```C++\nclass Animal\n{\npublic:\n\tint m_Age;\n};\n\n//继承前加virtual关键字后，变为虚继承\n//此时公共的父类Animal称为虚基类\nclass Sheep : virtual public Animal {};\nclass Tuo   : virtual public Animal {};\nclass SheepTuo : public Sheep, public Tuo {};\n\nvoid test01()\n{\n\tSheepTuo st;\n\tst.Sheep::m_Age = 100;\n\tst.Tuo::m_Age = 200;\n\n\tcout << \"st.Sheep::m_Age = \" << st.Sheep::m_Age << endl;\n\tcout << \"st.Tuo::m_Age = \" <<  st.Tuo::m_Age << endl;\n\tcout << \"st.m_Age = \" << st.m_Age << endl;\n}\n\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n总结：\n\n* 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义\n* 利用虚继承可以解决菱形继承问题\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 4.7  多态\n\n#### 4.7.1 多态的基本概念\n\n\n\n**多态是C++面向对象三大特性之一**\n\n多态分为两类\n\n* 静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名\n* 动态多态: 派生类和虚函数实现运行时多态\n\n\n\n静态多态和动态多态区别：\n\n* 静态多态的函数地址早绑定  -  编译阶段确定函数地址\n* 动态多态的函数地址晚绑定  -  运行阶段确定函数地址\n\n\n\n下面通过案例进行讲解多态\n\n\n\n```C++\nclass Animal\n{\npublic:\n\t//Speak函数就是虚函数\n\t//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。\n\tvirtual void speak()\n\t{\n\t\tcout << \"动物在说话\" << endl;\n\t}\n};\n\nclass Cat :public Animal\n{\npublic:\n\tvoid speak()\n\t{\n\t\tcout << \"小猫在说话\" << endl;\n\t}\n};\n\nclass Dog :public Animal\n{\npublic:\n\n\tvoid speak()\n\t{\n\t\tcout << \"小狗在说话\" << endl;\n\t}\n\n};\n//我们希望传入什么对象，那么就调用什么对象的函数\n//如果函数地址在编译阶段就能确定，那么静态联编\n//如果函数地址在运行阶段才能确定，就是动态联编\n\nvoid DoSpeak(Animal & animal)\n{\n\tanimal.speak();\n}\n//\n//多态满足条件： \n//1、有继承关系\n//2、子类重写父类中的虚函数\n//多态使用：\n//父类指针或引用指向子类对象\n\nvoid test01()\n{\n\tCat cat;\n\tDoSpeak(cat);\n\n\n\tDog dog;\n\tDoSpeak(dog);\n}\n\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n总结：\n\n多态满足条件\n\n* 有继承关系\n* 子类重写父类中的虚函数\n\n多态使用条件\n\n* 父类指针或引用指向子类对象\n\n重写：函数返回值类型  函数名 参数列表 完全一致称为重写\n\n\n\n\n\n\n\n\n\n#### 4.7.2 多态案例一-计算器类\n\n\n\n案例描述：\n\n分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类\n\n\n\n多态的优点：\n\n* 代码组织结构清晰\n* 可读性强\n* 利于前期和后期的扩展以及维护\n\n\n\n**示例：**\n\n```C++\n//普通实现\nclass Calculator {\npublic:\n\tint getResult(string oper)\n\t{\n\t\tif (oper == \"+\") {\n\t\t\treturn m_Num1 + m_Num2;\n\t\t}\n\t\telse if (oper == \"-\") {\n\t\t\treturn m_Num1 - m_Num2;\n\t\t}\n\t\telse if (oper == \"*\") {\n\t\t\treturn m_Num1 * m_Num2;\n\t\t}\n\t\t//如果要提供新的运算，需要修改源码\n\t}\npublic:\n\tint m_Num1;\n\tint m_Num2;\n};\n\nvoid test01()\n{\n\t//普通实现测试\n\tCalculator c;\n\tc.m_Num1 = 10;\n\tc.m_Num2 = 10;\n\tcout << c.m_Num1 << \" + \" << c.m_Num2 << \" = \" << c.getResult(\"+\") << endl;\n\n\tcout << c.m_Num1 << \" - \" << c.m_Num2 << \" = \" << c.getResult(\"-\") << endl;\n\n\tcout << c.m_Num1 << \" * \" << c.m_Num2 << \" = \" << c.getResult(\"*\") << endl;\n}\n\n\n\n//多态实现\n//抽象计算器类\n//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护\nclass AbstractCalculator\n{\npublic :\n\n\tvirtual int getResult()\n\t{\n\t\treturn 0;\n\t}\n\n\tint m_Num1;\n\tint m_Num2;\n};\n\n//加法计算器\nclass AddCalculator :public AbstractCalculator\n{\npublic:\n\tint getResult()\n\t{\n\t\treturn m_Num1 + m_Num2;\n\t}\n};\n\n//减法计算器\nclass SubCalculator :public AbstractCalculator\n{\npublic:\n\tint getResult()\n\t{\n\t\treturn m_Num1 - m_Num2;\n\t}\n};\n\n//乘法计算器\nclass MulCalculator :public AbstractCalculator\n{\npublic:\n\tint getResult()\n\t{\n\t\treturn m_Num1 * m_Num2;\n\t}\n};\n\n\nvoid test02()\n{\n\t//创建加法计算器\n\tAbstractCalculator *abc = new AddCalculator;\n\tabc->m_Num1 = 10;\n\tabc->m_Num2 = 10;\n\tcout << abc->m_Num1 << \" + \" << abc->m_Num2 << \" = \" << abc->getResult() << endl;\n\tdelete abc;  //用完了记得销毁\n\n\t//创建减法计算器\n\tabc = new SubCalculator;\n\tabc->m_Num1 = 10;\n\tabc->m_Num2 = 10;\n\tcout << abc->m_Num1 << \" - \" << abc->m_Num2 << \" = \" << abc->getResult() << endl;\n\tdelete abc;  \n\n\t//创建乘法计算器\n\tabc = new MulCalculator;\n\tabc->m_Num1 = 10;\n\tabc->m_Num2 = 10;\n\tcout << abc->m_Num1 << \" * \" << abc->m_Num2 << \" = \" << abc->getResult() << endl;\n\tdelete abc;\n}\n\nint main() {\n\n\t//test01();\n\n\ttest02();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n> 总结：C++开发提倡利用多态设计程序架构，因为多态优点很多\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.7.3 纯虚函数和抽象类\n\n\n\n在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容\n\n\n\n因此可以将虚函数改为**纯虚函数**\n\n\n\n纯虚函数语法：`virtual 返回值类型 函数名 （参数列表）= 0 ;`\n\n\n\n当类中有了纯虚函数，这个类也称为==抽象类==\n\n\n\n**抽象类特点**：\n\n * 无法实例化对象\n * 子类必须重写抽象类中的纯虚函数，否则也属于抽象类\n\n\n\n\n\n**示例：**\n\n```C++\nclass Base\n{\npublic:\n\t//纯虚函数\n\t//类中只要有一个纯虚函数就称为抽象类\n\t//抽象类无法实例化对象\n\t//子类必须重写父类中的纯虚函数，否则也属于抽象类\n\tvirtual void func() = 0;\n};\n\nclass Son :public Base\n{\npublic:\n\tvirtual void func() \n\t{\n\t\tcout << \"func调用\" << endl;\n\t};\n};\n\nvoid test01()\n{\n\tBase * base = NULL;\n\t//base = new Base; // 错误，抽象类无法实例化对象\n\tbase = new Son;\n\tbase->func();\n\tdelete base;//记得销毁\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.7.4 多态案例二-制作饮品\n\n**案例描述：**\n\n制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料\n\n\n\n利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶\n\n\n\n![1545985945198](assets/1545985945198.png)\n\n\n\n**示例：**\n\n```C++\n//抽象制作饮品\nclass AbstractDrinking {\npublic:\n\t//烧水\n\tvirtual void Boil() = 0;\n\t//冲泡\n\tvirtual void Brew() = 0;\n\t//倒入杯中\n\tvirtual void PourInCup() = 0;\n\t//加入辅料\n\tvirtual void PutSomething() = 0;\n\t//规定流程\n\tvoid MakeDrink() {\n\t\tBoil();\n\t\tBrew();\n\t\tPourInCup();\n\t\tPutSomething();\n\t}\n};\n\n//制作咖啡\nclass Coffee : public AbstractDrinking {\npublic:\n\t//烧水\n\tvirtual void Boil() {\n\t\tcout << \"煮农夫山泉!\" << endl;\n\t}\n\t//冲泡\n\tvirtual void Brew() {\n\t\tcout << \"冲泡咖啡!\" << endl;\n\t}\n\t//倒入杯中\n\tvirtual void PourInCup() {\n\t\tcout << \"将咖啡倒入杯中!\" << endl;\n\t}\n\t//加入辅料\n\tvirtual void PutSomething() {\n\t\tcout << \"加入牛奶!\" << endl;\n\t}\n};\n\n//制作茶水\nclass Tea : public AbstractDrinking {\npublic:\n\t//烧水\n\tvirtual void Boil() {\n\t\tcout << \"煮自来水!\" << endl;\n\t}\n\t//冲泡\n\tvirtual void Brew() {\n\t\tcout << \"冲泡茶叶!\" << endl;\n\t}\n\t//倒入杯中\n\tvirtual void PourInCup() {\n\t\tcout << \"将茶水倒入杯中!\" << endl;\n\t}\n\t//加入辅料\n\tvirtual void PutSomething() {\n\t\tcout << \"加入枸杞!\" << endl;\n\t}\n};\n\n//业务函数\nvoid DoWork(AbstractDrinking* drink) {\n\tdrink->MakeDrink();\n\tdelete drink;\n}\n\nvoid test01() {\n\tDoWork(new Coffee);\n\tcout << \"--------------\" << endl;\n\tDoWork(new Tea);\n}\n\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.7.5 虚析构和纯虚析构\n\n\n\n多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码\n\n\n\n解决方式：将父类中的析构函数改为**虚析构**或者**纯虚析构**\n\n\n\n虚析构和纯虚析构共性：\n\n* 可以解决父类指针释放子类对象\n* 都需要有具体的函数实现\n\n虚析构和纯虚析构区别：\n\n* 如果是纯虚析构，该类属于抽象类，无法实例化对象\n\n\n\n虚析构语法：\n\n`virtual ~类名(){}`\n\n纯虚析构语法：\n\n` virtual ~类名() = 0;`\n\n`类名::~类名(){}`\n\n\n\n**示例：**\n\n```C++\nclass Animal {\npublic:\n\n\tAnimal()\n\t{\n\t\tcout << \"Animal 构造函数调用！\" << endl;\n\t}\n\tvirtual void Speak() = 0;\n\n\t//析构函数加上virtual关键字，变成虚析构函数\n\t//virtual ~Animal()\n\t//{\n\t//\tcout << \"Animal虚析构函数调用！\" << endl;\n\t//}\n\n\n\tvirtual ~Animal() = 0;\n};\n\nAnimal::~Animal()\n{\n\tcout << \"Animal 纯虚析构函数调用！\" << endl;\n}\n\n//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。\n\nclass Cat : public Animal {\npublic:\n\tCat(string name)\n\t{\n\t\tcout << \"Cat构造函数调用！\" << endl;\n\t\tm_Name = new string(name);\n\t}\n\tvirtual void Speak()\n\t{\n\t\tcout << *m_Name <<  \"小猫在说话!\" << endl;\n\t}\n\t~Cat()\n\t{\n\t\tcout << \"Cat析构函数调用!\" << endl;\n\t\tif (this->m_Name != NULL) {\n\t\t\tdelete m_Name;\n\t\t\tm_Name = NULL;\n\t\t}\n\t}\n\npublic:\n\tstring *m_Name;\n};\n\nvoid test01()\n{\n\tAnimal *animal = new Cat(\"Tom\");\n\tanimal->Speak();\n\n\t//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏\n\t//怎么解决？给基类增加一个虚析构函数\n\t//虚析构函数就是用来解决通过父类指针释放子类对象\n\tdelete animal;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n总结：\n\n\t1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象\n\t\n\t2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构\n\t\n\t3. 拥有纯虚析构函数的类也属于抽象类\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 4.7.6 多态案例三-电脑组装\n\n\n\n**案例描述：**\n\n\n\n电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）\n\n将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商\n\n创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口\n\n测试时组装三台不同的电脑进行工作\n\n\n\n\n\n**示例：**\n\n```C++\n#include<iostream>\nusing namespace std;\n\n//抽象CPU类\nclass CPU\n{\npublic:\n\t//抽象的计算函数\n\tvirtual void calculate() = 0;\n};\n\n//抽象显卡类\nclass VideoCard\n{\npublic:\n\t//抽象的显示函数\n\tvirtual void display() = 0;\n};\n\n//抽象内存条类\nclass Memory\n{\npublic:\n\t//抽象的存储函数\n\tvirtual void storage() = 0;\n};\n\n//电脑类\nclass Computer\n{\npublic:\n\tComputer(CPU * cpu, VideoCard * vc, Memory * mem)\n\t{\n\t\tm_cpu = cpu;\n\t\tm_vc = vc;\n\t\tm_mem = mem;\n\t}\n\n\t//提供工作的函数\n\tvoid work()\n\t{\n\t\t//让零件工作起来，调用接口\n\t\tm_cpu->calculate();\n\n\t\tm_vc->display();\n\n\t\tm_mem->storage();\n\t}\n\n\t//提供析构函数 释放3个电脑零件\n\t~Computer()\n\t{\n\n\t\t//释放CPU零件\n\t\tif (m_cpu != NULL)\n\t\t{\n\t\t\tdelete m_cpu;\n\t\t\tm_cpu = NULL;\n\t\t}\n\n\t\t//释放显卡零件\n\t\tif (m_vc != NULL)\n\t\t{\n\t\t\tdelete m_vc;\n\t\t\tm_vc = NULL;\n\t\t}\n\n\t\t//释放内存条零件\n\t\tif (m_mem != NULL)\n\t\t{\n\t\t\tdelete m_mem;\n\t\t\tm_mem = NULL;\n\t\t}\n\t}\n\nprivate:\n\n\tCPU * m_cpu; //CPU的零件指针\n\tVideoCard * m_vc; //显卡零件指针\n\tMemory * m_mem; //内存条零件指针\n};\n\n//具体厂商\n//Intel厂商\nclass IntelCPU :public CPU\n{\npublic:\n\tvirtual void calculate()\n\t{\n\t\tcout << \"Intel的CPU开始计算了！\" << endl;\n\t}\n};\n\nclass IntelVideoCard :public VideoCard\n{\npublic:\n\tvirtual void display()\n\t{\n\t\tcout << \"Intel的显卡开始显示了！\" << endl;\n\t}\n};\n\nclass IntelMemory :public Memory\n{\npublic:\n\tvirtual void storage()\n\t{\n\t\tcout << \"Intel的内存条开始存储了！\" << endl;\n\t}\n};\n\n//Lenovo厂商\nclass LenovoCPU :public CPU\n{\npublic:\n\tvirtual void calculate()\n\t{\n\t\tcout << \"Lenovo的CPU开始计算了！\" << endl;\n\t}\n};\n\nclass LenovoVideoCard :public VideoCard\n{\npublic:\n\tvirtual void display()\n\t{\n\t\tcout << \"Lenovo的显卡开始显示了！\" << endl;\n\t}\n};\n\nclass LenovoMemory :public Memory\n{\npublic:\n\tvirtual void storage()\n\t{\n\t\tcout << \"Lenovo的内存条开始存储了！\" << endl;\n\t}\n};\n\n\nvoid test01()\n{\n\t//第一台电脑零件\n\tCPU * intelCpu = new IntelCPU;\n\tVideoCard * intelCard = new IntelVideoCard;\n\tMemory * intelMem = new IntelMemory;\n\n\tcout << \"第一台电脑开始工作：\" << endl;\n\t//创建第一台电脑\n\tComputer * computer1 = new Computer(intelCpu, intelCard, intelMem);\n\tcomputer1->work();\n\tdelete computer1;\n\n\tcout << \"-----------------------\" << endl;\n\tcout << \"第二台电脑开始工作：\" << endl;\n\t//第二台电脑组装\n\tComputer * computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);;\n\tcomputer2->work();\n\tdelete computer2;\n\n\tcout << \"-----------------------\" << endl;\n\tcout << \"第三台电脑开始工作：\" << endl;\n\t//第三台电脑组装\n\tComputer * computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;\n\tcomputer3->work();\n\tdelete computer3;\n\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 5 文件操作\n\n\n\n程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放\n\n通过**文件可以将数据持久化**\n\nC++中对文件操作需要包含头文件 ==&lt; fstream &gt;==\n\n\n\n文件类型分为两种：\n\n1. **文本文件**     -  文件以文本的**ASCII码**形式存储在计算机中\n2. **二进制文件** -  文件以文本的**二进制**形式存储在计算机中，用户一般不能直接读懂它们\n\n\n\n操作文件的三大类:\n\n1. ofstream：写操作\n2. ifstream： 读操作\n3. fstream ： 读写操作\n\n\n\n### 5.1文本文件\n\n#### 5.1.1写文件\n\n   写文件步骤如下：\n\n1. 包含头文件   \n\n   \\#include <fstream\\>\n\n2. 创建流对象  \n\n   ofstream ofs;\n\n3. 打开文件\n\n   ofs.open(\"文件路径\",打开方式);\n\n4. 写数据\n\n   ofs << \"写入的数据\";\n\n5. 关闭文件\n\n   ofs.close();\n\n   \n\n文件打开方式：\n\n| 打开方式    | 解释                       |\n| ----------- | -------------------------- |\n| ios::in     | 为读文件而打开文件         |\n| ios::out    | 为写文件而打开文件         |\n| ios::ate    | 初始位置：文件尾           |\n| ios::app    | 追加方式写文件             |\n| ios::trunc  | 如果文件存在先删除，再创建 |\n| ios::binary | 二进制方式                 |\n\n**注意：** 文件打开方式可以配合使用，利用|操作符\n\n**例如：**用二进制方式写文件 `ios::binary |  ios:: out`\n\n\n\n\n\n**示例：**\n\n```C++\n#include <fstream>\n\nvoid test01()\n{\n\tofstream ofs;\n\tofs.open(\"test.txt\", ios::out);\n\n\tofs << \"姓名：张三\" << endl;\n\tofs << \"性别：男\" << endl;\n\tofs << \"年龄：18\" << endl;\n\n\tofs.close();\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n总结：\n\n* 文件操作必须包含头文件 fstream\n* 读文件可以利用 ofstream  ，或者fstream类\n* 打开文件时候需要指定操作文件的路径，以及打开方式\n* 利用<<可以向文件中写数据\n* 操作完毕，要关闭文件\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#### 5.1.2读文件\n\n\n\n读文件与写文件步骤相似，但是读取方式相对于比较多\n\n\n\n读文件步骤如下：\n\n1. 包含头文件   \n\n   \\#include <fstream\\>\n\n2. 创建流对象  \n\n   ifstream ifs;\n\n3. 打开文件并判断文件是否打开成功\n\n   ifs.open(\"文件路径\",打开方式);\n\n4. 读数据\n\n   四种方式读取\n\n5. 关闭文件\n\n   ifs.close();\n\n\n\n**示例：**\n\n```C++\n#include <fstream>\n#include <string>\nvoid test01()\n{\n\tifstream ifs;\n\tifs.open(\"test.txt\", ios::in);\n\n\tif (!ifs.is_open())\n\t{\n\t\tcout << \"文件打开失败\" << endl;\n\t\treturn;\n\t}\n\n\t//第一种方式\n\t//char buf[1024] = { 0 };\n\t//while (ifs >> buf)\n\t//{\n\t//\tcout << buf << endl;\n\t//}\n\n\t//第二种\n\t//char buf[1024] = { 0 };\n\t//while (ifs.getline(buf,sizeof(buf)))\n\t//{\n\t//\tcout << buf << endl;\n\t//}\n\n\t//第三种\n\t//string buf;\n\t//while (getline(ifs, buf))\n\t//{\n\t//\tcout << buf << endl;\n\t//}\n\n\tchar c;\n\twhile ((c = ifs.get()) != EOF)\n\t{\n\t\tcout << c;\n\t}\n\n\tifs.close();\n\n\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n总结：\n\n- 读文件可以利用 ifstream  ，或者fstream类\n- 利用is_open函数可以判断文件是否打开成功\n- close 关闭文件 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 5.2 二进制文件\n\n以二进制的方式对文件进行读写操作\n\n打开方式要指定为 ==ios::binary==\n\n\n\n#### 5.2.1 写文件\n\n二进制方式写文件主要利用流对象调用成员函数write\n\n函数原型 ：`ostream& write(const char * buffer,int len);`\n\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n\n\n\n**示例：**\n\n```C++\n#include <fstream>\n#include <string>\n\nclass Person\n{\npublic:\n\tchar m_Name[64];\n\tint m_Age;\n};\n\n//二进制文件  写文件\nvoid test01()\n{\n\t//1、包含头文件\n\n\t//2、创建输出流对象\n\tofstream ofs(\"person.txt\", ios::out | ios::binary);\n\t\n\t//3、打开文件\n\t//ofs.open(\"person.txt\", ios::out | ios::binary);\n\n\tPerson p = {\"张三\"  , 18};\n\n\t//4、写文件\n\tofs.write((const char *)&p, sizeof(p));\n\n\t//5、关闭文件\n\tofs.close();\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n总结：\n\n* 文件输出流对象 可以通过write函数，以二进制方式写数据\n\n\n\n\n\n\n\n\n\n\n\n#### 5.2.2 读文件\n\n二进制方式读文件主要利用流对象调用成员函数read\n\n函数原型：`istream& read(char *buffer,int len);`\n\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n\n示例：\n\n```C++\n#include <fstream>\n#include <string>\n\nclass Person\n{\npublic:\n\tchar m_Name[64];\n\tint m_Age;\n};\n\nvoid test01()\n{\n\tifstream ifs(\"person.txt\", ios::in | ios::binary);\n\tif (!ifs.is_open())\n\t{\n\t\tcout << \"文件打开失败\" << endl;\n\t}\n\n\tPerson p;\n\tifs.read((char *)&p, sizeof(p));\n\n\tcout << \"姓名： \" << p.m_Name << \" 年龄： \" << p.m_Age << endl;\n}\n\nint main() {\n\n\ttest01();\n\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n```\n\n\n\n- 文件输入流对象 可以通过read函数，以二进制方式读数据\n","tags":["C++"]},{"title":"日期类","url":"/2022/12/11/5/","content":"```\n#include<iostream>\n\nusing namespace std;\n\nclass Date\n{\npublic:\n    void set(int year, int month, int day)\n    {\n        this->year = year;\n        this->month = month;\n        this->day = day;\n    }\n    //前置++\n    Date& operator++()\n    {\n        if (day < 28)\n        {\n            day++;\n            return *this;\n        }\n        else if (month == 2)\n        {\n            if (day == 28 && !(year % 400 == 0 || (year % 4 == 0 && year % 100 != 0)))\n            {\n                day++;\n                return *this;\n            }\n            month++, day = 1;\n            return *this;\n        }\n        else if (day == 29)\n        {\n            day++;\n            return *this;\n        }\n        else if (day == 30)\n        {\n            switch (month)\n            {\n            case 4:case 6:case 9:case 11:\n                day = 1;\n                month++;\n                return *this;\n                break;\n            }\n            day++;\n            return *this;\n        }\n        else if (month == 12)\n        {\n            year++, month = 1, day = 1;\n            return *this;\n        }\n        else\n        {\n            month++;\n            day = 1;\n            return *this;\n        }\n    }\n    //后置++\n    Date operator++(int)\n    {\n        Date* temp = this;\n        return *temp;\n        ++(*this);\n    }\n    //前置--\n    Date& operator--()\n    {\n        if (day == 1)\n        {\n            switch (month)\n            {\n            case 2:case4:case 6:case 8:case 9:case 11:\n                day = 31;\n                month--;\n                break;\n            case 5:case 7:case 10:case 12:\n                day = 30;\n                month--;\n                break;\n            case 1:\n                month = 12;\n                year--;\n                day = 31;\n            case 3:\n                if (year % 4 != 0)\n                    month--;\n                day = 28;\n                month--;\n                day = 29;\n                break;\n            default:\n                break;\n            }\n\n        }\n        else\n            day--;\n        return *this;\n    }\n    //后置--\n    Date operator--(int)\n    {\n        Date* temp = this;\n        return *temp;\n        --(*this);\n    }\npublic:\n    int year;\n    int month;\n    int day;\n};\n\nvoid show(Date data)\n{\n    cout << \"年：\" << data.year << \"月：\" << data.month << \"日：\" << data.day << endl;\n}\n\nint main()\n{\n    Date data;\n    data.set(2012, 4, 29);\n    show(data);\n    int a;\n    cout << \"选择：1、后置递增\\t 2、前置递增\\t 3、后置递减\\t 4、前置递减\" << endl;\n    cin >> a;\n    switch (a)\n    {\n    case 1:\n        show(data++);\n        break;\n    case 2:\n        show(++data);\n        break;\n    case 3:\n        show(data--);\n        break;\n    case 4:\n        show(--data);\n        break;\n    default:\n        break;\n    }\n    return 0;\n}\n```\n","tags":["C++"]},{"title":"学生信息管理系统","url":"/2022/12/11/4/","content":"\n```\n#include<iostream>\n#include<string>\n#include<vector>\n#include<windows.h>\n#include<algorithm>\n\nusing namespace std;\n\nclass student\n{\npublic:\n    string s_name;\n    int s_id = 0;\n    int y_score = 0;//语文成绩\n    int s_score = 0;//数学成绩\n    int e_score = 0;//英语成绩\n    int s_total = 0;\n};\n\nvector<student> v;\nvector<student>z;\n\nvoid showmenu()\n{\n    cout << \"*******************************\" << endl;\n    cout << \"欢迎来到学生管理系统\" << endl;\n    cout << \"请选择您的操作\" << endl;\n    cout << \"1.添加学生\" << endl;\n    cout << \"2.输出学生列表\" << endl;\n    cout << \"3.对成绩进行排序\" << endl;\n    cout << \"4.根据学号查找学生信息\" << endl;\n    cout << \"输入其他字符退出程序\" << endl;\n    cout << \"*******************************\" << endl;\n}\n\nvoid showstudent(vector<student>& a)\n{\n    for (vector<student>::iterator it = a.begin(); it != a.end(); it++)\n    {\n        cout << \"姓名：\" << (*it).s_name << \"\\t学号：\" << (*it).s_id << \"\\t语文成绩：\" << (*it).y_score << \"\\t数学成绩：\" << (*it).s_score << \"\\t英语成绩：\" << (*it).e_score << \"\\t总成绩：\" << (*it).s_total << endl;\n    }\n}\n\nvoid showstudent1(vector<student>& a)\n{\n    int i = 1;\n    for (vector<student>::iterator it = a.begin(); it != a.end(); it++, i++)\n    {\n        cout << \"第\" << i << \"名： 姓名：\" << (*it).s_name << \"\\t学号：\" << (*it).s_id << \"\\t语文成绩：\" << (*it).y_score << \"\\t数学成绩：\" << (*it).s_score << \"\\t英语成绩：\" << (*it).e_score << \"\\t总成绩：\" << (*it).s_total << endl;\n    }\n}\n\nbool comp(const student& a, const student& b)\n{\n    return a.s_total > b.s_total;\n}\n\nint main()\n{\n    while (true)\n    {\n    aaa:\n        showmenu();\n        int a;\n        cin >> a;\n        system(\"cls\");\n        switch (a)\n        {\n        case 1:\n        {\n            student stu;\n            cout << \"姓名：\" << endl;\n            cin >> stu.s_name;\n            cout << \"学生号：\" << endl;\n            cin >> stu.s_id;\n            cout << \"语文成绩\" << endl;\n            cin >> stu.y_score;\n            cout << \"数学成绩\" << endl;\n            cin >> stu.s_score;\n            cout << \"英语成绩\" << endl;\n            cin >> stu.e_score;\n            stu.s_total = stu.y_score + stu.s_score + stu.e_score;\n            v.push_back(stu);\n            cout << \"添加成功！\" << endl;\n            Sleep(1000);\n            system(\"cls\");\n            break;\n        }\n        case 2:\n        {\n            showstudent(v);\n            system(\"pause\");\n            system(\"cls\");\n            break;\n        }\n        case 3:\n        {\n            z = v;\n            sort(z.begin(), z.end(), comp);\n            showstudent1(z);\n            system(\"pause\");\n            system(\"cls\");\n            break;\n        }\n        case 4:\n        {\n            int id;\n            cout << \"请输入学生id号：\" << endl;\n            cin >> id;\n            for (vector<student>::iterator it = v.begin(); it != v.end(); it++)\n            {\n                if ((*it).s_id == id)\n                {\n                    cout << \"查找成功 学生信息如下：\" << endl;\n                    cout << \"姓名：\" << (*it).s_name << \"\\t学号：\" << (*it).s_id << \"\\t语文成绩：\" << (*it).y_score << \"\\t数学成绩：\" << (*it).s_score << \"\\t英语成绩：\" << (*it).e_score << \"\\t总成绩：\" << (*it).s_total << endl;\n                    system(\"pause\");\n                    system(\"cls\");\n                    goto aaa;\n                }\n            }\n            cout << \"查无此人！\" << endl;\n            system(\"pause\");\n            system(\"cls\");\n            break;\n        }\n        default:\n        {\n            goto bbb;\n        }\n        }\n\n    }\nbbb:\n    return 0;\n}\n```\n\n","tags":["C++"]},{"title":"糖果机","url":"/2022/12/11/3/","content":"\n```\n#include<map>\n#include<vector>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<windows.h>\n\nusing namespace std;\n\nclass Users {\nprivate:\n\tmap<string, string> m;\npublic:\n\tUsers()\n\t{\n\t\tm[\"Administrator\"] = string(\"114514\");\n\t}\n\n\tbool check(string username, string password)\n\t{\n\t\tauto it = m.find(username);\n\t\tif (it == m.end())\n\t\t\treturn false;\n\t\tif (it->second != password)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tbool login()\n\t{\n\t\tputs(\"输入用户名:\");\n\t\tstring uname;\n\t\tcin >> uname;\n\t\tputs(\"输入密码:\");\n\t\tstring passw;\n\t\tcin >> passw;\n\t\tif (!check(uname, passw))\n\t\t{\n\t\t\tputs(\"用户名或密码错误\");\n\t\t\tSleep(600);\n\t\t\treturn false;\n\t\t}\n\t\tputs(\"登录成功\");\n\t\tSleep(600);\n\t\tsystem(\"cls\");\n\t\treturn true;\n\t}\n}users;\n\nclass CandyList {\nprivate:\n\tmap<string, int> list;//名字到id的映射\n\tvector<string> nameList;\npublic:\n\tCandyList()\n\t{\n\t\tnameList.resize(1);\n\t}\n\n\tint queryId(string name)//传入名字，返回id，不存在返回0\n\t{\n\t\tauto it = list.find(name);\n\t\tif (it != list.end())\n\t\t\treturn it->second;\n\t\treturn 0;\n\t}\n\n\tstring queryName(int id)//传入ID 返回名字\n\t{\n\t\tif (id > nameList.size())\n\t\t\treturn string(\"\");\n\t\treturn nameList[id];\n\t}\n\n\tint addCandyKind(string name)//无论有没有，都返回id\n\t{\n\t\tint id = queryId(name);\n\t\tif (id)\n\t\t\treturn id;\n\t\tid = list.size() + 1;\n\t\tlist[name] = id;\n\t\tnameList.push_back(name);\n\t\treturn id;\n\t}\n}candyList;\n\nclass Store {//仓库\nprivate:\n\tvector<pair<int, int> > s; //数量、单价\n\tint sum;\npublic:\n\tStore()\n\t{\n\t\ts.clear();\n\t\ts.resize(100);\n\t\tsum = 0;\n\t}\n\tint getSum()\n\t{\n\t\treturn sum;\n\t}\n\n\tint getPrice(int id)\n\t{\n\t\treturn s[id].second;\n\t}\n\n\tvoid displayCandy()\n\t{\n\t\tcout << \"编号\\t品名\\t剩余数量 单价\" << endl;\n\t\tfor (int i = 0; i < s.size(); i++)\n\t\t{\n\t\t\tif (s[i].first > 0)\n\t\t\t{\n\t\t\t\tcout << i << \"\\t\" << candyList.queryName(i) << \"\\t\" << s[i].first << \"\\t \" << s[i].second << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid addCandy(string name, int num, int price = -1)\n\t{\n\t\tbool ok = 1;\n\t\tif (num < 1)\n\t\t\tok = 0, puts(\"数量错误\");\n\t\tif (price < -1 || price == 0)\n\t\t\tok = 0, puts(\"价格错误\");\n\t\tif (!ok)\n\t\t\treturn;\n\t\tint id = candyList.addCandyKind(name);\n\t\ts[id].first += num;\n\t\tsum += num;\n\t\tif (~price)\n\t\t\ts[id].second = price;//更新价格\n\t}\n\n\tint rmCandy(int id, int num, int pay)//卖糖\n\t{\n\t\tif (!id)\n\t\t{\n\t\t\tputs(\"编号错误！\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (s[id].first < num)\n\t\t{\n\t\t\tputs(\"数量不足\");\n\t\t\treturn 0;\n\t\t}\n\t\tint totPrice = num * s[id].second;\n\t\tif (pay < totPrice)\n\t\t{\n\t\t\tputs(\"钱不够\");\n\t\t\treturn -1;\n\t\t}\n\t\ts[id].first -= num;\n\t\tsum -= num;\n\t\treturn pay - totPrice;\n\t}\n}store;\n\nclass Show {//前端\nprivate:\n\tinline void read(int& x)\n\t{\n\t\tint s = 0, w = 1;\n\t\tchar ch = getchar();\n\t\twhile (ch < '0' || ch > '9')\n\t\t{\n\t\t\tif (ch == '-')\n\t\t\t\tw = -1;\n\t\t\tch = getchar();\n\t\t}\n\t\twhile (ch >= '0' && ch <= '9')\n\t\t\ts = s * 10 + ch - '0', ch = getchar();\n\t\tx = s * w;\n\t}\n\npublic:\n\tShow()\n\t{\n\t\tstore.addCandy(string(\"白砂糖\"), 10, 10);\n\t}\n\tvoid run()\n\t{\n\t\tprintf(\"启动中\");\n\t\tfor (int i = 0; i < 5; i++)\n\t\t{\n\t\t\tSleep(100);\n\t\t\tprintf(\".\");\n\t\t}\n\t\twhile (1)\n\t\t{\n\t\taa:\n\t\t\tsystem(\"cls\");\n\t\t\tif (store.getSum())\n\t\t\t\tprintf(\"营业中!\\n买糖请输入1\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"缺货 暂停营业！\\n\");\n\t\t\tputs(\"加糖请输入2\\n退出系统输入3\");\n\t\t\tint type = 0;\n\t\t\t//read(type);//提高容错性\n\t\t\tcin >> type;\n\t\t\tswitch (type)\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t{\n\t\t\t\tcout << \"欢迎光临！\" << endl;\n\t\t\t\tstore.displayCandy();\n\t\t\t\tputs(\"输入编号：\");\n\t\t\t\tint id;\n\t\t\t\tread(id);\n\t\t\t\tputs(\"输入数量：\");\n\t\t\t\tint num;\n\t\t\t\tread(num);\n\t\t\t\tputs(\"请付款：\");\n\t\t\t\tint pay;\n\t\t\t\tread(pay);\n\t\t\t\tint temp = store.rmCandy(id, num, pay);\n\t\t\t\tif (temp > 0)\n\t\t\t\t\tcout << \"给你找零:\" << temp << endl << \"\\n欢迎下次光临！\";\n\t\t\t\telse if (temp == 0)\n\t\t\t\t\tcout << \"交易成功 欢迎下次光临！\" << endl;\n\t\t\t\tSleep(1000);\n\t\t\t\tsystem(\"cls\");\n\t\t\t\tgoto aa;\n\t\t\t}\n\t\t\tcase 2:\n\t\t\t{\n\t\t\t\tif (!users.login())\n\t\t\t\t\tcontinue;\n\t\t\t\tputs(\"请输入品名\");\n\t\t\t\tstring name;\n\t\t\t\tcin >> name;\n\t\t\t\tint id = candyList.queryId(name);//不存在这个糖 id==0\n\t\t\t\tputs(\"请输入数量\");\n\t\t\t\tint num, price;\n\t\t\t\tbool transPrice = 0;\n\t\t\t\tread(num);\n\t\t\t\tif (!id)\n\t\t\t\t\tputs(\"输入定价(分/个)\"), read(price), transPrice = 1;\n\t\t\t\tif (transPrice)\n\t\t\t\t\tstore.addCandy(name, num, price);\n\t\t\t\telse\n\t\t\t\t\tstore.addCandy(name, num);\n\t\t\t\tgoto aa;\n\t\t\t}\n\t\t\tcase 3:\n\t\t\t{\n\t\t\t\tgoto flag;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tcout << \"输入错误！请重新输入！\" << endl;\n\t\t\t\tSleep(1000);\n\t\t\t\tgoto aa;\n\t\t\t}\n\t\t\t}\n\t\tflag:\n\t\t\tcout << \"正在退出\";\n\t\t\tfor (int i = 0; i < 5; i++)\n\t\t\t{\n\t\t\t\tSleep(100);\n\t\t\t\tprintf(\".\");\n\t\t\t}\n\t\t\tcout << \"\\n已退出！再见！\" << endl;\n\t\t\tbreak;\n\t\t}\n\t}\n};\n\nint main()\n{\n\tShow machine;\n\tmachine.run();\n\tsystem(\"pause\");\n}\n```\n\n","tags":["C++"]},{"title":"打印玫瑰花","url":"/2022/12/11/2/","content":"\n```\n#include <stdio.h>\n#include <math.h>\n\nconst int max_iterations = 128;\nconst float stop_threshold = 0.01f;\nconst float grad_step = 0.01f;\nconst float clip_far = 10.0f;\n\nconst float PI = 3.14159265359f;\nconst float PI2 = 6.28318530718f;\nconst float DEG_TO_RAD = PI / 180.0f;\n\ntypedef struct { float x, y; } vec2;\ntypedef struct { float x, y, z; } vec3;\ntypedef struct { float m[9]; } mat3;\n\nconst vec3 light_pos = { 20.0f, 50.0f, 20.0f };\n\nfloat min(float a, float b) { return a < b ? a : b; }\nfloat max(float a, float b) { return a > b ? a : b; }\nfloat clamp(float f, float a, float b) { return max(min(f, b), a); }\nvec2 make2(float x, float y) { vec2 r = { x, y }; return r; }\nvec2 add2(vec2 a, vec2 b) { vec2 r = { a.x + b.x, a.y + b.y }; return r; }\nvec2 sub2(vec2 a, vec2 b) { vec2 r = { a.x - b.x, a.y - b.y }; return r; }\nfloat dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat length2(vec2 v) { return sqrt(dot2(v, v)); }\nvec3 make3(float x, float y, float z) { vec3 r = { x, y, z }; return r; }\nvec3 add3(vec3 a, vec3 b) { vec3 r = { a.x + b.x, a.y + b.y, a.z + b.z }; return r; }\nvec3 sub3(vec3 a, vec3 b) { vec3 r = { a.x - b.x, a.y - b.y, a.z - b.z }; return r; }\nvec3 mul3(vec3 a, vec3 b) { vec3 r = { a.x * b.x, a.y * b.y, a.z * b.z }; return r; }\nvec3 scale3(vec3 v, float s) { vec3 r = { v.x * s, v.y * s, v.z * s }; return r; }\nfloat dot3(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat length3(vec3 v) { return sqrt(dot3(v, v)); }\nvec3 normalize3(vec3 v) { return scale3(v, 1.0f / length3(v)); }\nvec3 mul(mat3 m, vec3 v) {\n    return make3(\n        m.m[0] * v.x + m.m[3] * v.y + m.m[6] * v.z,\n        m.m[1] * v.x + m.m[4] * v.y + m.m[7] * v.z,\n        m.m[2] * v.x + m.m[5] * v.y + m.m[8] * v.z);\n}\n\nmat3 rotationXY(float x, float y) {\n    vec2 c = { cos(x), cos(y) }, s = { sin(x), sin(y) };\n    mat3 m = {\n        c.y      , 0.0f, -s.y,\n        s.y * s.x,  c.x,  c.y * s.x,\n        s.y * c.x, -s.x,  c.y * c.x\n    };\n    return m;\n}\n\nfloat opI(float d1, float d2) { return max(d1, d2); }\nfloat opU(float d1, float d2) { return min(d1, d2); }\nfloat opS(float d1, float d2) { return max(-d1, d2); }\n\nfloat sdPetal(vec3 p, float s) {\n    p = add3(mul3(p, make3(0.8f, 1.5f, 0.8f)), make3(0.1f, 0.0f, 0.0f));\n    vec2 q = make2(length2(make2(p.x, p.z)), p.y);\n\n    float lower = length2(q) - 1.0f;\n    lower = opS(length2(q) - 0.97f, lower);\n    lower = opI(lower, q.y);\n\n    float upper = length2(sub2(q, make2(s, 0.0f))) + 1.0f - s;\n    upper = opS(upper, length2(sub2(q, make2(s, 0.0f))) + 0.97f - s);\n    upper = opI(upper, -q.y);\n    upper = opI(upper, q.x - 2.0f);\n\n    float region = length3(sub3(p, make3(1.0f, 0.0f, 0.0f))) - 1.0f;\n    return opI(opU(upper, lower), region);\n}\n\nfloat map(vec3 p) {\n    float d = 1000.0f, s = 2.0f;\n    mat3 r = rotationXY(0.1f, PI2 * 0.618034f);\n    r.m[0] *= 1.08f;  r.m[1] *= 1.08f;  r.m[2] *= 1.08f;\n    r.m[3] *= 0.995f; r.m[4] *= 0.995f; r.m[5] *= 0.995f;\n    r.m[6] *= 1.08f;  r.m[7] *= 1.08f;  r.m[8] *= 1.08f;\n    for (int i = 0; i < 21; i++) {\n        d = opU(d, sdPetal(p, s));\n        p = mul(r, p);\n        p = add3(p, make3(0.0, -0.02, 0.0));\n        s *= 1.05f;\n    }\n    return d;\n}\n\nvec3 gradient(vec3 pos) {\n    const vec3 dx = { grad_step, 0.0, 0.0 };\n    const vec3 dy = { 0.0, grad_step, 0.0 };\n    const vec3 dz = { 0.0, 0.0, grad_step };\n    return normalize3(make3(\n        map(add3(pos, dx)) - map(sub3(pos, dx)),\n        map(add3(pos, dy)) - map(sub3(pos, dy)),\n        map(add3(pos, dz)) - map(sub3(pos, dz))));\n}\n\nfloat ray_marching(vec3 origin, vec3 dir, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < max_iterations; i++) {\n        float dist = map(add3(origin, scale3(dir, depth)));\n        if (dist < stop_threshold)\n            return depth;\n        depth += dist * 0.3;\n        if (depth >= end)\n            return end;\n    }\n    return end;\n}\n\nfloat shading(vec3 v, vec3 n, vec3 eye) {\n    vec3 ev = normalize3(sub3(v, eye));\n    vec3 vl = normalize3(sub3(light_pos, v));\n    float diffuse = dot3(vl, n) * 0.5f + 0.5f;\n    vec3 h = normalize3(sub3(vl, ev));\n    float rim = pow(1.0f - max(-dot3(n, ev), 0.0f), 2.0f) * 0.15f;\n    float ao = clamp(v.y * 0.5f + 0.5f, 0.0f, 1.0f);\n    return (diffuse + rim) * ao;\n}\n\nvec3 ray_dir(float fov, vec2 pos) {\n    vec3 r = { pos.x, pos.y, -tan((90.0f - fov * 0.5f) * DEG_TO_RAD) };\n    return normalize3(r);\n}\n\nfloat f(vec2 fragCoord) {\n    vec3 dir = ray_dir(45.0f, fragCoord);\n    vec3 eye = { 0.0f, 0.0f, 4.5f };\n    mat3 rot = rotationXY(-1.0f, 1.0f);\n\n    dir = mul(rot, dir);\n    eye = mul(rot, eye);\n\n    float depth = ray_marching(eye, dir, 0.0f, clip_far);\n    vec3 pos = add3(eye, scale3(dir, depth));\n    if (depth >= clip_far)\n        return 0.0f;\n    else\n        return shading(pos, gradient(pos), eye);\n}\n\nint main() {\n    puts(\"\\033[91m\");\n    for (int y = 0; y < 80; y++) {\n        for (int x = 0; x < 160; x++)\n            putchar(\"  .,-:;+=*#@\"[(int)(f(make2((x / 160.0f - 0.5f) * 2.0f, (y / 80.0f - 0.5f) * -2.0f)) * 12.0f)]);\n        putchar('\\n');\n    }\n}\n```\n\n","tags":["C++"]},{"title":"ATM机","url":"/2022/12/11/1/","content":"\n```\n#include <string>\n#include <iostream>\n#include <vector>\n#include <Windows.h>\n#include <stdlib.h>\n#include <fstream>\n#include <ctime>\n\nusing namespace std;\n\nclass Account\n{\npublic:\n    string name;//姓名\n    int accountNumber = 0;//账号\n    int pinNumber = 0;//密码\n    int balance = 0;//余额\npublic:\n    bool welcome();//初始界面\n    void show();//打印菜单\n    void deposit();//存款\n    void withdrawal();//取款\n    void tran();//转账\n    void change();//修改密码\n    void getbalance();//查询余额\n    void print();//打印账号信息\n};\n\nvector<Account> account;\nAccount ATM;\nvector<Account>::iterator atm;\n\nvoid wait() {\n    int a = getchar();\n    a = getchar();\n}\n\nvoid keep() {\n    ofstream ofs(\"ATM.txt\");\n    if (ofs.is_open()) {\n        vector<Account>::iterator it;\n        for (it = account.begin(); it != account.end(); it++) {\n            ofs << it->name << \"\\t\" << it->accountNumber << \"\\t\" << it->pinNumber << \"\\t\" << it->balance << \"\\t\" << endl;\n        }\n        ofs.close();\n    }\n}\n\nvoid open() {\n    ifstream ifs(\"ATM.txt\");\n    if (ifs.is_open()) {\n        cout << \"文件打开成功！\" << endl;\n        system(\"cls\");\n        Account a;\n        while (ifs >> a.name >> a.accountNumber >> a.pinNumber >> a.balance) {\n            account.push_back(a);\n        }\n        ifs.close();\n    }\n    else {\n        cout << \"文件不存在！\" << endl;\n    }\n}\n\nbool Account::welcome() {\n    Account temp;\n    cout << \"欢迎使用！\\n请选择操作：\\n 1、登录\\n 2、开户\\n 3、退出\" << endl;\n    int a;\n    cin >> a;\n    system(\"cls\");\n    switch (a)\n    {\n    case 1: {\n        if (account.begin() == account.end()) {\n            cout << \"没有账号，无法登录！\" << endl;\n            wait();\n            return false;\n        }\n        else {\n            cout << \"请输入账号：\" << endl;\n            cin >> temp.accountNumber;\n            for (vector<Account>::iterator it = account.begin(); it != account.end(); it++) {\n                if (it->accountNumber == temp.accountNumber) {\n                    cout << \"请输入密码：\" << endl;\n                    cin >> temp.pinNumber;\n                    if (it->pinNumber == temp.pinNumber) {\n                        atm = it;\n                        cout << \"登陆成功！\" << endl;\n                        wait();\n                        return true;\n                    }\n                    else {\n                        cout << \"密码错误，无法登录！\" << endl;\n                        wait();\n                        return false;\n                    }\n                }\n            }\n            cout << \"账号不存在！\" << endl;\n            return false;\n        }\n    }\n    case 2: {\n        cout << \"请输入姓名：\" << endl;\n        cin >> temp.name;\n        cout << \"请输入密码：\" << endl;\n        cin >> temp.pinNumber;\n        srand(unsigned int(time(0)));\n        srand(temp.pinNumber + rand());\n        temp.accountNumber = rand() * 10000000 % 10000000 + 60000000;\n        cout << \"开户成功，您的账号为：\" << temp.accountNumber << endl;\n        account.push_back(temp);\n        wait();\n        return false;\n        break;\n    }\n    case 3: {\n        keep();\n        cout << \"感谢使用，再见！\" << endl;\n        exit(0);\n    }\n    default:return false; break;\n    }\n}\n\nvoid Account::show() {\n    system(\"cls\");\n    cout << \"请选择你需要的服务\" << endl;\n    cout << \"1、存款\" << endl;\n    cout << \"2、取款\" << endl;\n    cout << \"3、转账\" << endl;\n    cout << \"4、查询余额\" << endl;\n    cout << \"5、修改密码\" << endl;\n    cout << \"6、显示账号信息\" << endl;\n    cout << \"7、退出\" << endl;\n}\n\nvoid Account::deposit() {\n    int temp;\n    cout << \"请输入存款金额：\" << endl;\n    cin >> temp;\n    atm->balance += temp;\n    cout << \"存款成功！\" << endl;\n}\n\nvoid Account::withdrawal() {\n    cout << \"请输入取款金额：\" << endl;\n    int temp;\n    cin >> temp;\n    if (temp > atm->balance)\n        cout << \"余额不足！\" << endl;\n    else\n        atm->balance -= temp;\n    cout << \"成功！\" << endl;\n}\n\nvoid Account::tran() {\n    Account temp;\n    cout << \"请输入对方账户：\" << endl;\n    cin >> temp.accountNumber;\n    for (vector<Account>::iterator it = account.begin(); it != account.end(); it++) {\n        if (temp.accountNumber == it->accountNumber)\n        {\n            int a;\n            cout << \"请输入转账金额：\" << endl;\n            cin >> a;\n            if (a < atm->balance && a > 0) {\n                atm->balance -= a;\n                it->balance += a;\n                cout << \"转账成功！\" << endl;\n                return;\n            }\n            else if (a > atm->balance) {\n                cout << \"余额不足！\" << endl;\n                return;\n            }\n            else {\n                cout << \"输入错误！\" << endl;\n                return;\n            }\n        }\n    }\n    cout << \"账户不存在！\" << endl;\n    return;\n}\n\nvoid Account::change() {\n    cout << \"请输入新密码\" << endl;\n    cin >> atm->pinNumber;\n    cout << \"修改成功！\" << endl;\n}\n\nvoid Account::getbalance() {\n    cout << \"余额为：\" << atm->balance << endl;\n}\n\nvoid Account::print() {\n    cout << \"姓名：\" << atm->name << endl;\n    cout << \"账户名：\" << atm->accountNumber << endl;\n    cout << \"余额：\" << atm->balance << endl;\n}\n\nint main() {\n    open();\naaa:\n    system(\"cls\");\n    bool b = ATM.welcome();\n    while (b) {\n        int a;\n        ATM.show();\n        cin >> a;\n        switch (a) {\n        case 1:system(\"cls\"); (*atm).deposit(); wait(); break;\n        case 2:system(\"cls\"); (*atm).withdrawal(); wait(); break;\n        case 3:system(\"cls\"); (*atm).tran(); wait(); break;\n        case 4:system(\"cls\"); (*atm).getbalance(); wait(); break;\n        case 5:system(\"cls\"); (*atm).change(); wait(); break;\n        case 6:system(\"cls\"); (*atm).print(); wait(); break;\n        case 7:system(\"cls\"); keep(); cout << \"感谢使用，再见！\" << endl; b = false; break;\n        default:break;\n        }\n    }\n    goto aaa;\n}\n```\n\n","tags":["C++"]}]